Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 121)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 122)
@@ -512,12 +512,7 @@
 		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), name, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
 		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SELF_NAME, context.topClass(), context.topMethod());
 		Invocation invok = dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation());
-		if (invok == null) {
-			System.err.println("Could not create invocation:'"+context.topMethod()+"' / '"+receiver+"' / '"+invoked+"'");
-		}
-		else {
-			context.setLastInvocation( invok );
-		}
+		context.setLastInvocation( invok );
 
 		return super.visit(node);
 	}
@@ -529,12 +524,7 @@
 		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
 		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, context.topClass(), context.topMethod());
 		Invocation invok = dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation());
-		if (invok == null) {
-			System.err.println("Could not create invocation:'"+context.topMethod()+"' / '"+receiver+"' / '"+invoked+"'");
-		}
-		else {
-			context.setLastInvocation( invok );
-		}
+		context.setLastInvocation( invok );
 
 		return super.visit(node);
 	}
@@ -558,12 +548,7 @@
 				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
 			}
 			Invocation invok = dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation());
-			if (invok == null) {
-				System.err.println("Could not create invocation:'"+sender+"' / '"+receiver+"' / '"+invoked+"'");
-			}
-			else {
-				context.setLastInvocation( invok );
-			}
+			context.setLastInvocation( invok );
 		}
 	}
 
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 54)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 55)
@@ -136,6 +136,9 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 		Method meth = dico.ensureFamixMethod(node.resolveBinding());
+		if (meth == null) {
+			meth = dico.ensureFamixMethod(node, context.topClass());
+		}
 		this.context.pushMethod(meth);
 		for (Name excepName : (List<Name>)node.thrownExceptions()) {
 			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding());
@@ -155,14 +158,13 @@
 	}
 
 	public boolean visit(MethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
-
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()), node.arguments().size());
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("static-access")
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME), node.arguments().size());
 		return super.visit(node);
 	}
 
@@ -394,11 +396,18 @@
 	 * @param name of the method invoked
 	 * @param receiver of the call, i.e. the object to which the message is sent
 	 */
-	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver) {
+	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver, int numberOfArguments) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
 			Method invoked = this.dico.ensureFamixMethod(bnd);
 			if (invoked == null) {
+				if (receiver != null && receiver.getName().equals("self")) {
+					receiver = this.context.topClass();
+				}
+				invoked = this.dico.ensureFamixMethod(name, receiver, numberOfArguments);
+				//invoked = this.dico.ensureFamixStubMethod(name);
+			}
+			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(name);
 			}
 			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 18)
+++ verveine.extractor.java/.classpath	(revision 19)
@@ -13,7 +13,7 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
-	<classpathentry kind="lib" path="lib/famix.jar" sourcepath="/verveine.core"/>
+	<classpathentry kind="lib" path="lib/famix.jar"/>
+	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 18)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 19)
@@ -637,7 +637,16 @@
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
 		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
 		
-		fmx.setContainer( ensureFamixNamespaceJavaLang(null));
+		if (fmx != null) {
+			fmx.setContainer( ensureFamixNamespaceJavaLang(null));
+			
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.TRUE);
+		}
 		// Note: "Object" has no superclass
 
 		return fmx;
@@ -662,8 +671,17 @@
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
 		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
-		fmx.setContainer( ensureFamixNamespaceDefault());
+		if (fmx != null) {
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+			fmx.setContainer( ensureFamixNamespaceDefault());
+			
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.TRUE);
+		}
 
 		return fmx;
 	}
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 120)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 121)
@@ -496,7 +496,7 @@
 	 * @return the Invocation
 	 */
 	public Invocation addFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
-		if ( (sender == null) || (invoked == null) || (receiver == null) ) {
+		if ( (sender == null) || (invoked == null) ) {
 			return null;
 		}
 		Invocation invok = new Invocation();
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 120)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 121)
@@ -30,7 +30,7 @@
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
 		this.mapImpVar = new Hashtable<NamedEntity,ImplicitVars>();
 		
-		if (! this.famixRepo.isEmpty()) {
+		if (! this.mapBind.isEmpty()) {
 			// nothing
 		}
 	}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 120)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 121)
@@ -112,7 +112,7 @@
 		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo, Attribute.class).size());//10+{System.out}
 		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo, Namespace.class).size());//2+{moose,java.lang,java.io,java}
 		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo, Parameter.class).size());
-		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());//FIXME pb with getreceiver
 		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo, Inheritance.class).size());//6 internal + 24 from imported packages/classes
 		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo, Access.class).size());// 16 "internal" attributes + 9 System.out
 		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo, LocalVariable.class).size());
@@ -383,17 +383,17 @@
 				 (mNode.getName().equals("methodWithEmptyBody")) ||
 				 (mNode.getName().equals("canOutput")) ||
 				 (mNode.getName().equals("canOriginate")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
+				assertEquals("Wrong number of outgoing invocation for Node."+mNode.getSignature(), 0, mNode.getOutgoingInvocations().size());
 			}
 			else if ( (mNode.getName().equals("Node")) ||
 					  (mNode.getName().equals("accept")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
+				assertEquals("Wrong number of outgoing invocation for Node."+mNode.getSignature(), 1, mNode.getOutgoingInvocations().size());
 			}
 			else if (mNode.getName().equals("send"))  {
-				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
+				assertEquals("Wrong number of outgoing invocation for Node.send()", 6, mNode.getOutgoingInvocations().size());
 			}
 			else if (mNode.getName().equals("printOn")) {
-				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
+				assertEquals("Wrong number of outgoing invocation for Node.printOn()", 8, mNode.getOutgoingInvocations().size());
 			}
 		}
 		
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 120)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 121)
@@ -6,12 +6,15 @@
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
@@ -24,11 +27,13 @@
 
 	@Test
 	public void testAssociation() {
-		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Association.class) ) {
-			assertNotNull(ass.getClass().getSimpleName()+(ass.getTo()==null?"":" to: "+ass.getTo().getName())+" as no From", ass.getFrom());
+		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Access.class) ) {
+			if (! (ass instanceof Invocation)) { // null receiver allowed for invocations
+				assertNotNull(ass.getClass().getSimpleName()+(ass.getTo()==null? "" : " to: "+ass.getTo().getName())+" as no From", ass.getFrom());
+			}
 			assertNotNull(ass.getClass().getSimpleName()+" from: "+ass.getFrom().getName()+" as no To", ass.getTo());
 		}
-		
+
 		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Association.class) ) {
 			Association n = ass.getNext();
 			if (n!=null) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 120)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 121)
@@ -77,6 +77,7 @@
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -382,7 +383,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
-//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression: "+((VariableDeclaration)node.fragments().iterator().next()).getName().getIdentifier()+" (...)");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
@@ -398,7 +399,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
-//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement: "+((VariableDeclaration)node.fragments().iterator().next()).getName().getIdentifier()+" (...)");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
@@ -428,11 +429,7 @@
 				// creating a class' field
 				fmx = dico.ensureFamixAttribute(bnd, name, varTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
 			}
-			else if (node instanceof VariableDeclarationExpression) {
-				// creating a method's local variable
-				fmx = dico.ensureFamixLocalVariable(bnd, name, varTyp, (Method) ctxt);
-			}
-			else if (node instanceof VariableDeclarationExpression) {
+			else if ( (node instanceof VariableDeclarationExpression) || (node instanceof VariableDeclarationStatement) ) {
 				// creating a method's local variable
 				fmx = dico.ensureFamixLocalVariable(bnd, name, varTyp, (Method) ctxt);
 			}
@@ -500,7 +497,8 @@
 	}
 
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, this.context.topClass(), context.top()));
+		NamedEntity receiver = this.dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, this.context.topClass(), context.top());
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), receiver);
 
 		this.context.addTopMethodNOS(1);
 		return super.visit(node);
@@ -513,7 +511,13 @@
 		String name = context.topMethod().getName();
 		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), name, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
 		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SELF_NAME, context.topClass(), context.topMethod());
-		context.setLastInvocation( dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation()) );
+		Invocation invok = dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation());
+		if (invok == null) {
+			System.err.println("Could not create invocation:'"+context.topMethod()+"' / '"+receiver+"' / '"+invoked+"'");
+		}
+		else {
+			context.setLastInvocation( invok );
+		}
 
 		return super.visit(node);
 	}
@@ -524,7 +528,13 @@
 		// ConstructorInvocation (i.e. 'super(...)' ) happen in constructor, so the name is that of the superclass
 		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
 		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, context.topClass(), context.topMethod());
-		context.setLastInvocation( dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation()) );
+		Invocation invok = dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation());
+		if (invok == null) {
+			System.err.println("Could not create invocation:'"+context.topMethod()+"' / '"+receiver+"' / '"+invoked+"'");
+		}
+		else {
+			context.setLastInvocation( invok );
+		}
 
 		return super.visit(node);
 	}
@@ -544,10 +554,16 @@
 				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/varTyp);  // cast needed to desambiguate the call
 			}
 			else {
-				// method static of a class called on the class
+				//  static method called on the class (or null receiver)
 				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
 			}
-			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			Invocation invok = dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation());
+			if (invok == null) {
+				System.err.println("Could not create invocation:'"+sender+"' / '"+receiver+"' / '"+invoked+"'");
+			}
+			else {
+				context.setLastInvocation( invok );
+			}
 		}
 	}
 
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 34)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 35)
@@ -102,14 +102,14 @@
 	
 	@Test
 	public void testEntitiesNumber() {
-		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable,}
 		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
 		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
 		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
 		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
 		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
+		assertEquals(6+24, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
 		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
 		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
 	}
@@ -174,7 +174,7 @@
 	public void testInheritance() {
 		fr.inria.verveine.core.gen.famix.Class clazz;
 		Collection<Inheritance> superInheritances;
-		Inheritance inh;
+		Inheritance inh, inh2 = null;
 		
 		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
 		assertNotNull(clazz);
@@ -191,6 +191,27 @@
 		inh = superInheritances.iterator().next();
 		assertSame(clazz, inh.getSubclass());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(2, superInheritances.size()); // superInheritances: Object and IPrinter (in this order)
+		for (Inheritance inheritance : superInheritances) {
+			assertSame(clazz, inheritance.getSubclass());
+			if (inheritance.getSuperclass().getName().equals("IPrinter")) {
+				inh2 = inheritance;
+				assertNull(inheritance.getNext());
+				assertSame(inheritance,inheritance.getPrevious().getNext());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter"), inheritance.getSuperclass());
+			} else {
+				inh = inheritance;
+				assertNull(inheritance.getPrevious());
+				assertSame(inheritance,inheritance.getNext().getPrevious());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inheritance.getSuperclass());
+			}
+		}
+		assertSame(inh.getNext(), inh2);
+		assertSame(inh2.getPrevious(), inh);
 	}
 
 	@Test
@@ -248,7 +269,7 @@
 		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
 		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
-		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
+		assertEquals(8, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 118)
+++ verveine.core/.classpath	(revision 119)
@@ -4,6 +4,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 118)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 119)
@@ -345,8 +345,8 @@
 		AnnotationInstance inst = null;
 		if ( (fmx != null) && (annType != null) ) {
 			inst = new AnnotationInstance();
-			inst.setAnnotationType(annType);
 			inst.setAnnotatedEntity(fmx);
+			inst.setAnnotationType(annType);
 			inst.addAttributes(annAtts);
 			this.famixRepo.add(inst);
 		}
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 118)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 119)
@@ -19,6 +19,11 @@
         return parentEnum;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentEnum();
+	}
+
     public void setParentEnum(Enum parentEnum) {
         if (this.parentEnum != null) {
             if (this.parentEnum.equals(parentEnum)) return;
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 118)
+++ verveine.extractor.java/.classpath	(revision 119)
@@ -9,10 +9,10 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
 	<classpathentry kind="lib" path="lib/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/junit.jar"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
+	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 118)
+++ verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 119)
@@ -2,10 +2,10 @@
 
 import java.util.ArrayList;
 import java.util.List;
-/*
-public class Card {
+
+public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
 
-	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
+public class Card {
 
 	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
         SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
@@ -22,7 +22,7 @@
     public String toString() { return rank + " of " + suit; }
 
     private static final List<Card> protoDeck = new ArrayList<Card>();
-
+/*
     // Initialize prototype deck
     static {
         for (Suit s : Suit.values())
@@ -33,9 +33,9 @@
             	protoDeck.add(new Card(r, s));
             }
     }
-
+*/
     public static ArrayList<Card> newDeck() {
         return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
     }
- */
+
 }
Index: verveine.extractor.java/test_src/ad_hoc/Element.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 118)
+++ verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 119)
@@ -18,31 +18,10 @@
 
 package ad_hoc;
 
+import ad_hoc.FameProperty;
 /**
  * Abstract superclass of MSE metamodel.
- * 
- * This is an abstract class with attributes </p>
- * <ul>
- * <li>Element <code>owner</code> (derived)</li>
- * <li>String <code>fullname</code> (derived)</li>
- * <li>String <code>name</code></li>
- * </ul>
- * <p>
- * with these constraints
- * </p>
- * <ul>
- * <li> <code>name</code> must be alphanumeric</li>
- * <li> <code>fullname</code> is derived recursively, concatenating
- * <code>owner.fullname</code> and <code>name</code></li>
- * <li> <code>fullname</code> is separated by dots, eg
- * <code>MSE.Class.attributes</code></li>
- * </ul>
- * 
- * @author Adrian Kuhn
- * 
  */
-@FamePackage("FM3")
-@FameDescription("Element")
 public abstract class Element {
 
     private String name;
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 118)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 119)
@@ -99,39 +99,16 @@
 	
 	@Test
 	public void testAnnotation() {
-		Collection<AnnotationType> l_FmProp = TestVerveineUtils.listElements(repo,AnnotationType.class, "FameProperty");
-		assertEquals(1, l_FmProp.size());
-
-		AnnotationType fmProp = l_FmProp.iterator().next();
+		AnnotationType fmProp = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FameProperty");
 		assertNotNull(fmProp);
 		assertEquals("FameProperty", fmProp.getName());
 		// FIXME assertFalse(fmProp.getIsStub());
-		
-		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
-		assertNotNull(fmPckg);
-		assertEquals("FamePackage", fmPckg.getName());
-		assertTrue(fmPckg.getIsStub());
-		
-		AnnotationType fmDesc = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FameDescription");
-		assertNotNull(fmDesc);
-		assertEquals("FameDescription", fmDesc.getName());
-		assertTrue(fmDesc.getIsStub());
 
-		// class annotations 
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Element");
 		assertNotNull(clazz);
-		Collection<AnnotationInstance> annInstances = clazz.getAnnotationInstances();
-		assertEquals(2, annInstances.size());
-		for (AnnotationInstance annotationInstance : annInstances) {
-			assertSame(clazz, annotationInstance.getAnnotatedEntity());
-			if (annotationInstance.getAnnotationType().getName().equals("FamePackage")) {
-				assertSame(fmPckg, annotationInstance.getAnnotationType());
-			} else {
-				assertEquals("FameDescription", annotationInstance.getAnnotationType().getName());
-				assertSame(fmDesc, annotationInstance.getAnnotationType());
-			}
-		}
+		assertEquals(3, fmProp.getInstances().size());
 
+		assertEquals(5, fmProp.getAttributes().size());
 		AnnotationTypeAttribute decl = null;
 		for (AnnotationTypeAttribute a : TestVerveineUtils.listElements(repo, AnnotationTypeAttribute.class, "derived")) {
 			if (a.getParentAnnotationType() == fmProp) {
@@ -139,11 +116,11 @@
 				break;
 			}
 		}
-		assertNotNull(decl);
+		assertNotNull("FameProperty missing AnnotationTypeAttribute: derived", decl);
 		
 		// Method annotations
 		for (Method meth : clazz.getMethods()) {
-			annInstances = meth.getAnnotationInstances();
+			Collection<AnnotationInstance> annInstances = meth.getAnnotationInstances();
 			if (meth.getName().equals("getFullname") || meth.getName().equals("getName") || meth.getName().equals("getOwner")) {
 				assertEquals(1, annInstances.size());
 				AnnotationInstance annInst = annInstances.iterator().next();
@@ -357,29 +334,47 @@
 
 	@Test
 	public void testEnumDecl() {
+		fr.inria.verveine.core.gen.famix.Class card = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Card");
+		assertNotNull(card);
+
 		fr.inria.verveine.core.gen.famix.Enum rk = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Rank");
 		assertNotNull(rk);
 		assertEquals("Rank", rk.getName());
-		//assertEquals(13, card.getValues().size());
-		assertSame(TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Card"), rk.getBelongsTo());
+		assertEquals(13, rk.getValues().size());
+		assertSame(card, rk.getBelongsTo());
 
 		EnumValue nine = TestVerveineUtils.detectElement(repo, EnumValue.class, "NINE");
 		assertNotNull(nine);
 		assertEquals("NINE", nine.getName());
 		assertSame(rk, nine.getParentEnum());
-		assertSame(rk, nine.getBelongsTo());
 
 		fr.inria.verveine.core.gen.famix.Enum st = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Suit");
 		assertNotNull(st);
 		assertEquals("Suit", st.getName());
-		//assertEquals(4, card.getValues().size());
+		assertEquals(4, st.getValues().size());
 		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "ad_hoc"), st.getBelongsTo());
 
 		EnumValue hrt = TestVerveineUtils.detectElement(repo, EnumValue.class, "HEARTS");
 		assertNotNull(hrt);
 		assertEquals("HEARTS", hrt.getName());
 		assertSame(st, hrt.getParentEnum());
-		assertSame(st, hrt.getBelongsTo());
+
+		assertEquals(3, card.getAttributes().size());
+		for (Attribute a : card.getAttributes()) {
+			if (a.getName().equals("rank")) {
+				assertEquals(rk, a.getDeclaredType());
+			}
+			else if (a.getName().equals("suit")) {
+				assertEquals(st, a.getDeclaredType());
+			}
+			else {
+				assertEquals("protoDeck", a.getName());
+			}
+		}
 	}
 
+	@Test
+	public void testStaticInitializationBlock() {
+		fail("must test static initialization block in Card.java");
+	}
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 118)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 119)
@@ -687,8 +687,6 @@
 		return super.visit(node);
 	}
 
-	
-
 	/**
 	 * Finds and/or create the Famix Entity receiving a message
 	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 65)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 66)
@@ -3,6 +3,7 @@
 
 import ch.akuhn.fame.internal.MultivalueSet;
 import java.util.*;
+
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
@@ -215,7 +216,14 @@
         parentType.getMethods().add(this);
     }
     
-
-
-}
+    private Collection<Type> declaredArgumentTypes;
+    
+    @FameProperty(name = "declaredArgumentTypes")
+    public Collection<Type> getDeclaredArgumentTypes() {
+        return declaredArgumentTypes;
+    }
 
+    public void setDeclaredArgumentTypes(Collection<Type> declaredArgumentTypes) {
+        this.declaredArgumentTypes = declaredArgumentTypes;
+    }
+}
\ No newline at end of file
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 10)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 11)
@@ -367,6 +367,7 @@
 		assertSame(FileAnchor.class, anc.getClass());
 		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
+		assertEquals(31, ((FileAnchor)anc).getEndLine());
 		
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
 		assertNotNull(meth);
@@ -377,6 +378,7 @@
 		assertSame(FileAnchor.class, anc.getClass());
 		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
 		assertEquals(39, ((FileAnchor)anc).getStartLine());
+		assertEquals(41, ((FileAnchor)anc).getEndLine());
 		
 		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
 		assertNotNull(meth);
@@ -387,6 +389,7 @@
 		assertSame(FileAnchor.class, anc.getClass());
 		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
 		assertEquals(15, ((FileAnchor)anc).getStartLine());
+		assertEquals(15, ((FileAnchor)anc).getEndLine());
 		
 	}
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 10)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 11)
@@ -575,7 +575,8 @@
 		
 		if ( (fmx != null) && (ast != null) ) {
 			// position in source file
-			int pos = ast.getStartPosition();
+			int beg = ast.getStartPosition();
+			int end = beg + ast.getLength();
 			// find source file
 			while ( ! (ast instanceof CompilationUnit) ) {
 				ASTNode tmp = ast.getParent();
@@ -590,7 +591,8 @@
 			// now create the Famix SourceAnchor
 			fa = new FileAnchor();
 			fa.setFileName((String) ((CompilationUnit)ast).getProperty(SOURCE_FILENAME_PROPERTY));
-			fa.setStartLine(((CompilationUnit)ast).getLineNumber(pos));
+			fa.setStartLine(((CompilationUnit)ast).getLineNumber(beg));
+			fa.setEndLine(((CompilationUnit)ast).getLineNumber(end));
 			fmx.setSourceAnchor(fa);
 			famixRepo.add(fa);
 		}
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 119)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 120)
@@ -90,17 +90,6 @@
 		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
 			return null;
 		}
-		
-		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
-		}
-		else {
-			// Unfortunately different entities with the same name and same type may exist
-			// e.g. 2 parameters of 2 different methods but having the same name
-			// so we must recreate a new entity each time
-
-			//fmxEnt = getEntityByName(fmxClass, name);
-		}
 
 		if (fmx != null) {
 			return fmx;
Index: verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 119)
+++ verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 120)
@@ -3,8 +3,6 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
-
 public class Card {
 
 	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
@@ -19,7 +17,14 @@
 
     public Rank rank() { return rank; }
     public Suit suit() { return suit; }
-    public String toString() { return rank + " of " + suit; }
+    public String toString() {
+    	if (suit == Suit.CLUBS) {
+    		return rank + " of " + suit;
+    	}
+    	else {
+    		return rank + " of clubs";
+    	}
+    }
 
     private static final List<Card> protoDeck = new ArrayList<Card>();
 /*
@@ -39,3 +44,5 @@
     }
 
 }
+
+public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 119)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 120)
@@ -7,7 +7,6 @@
 import static org.junit.Assert.*;
 
 import java.io.File;
-import java.io.FileWriter;
 import java.util.Collection;
 
 import org.junit.Before;
@@ -220,106 +219,60 @@
 	
 	@Test
 	public void testMethodParameterArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				//assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				///assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				//assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		if (meth.getParameters().size() == 3) {
+			for (Parameter param : meth.getParameters()) {
+				if (param.getName().equals("fmxClass")) {
+					Type classT = param.getDeclaredType();
+					assertNotNull(classT);
+					assertEquals("Class", classT.getName());
+					assertEquals(ParameterizedType.class, classT.getClass());
+					assertEquals(1, ((ParameterizedType)classT).getArguments().size());
+					Type t = ((ParameterizedType)classT).getArguments().iterator().next();
+					assertEquals("T", t.getName());
+					assertSame(meth, t.getBelongsTo());
+				}
+				else if (param.getName().equals("bnd")) {
+					Type b = param.getDeclaredType();
+					assertNotNull(b);
+					assertEquals("B", b.getName());
+					assertSame(meth.getBelongsTo(), b.getBelongsTo());  // b defined in Dictionary class just as the method
+				}
+				else {
+					assertEquals("name", param.getName());
+				}
 			}
 		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				//assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				//assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
+		else {
+			assertEquals(2, meth.getParameters().size());
 		}
 	}
 	
 	@Test
 	public void testMethodLocalVariableArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
-		assertNotNull(fmxMethod);
-		assertEquals(1, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
-			//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-			//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
-			if (fmxLocalVariable.getName().equals("ret")) {
-				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxLocalVariable.getName().equals("l_name")) {
-				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
-			if (fmxLocalVariable.getName().equals("fmx")) {
-				//assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(meth);
+		assertEquals(2, meth.getLocalVariables().size());
+		for (LocalVariable var : meth.getLocalVariables()) {
+			Type collec;
+			if (var.getName().equals("ret")) {
+				collec = var.getDeclaredType();
+				assertNotNull(collec);
+				assertEquals("Collection", collec.getName());
+				assertEquals(ParameterizedType.class, collec.getClass());
+				assertEquals(1, ((ParameterizedType)collec).getArguments().size());
+				Type t = ((ParameterizedType)collec).getArguments().iterator().next();
+				assertEquals("T", t.getName());
+				assertSame(meth, t.getBelongsTo());
 			}
-			if (fmxLocalVariable.getName().equals("l")) {
-				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			if (var.getName().equals("l_name")) {
+				collec = var.getDeclaredType();
+				assertNotNull(collec);
+				assertEquals("Collection", collec.getName());
+				assertEquals(ParameterizedType.class, collec.getClass());
+				assertEquals(1, ((ParameterizedType)collec).getArguments().size());
+				Type ne = ((ParameterizedType)collec).getArguments().iterator().next();
+				assertEquals("NamedEntity", ne.getName());
 			}
 		}
 	}
@@ -374,6 +327,11 @@
 	}
 
 	@Test
+	public void testEnumAccess() {
+		fail("must test access to EnumValues in Card.java");		
+	}
+
+	@Test
 	public void testStaticInitializationBlock() {
 		fail("must test static initialization block in Card.java");
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 119)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 120)
@@ -566,9 +566,15 @@
 	public boolean visit(QualifiedName node) {
 		IBinding bnd = node.resolveBinding();
 		if (bnd instanceof IVariableBinding) {
-			// apparently this is a field
-			BehaviouralEntity accessor = this.context.topMethod();
-			createAccessedAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null, accessor);
+			if (((IVariableBinding) bnd).isEnumConstant()) {
+				// it is an enumerated constant
+				//TODO record the access to the enumValue
+			}
+			else {
+				// looks like it is a field
+				BehaviouralEntity accessor = this.context.topMethod();
+				createAccessedAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null, accessor);
+			}	
 		}
 		return super.visit(node);
 	}
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 62)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 63)
@@ -314,7 +314,7 @@
 						ret = dico.ensureFamixParameter( (IVariableBinding)bnd);
 					}
 					else { // suppose it's a local variable
-						ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd);
+						ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, context.topMethod());
 					}
 				}
 			}
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 4)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 5)
@@ -89,7 +89,7 @@
 		assertEquals(0, interfce.getAttributes().size());
 		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
 		assertTrue(interfce.getIsInterface());
-		
+
 		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
 		assertNotNull(innerClass);
 		assertEquals("XPrinter", innerClass.getName());
@@ -383,4 +383,37 @@
 		
 	}
 
+	@Test
+	public void testModifiers() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsInterface());
+		assertTrue(clazz.getIsAbstract());
+		assertTrue(clazz.getModifiers().contains("abstract"));
+		assertTrue(clazz.getIsPublic());
+		assertFalse(clazz.getIsPrivate());
+		assertFalse(clazz.getIsProtected());
+		assertFalse(clazz.getIsFinal());
+		
+		assertEquals(3, clazz.getMethods().size());
+		for (Method m : clazz.getMethods()) {
+			assertTrue(m.getIsPublic());
+			assertFalse(m.getIsPrivate());
+			assertFalse(m.getIsProtected());
+			assertFalse(m.getIsFinal());
+			if (m.getName().equals("output")) {
+				assertTrue(m.getIsAbstract());
+			}
+			else {
+				assertFalse(m.getIsAbstract());
+			}
+		}
+		
+		assertEquals(1, clazz.getAttributes().size());
+		Attribute a = clazz.getAttributes().iterator().next();
+		assertFalse(a.getIsPublic());
+		assertFalse(a.getIsPrivate());
+		assertTrue(a.getIsProtected());
+		assertFalse(a.getIsFinal());
+	}
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 4)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 5)
@@ -10,6 +10,7 @@
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
 import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.Modifier;
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
@@ -18,6 +19,7 @@
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
@@ -246,7 +248,7 @@
 		}
 		
 		if ((fmx!=null) && fmx.getIsStub()) {
-			// apparently we just created it or it already existed as a stub), so add information to it
+			// apparently we just created it or it already existed as a stub, so add information to it
 			fmx.setIsInterface(bnd.isInterface());
 			fmx.setContainer(owner);
 			if (sups.size() > 0) {
@@ -255,6 +257,11 @@
 					ensureFamixInheritance(sup, fmx);
 				}
 			}
+			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
+			if (fmx.getIsAbstract()) {
+				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
+				fmx.addModifiers("abstract");
+			}
 			fmx.setName(identifier); // might be different from bnd.getName() in the case of anonymous class
 			fmx.setIsStub(Boolean.FALSE);
 		}
@@ -329,11 +336,12 @@
 		}
 		
 		if ((fmx!=null) && fmx.getIsStub()) {
-			// apparently we just created it, so add information to it
+			// apparently we just created it or it already existed as a stub, so add information to it
 			fmx.setParentType(parentClass);
 			fmx.setDeclaredType(rettyp);	
 			fmx.setName(bnd.getName());
 			fmx.setSignature(sig);
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
 			fmx.setIsStub(Boolean.FALSE);
 		}
 
@@ -384,6 +392,7 @@
 		
 		if ((fmx!=null) && fmx.getIsStub()) {
 			// apparently we just created it, so add information to it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
 			fmx.setParentType(parentClass);
 			fmx.setDeclaredType(typ);	
 			fmx.setName(bnd.getName());
@@ -393,6 +402,19 @@
 		return fmx;
 	}
 
+	/** Sets the modifiers (abstract, public, ...) of a FamixNamedEntity
+	 * @param fmx -- the FamixNamedEntity
+	 * @param mod -- a description of the modifiers as understood by org.eclipse.jdt.core.dom.Modifier
+	 */
+	private void setNamedEntityModifiers(NamedEntity fmx, int mod) {
+		fmx.setIsAbstract(Modifier.isAbstract(mod));
+		fmx.setIsFinal(Modifier.isFinal(mod));
+		fmx.setIsPrivate(Modifier.isPrivate(mod));
+		fmx.setIsProtected(Modifier.isProtected(mod));
+		fmx.setIsPublic(Modifier.isPublic(mod));
+	}
+
+
 	/**
 	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 117)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 118)
@@ -127,6 +127,10 @@
 	}
 }
 
+class ImplicitVariable extends NamedEntity {
+	
+}
+
 class Repository {
 	public boolean isEmtpy() {
 		return false;
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 117)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 118)
@@ -170,7 +170,7 @@
 		ITypeBinding bnd = node.resolveBinding();
 		@SuppressWarnings("unchecked")
 		List<TypeParameter> tparams = (List<TypeParameter>)node.typeParameters();
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), tparams.size()>0); //   /*ctxt*/context.top());
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), tparams.size()>0);
 		if (fmx != null) {
 			fmx.setIsStub(false);
 
@@ -301,18 +301,23 @@
 				paramTypes.add(param.getType());
 		}
 
-		// creating/recovering it
-		// creates it with a fake return type because we might need this FamixMethod to create the return type (if it is a ParameterizedType)
-		// we reset the return type to its proper value later
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/dico.ensureFamixClassObject(null), context.topClass());
+		fr.inria.verveine.core.gen.famix.Type fmxRetTyp = null;
+		if (! node.isConstructor()) {
+			// creates the method with a fake return type because we might need this FamixMethod to create the return type (if it is a ParameterizedType)
+			// we reset the return type to its proper value later
+			fmxRetTyp = dico.ensureFamixClassObject(null);
+		}
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/fmxRetTyp, context.topClass());
 
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
 			// now will recompute the actual returnType
 			this.context.pushMethod(fmx);
-			fr.inria.verveine.core.gen.famix.Type fmxRetTyp = referedType(node.getReturnType2(), fmx);
-			fmx.setDeclaredType(fmxRetTyp);
+			if (! node.isConstructor()) {
+				fmxRetTyp = referedType(node.getReturnType2(), fmx);
+				fmx.setDeclaredType(fmxRetTyp);
+			}
 
 			dico.addSourceAnchor(fmx, node);
 			dico.addFamixAnnotationInstances(bnd, fmx);
@@ -466,6 +471,11 @@
 				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
 			}
 		}
+		else if ( typ.isSimpleType() && (typ.resolveBinding()==null) && (ctxt instanceof Method)) {
+			// might be a wildcardType with no previous "definition"
+			// in this case the owner is this very method
+			fmxTyp = dico.ensureFamixType((ITypeBinding)null, dico.findTypeName(typ), /*owner*/ctxt, ctxt);
+		}
 		else {
 			fmxTyp = dico.ensureFamixType(typ.resolveBinding(), dico.findTypeName(typ), /*owner*/null, ctxt);
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 117)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 118)
@@ -114,7 +114,7 @@
 			if (name == null) {
 				return null;
 			}
-			fmx = searchTypeInContext(name, ctxt);
+			fmx = searchTypeInContext(name, ctxt); // WildCard Types don't have binding
 			if (fmx != null) {
 				return fmx;
 			}
@@ -146,10 +146,6 @@
 			return ensureFamixEnum(bnd, name, owner);
 		}
 		
-		if (bnd.isTypeVariable() ) {
-			return ensureFamixParameterType(bnd, name, (ParameterizableClass) owner);
-		}
-
 		if (bnd.isRawType() || bnd.isGenericType()) {
 			return ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
 		}
@@ -163,6 +159,20 @@
 			return ensureFamixClass(bnd, name, owner, /*isGeneric*/false);
 		}
 
+		if (name == null) {
+			name = bnd.getName();
+		}
+		
+		if (owner == null) {
+			owner = ensureOwner(bnd);
+		}
+
+		if (bnd.isTypeVariable() ) {
+			// a type defined for a method parameter or return type
+			fmx = super.ensureFamixType(bnd, name, owner);
+			
+			return fmx;
+		}
 
 		return super.ensureFamixType(bnd, name, owner);
 	}
@@ -205,7 +215,6 @@
 
 		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
 		if (fmx != null) {
-//			System.out.println("ensureClass, recovered from bnd:"+fmx.toString());
 			return fmx;
 		}
 
@@ -246,31 +255,7 @@
 
 		// --------------- owner
 		if (owner == null) {
-			IMethodBinding parentMtd = bnd.getDeclaringMethod();
-			if (parentMtd != null) {
-				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			}
-			else {
-				ITypeBinding parentClass = bnd.getDeclaringClass();
-				if (parentClass != null) {
-					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
-					if (tmpOwn instanceof ParameterizedType) {
-						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
-					}
-					else {
-						owner = tmpOwn;
-					}
-				}
-				else {
-					IPackageBinding parentPckg = bnd.getPackage();
-					if (parentPckg != null) {
-						owner = this.ensureFamixNamespace(parentPckg, null);
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
-				}
-			}
+			owner = ensureOwner(bnd);
 		}
 
 		// --------------- superclasses (including interfaces)
@@ -315,6 +300,41 @@
 		return fmx;
 	}
 
+	/**
+	 * Ensures a famix entity for a owner that can be a method, a class or a namespace
+	 * @param bnd -- binding for the owned entity
+	 * @return a famix entity for the owner
+	 */
+	private ContainerEntity ensureOwner(ITypeBinding bnd) {
+		ContainerEntity owner = null;
+		IMethodBinding parentMtd = bnd.getDeclaringMethod();
+		if (parentMtd != null) {
+			owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+		}
+		else {
+			ITypeBinding parentClass = bnd.getDeclaringClass();
+			if (parentClass != null) {
+				Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+				if (tmpOwn instanceof ParameterizedType) {
+					owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+				}
+				else {
+					owner = tmpOwn;
+				}
+			}
+			else {
+				IPackageBinding parentPckg = bnd.getPackage();
+				if (parentPckg != null) {
+					owner = this.ensureFamixNamespace(parentPckg, null);
+				}
+				else {
+					owner = this.ensureFamixNamespaceDefault();
+				}
+			}
+		}
+		return owner;
+	}
+
 /*	public ParameterizableClass ensureFamixParameterizableType(ITypeBinding bnd, String name, ContainerEntity owner) {
 		ParameterizableClass fmx = null;
 		
@@ -349,31 +369,7 @@
 
 		// --------------- owner
 		if (owner == null) {
-			IMethodBinding parentMtd = bnd.getDeclaringMethod();
-			if (parentMtd != null) {
-				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			}
-			else {
-				ITypeBinding parentClass = bnd.getDeclaringClass();
-				if (parentClass != null) {
-					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
-					if (tmpOwn instanceof ParameterizedType) {
-						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
-					}
-					else {
-						owner = tmpOwn;
-					}
-				}
-				else {
-					IPackageBinding parentPckg = bnd.getPackage();
-					if (parentPckg != null) {
-						owner = this.ensureFamixNamespace(parentPckg, null);
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
-				}
-			}
+			owner = ensureOwner(bnd);
 		}
 
 		// --------------- generic
@@ -432,25 +428,7 @@
 
 		// --------------- owner
 		if (owner == null) {
-			IMethodBinding parentMtd = bnd.getDeclaringMethod();
-			if (parentMtd != null) {
-				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			}
-			else {
-				ITypeBinding parentClass = bnd.getDeclaringClass();
-				if (parentClass != null) {
-					owner = this.ensureFamixClass(parentClass, null, null);
-				}
-				else {
-					IPackageBinding parentPckg = bnd.getPackage();
-					if (parentPckg != null) {
-						owner = this.ensureFamixNamespace(parentPckg, null);
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
-				}
-			}
+			owner = ensureOwner(bnd);
 		}
 
 		// --------------- recover from name ?
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 80)
+++ verveine.extractor.java/.classpath	(revision 81)
@@ -11,8 +11,7 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/famix.jar"/>
-	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/memusage.txt
===================================================================
--- verveine.extractor.java/memusage.txt	(revision 0)
+++ verveine.extractor.java/memusage.txt	(revision 81)
@@ -0,0 +1,54 @@
+
+memory usage for Eclipse 3.1
+$ time ./verveinej3_1.sh 2> toto.log >&2
+$ time ./verveinej-mono-3_1.sh 2> toto.log >&2
+
+120.51user 3.31system 2:25.05elapsed 85%CPU 
+(0avgtext+0avgdata 9.646.080maxresident)k
+292144inputs+221248outputs (2356major+700607minor)pagefaults 0swaps
+8522 toto.log
+
+120.79user 2.95system 1:53.51elapsed 109%CPU 
+(0avgtext+0avgdata 9.175.040maxresident)k
+142416inputs+220976outputs (87major+622960minor)pagefaults 0swaps
+8522 toto.log
+3.340.182 output.mse
+
+112.33user 4.35system 1:40.17elapsed 116%CPU 
+(0avgtext+0avgdata 9.777.152maxresident)k
+68760inputs+221504outputs (190major+682907minor)pagefaults 0swaps
+
+$ for i in `grep FAMIX output.mse | sed -e 's/ (id:.*//' | sed -e 's/^        (//' | sort -u`; do echo -n "$i   "; grep -c $i output.mse ; done
+FAMIX.Access   60984
+FAMIX.Attribute   27473
+FAMIX.CaughtException   3690
+FAMIX.Class   7906
+FAMIX.Comment   37000
+FAMIX.DeclaredException   3848
+FAMIX.FileAnchor   124493
+FAMIX.ImplicitVariable   4996
+FAMIX.Inheritance   7136
+FAMIX.Invocation   169940
+FAMIX.LocalVariable   37753
+FAMIX.Method   53602
+FAMIX.Namespace   377
+FAMIX.Parameter   52480
+FAMIX.PrimitiveType   9
+FAMIX.Reference   30799
+FAMIX.ThrownException   2414
+FAMIX.UnknownVariable   23090
+FAMIX   647990
+
+$ grep -c 'null binding' toto.log 
+8413
+
+
+=======================================
+SEPARATE
+
+2041.59user 115.58system 27:47.42elapsed 129%CPU 
+(0avgtext+0avgdata 7.086.080maxresident)k
+135200inputs+6149832outputs (110major+16978083minor)pagefaults 0swaps
+
+
+FAMIX.Attribute   27520
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/test_src/Dictionary/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 80)
+++ verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 81)
@@ -32,13 +32,6 @@
 
 public class Dictionary<B> {
 
-	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
-	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
-	public static final String SELF_NAME = "self";
-	public static final String SUPER_NAME = "super";
-
-	protected Repository famixRepo;
-
 	protected Map<B,NamedEntity> mapBind;
 
 	protected Map<String,Collection<NamedEntity>> mapName;
@@ -66,78 +59,6 @@
 			recoverExistingRepository();
 		}
 	}
-
-	protected void recoverExistingRepository() {
-		for (Object obj : famixRepo.getElements()) {
-			if (obj instanceof NamedEntity) {
-				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
-			}
-		}
-		
-		for (Access acc : famixRepo.all(Access.class)) {
-			try {
-				if (acc.getIsWrite()) { }
-			}
-			catch (NullPointerException e) {
-				acc.setIsWrite(Boolean.FALSE);
-			}
-		}
-
-		for (fr.inria.verveine.core.gen.famix.Class clazz : famixRepo.all(fr.inria.verveine.core.gen.famix.Class.class)) {
-			try { if (clazz.getIsAbstract()) { } }
-			catch (NullPointerException e) { clazz.setIsAbstract(Boolean.FALSE); }
-			try { if (clazz.getIsStub()) { } }
-			catch (NullPointerException e) { clazz.setIsStub(Boolean.FALSE); }
-			try { if (clazz.getIsPublic()) { } }
-			catch (NullPointerException e) { clazz.setIsPublic(Boolean.FALSE); }
-			try { if (clazz.getIsPrivate()) { } }
-			catch (NullPointerException e) { clazz.setIsPrivate(Boolean.FALSE); }
-			try { if (clazz.getIsProtected()) { } }
-			catch (NullPointerException e) { clazz.setIsProtected(Boolean.FALSE); }
-			try { if (clazz.getIsFinal()) { } }
-			catch (NullPointerException e) { clazz.setIsFinal(Boolean.FALSE); }
-		}
-
-		for (Method meth : famixRepo.all(Method.class)) {
-			try { if (meth.getIsAbstract()) { } }
-			catch (NullPointerException e) { meth.setIsAbstract(Boolean.FALSE); }
-			try { if (meth.getIsStub()) { } }
-			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
-			try { if (meth.getIsPublic()) { } }
-			catch (NullPointerException e) { meth.setIsPublic(Boolean.FALSE); }
-			try { if (meth.getIsPrivate()) { } }
-			catch (NullPointerException e) { meth.setIsPrivate(Boolean.FALSE); }
-			try { if (meth.getIsProtected()) { } }
-			catch (NullPointerException e) { meth.setIsProtected(Boolean.FALSE); }
-			try { if (meth.getIsFinal()) { } }
-			catch (NullPointerException e) { meth.setIsFinal(Boolean.FALSE); }
-		}
-
-		for (Attribute att : famixRepo.all(Attribute.class)) {
-			try { if (att.getIsAbstract()) { } }
-			catch (NullPointerException e) { att.setIsAbstract(Boolean.FALSE); }
-			try { if (att.getIsStub()) { } }
-			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
-			try { if (att.getIsPublic()) { } }
-			catch (NullPointerException e) { att.setIsPublic(Boolean.FALSE); }
-			try { if (att.getIsPrivate()) { } }
-			catch (NullPointerException e) { att.setIsPrivate(Boolean.FALSE); }
-			try { if (att.getIsProtected()) { } }
-			catch (NullPointerException e) { att.setIsProtected(Boolean.FALSE); }
-			try { if (att.getIsFinal()) { } }
-			catch (NullPointerException e) { att.setIsFinal(Boolean.FALSE); }
-		}
-
-	}
-	
-	protected void mapEntityToName(String name, NamedEntity ent) {
-		Collection<NamedEntity> l_ent = mapName.get(name);
-		if (l_ent == null) {
-			l_ent = new LinkedList<NamedEntity>();
-		}
-		l_ent.add(ent);
-		mapName.put(name, l_ent);
-	}
 	
 	@SuppressWarnings("unchecked")
 	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
@@ -218,264 +139,5 @@
 		
 		return fmx;
 	}
-
-	public void famixRepoAdd(Entity e) {
-		this.famixRepo.add(e);
-	}
-
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
-		if (fmx != null) {
-			fmx.setIsAbstract(Boolean.FALSE);
-			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsInterface(Boolean.FALSE);
-			fmx.setIsPrivate(Boolean.FALSE);
-			fmx.setIsProtected(Boolean.FALSE);
-			fmx.setIsPublic(Boolean.FALSE);
-		}
-
-		return fmx;
-	}
-
-	public Method ensureFamixMethod(String name) {
-		return (Method) ensureFamixEntity(Method.class, null, name);
-	}
-
-	public Attribute ensureFamixAttribute(String name) {
-		return (Attribute) ensureFamixEntity(Attribute.class, null, name);
-	}
-
-	public LocalVariable ensureFamixLocalVariable(String name) {
-		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
-	}
-
-	public Comment createFamixComment(String cmt) {
-		Comment fmx = new Comment();
-		fmx.setContent(cmt);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
-	}
-
-	public Comment createFamixComment(String cmt, SourcedEntity owner) {
-		Comment fmx = new Comment();
-		fmx.setContent(cmt);
-		fmx.setContainer(owner);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
-	}
-
-	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, String type) {
-		Parameter fmx = new Parameter();
-		fmx.setName(identifier);
-		fmx.setParentBehaviouralEntity(owner);
-		fmx.setDeclaredType(ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type));
-		this.famixRepo.add(fmx);
-		
-		return fmx;
-	}
-	
-	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
-		return ensureFamixInheritance(sup, sub, null);
-	}
-	
-	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Association prev) {
-		for (Inheritance i : sup.getSubInheritances()) {
-			if (i.getSubclass() == sub) {
-				return i;
-			}
-		}
-		Inheritance inh = new Inheritance();
-		inh.setSuperclass(sup);
-		inh.setSubclass(sub);
-		chainPrevNext(prev,inh);
-		famixRepoAdd(inh);
-		return inh;
-	}
-
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
-		return ensureFamixReference(src, tgt, null);
-	}
-	
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
-		Reference ref = new Reference();
-		ref.setTarget(tgt);
-		ref.setSource(src);
-		chainPrevNext(prev,ref);
-		famixRepoAdd(ref);
-		
-		return ref;
-	}
-
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
-		return ensureFamixInvocation(sender, invoked, receiver, null);
-	}
-
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
-		Invocation invok = new Invocation();
-		invok.setReceiver(receiver);
-		invok.setSender(sender);
-		invok.setSignature(invoked.getSignature());
-		invok.addCandidates(invoked);
-		chainPrevNext(prev,invok);
-		famixRepoAdd(invok);
-		
-		return invok;
-	}
-
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
-		Access acc = new Access();
-		acc.setAccessor(accessor);
-		acc.setVariable(var);
-		acc.setIsWrite(new Boolean(isWrite));
-		chainPrevNext(prev, acc);
-		famixRepoAdd(acc);
-		
-		return acc;
-	}
-
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
-		return ensureFamixAccess(accessor, var, isWrite, null);
-	}
-	
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
-		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
-	}
-
-	private void chainPrevNext(Association prev, Association next) {
-		if (prev != null) {
-			next.setPrevious(prev);  // not yet implemented in importer
-		}
-	}
-
-	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		DeclaredException decl = new DeclaredException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
-	}
-
-	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		CaughtException decl = new CaughtException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
-	}
-
-	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		ThrownException decl = new ThrownException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
-	}
-
-	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
-		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByBinding(bnd), iv_name);
-	}
-
-	public ImplicitVariable getImplicitVariableByClass(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
-		ImplicitVars iv = mapImpVar.get(clazz);
-		ImplicitVariable ret = null;
-		
-		if (iv == null) {
-			iv = new ImplicitVars();
-		}
-		
-		if (name.equals(SELF_NAME)) {
-			ret = iv.self_iv;
-		}
-		else if (name.equals(SUPER_NAME)) {
-			ret = iv.super_iv;
-		}
-
-		return ret;
-	}
-
-	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
-		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
-		
-		if (fmx == null) {
-			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
-			if (fmx!=null) {
-				fmx.setContainer(clazz);
-				fmx.setIsStub(Boolean.FALSE);
-
-				ImplicitVars iv = mapImpVar.get(clazz);				
-				if (iv == null) {
-					iv = new ImplicitVars();
-				}
-
-				if (name.equals(SELF_NAME)) {
-					iv.self_iv = fmx;
-				}
-				else if (name.equals(SUPER_NAME)) {
-					iv.super_iv = fmx;
-				}
-				
-				mapImpVar.put(clazz, iv);
-			}
-		}
-
-		return fmx;
-	}
-
-	@SuppressWarnings("unchecked")
-	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B bnd, String name) {
-		T fmx = null;
-		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
-		}
-		
-		if (fmx == null) {
-			Collection<T> l = getEntityByName( fmxClass, name);
-			if (l.size() > 0) {
-				fmx = l.iterator().next();
-			}
-			else {
-				fmx = createFamixEntity(fmxClass, name);
-			}
-			
-			if (bnd != null) {
-				// may happen for example if the entity was first created without binding
-				// and we find a binding for it later
-				mapBind.put(bnd, fmx);
-			}
-		}
-
-		return fmx;
-	}
-
-	public Namespace ensureFamixNamespace(String name) {
-		return  ensureFamixUniqEntity(Namespace.class, null, name);
-	}
-
-	public Namespace ensureFamixNamespaceDefault() {
-		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, DEFAULT_PCKG_NAME);
-
-		return fmx;
-	}
-
-	public PrimitiveType ensureFamixPrimitiveType(String name) {
-		return  ensureFamixUniqEntity(PrimitiveType.class, null, name);
-	}
-
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
-		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
-		if (fmx != null) {
-			fmx.setContainer( ensureFamixNamespaceDefault());
-			fmx.setIsAbstract(Boolean.FALSE);
-			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsInterface(Boolean.FALSE);
-			fmx.setIsPrivate(Boolean.FALSE);
-			fmx.setIsProtected(Boolean.FALSE);
-			fmx.setIsPublic(Boolean.FALSE);
-		}
-
-		return fmx;
-	}
 	
 }
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 80)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 81)
@@ -22,10 +22,15 @@
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
@@ -60,75 +65,54 @@
 
 	@Test
 	public void testClassParameterTypes() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Dictionary");
-		assertNotNull(nodeClass);
-		assertEquals("Dictionary", nodeClass.getName());
-		assertFalse(nodeClass.getIsInterface());
-		assertEquals(1, nodeClass.getParameterTypes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), nodeClass.getParameterTypes().iterator().next());
+		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dicoClass);
+		assertEquals("Dictionary", dicoClass.getName());
+		assertEquals(2, dicoClass.getTypes().size());
+		assertEquals(1, dicoClass.getParameters().size());
+		
+		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
+		assertNotNull(dicoParam);
+		assertEquals("B", dicoParam.getName());
+		
+		assertSame(dicoClass, dicoParam.getContainer());
+		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
 	}
 
 	@Test
-	public void testFieldArgumentTypes() {
-		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "DEFAULT_PCKG_NAME");
-		assertNotNull(famixAtt);
-		assertEquals("DEFAULT_PCKG_NAME", famixAtt.getName());
-		assertNull(famixAtt.getDeclaredArgumentTypes());
+	public void testParameterTypeAsType() {
+		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
+		assertNotNull(gebb);
+		assertSame(1, gebb.getParameters().size());
 		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "STUB_METHOD_CONTAINER_NAME");
-		assertNotNull(famixAtt);
-		assertEquals("STUB_METHOD_CONTAINER_NAME", famixAtt.getName());
-		assertNull(famixAtt.getDeclaredArgumentTypes());
+		Parameter bnd = gebb.getParameters().iterator().next();
+		assertNotNull(bnd);
+		assertEquals("bnd", bnd.getName());
 		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "SELF_NAME");
-		assertNotNull(famixAtt);
-		assertEquals("SELF_NAME", famixAtt.getName());
-		assertNull(famixAtt.getDeclaredArgumentTypes());
+		Type b = bnd.getDeclaredType();
+		assertNotNull(b);
+		assertEquals("B", b.getName());
+		assertSame(ParameterType.class, b.getClass());
 		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "SUPER_NAME");
-		assertNotNull(famixAtt);
-		assertEquals("SUPER_NAME", famixAtt.getName());
-		assertNull(famixAtt.getDeclaredArgumentTypes());
-		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "famixRepo");
-		assertNotNull(famixAtt);
-		assertEquals("famixRepo", famixAtt.getName());
-		assertNull(famixAtt.getDeclaredArgumentTypes());
-
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
+		ContainerEntity cont = b.getContainer();
+		assertNotNull(cont);
+		assertEquals("Dictionary", cont.getName());
+		assertSame(ParameterizableClass.class, cont.getClass());
+	}
+	
+	/*Test
+	public void testFieldArgumentTypes() {
+		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
 		assertNotNull(famixAtt);
 		assertEquals("mapBind", famixAtt.getName());
 		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
 		Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
 		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
 		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
-		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapName");
-		assertNotNull(famixAtt);
-		assertEquals("mapName", famixAtt.getName());
-		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		it = famixAtt.getDeclaredArgumentTypes().iterator();
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "String"), it.next());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "Collection"), it.next());
-		
-		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapImpVar");
-		assertNotNull(famixAtt);
-		assertEquals("mapImpVar", famixAtt.getName());
-		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		it = famixAtt.getDeclaredArgumentTypes().iterator();
-		Collection<Type> fmxClasses = TestVerveineUtils.listElements(repo, Type.class, "Class");
-		String javaLangNamespace = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
-		Namespace ns = TestVerveineUtils.detectElement(repo, Namespace.class, javaLangNamespace);
-		//There are two classes with the name Class (java.lang and famix namespaces). Ensure to get the correct one.
-		for (Type fmxClass : fmxClasses) {
-			if (ns != fmxClass.getContainer()) {
-				assertSame(fmxClass, it.next());
-			}
-		}
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "ImplicitVars"), it.next());
 	}
-
-	@Test
+*/
+	
+	/*Test
 	public void testMethodParameterArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
 		assertNotNull(fmxMethod);
@@ -192,8 +176,9 @@
 			}
 		}
 	}
+	*/
 	
-	@Test
+	/*Test
 	public void testMethodLocalVariableArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
 		assertNotNull(fmxMethod);
@@ -233,12 +218,14 @@
 			}
 		}
 	}
+	*/
 	
-	@Test
+	/*Test
 	public void testMethodReturnArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
 		assertNotNull(fmxMethod);
 		assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
 		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
 	}
+	*/
 }
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 80)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 81)
@@ -36,6 +36,7 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -70,7 +71,7 @@
 				"server/OutputServer.java",
 				"server/PrintServer.java"
 		};
-		
+
 		// separate parsing of each source file
 		for (String f : files) {
 			parseFile(f);
@@ -104,7 +105,10 @@
 	
 	@Test
 	public void testEntitiesNumber() {
-		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable,}
+		for (Type t : TestVerveineUtils.selectElementsOfType(repo, Type.class) ) {
+			System.out.println("TEST TYPES "+t.getName()+"   --> "+t.getClass().getCanonicalName());
+		}
+		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
 		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
 		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 80)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 81)
@@ -304,7 +304,7 @@
 			if (bnd != null) {
 				if (bnd instanceof ITypeBinding) {
 					// msg() is a static method of Name
-					ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd), bnd.getName());
+					ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, this.context.top()), bnd.getName());
 				}
 				else if (bnd instanceof IVariableBinding) {
 					if ( ((IVariableBinding)bnd).isField() ) {
@@ -362,7 +362,7 @@
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
 			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding());
+			return dico.ensureFamixType( expr.resolveTypeBinding(), this.context.top());
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 80)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 81)
@@ -36,6 +36,7 @@
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeParameter;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -49,6 +50,7 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -102,20 +104,43 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+//		System.out.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+
 		ITypeBinding bnd = node.resolveBinding();
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
+
+		// Dealing with Parameterized classes
+		List<TypeParameter> nodeParameters = node.typeParameters();
+
+//System.out.println("                                        size="+nodeParameters.size());
+		if (nodeParameters.size() > 0) {
+			fmx = dico.ensureFamixParameterizableClass(bnd);
+		}
+		else {
+			fmx = dico.ensureFamixClass(bnd);
+		}
+		
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
 		else {
-			// TODO try to find a binded version corresponding to this stub?
 			System.err.println("         Class="+node.getName().getIdentifier() + ",  fallback to creating a stub");
-			fmx = dico.ensureFamixClass(node.getName().getIdentifier());
+			if (nodeParameters.size() > 0) {
+				fmx = dico.ensureFamixParameterizableClass(node.getName().getIdentifier());
+			}
+			else {
+				fmx = dico.ensureFamixClass(node.getName().getIdentifier());
+			}
 			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
 			fmx.setContainer( context.top());
 		}
-		fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
+
+		// Dealing with Parameterized classes: adding the parameters
+		if (nodeParameters.size() > 0) {
+			for (TypeParameter param : nodeParameters) {
+				dico.ensureFamixParameterType(param.getName().getIdentifier(), (ParameterizableClass)fmx);
+			}
+		}
 		
 		dico.addSourceAnchor(fmx, node);
 		Javadoc jdoc = node.getJavadoc();
@@ -123,6 +148,7 @@
 			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 			dico.addSourceAnchor(cmt, jdoc);
 		}
+		
 		//Annotation
 		if (bnd != null) {
 			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
@@ -130,6 +156,7 @@
 				dico.createFamixAnnotationInstance(fmx, annType);
 			}
 		}
+		
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -193,10 +220,10 @@
 				} else {
 					// Has no binding? It might be a Generic parameter
 					System.err.println("         Parameter="+param.getName().getIdentifier());
-					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, param.getType().toString());
+					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), param.getType().toString(), this.context.topClass()));
 				}
 				if (param.getType().isParameterizedType()) {
-					fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
+					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
 				}
 			}
 			
@@ -253,7 +280,7 @@
 				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
 			}
 			if (node.getType().isParameterizedType()) {
-				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
+				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
 			}
 			dico.addSourceAnchor(fmx, node);
 			Javadoc jdoc = node.getJavadoc();
@@ -307,7 +334,7 @@
 				dico.addSourceAnchor(fmx, node);
 			}
 			if (nodeTyp.isParameterizedType()) {
-				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
 			}
 		}
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 80)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 81)
@@ -30,6 +30,8 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
@@ -67,7 +69,7 @@
 	 */
 	public Namespace ensureFamixNamespace(IPackageBinding bnd) {
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Namespace");
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Namespace");
 			return null;
 		}
 
@@ -118,54 +120,108 @@
 		return fmx;
 	}
 
-	public Type ensureFamixType(ITypeBinding bnd) {
+	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
+	 * Checks for: primitive type, interface, class, parameterizable class
+	 * @param bnd -- JDT binding for the type
+	 * @return the type recovered or created, or null in case of an error
+	 */
+	public Type ensureFamixType(ITypeBinding bnd, ContainerEntity ctxt) {
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
 			return null;
 		}
+		return ensureFamixType(bnd, bnd.getName(), ctxt);
+	}
 
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
+	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
+	 * Checks for: primitive type, interface, class, parameterizable class
+	 * Types are more difficult entities, they can be recovered from their binding or from their name in their context
+	 * @param bnd -- JDT binding for the type
+	 * @param name -- name of the type
+	 * @return the type recovered or created, or null in case of an error
+	 */
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity ctxt) {
+		Type fmx = null;
+	
+		if (bnd != null) {
+			bnd = findNonArrayType(bnd);
+			
+			fmx = (Type) getEntityByBinding(bnd);
+			
+			if (fmx != null) {
+				return fmx;
+			}
+
+			fmx = findTypeInContext(name, ctxt);
+			if (fmx != null) {
+				mapBind.put(bnd, fmx);
+				return fmx;
+			}
 		}
 		
-		if (bnd.isPrimitive()) {
-			return ensureFamixPrimitiveType(bnd);
+		if ( (fmx == null) && (bnd != null) ) {		
+			// not found, will have to create it
+			// from the binding
+			if (bnd.isPrimitive()) {
+				fmx = ensureFamixPrimitiveType(bnd);
+			}
+			else if (bnd.isClass())  {
+				fmx = ensureFamixClass(bnd);
+			}
+			else if (bnd.isGenericType())  {
+				fmx = ensureFamixParameterizableClass(bnd);
+			}
+			else if (bnd.isParameterizedType())  {
+				fmx = super.ensureFamixType(bnd.getName());
+				mapBind.put(bnd, fmx);
+			}
+			else {
+				fmx = super.ensureFamixType(bnd.getName());
+				mapBind.put(bnd, fmx);
+			}
 		}
-		else {
-			return ensureFamixClass(bnd);
+
+		if (fmx == null) {
+			// not found and not created by binding (probably null), will have to create it
+			// from its name
+			fmx = this.ensureFamixType(name);
 		}
+		return fmx;
 	}
 	
-	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
-		Collection<Type> fmxTypes = new ArrayList<Type>();
-		Type fmxType = null;
-		for (org.eclipse.jdt.core.dom.Type type : types) {
-			ITypeBinding bnd = type.resolveBinding();
-			if (bnd != null) {
-				fmxType = ensureFamixType(bnd);
-			} else {
-				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+	/** Searches for a type with the given name in the context (a Famix Method or Famix Type)
+	 * If the context is a method, zsearches in its owner. Otherwise returns null.
+	 * See {@link getEntityByName} to search an entity by its name outside any special context
+	 * @param name of the type to look for
+	 * @param ctxt -- context of the search
+	 * @return the Famix Type found or null
+	 */
+	private Type findTypeInContext(String name, ContainerEntity ctxt) {
+		if (ctxt == null) {
+//System.out.println("lookfor type"+ name+"  in NULL context  :-(");
+			return null;
+		}
+//System.out.println("lookfor type"+ name+"  in context:" +ctxt.getName());
+		for (Type typ : ctxt.getTypes()) {
+			if (typ.getName().equals(name)) {
+				return typ;
 			}
-			fmxTypes.add(fmxType);
 		}
-		return fmxTypes;
-	}
-	
-	public Type ensureFamixType(ITypeBinding bnd, String type) {
-		Type fmx = ensureFamixType(bnd);
-		if (fmx == null) {
-			return ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type);
+		if (ctxt instanceof Method) {
+			return findTypeInContext(name, ctxt.getBelongsTo());
 		}
-		return fmx;
+		
+		return null;
 	}
-	
-	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
+
+	//TODO remove this method
+	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
 		Collection<Type> fmxTypes = new ArrayList<Type>();
 		Type fmxType = null;
-		for (TypeParameter type : types) {
+		for (org.eclipse.jdt.core.dom.Type type : types) {
 			ITypeBinding bnd = type.resolveBinding();
 			if (bnd != null) {
-				fmxType = ensureFamixType(bnd);
+				fmxType = ensureFamixType(bnd, null);
 			} else {
 				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
 			}
@@ -177,12 +233,11 @@
 	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Primitive Type");
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Primitive Type");
 			return null;
 		}
 		
 		PrimitiveType fmx = super.ensureFamixPrimitiveType(bnd.getName());
-		fmx.setIsStub(false);
 		mapBind.put(bnd, fmx);
 		return fmx;
 	}
@@ -190,7 +245,7 @@
 	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
 			return null;
 		}
 		
@@ -202,6 +257,41 @@
 	}
 
 	/**
+	 * Returns a Famix ParameterType (in a ParameterizableClass) with the given name
+	 * We cannot use bindings here since they are usually null (TODO check the javadoc)
+	 * @param paramName -- the name of the ParameterType
+	 * @param owner -- the ParameterizableClass that defines this ParameterType
+	 * @return the Famix Entity created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public ParameterType ensureFamixParameterType(String paramName, ParameterizableClass owner) {
+		//System.err.println("TRACE: ensureFamixParameterType( "+paramName+" , "+owner.getName()+" )");
+		ParameterType fmx = null;
+System.out.println("creating CLASS: "+paramName+"   type: ParameterType");
+		fmx = ensureFamixParameterType(paramName);
+
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+		fmx.setContainer( owner);
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a Famix Parameterizable Class associated with the ITypeBinding similarly to ensureFamixClass for normal classes
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public ParameterizableClass ensureFamixParameterizableClass(ITypeBinding bnd) {
+		if (bnd == null) {
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
+			return null;
+		}
+
+		bnd = findNonArrayType(bnd);
+
+		return ensureFamixClassOrSub(ParameterizableClass.class, bnd, findClassOwner(bnd));
+	}
+
+	/**
 	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
 	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
@@ -209,75 +299,105 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd) {
-		ContainerEntity owner = null;
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
-		String identifier = null;
-		boolean wasBound = false;
-		
-		
+
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
+//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
 			return null;
 		}
-		
+
 		if (bnd.getName().equals(OBJECT_NAME)) {
 			return ensureFamixClassObject(bnd);
 		}
 
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
-		}
-		
-		if (bnd.isPrimitive()) {
-			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
-			System.err.println("Warning: cannot create Famix Class from a primitive type");
-			return null;
-		}
+		bnd = findNonArrayType(bnd);
+
+		return ensureFamixClassOrSub(fr.inria.verveine.core.gen.famix.Class.class, bnd, findClassOwner(bnd));
+	}
 		
-		// container
-		IMethodBinding parentMtd = bnd.getDeclaringMethod();
-		if (parentMtd != null) {
-			owner = this.ensureFamixMethod(parentMtd);
+	/**
+	 * Create a FamixClass or one of its subclass
+	 * @param bnd -- the JDT Binding. If null the methods silently returns null
+	 */
+	@SuppressWarnings("unchecked")
+	private <T extends fr.inria.verveine.core.gen.famix.Class>
+			T ensureFamixClassOrSub( Class<T> fmxClass, ITypeBinding bnd, ContainerEntity owner) {
+
+		String identifier = findClassName(bnd);
+//System.out.println("ensure CLASS: "+identifier+"   type: "+fmxClass.getCanonicalName());
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = findClassSupers(bnd);
+
+		// finally trying to recover the entity or creating it
+		T fmx = null;
+		// ... trying to recover from binding
+		fmx = (T) getEntityByBinding(bnd);
+
+		boolean wasBound = false;
+		if (fmx != null) {
+			wasBound = true;
 		}
 		else {
-			ITypeBinding parentClass = bnd.getDeclaringClass();
-			if (parentClass != null) {
-				owner = this.ensureFamixClass(parentClass);
-			}
-			else {
-				IPackageBinding parentPckg = bnd.getPackage();
-				if (parentPckg != null) {
-					owner = this.ensureFamixNamespace(parentPckg);
-				}
-				else {
-					owner = this.ensureFamixNamespaceDefault();
+			wasBound = false;
+			// trying to recover from name and other informations
+			for (T candidate : getEntityByName(fmxClass, identifier) ) {
+				if (candidate.getContainer() == owner) {
+					// could test superclass also...
+					fmx = candidate;
+					break;
 				}
 			}
 		}
-
-		// name
-		if (bnd.isAnonymous()) {
-			if (bnd.getSuperclass() != null) {
-				identifier = bnd.getSuperclass().getName();
-			}
-			if ( (identifier == null) || identifier.equals(OBJECT_NAME)) {
-				ITypeBinding[] intfcs = bnd.getInterfaces();
-				if ( (intfcs != null) && (intfcs.length > 0) ) {
-					identifier = bnd.getInterfaces()[0].getName();
-				}
-				else {
-					identifier = "???";
+		
+		if (fmx == null) {
+			// could not recover it, creating a new entity
+			// note: name might be different from bnd.getName() in the case of anonymous class
+			fmx = (T) ensureFamixEntity(fmxClass, bnd, identifier);
+		}
+		
+		if ((fmx!=null) && (! wasBound)) {
+			// apparently we just created it or it already existed but was not bound, so add information to it
+			fmx.setIsInterface(bnd.isInterface());
+			fmx.setContainer(owner);
+			if (sups.size() > 0) {
+				// some types don't have superclass
+				Inheritance lastInheritance = null;
+				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+					lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 				}
 			}
-			identifier = "anonymous(" + identifier + ")";
+			if (! wasBound) {
+				mapBind.put(bnd, fmx);
+			}
+			// modifiers
+			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
+			if (fmx.getIsAbstract()) {
+				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
+				fmx.addModifiers("abstract");
+			}
 		}
-		else {
-			identifier = bnd.getName();
+	
+		return fmx;
+	}
+
+	/** Find the "basic" type of something that may be an array
+	 * @param bnd -- non null binding for the class definition
+	 * @return the "basic" (non array) type binding
+	 */
+	private ITypeBinding findNonArrayType(ITypeBinding bnd) {
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
 		}
+		return bnd;
+	}
 
-		// superclass and/or implemented interfaces
+	/** 
+	 * Finds and returns the superclass and/or implemented interfaces of a class declaration
+	 * @param bnd -- non null binding for the class definition
+	 * @return the list of super types
+	 */
+	private Collection<fr.inria.verveine.core.gen.famix.Class> findClassSupers(ITypeBinding bnd) {
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
 		if (! bnd.getName().equals(OBJECT_NAME)) {
-			// "Object" does't have a superclass
+			// "Object" doesn't have a superclass
 			
 			// superclass
 			if (! bnd.isInterface()) {
@@ -288,87 +408,79 @@
 				}
 				else {
 					if (supbnd != null) {
+						//TODO ensureFamixType ??
 						sups.add(ensureFamixClass(supbnd));
 					}
 					for (ITypeBinding intbnd : intsbnd) {
+						//TODO ensureFamixType ??
 						sups.add( ensureFamixClass(intbnd));
 					}
 				}
 			}
 			else {
 				for (ITypeBinding supbnd : bnd.getInterfaces()) {
+					//TODO ensureFamixType ??
 					sups.add( ensureFamixClass(supbnd));
 				}
 			}
 		}
+		return sups;
+	}
 
-		// finally trying to recover the entity or creating it
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
-		// ... trying to recover from binding
-		fmx = (fr.inria.verveine.core.gen.famix.Class) getEntityByBinding(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+	/** Finds and returns the name of a class declaration, especially for anonymous class
+	 * @param bnd -- non null binding for the class definition
+	 * @return the name
+	 */
+	private String findClassName(ITypeBinding bnd) {
+		String identifier = null;
+		if (! bnd.isAnonymous()) {
+			identifier = bnd.getName();
 		}
 		else {
-			wasBound = false;
-			// trying to recover from name and other informations
-			for (fr.inria.verveine.core.gen.famix.Class candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, identifier) ) {
-				if ( //(! candidate.getIsStub()) &&
-						(candidate.getContainer() == owner) ) {
-					// could test superclass also...
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
+			if (bnd.getSuperclass() != null) {
+				identifier = bnd.getSuperclass().getName();
+			}
+			if ( (identifier == null) || identifier.equals(OBJECT_NAME)) {
+				ITypeBinding[] intfcs = bnd.getInterfaces();
+				if ( (intfcs != null) && (intfcs.length > 0) ) {
+					identifier = bnd.getInterfaces()[0].getName();
 				}
-/*				else if ( candidate.getIsStub() ) {
-					// find out whether this candidate is defined in the same namespace as the binding received in parameter
-					ContainerEntity ownerBnd = owner;  // the owner of the bounded entity received as parameter
-					ContainerEntity ownerStub = candidate.getContainer();  // the owner of the current candidate
-					while ( (ownerBnd != null) &&
-							(ownerStub != null) &&
-							(! (ownerBnd instanceof Namespace)) &&
-							(ownerBnd.getClass() == ownerStub.getClass()) &&
-							ownerBnd.getName().equals(ownerStub.getName()) ) {
-								ownerBnd = ownerBnd.getContainer();
-								ownerStub = ownerStub.getContainer();
-					}
-					if ( (ownerBnd instanceof Namespace) &&
-						(ownerStub instanceof Namespace) &&
-						ownerBnd.getName().equals(ownerStub.getName()) ) {
-						fmx = candidate;
-						mapBind.put(bnd, fmx);
-						break;
-					}
-				}*/
+				else {
+					identifier = "???";
+				}
 			}
+			identifier = "anonymous(" + identifier + ")";
 		}
-		
-		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = (fr.inria.verveine.core.gen.famix.Class) ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, bnd.getName());
+		return identifier;
+	}
+
+	/** Finds and returns the owner of a class declaration
+	 * It can be a method (anonymous class), a class (inner class, or ParameterType), or a package (normal class)
+	 * @param bnd -- non null binding for the class definition
+	 * @return the owner found
+	 */
+	private ContainerEntity findClassOwner(ITypeBinding bnd) {
+		ContainerEntity owner = null;
+		IMethodBinding parentMtd = bnd.getDeclaringMethod();
+		if (parentMtd != null) {
+			owner = this.ensureFamixMethod(parentMtd);
 		}
-		
-		if ((fmx!=null) && (! wasBound)) {
-			// apparently we just created it or it already existed but was not bound, so add information to it
-			fmx.setIsInterface(bnd.isInterface());
-			fmx.setContainer(owner);
-			if (sups.size() > 0) {
-				// some types don't have superclass
-				Inheritance lastInheritance = null;
-				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-					lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
-				}
+		else {
+			ITypeBinding parentClass = bnd.getDeclaringClass();
+			if (parentClass != null) {
+				owner = this.ensureFamixClass(parentClass);
 			}
-			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
-			if (fmx.getIsAbstract()) {
-				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
-				fmx.addModifiers("abstract");
+			else {
+				IPackageBinding parentPckg = bnd.getPackage();
+				if (parentPckg != null) {
+					owner = this.ensureFamixNamespace(parentPckg);
+				}
+				else {
+					owner = this.ensureFamixNamespaceDefault();
+				}
 			}
-			fmx.setName(identifier); // might be different from bnd.getName() in the case of anonymous class
 		}
-	
-		return fmx;
+		return owner;
 	}
 
 	/**
@@ -379,38 +491,26 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class owner = null;
+		Type owner = null;
 		Type rettyp = null;
 		String sig = null;
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix Method");
+//			System.err.println("Warning: Unexpected null binding to Famix Method");
 			return null;
 		}
 
 		// owner
-		owner = this.ensureFamixClass(bnd.getDeclaringClass());
+		owner = this.ensureFamixType(bnd.getDeclaringClass(), null);
 
 		// return type
 		if (! bnd.isConstructor()) {
-			rettyp = this.ensureFamixType(bnd.getReturnType());
+			rettyp = this.ensureFamixType(bnd.getReturnType(), /*context*/owner); // the context is the declaring class
 		}
 		// TODO   else what?
 
-		// method signature
-		sig = bnd.getName() + "(";
-		boolean first = true;
-		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
-			if (! first) {
-				sig += "," + parBnd.getName();
-			}
-			else {
-				sig += parBnd.getName();
-				first = false;
-			}
-		}
-		sig += ")";
+		sig = computeSignature(bnd);
 
 		// finally trying to recover the entity or creating it
 		Method fmx = null;
@@ -428,7 +528,7 @@
 					 (candidate.getDeclaredType() == rettyp) &&
 					 (candidate.getSignature().equals(sig)) ) {
 					// we could also test that this candidate is not bound yet (to another bnd)
-					// but it requires significant modifications and might not be that useful?
+					// but it would require significant modifications and might not be that useful?
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
 					break;
@@ -452,6 +552,28 @@
 
 		return fmx;
 	}
+
+	/** Computes the signature of a method from its binding
+	 * @param bnd -- bJDT binding of the method
+	 * @return the signature of the method in a String
+	 */
+	private String computeSignature(IMethodBinding bnd) {
+		String sig;
+		// method signature
+		sig = bnd.getName() + "(";
+		boolean first = true;
+		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+			if (! first) {
+				sig += "," + parBnd.getName();
+			}
+			else {
+				sig += parBnd.getName();
+				first = false;
+			}
+		}
+		sig += ")";
+		return sig;
+	}
 	
 	@SuppressWarnings("unchecked")
 	public String stubMethodSignature(MethodDeclaration node) {
@@ -509,17 +631,17 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class owner = null;
+		Type owner = null;
 		Type typ = null;
 		boolean wasBound = false;
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix Attribute");
+//			System.err.println("Warning: Unexpected null binding to Famix Attribute");
 			return null;
 		}
 
-		owner = this.ensureFamixClass(bnd.getDeclaringClass());
-		typ = this.ensureFamixType(bnd.getType());
+		owner = this.ensureFamixType(bnd.getDeclaringClass(), /*context*/null); // the context is the declaring class=owner
+		typ = this.ensureFamixType(bnd.getType(), owner);
 
 		// finally trying to recover the entity or creating it
 		Attribute fmx = null;
@@ -587,11 +709,11 @@
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix Parameter");
+//			System.err.println("Warning: Unexpected null binding to Famix Parameter");
 			return null;
 		}
 
-		// actually it seems to be very little chances that the aprameter alreasy exist.
+		// actually it seems to be very little chances that the parameter alreasy exist.
 		// but who knows? Does not hurt to try
 		Parameter fmx = (Parameter) getEntityByBinding(bnd);
 		
@@ -611,7 +733,8 @@
 				fmx.setParentBehaviouralEntity(owner);
 			}
 			// type of the attribute
-			fmx.setDeclaredType(this.ensureFamixType(bnd.getType()));
+//System.out.println("looking for parameter type:"+bnd.getName()+"  context="+owner.getName());
+			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), /*context*/owner));
 		}
 		
 		return fmx;
@@ -634,7 +757,7 @@
 		boolean wasBound = false;
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix LocalVariable");
+//			System.err.println("Warning: Unexpected null binding to Famix LocalVariable");
 			return null;
 		}
 
@@ -642,7 +765,7 @@
 		if (owner == null) {
 			owner = fmxMethod;
 		}
-		typ = this.ensureFamixType(bnd.getType());
+		typ = this.ensureFamixType(bnd.getType(), /*context*/fmxMethod);
 
 		// finally trying to recover the entity or creating it
 		LocalVariable fmx = null;
@@ -834,4 +957,5 @@
 
 		return fmx;
 	}
+
 }
\ No newline at end of file
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 38)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 39)
@@ -116,6 +116,7 @@
 			metric_cyclo = EMPTY_CYCLO;
 			metric_nos = EMPTY_NOS;
 			setLastInvocation(null);
+			setLastAccess(null);
 		}
 
 	}
@@ -131,11 +132,6 @@
 	Access lastAccess = null;
 	
 	/**
-	 * last Inheritance registered to set the previous/next
-	 */
-	Inheritance lastInheritance = null;
-	
-	/**
 	 * last Reference registered to set the previous/next
 	 */
 	Reference lastReference = null;
@@ -148,14 +144,6 @@
 		this.lastAccess = lastAccess;
 	}
 
-	public Inheritance getLastInheritance() {
-		return lastInheritance;
-	}
-
-	public void setLastInheritance(Inheritance lastInheritance) {
-		this.lastInheritance = lastInheritance;
-	}
-
 	public Reference getLastReference() {
 		return lastReference;
 	}
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 2)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 3)
@@ -25,12 +25,14 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
 
 import fr.inria.verveine.extractor.java.BatchParser;
 import fr.inria.verveine.extractor.java.JavaDictionary;
@@ -77,7 +79,7 @@
 		assertEquals("Node", nodeClass.getName());
 		assertEquals(11, nodeClass.getMethods().size());
 		assertEquals(2, nodeClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo,Namespace.class, "moose.lan"), nodeClass.getContainer());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
 		
 		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
 		assertNotNull(innerClass);
@@ -101,7 +103,8 @@
 		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
-		assertEquals(JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		assertEquals( javaLangName, javaLang.getName());
 		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
 
 		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
@@ -143,14 +146,14 @@
 		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
 		assertNotNull(mweb);
 		assertEquals("methodWithEmptyBody", mweb.getName());
-		assertEquals("methodWithEmptyBody ()", mweb.getSignature());
+		assertEquals("methodWithEmptyBody()", mweb.getSignature());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "void"), mweb.getDeclaredType());
 
 		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
 		assertNotNull(em);
 		assertEquals("equalsMultiple", em.getName());
-		assertEquals("equalsMultiple (AbstractDestinationAddress)", em.getSignature());
+		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "boolean"), em.getDeclaredType());
 
@@ -165,7 +168,7 @@
 		}
 		assertNotNull(n);
 		assertEquals("name", n.getName());
-		assertEquals("name ()", n.getSignature());
+		assertEquals("name()", n.getSignature());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
 	}
@@ -190,7 +193,8 @@
 
 	@Test
 	public void testStubs() {
-		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, JavaDictionary.OBJECT_PACKAGE_NAME);
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
 		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
 		
@@ -271,7 +275,7 @@
 		for (Method mSDA : sdaClass.getMethods()) {
 			for (Invocation inv : mSDA.getOutgoingInvocations()) {
 				assertTrue( "Unexpected method signature: "+inv.getSignature(),
-							inv.getSignature().equals("equalsSingle (String)") || inv.getSignature().equals("id ()") || inv.getSignature().equals("equals (Object)"));
+							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
 				if (inv.getSignature().equals("equalsSingle (String)")) {
 					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
 					assertEquals("self", inv.getReceiver().getName());
@@ -331,4 +335,41 @@
 			assertEquals(output, acc.getAccessor());
 		}
 	}
+
+	@Test
+	public void testSourceAnchors() {
+		SourceAnchor anc = null;
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
+		assertEquals(17, ((FileAnchor)anc).getStartLine());
+		
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
+		assertNotNull(meth);
+
+		anc = meth.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(meth, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
+		assertEquals(39, ((FileAnchor)anc).getStartLine());
+		
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
+		assertNotNull(meth);
+
+		anc = att.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(att, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
+		assertEquals(15, ((FileAnchor)anc).getStartLine());
+		
+	}
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 2)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 3)
@@ -336,9 +336,9 @@
 			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(name);
 			}
-			/*Invocation inv =*/ dico.ensureFamixInvocation(sender, invoked, receiver);
-			/* An example of how to include location information to an entity:
-			   dico.addSourceAnchor(inv, node); */
+			/* An example of how to include location information to an invocation
+			 * But would require to pass the ASTNode in parameter to this method */
+			/*dico.addSourceAnchor(*/ dico.ensureFamixInvocation(sender, invoked, receiver) /*,node)*/ ;
 		}
 	}
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 2)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 3)
@@ -3,6 +3,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTVisitor;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
@@ -13,7 +14,6 @@
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.VariableDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -57,7 +57,8 @@
 		else {
 			fmx = dico.ensureFamixNamespace(pckg.resolveBinding());
 			if (fmx == null) {
-			System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName());
+				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				// try again without binding
 				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
 			}
 		}
@@ -75,12 +76,13 @@
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(node.resolveBinding());
 		if (fmx == null) {
-			// TODO try to find a bounded version corresponding to this stub?
-			System.err.println("         Class="+node.getName().getIdentifier());
+			// TODO try to find a binded version corresponding to this stub?
+			System.err.println("         Class="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixClass(node.getName().getIdentifier());
 			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
 			fmx.setContainer( context.top());
 		}
+		dico.addSourceAnchor(fmx, node);
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -96,11 +98,12 @@
 		if (decl != null) {
 			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding());
 			if (fmx == null) {
-				System.err.println("         Class="+"anonymous(??)");
+				System.err.println("         Class="+"anonymous(??),  fallback to creating a stub");
 				fmx = dico.ensureFamixClass("anonymous(??)");
 				dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
 				fmx.setContainer( context.top());
 			}
+			dico.addSourceAnchor(fmx, node);
 			this.context.pushClass(fmx);
 		}
 		return super.visit(node);
@@ -115,12 +118,13 @@
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
 		Method fmx = dico.ensureFamixMethod(node.resolveBinding());
 		if (fmx == null) {
-			System.err.println("         Method="+node.getName().getIdentifier());
+			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
 			fmx.setSignature(fmx.getName()+" (???)");
 			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
 		}
+		
 		if (fmx != null) {
 			@SuppressWarnings("unchecked")
 			Iterator<SingleVariableDeclaration> iter = node.parameters().iterator();
@@ -128,6 +132,8 @@
 				SingleVariableDeclaration param = iter.next();
 				dico.ensureFamixParameter(param.resolveBinding());
 			}
+			
+			dico.addSourceAnchor(fmx, node);
 			this.context.pushMethod(fmx);
 		}
 		return super.visit(node);	
@@ -145,12 +151,14 @@
 //			System.err.println("            Field: "+vd.getName().getIdentifier());
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
 			if (fmx == null) {
-				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
+				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
 				// should try to find type name from 'node.getType()' ?
 				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
 			}
+			
+			dico.addSourceAnchor(fmx, node);
 		}
 		return super.visit(node);
 	}
@@ -158,18 +166,18 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-		visitVariableDeclaration(node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-		visitVariableDeclaration(node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
-	private void visitVariableDeclaration(Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+	private void visitVariableDeclaration(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
 		if (nodeTyp.isPrimitiveType()) {
 			return;
 		}
@@ -177,11 +185,13 @@
 		for (VariableDeclarationFragment vd : fragments) {
 			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding());
 			if (fmx == null) {
-				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
+				System.err.println("         Variable="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
 				// should try to find type name from 'node.getType()' ?
 				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+
+				dico.addSourceAnchor(fmx, node);
 			}
 		}
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 2)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 3)
@@ -56,14 +56,9 @@
 			return null;
 		}
 
-		Namespace fmx = ensureFamixUniqEntity(Namespace.class, bnd, bnd.getName());
+		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, null);
 
 		if (fmx!=null) {
-			if (createParentScope(fmx) != null) {
-				// remove the name of the parent from the name of this package
-				/*String name = fmx.getName();
-				fmx.setName(name.substring(name.lastIndexOf('.')+1));*/
-			}
 			fmx.setIsStub(Boolean.FALSE);			
 		}
 		return fmx;
@@ -71,13 +66,9 @@
 
 	@Override
 	public Namespace ensureFamixNamespace(String name) {
-		Namespace fmx = super.ensureFamixNamespace(name);
+		Namespace fmx = ensureFamixNamespaceWithParentScope(null, name);
 		
 		if (fmx!=null) {
-			if (createParentScope(fmx) != null) {
-				// remove the name of the parent from the name of this package
-				/*fmx.setName(name.substring(name.lastIndexOf('.')+1));*/
-			}
 			fmx.setIsStub(Boolean.FALSE);			
 		}
 		
@@ -85,24 +76,42 @@
 	}
 
 	/**
-	 * Creates and returns a parent namespace for 'fmx'
-	 * @param fmx - the namespace for which to create a parent
-	 * @return the parent namespace created or null
+	 * Creates or recovers a namespace. Also creates or recovers recusively it's parent namespaces
+	 * At least one of bnd and name must be passed, possibly both
+	 * @param bnd - the (optional) binding for the namespace
+	 * @param name - the (optional) full name for the namespace
+	 * @return the namespace created or null
 	 */
-	private Namespace createParentScope(Namespace fmx) {
-		String name = fmx.getName();
-		Namespace parentScope = null;
-		if (fmx.getParentScope() == null) {
-			int pt = name.lastIndexOf('.');
-			if (pt > 0) {
-				parentScope = ensureFamixNamespace(name.substring(0, pt));
-				if (parentScope != null) {
-					parentScope.addChildScopes(fmx);
-				}
+	private Namespace ensureFamixNamespaceWithParentScope(IPackageBinding bnd, String name) {
+		Namespace fmx = null;
+		Namespace parent = null;
+		String[] nameComps;
+		
+		if (bnd != null) {
+			nameComps = bnd.getNameComponents();
+		}
+		else {
+			if (name != null) {
+				nameComps = name.split("\\.");
+			}
+			else {
+				return null;
 			}
 		}
+
+		for (String nameComp : nameComps ) {
+			fmx = ensureFamixUniqEntity(Namespace.class, null, nameComp);
+			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
+				parent.addChildScopes(fmx);
+			}
+			parent = fmx;
+		}
 		
-		return parentScope;
+		if ( (fmx != null) && (bnd != null) ) {
+			mapBind.put(bnd, fmx);
+		}
+
+		return fmx;
 	}
 
 	/**
@@ -270,7 +279,7 @@
 		}
 
 		// method signature
-		sig = bnd.getName() + " (";
+		sig = bnd.getName() + "(";
 		boolean first = true;
 		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
 			if (! first) {
@@ -486,14 +495,14 @@
 			while ( ! (ast instanceof CompilationUnit) ) {
 				ASTNode tmp = ast.getParent();
 				if ( (ast == null) || (tmp == ast) ) {
-					// we reach the top node without finding a CompilationUnit. This is strange, but what can we do ... ?
+					// we reached the top node without finding a CompilationUnit. This would be strange, but what can one do ... ?
 					return null;
 				}
 				else {
 					ast = tmp;
 				}
 			}
-			// noew create the Famix SourceAnchor
+			// now create the Famix SourceAnchor
 			fa = new FileAnchor();
 			fa.setFileName((String) ((CompilationUnit)ast).getProperty(SOURCE_FILENAME_PROPERTY));
 			fa.setStartLine(((CompilationUnit)ast).getLineNumber(pos));
@@ -524,8 +533,9 @@
 	 * @param bnd -- a potential binding for the "java.lang" package
 	 * @return a Famix Namespace for "java.lang"
 	 */
-	public Namespace ensureFamixNamespaceJavaLang(ITypeBinding bnd) {
-		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, bnd, OBJECT_PACKAGE_NAME);
+	public Namespace ensureFamixNamespaceJavaLang(IPackageBinding bnd) {
+		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, OBJECT_PACKAGE_NAME);
+		
 		fmx.setIsStub(false);
 
 		return fmx;
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 116)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 117)
@@ -11,8 +11,6 @@
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
-import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
@@ -101,27 +99,16 @@
 		assertTrue(serial.getIsInterface());
 		assertEquals(0, serial.getSuperInheritances().size());
 
-		ParameterizableClass comp = TestVerveineUtils.detectElement(repo,ParameterizableClass.class, "Comparable");
-		assertNotNull(comp);
-		assertSame(javaLang, comp.getContainer());
-		assertTrue(comp.getIsInterface());
-		assertEquals(0, comp.getSuperInheritances().size());
-
-		ParameterizedType compStr = TestVerveineUtils.detectElement(repo,ParameterizedType.class, "Comparable");
-		assertNotNull(compStr);
-		assertSame(comp, compStr.getParameterizableClass());
-		assertEquals(0, compStr.getSuperInheritances().size());
-		
 		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
 		assertNotNull(str);
 		assertSame(javaLang, str.getContainer());
 		assertEquals(4, str.getSuperInheritances().size());
 		for (Inheritance inh : str.getSuperInheritances()) {
-			assertTrue( "Unexpected super-class for String: "+inh.getSuperclass().getName(),
+			assertTrue( "Unexpected super-class for String: "+inh.getSuperclass(),
 					(inh.getSuperclass() == obj) ||
 					(inh.getSuperclass() == charSeq) ||
 					(inh.getSuperclass() == serial) ||
-					(inh.getSuperclass() == compStr) );
+					(inh.getSuperclass().getName().equals("Comparable")) );  // there are 2 'comparable' in one case, so it's best to only test the name
 		}
 
 		// System
@@ -130,11 +117,15 @@
 		assertSame(javaLang, syst.getContainer());
 		assertEquals(1, syst.getSuperInheritances().size());
 		assertEquals(obj, syst.getSuperInheritances().iterator().next().getSuperclass());
-		assertEquals(2, syst.getAttributes().size());
+		boolean foundOut = false;
 		for (Attribute att : syst.getAttributes()) {
-			assertTrue( "Unexpected super-class for String: "+att.getName(),
-					att.getName().equals("out") || att.getName().equals("err") );
-
+			if (att.getName().equals("out")) {
+				foundOut = true;
+			}
+			else {
+				assertTrue( "Unexpected System attribute: "+att.getName(), att.getName().equals("err") );
+			}
 		}
+		assertTrue("System does not have an attribute 'out'", foundOut);
 	}
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 116)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 117)
@@ -1,509 +0,0 @@
-package fr.inria.verveine.extractor.java;
-
-import java.util.Collection;
-import java.util.List;
-
-import org.eclipse.jdt.core.dom.ASTVisitor;
-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
-import org.eclipse.jdt.core.dom.ArrayAccess;
-import org.eclipse.jdt.core.dom.ArrayCreation;
-import org.eclipse.jdt.core.dom.Assignment;
-import org.eclipse.jdt.core.dom.CastExpression;
-import org.eclipse.jdt.core.dom.CatchClause;
-import org.eclipse.jdt.core.dom.ClassInstanceCreation;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.ConditionalExpression;
-import org.eclipse.jdt.core.dom.Expression;
-import org.eclipse.jdt.core.dom.FieldAccess;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.IBinding;
-import org.eclipse.jdt.core.dom.IMethodBinding;
-import org.eclipse.jdt.core.dom.IPackageBinding;
-import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IVariableBinding;
-import org.eclipse.jdt.core.dom.ImportDeclaration;
-import org.eclipse.jdt.core.dom.InfixExpression;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.MethodInvocation;
-import org.eclipse.jdt.core.dom.Name;
-import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParenthesizedExpression;
-import org.eclipse.jdt.core.dom.QualifiedName;
-import org.eclipse.jdt.core.dom.QualifiedType;
-import org.eclipse.jdt.core.dom.SimpleName;
-import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.StringLiteral;
-import org.eclipse.jdt.core.dom.SuperFieldAccess;
-import org.eclipse.jdt.core.dom.SuperMethodInvocation;
-import org.eclipse.jdt.core.dom.ThisExpression;
-import org.eclipse.jdt.core.dom.ThrowStatement;
-import org.eclipse.jdt.core.dom.Type;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeLiteral;
-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
-
-import fr.inria.verveine.core.EntityStack;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.Class;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-
-/**
- * AST Visitor that defines all the (Famix) entities of interest and links betgween them
- * Famix entities are stored in a Map along with the (AST) IBindings to which they correspond
- */
-public class VerveineRefVisitor extends ASTVisitor {
-
-	/** 
-	 * A dictionary allowing to recover created FAMIX Entities
-	 */
-	protected JavaDictionary dico;
-
-	/**
-	 * A stack that keeps the current definition context (package/class/method)
-	 */
-	protected EntityStack context;
-
-	public VerveineRefVisitor(JavaDictionary dico) {
-		this.dico = dico;
-		this.context = new EntityStack();
-	}
-
-	// VISITOR METHODS
-
-	public boolean visit(CompilationUnit node) {
-//		System.err.println("TRACE, RefVisiting CompilationUnit");
-
-		PackageDeclaration pckg = node.getPackage();
-		Namespace fmx = null;
-		if (pckg==null) {
-			 fmx = dico.ensureFamixNamespaceDefault();
-		}
-		else {
-			fmx = (Namespace)dico.getEntityByKey(pckg.resolveBinding());
-		}
-		if (pckg != null) {
-			this.context.pushPckg(fmx);
-			return super.visit(node);
-		}
-		else {
-			this.context.pushPckg(null);
-			return false;
-		}
-	}
-
-	public void endVisit(CompilationUnit node) {
-		this.context.popPckg();
-		super.endVisit(node);
-	}
-
-	/**
-	 * creating reference from package of this compilation unit to imported package
-	 * not sure it is a good idea ?!?
-	 */
-	public boolean visit(ImportDeclaration node) {
-
-		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
-
-		IBinding importBnd = node.resolveBinding();
-		String importName = node.getName().getFullyQualifiedName();
-		if (importBnd instanceof IMethodBinding)  {
-			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
-			importName = dico.removeLastName(importName);
-			importName = dico.removeLastName(importName);
-		}
-		else if (importBnd instanceof IVariableBinding)  {
-			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
-			importName = dico.removeLastName(importName);
-			importName = dico.removeLastName(importName);
-		}
-		else if (importBnd instanceof ITypeBinding)  {
-			importBnd = ((ITypeBinding)importBnd).getPackage();
-			importName = dico.removeLastName(importName);
-		}
-		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.addFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
-		
-		return super.visit(node);
-	}
-
-	public boolean visit(TypeDeclaration node) {
-//		System.err.println("TRACE, RefVisiting TypeDeclaration: "+node.getName().getIdentifier());
-		ITypeBinding bnd = node.resolveBinding();
-		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
-		if (fmx != null) {
-			this.context.pushClass(fmx );
-
-			dico.addFamixAnnotationInstances(bnd, fmx);
-
-			return super.visit(node);
-		}
-		else {
-			this.context.pushClass(null);
-			return false;
-		}
-	}
-
-	public void endVisit(TypeDeclaration node) {
-		this.context.popClass();
-		super.endVisit(node);
-	}
-
-	public boolean visit(ClassInstanceCreation node) {
-//		System.err.println("TRACE, RefVisiting ClassInstanceCreation");
-		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
-		if (decl != null) {
-			ITypeBinding bnd = decl.resolveBinding();
-			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
-			if (fmx != null) {
-				this.context.pushClass(fmx);
-				dico.addFamixAnnotationInstances(bnd, fmx);
-				return super.visit(node);
-			}
-			else {
-				this.context.pushClass(null );
-				return false;
-			}
-		}
-		else {// TODO appears to be a new: class reference
-			return super.visit(node);
-		}
-	}
-
-	public void endVisit(AnonymousClassDeclaration node) {
-		this.context.popClass();
-		super.endVisit(node);
-	}
-
-	@SuppressWarnings("unchecked")
-	public boolean visit(MethodDeclaration node) {
-//		System.err.println("TRACE, RefVisiting MethodDeclaration: "+node.getName().getIdentifier());
-
-		IMethodBinding bnd = node.resolveBinding();
-		Method meth = (Method) dico.getEntityByKey(bnd);
-
-		if (meth != null) {
-			this.context.pushMethod(meth);
-
-			dico.addFamixAnnotationInstances(bnd, meth);
-
-			// Exceptions
-			for (Name excepName : (List<Name>)node.thrownExceptions()) {
-				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
-				if (excepFmx != null) {
-					dico.createFamixDeclaredException(meth, excepFmx);
-				}
-			}
-			return super.visit(node);
-		}
-		else {
-			this.context.pushMethod(null);
-			return false;
-		}
-
-	}
-
-	public void endVisit(MethodDeclaration node) {
-		this.context.popMethod();
-		super.endVisit(node);
-	}
-
-	@SuppressWarnings({ "unchecked" })
-	public boolean visit(FieldDeclaration node) {
-//		System.err.println("TRACE, RefVisiting FieldDeclaration: ");
-		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-			IVariableBinding bnd = vd.resolveBinding();
-			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
-
-			if (fmx != null) {
-				dico.addFamixAnnotationInstances(bnd, fmx);
-			}
-		}
-		return super.visit(node);
-	}
-
-	public boolean visit(MethodInvocation node) {
-		Expression callingExpr = node.getExpression();
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(callingExpr));
-		if (callingExpr instanceof SimpleName) {
-			// we might have a hidden FieldAccess here
-			IBinding bnd = ((Name) callingExpr).resolveBinding();
-			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
-				BehaviouralEntity accessor = this.context.topMethod();
-				// note: using a field without anything before, owner must be the currently parsed class
-				createAccessedAttribute((IVariableBinding)bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass(), accessor);
-			}
-		}
-		return super.visit(node);
-	}
-
-	@SuppressWarnings({ "static-access" })
-	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(dico.SUPER_NAME, this.context.topClass(), context.top()));
-		return super.visit(node);
-	}
-
-	/**
-	 * Handles an invocation of a method by creating the corresponding Famix Entity
-	 * @param calledBnd -- a binding for the method
-	 * @param calledName of the method invoked
-	 * @param receiver of the call, i.e. the object to which the message is sent
-	 */
-	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
-		BehaviouralEntity sender = this.context.topMethod();
-		if (sender != null) {
-			Method invoked = null;
-			if (receiver instanceof StructuralEntity) {
-				fr.inria.verveine.core.gen.famix.Type varTyp = ((StructuralEntity)receiver).getDeclaredType();
-				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/varTyp);  // cast needed to desambiguate the call
-			}
-			else {
-				// method static of a class called on the class
-				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
-			}
-			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
-		}
-	}
-
-	public boolean visit(FieldAccess node) {
-		BehaviouralEntity accessor = this.context.topMethod();
-		IVariableBinding bnd = node.resolveFieldBinding();
-		// FIXME if bnd == null we have a problem
-		createAccessedAttribute(bnd, node.getName().getIdentifier(), null, null, accessor);
-
-		return super.visit(node);
-	}
-
-	/*
-	 * Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
-	 */
-	public boolean visit(QualifiedName node) {
-		IBinding bnd = node.resolveBinding();
-		if (bnd instanceof IVariableBinding) {
-			// apparently this is a field
-			BehaviouralEntity accessor = this.context.topMethod();
-			createAccessedAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null, accessor);
-		}
-		return super.visit(node);
-	}
-
-	/* 
-	 * Another FieldAccess in disguise: SomeClass.class
-	 */
-	public boolean visit(TypeLiteral node) {
-		fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
-		BehaviouralEntity accessor = this.context.topMethod();
-		createAccessedAttribute(null, "class", javaMetaClass, javaMetaClass, accessor);
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(CatchClause node) {
-		Method meth = this.context.topMethod();
-		Type excepClass = node.getException().getType();
-		if (meth != null) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
-			if (excepClass instanceof SimpleType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
-			}
-			else if (excepClass instanceof QualifiedType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), /*owner*/null, /*isGeneric*/false);
-			}
-			if (excepFmx != null) {
-				dico.createFamixCaughtException(meth, excepFmx);
-			}
-		}
-
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(ThrowStatement node) {
-		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), /*name*/(String)null, /*owner*/(ContainerEntity)null, /*isGeneric*/false);
-		if (excepFmx != null) {
-			dico.createFamixThrownException(meth, excepFmx);
-		}
-		return super.visit(node);
-	}
-
-	/**
-	 * Finds and/or create the Famix Entity receiving a message
-	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
-	 * @param expr -- the Java expression describing the receiver
-	 * @return the Famix Entity or null if could not find it
-	 */
-	@SuppressWarnings("static-access")
-	private NamedEntity getReceiver(Expression expr) {
-		// msg(), same as ThisExpression
-		if (expr == null) {
-			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
-		}
-
-		// array[i].msg()
-		else if (expr instanceof ArrayAccess) {
-			return getReceiver(((ArrayAccess) expr).getArray());
-		}
-
-		// new type[].msg() -- TODO similar to ClassInstanceCreation
-		else if (expr instanceof ArrayCreation) {
-			//System.err.println("WARNING: Ignored receiver expression in method call: ArrayCreation");
-			return null;
-		}
-
-		// (variable = value).msg()
-		else if (expr instanceof Assignment) {
-			return getReceiver(((Assignment) expr).getLeftHandSide());
-		}
-
-		// ((type)expr).msg()
-		else if (expr instanceof CastExpression) {
-			return getReceiver(((CastExpression) expr).getExpression());
-		}
-
-		// new Class().msg() -- TODO anonymous object of a known class ...
-		else if (expr instanceof ClassInstanceCreation) {
-			//System.err.println("WARNING: Ignored receiver expression in method call: ClassInstanceCreation");
-			return null;
-		}
-
-		// (cond-expr ? then-expr : else-expr).msg()
-		else if (expr instanceof ConditionalExpression) {
-			// can be one or the other (then-expr/else-expr) so we choose one
-			NamedEntity ret = getReceiver(((ConditionalExpression) expr).getThenExpression());
-			if (ret == null) {
-				// can as well try the other
-				ret = getReceiver(((ConditionalExpression) expr).getElseExpression());
-			}
-			return ret;
-		}
-
-		// field.msg()
-		else if (expr instanceof FieldAccess) {
-			Attribute ret = createAccessedAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), /*type*/null, /*owner*/null, /*accessor*/null);
-			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
-				ret.setParentType(dico.ensureFamixClassArray());
-			}
-
-			return ret;
-		}
-
-		// (left-expr oper right-expr).msg()
-		else if (expr instanceof InfixExpression) {
-			// anonymous receiver
-			return null;
-		}
-
-		// msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
-		else if (expr instanceof MethodInvocation) {
-			//System.err.println("WARNING: Ignored receiver expression in method call: MethodInvocation");
-
-			return null;
-		}
-
-		// name.msg()
-		else if (expr instanceof Name) {
-			// can be a class or a variable name
-			IBinding bnd = ((Name) expr).resolveBinding();
-			if (bnd == null) {
-				return null;
-			}
-			NamedEntity ret = null;
-			if (bnd instanceof ITypeBinding) {
-				// msg() is a static method of Name
-				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
-			}
-			else if (bnd instanceof IVariableBinding) {
-				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
-				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = createAccessedAttribute((IVariableBinding)bnd, varName, /*typ*/null, /*owner*/null, /*accessor*/null);
-					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
-						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
-					}
-
-					return ret;
-				}
-				else if ( ((IVariableBinding)bnd).isParameter() ) {
-					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
-				}
-				else { // suppose it's a local variable
-					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
-				}
-			}
-			
-			return ret;
-		}
-
-		// (expr).msg()
-		else if (expr instanceof ParenthesizedExpression) {
-			return getReceiver(((ParenthesizedExpression) expr).getExpression());
-		}
-
-		// "string".msg() -- TODO similar to ClassInstanceCreation, anonymous String object
-		else if (expr instanceof StringLiteral) {
-			//System.err.println("WARNING: Ignored receiver expression in method call: StringLiteral");
-			return null;
-		}
-
-		// super.field.msg()
-		else if (expr instanceof SuperFieldAccess) {
-			Attribute ret = createAccessedAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), /*typ*/null, /*owner*/null, /*accessor*/null);
-			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
-				ret.setParentType(dico.ensureFamixClassArray());
-			}
-
-			return ret;
-		}
-
-		// super.msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
-		else if (expr instanceof SuperMethodInvocation) {
-			//System.err.println("WARNING: Ignored receiver expression in method call: SuperMethodInvocation");
-			
-			return null;
-		}
-		
-		// this.msg()
-		else if (expr instanceof ThisExpression) {
-			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
-		}
-
-		// type.class.msg()
-		else if (expr instanceof TypeLiteral) {
-			// similar to a field access
-			Attribute ret;
-			fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
-			ret =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
-
-			return ret;
-		}
-
-		// ... OTHER POSSIBLE EXPRESSIONS ?
-		else  {
-			System.err.println("WARNING: Unexpected receiver expression: "+expr.getClass().getName()+" (method called is" + expr.getClass().getName() + ".aMethod(...))");
-		}
-
-		return null;
-	}
-
-	private Attribute createAccessedAttribute(IVariableBinding bnd, String attName, fr.inria.verveine.core.gen.famix.Type typ, fr.inria.verveine.core.gen.famix.Type owner, BehaviouralEntity accessor) {
-		Attribute accessed;
-		if (bnd != null) {
-			bnd = bnd.getVariableDeclaration();
-		}
-		accessed =  dico.ensureFamixAttribute(bnd, attName, typ, owner);
-		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
-			accessed.setParentType(dico.ensureFamixClassArray());
-		}
-		
-		if ( (accessed != null) && (accessor != null) ) {
-			context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
-		}
-		return accessed;
-	}
-}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 116)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 117)
@@ -1,500 +0,0 @@
-package fr.inria.verveine.extractor.java;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.eclipse.jdt.core.dom.ASTNode;
-import org.eclipse.jdt.core.dom.ASTVisitor;
-import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
-import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
-import org.eclipse.jdt.core.dom.AssertStatement;
-import org.eclipse.jdt.core.dom.Assignment;
-import org.eclipse.jdt.core.dom.ClassInstanceCreation;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.ConstructorInvocation;
-import org.eclipse.jdt.core.dom.ContinueStatement;
-import org.eclipse.jdt.core.dom.DoStatement;
-import org.eclipse.jdt.core.dom.EnhancedForStatement;
-import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
-import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.ForStatement;
-import org.eclipse.jdt.core.dom.IMethodBinding;
-import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.MethodInvocation;
-import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParameterizedType;
-import org.eclipse.jdt.core.dom.ReturnStatement;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
-import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
-import org.eclipse.jdt.core.dom.SuperMethodInvocation;
-import org.eclipse.jdt.core.dom.SwitchCase;
-import org.eclipse.jdt.core.dom.SwitchStatement;
-import org.eclipse.jdt.core.dom.SynchronizedStatement;
-import org.eclipse.jdt.core.dom.ThrowStatement;
-import org.eclipse.jdt.core.dom.TryStatement;
-import org.eclipse.jdt.core.dom.Type;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeParameter;
-import org.eclipse.jdt.core.dom.VariableDeclaration;
-import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
-import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
-import org.eclipse.jdt.core.dom.WhileStatement;
-
-import fr.inria.verveine.core.EntityStack;
-import fr.inria.verveine.core.gen.famix.AnnotationType;
-import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
-import fr.inria.verveine.core.gen.famix.Class;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.EnumValue;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.ParameterType;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-
-/**
- * AST Visitor that defines all the (Famix) entities of interest
- * Famix entities are stored in a Map along with the IBindings to which they correspond
- */
-public class VerveineDefVisitor extends ASTVisitor {
-
-	/** 
-	 * A dictionary allowing to recover created FAMIX Entities
-	 */
-	protected JavaDictionary dico;
-
-	/**
-	 * A stack that keeps the current definition context (package/class/method)
-	 */
-	protected EntityStack context;
-
-	public VerveineDefVisitor(JavaDictionary dico) {
-		this.dico = dico;
-		this.context = new EntityStack();
-	}
-
-	// VISITOR METHODS
-
-	public boolean visit(CompilationUnit node) {
-//		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
-		Namespace fmx = null;
-		PackageDeclaration pckg = node.getPackage();
-		if (pckg==null) {
-			fmx = dico.ensureFamixNamespaceDefault();
-		}
-		else {
-			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
-			fmx.setIsStub(false);
-		}
-
-		if (pckg != null) {
-			return super.visit(node);
-		}
-		else {
-			this.context.pushPckg(null);
-			return false;
-		}
-	}
-
-	public void endVisit(CompilationUnit node) {
-		this.context.popPckg();
-		super.endVisit(node);
-	}
-
-	/*
-	 * Can only be a class or interface declaration
-	 */
-	public boolean visit(TypeDeclaration node) {
-//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
-		ITypeBinding bnd = node.resolveBinding();
-		@SuppressWarnings("unchecked")
-		List<TypeParameter> tparams = (List<TypeParameter>)node.typeParameters();
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), tparams.size()>0); //   /*ctxt*/context.top());
-		if (fmx != null) {
-			fmx.setIsStub(false);
-
-			this.context.pushClass(fmx);
-
-			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
-			
-			for (TypeParameter tp : tparams) {
-				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
-				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note: owner of the ParameterType is the ParameterizableClass
-				if (fmxParam != null) {
-					fmxParam.setIsStub(false);
-				}
-			}
-			return super.visit(node);
-		}
-		else {
-			this.context.pushClass(null);
-			return false;
-		}
-	}
-
-	public void endVisit(TypeDeclaration node) {
-		this.context.popClass();
-		super.endVisit(node);
-	}
-
-	public boolean visit(ClassInstanceCreation node) {
-//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
-		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
-		if (decl != null) {
-			fmx = (Class) this.dico.ensureFamixType(decl.resolveBinding(), /*name*/"anonymous("+dico.findTypeName(node.getType())+")", /*owner*/context.top(), /*ctxt*/context.top());  //  isGeneric = false
-			if (fmx != null) {
-				fmx.setIsStub(false);
-
-				dico.addSourceAnchor(fmx, node);
-				this.context.pushClass(fmx);
-				return super.visit(node);
-			}
-			else {
-				this.context.pushClass(null);
-				return false;
-			}
-		}
-		return super.visit(node);
-	}
-
-	public void endVisit(ClassInstanceCreation node) {
-		if (node.getAnonymousClassDeclaration() != null) {
-			this.context.popClass();
-		}
-		super.endVisit(node);
-	}
-
-	public boolean visit(AnnotationTypeDeclaration node) {
-//		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
-		ITypeBinding bnd = node.resolveBinding();
-		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
-		if (fmx != null) {
-			fmx.setIsStub(Boolean.FALSE);
-			
-			context.pushAnnotationType(fmx);
-			return super.visit(node);
-		}
-		else {
-			context.pushAnnotationType(null);
-			return false;
-		}
-	}
-
-	public void endVisit(AnnotationTypeDeclaration node) {
-		this.context.popAnnotationType();
-		super.endVisit(node);
-	}
-
-	public boolean visit(AnnotationTypeMemberDeclaration node) {
-//		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
-		IMethodBinding bnd = node.resolveBinding();
-		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
-		if (fmx != null) {
-			fmx.setIsStub(false);
-			
-			context.pushAnnotationMember(fmx);
-			return super.visit(node);
-		}
-		else {
-			context.pushAnnotationMember(null);
-			return false;
-		}
-	}
-
-	public void endVisit(AnnotationTypeMemberDeclaration node) {
-		this.context.popAnnotationMember();
-		super.endVisit(node);
-	}
-
-	@SuppressWarnings("unchecked")
-	public boolean visit(EnumDeclaration node) {
-//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
-		if (fmx != null) {
-			fmx.setIsStub(Boolean.FALSE);
-			
-			for (EnumConstantDeclaration ecst : (List<EnumConstantDeclaration>)node.enumConstants()) {
-				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
-				ev.setIsStub(Boolean.FALSE);
-			}
-			return super.visit(node);
-		}
-		else {
-			return false;
-		}
-	}
-
-	@SuppressWarnings("unchecked")
-	public boolean visit(MethodDeclaration node) {
-//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
-		
-		// some info needed to create the Famix Method
-		IMethodBinding bnd = node.resolveBinding();
-
-		Collection<Type> paramTypes = new ArrayList<Type>();
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				paramTypes.add(param.getType());
-		}
-
-		// creating/recovering it
-		// creates it with a fake return type because we might need this FamixMethod to create the return type (if it is a ParameterizedType)
-		// we reset the return type to its proper value later
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/dico.ensureFamixClassObject(null), context.topClass());
-
-		if (fmx != null) {
-			fmx.setIsStub(false);
-			
-			this.context.pushMethod(fmx);
-			fr.inria.verveine.core.gen.famix.Type fmxRetTyp = referedType(node.getReturnType2(), fmx);
-			fmx.setDeclaredType(fmxRetTyp);
-			if (node.getBody() != null) {
-				context.setTopMethodCyclo(1);
-			}
-
-			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
-
-			// creating the method's parameters
-			List<VariableDeclaration> paramAsVarList;
-			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				// Note: method and ParamTyp bindings are null for ParameterType :-(
-				paramAsVarList = new ArrayList<VariableDeclaration>(1);
-				paramAsVarList.add(param);
-				fr.inria.verveine.core.gen.famix.Type varTyp = referedType(param.getType(), context.topMethod());
-				visitVariablesDeclarations(node, varTyp, paramAsVarList, context.topMethod());
-			}
-			return super.visit(node);
-		}
-		else {
-			this.context.pushMethod(null);
-			return false;
-		}
-	}
-
-	public void endVisit(MethodDeclaration node) {
-		int cyclo = 0;
-		int nos = 0;
-		if (context.topMethod() != null) {
-			cyclo = context.getTopMethodCyclo();
-			nos = context.getTopMethodNOS();
-		}
-		Method fmx = this.context.popMethod();
-		if (fmx != null) {
-			fmx.setNOS(nos);
-			fmx.setCyclo(cyclo);
-		}
-		super.endVisit(node);
-	}
-
-	@SuppressWarnings({ "unchecked" })
-	public boolean visit(FieldDeclaration node) {
-//		System.err.println("TRACE, DefVisiting FieldDeclaration");
-
-		fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topClass());
-		for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
-			dico.addSourceAnchor(att, node);
-			dico.createFamixComment(node.getJavadoc(), att);
-		}
-		return super.visit(node);
-	}
-
-	@SuppressWarnings("unchecked")
-	public boolean visit(VariableDeclarationExpression node) {
-//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-
-		// we don't declare (local) variables that have a primitive type
-		// because we are assuming that the user is not interested in them 
-		if (! node.getType().isPrimitiveType()) {
-			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
-			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
-				dico.addSourceAnchor(att, node);
-			}
-		}
-
-		return super.visit(node);
-	}
-
-	@SuppressWarnings("unchecked")
-	public boolean visit(VariableDeclarationStatement node) {
-//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-
-		// we don't declare (local) variables that have a primitive type
-		// because we are assuming that the user is not interested in them 
-		if (! node.getType().isPrimitiveType()) {
-			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
-			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
-				dico.addSourceAnchor(att, node);
-			}
-		}
-
-		return super.visit(node);
-	}
-
-	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, fr.inria.verveine.core.gen.famix.Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
-		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
-
-		for (VariableDeclaration vd : fragments) {
-			StructuralEntity fmx;
-			if (node instanceof MethodDeclaration) {
-				// creating the parameters of a method. In this case, 'fragment' is aList<SingleVariableDeclarationFragment> and 'varType' is null
-				fmx = dico.ensureFamixParameter(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method)ctxt);
-			}
-			else if (node instanceof FieldDeclaration) {
-				// creating a class' field
-				fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
-			}
-			else if (node instanceof VariableDeclarationExpression) {
-				// creating a method's local variable
-				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method) ctxt);
-			}
-			else if (node instanceof VariableDeclarationExpression) {
-				// creating a method's local variable
-				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method) ctxt);
-			}
-			else {
-				fmx = null;
-			}
-
-			if (fmx != null) {
-				fmx.setIsStub(false);
-				ret.add(fmx);
-			}
-		}
-
-		return ret;
-	}
-
-	@SuppressWarnings("unchecked")
-	private fr.inria.verveine.core.gen.famix.Type referedType(Type typ, ContainerEntity ctxt) {
-		fr.inria.verveine.core.gen.famix.Type fmxTyp = null;
-
-		if (typ == null) {
-			return null;
-		}
-
-		if (typ.isParameterizedType()) {
-			ITypeBinding parameterizedBnd = typ.resolveBinding();
-			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
-			String tname = dico.findTypeName(typ);
-			ParameterizableClass generic = null;
-			generic = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
-
-			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, generic, /*owner*/ctxt);
-			for (Type targ : (List<Type>) ((ParameterizedType)typ).typeArguments()) {
-				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), /*owner*/null, ctxt);
-				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
-			}
-		}
-		else {
-			fmxTyp = dico.ensureFamixType(typ.resolveBinding(), dico.findTypeName(typ), /*owner*/null, ctxt);
-		}
-		return fmxTyp;
-	}
-
-	// METRICS: CYCLO, NOS
-	
-	public boolean visit(AssertStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(Assignment node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(ConstructorInvocation node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(ContinueStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(DoStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(EnhancedForStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(ForStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(IfStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(MethodInvocation node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(ReturnStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(SuperConstructorInvocation node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(SuperMethodInvocation node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(SwitchCase node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(SwitchStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(SynchronizedStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(ThrowStatement node) {
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(TryStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-	public boolean visit(WhileStatement node) {
-		this.context.addTopMethodCyclo(1);
-		this.context.addTopMethodNOS(1);
-		return super.visit(node);
-	}
-
-}
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineVisitor.java	(revision 117)
@@ -0,0 +1,857 @@
+package fr.inria.verveine.extractor.java;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
+import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
+import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.ArrayAccess;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.AssertStatement;
+import org.eclipse.jdt.core.dom.Assignment;
+import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConditionalExpression;
+import org.eclipse.jdt.core.dom.ConstructorInvocation;
+import org.eclipse.jdt.core.dom.ContinueStatement;
+import org.eclipse.jdt.core.dom.DoStatement;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
+import org.eclipse.jdt.core.dom.EnumDeclaration;
+import org.eclipse.jdt.core.dom.Expression;
+import org.eclipse.jdt.core.dom.FieldAccess;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.ForStatement;
+import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.IPackageBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.ImportDeclaration;
+import org.eclipse.jdt.core.dom.InfixExpression;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.Name;
+import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.ParenthesizedExpression;
+import org.eclipse.jdt.core.dom.QualifiedName;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.ReturnStatement;
+import org.eclipse.jdt.core.dom.SimpleName;
+import org.eclipse.jdt.core.dom.SimpleType;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.StringLiteral;
+import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperFieldAccess;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.SwitchCase;
+import org.eclipse.jdt.core.dom.SwitchStatement;
+import org.eclipse.jdt.core.dom.SynchronizedStatement;
+import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.TryStatement;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeLiteral;
+import org.eclipse.jdt.core.dom.TypeParameter;
+import org.eclipse.jdt.core.dom.VariableDeclaration;
+import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
+import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WhileStatement;
+
+import fr.inria.verveine.core.Dictionary;
+import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+
+/**
+ * AST Visitor that defines all the (Famix) entities of interest
+ * Famix entities are stored in a Map along with the IBindings to which they correspond
+ */
+public class VerveineVisitor extends ASTVisitor {
+
+	/** 
+	 * A dictionary allowing to recover created FAMIX Entities
+	 */
+	protected JavaDictionary dico;
+
+	/**
+	 * A stack that keeps the current definition context (package/class/method)
+	 */
+	protected EntityStack context;
+
+	public VerveineVisitor(JavaDictionary dico) {
+		this.dico = dico;
+		this.context = new EntityStack();
+	}
+
+	// VISITOR METHODS
+
+	public boolean visit(CompilationUnit node) {
+//		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
+		Namespace fmx = null;
+		PackageDeclaration pckg = node.getPackage();
+		if (pckg==null) {
+			fmx = dico.ensureFamixNamespaceDefault();
+		}
+		else {
+			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
+			fmx.setIsStub(false);
+		}
+
+		if (pckg != null) {
+			return super.visit(node);
+		}
+		else {
+			return false;
+		}
+	}
+
+	public void endVisit(CompilationUnit node) {
+		this.context.popPckg();
+		super.endVisit(node);
+	}
+
+	/**
+	 * creating reference from package of this compilation unit to imported package
+	 * not sure it is a good idea ?!?
+	 */
+	public boolean visit(ImportDeclaration node) {
+
+		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
+
+		IBinding importBnd = node.resolveBinding();
+		String importName = node.getName().getFullyQualifiedName();
+		if (importBnd instanceof IMethodBinding)  {
+			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
+		}
+		else if (importBnd instanceof IVariableBinding)  {
+			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
+		}
+		else if (importBnd instanceof ITypeBinding)  {
+			importBnd = ((ITypeBinding)importBnd).getPackage();
+			importName = dico.removeLastName(importName);
+		}
+		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
+		context.setLastReference( dico.addFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		
+		return super.visit(node);
+	}
+
+	/*
+	 * Can only be a class or interface declaration
+	 */
+	public boolean visit(TypeDeclaration node) {
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		@SuppressWarnings("unchecked")
+		List<TypeParameter> tparams = (List<TypeParameter>)node.typeParameters();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), tparams.size()>0); //   /*ctxt*/context.top());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+
+			this.context.pushClass(fmx);
+
+			dico.addSourceAnchor(fmx, node);
+			dico.addFamixAnnotationInstances(bnd, fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+			
+			for (TypeParameter tp : tparams) {
+				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
+				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note: owner of the ParameterType is the ParameterizableClass
+				if (fmxParam != null) {
+					fmxParam.setIsStub(false);
+				}
+			}
+			return super.visit(node);
+		}
+		else {
+			return false;
+		}
+	}
+
+	public void endVisit(TypeDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(ClassInstanceCreation node) {
+//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
+		if (decl != null) {
+			ITypeBinding bnd = decl.resolveBinding();
+			fmx = (Class) this.dico.ensureFamixType(bnd, /*name*/"anonymous("+dico.findTypeName(node.getType())+")", /*owner*/context.top(), /*ctxt*/context.top());  //  isGeneric = false
+			if (fmx != null) {
+				fmx.setIsStub(false);
+
+				dico.addFamixAnnotationInstances(bnd, fmx);
+				dico.addSourceAnchor(fmx, node);
+				this.context.pushClass(fmx);
+				return super.visit(node);
+			}
+			else {
+				return false;
+			}
+		}
+		return super.visit(node);
+	}
+
+	/* 
+	 * intended to close 'visit(ClassInstanceCreation node)' for just this specific case
+	 */
+	public void endVisit(AnonymousClassDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeDeclaration node) {
+//		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			context.pushAnnotationType(fmx);
+			return super.visit(node);
+		}
+		else {
+			context.pushAnnotationType(null);
+			return false;
+		}
+	}
+
+	public void endVisit(AnnotationTypeDeclaration node) {
+		this.context.popAnnotationType();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeMemberDeclaration node) {
+//		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+		IMethodBinding bnd = node.resolveBinding();
+		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			context.pushAnnotationMember(fmx);
+			return super.visit(node);
+		}
+		else {
+			context.pushAnnotationMember(null);
+			return false;
+		}
+	}
+
+	public void endVisit(AnnotationTypeMemberDeclaration node) {
+		this.context.popAnnotationMember();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(EnumDeclaration node) {
+//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			for (EnumConstantDeclaration ecst : (List<EnumConstantDeclaration>)node.enumConstants()) {
+				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
+				ev.setIsStub(Boolean.FALSE);
+			}
+			return super.visit(node);
+		}
+		else {
+			return false;
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(MethodDeclaration node) {
+//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		
+		// some info needed to create the Famix Method
+		IMethodBinding bnd = node.resolveBinding();
+
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+
+		// creating/recovering it
+		// creates it with a fake return type because we might need this FamixMethod to create the return type (if it is a ParameterizedType)
+		// we reset the return type to its proper value later
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/dico.ensureFamixClassObject(null), context.topClass());
+
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			// now will recompute the actual returnType
+			this.context.pushMethod(fmx);
+			fr.inria.verveine.core.gen.famix.Type fmxRetTyp = referedType(node.getReturnType2(), fmx);
+			fmx.setDeclaredType(fmxRetTyp);
+
+			dico.addSourceAnchor(fmx, node);
+			dico.addFamixAnnotationInstances(bnd, fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
+			// creating the method's parameters
+			List<VariableDeclaration> paramAsVarList;
+			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				// Note: method and ParamTyp bindings are null for ParameterType :-(
+				paramAsVarList = new ArrayList<VariableDeclaration>(1);
+				paramAsVarList.add(param);
+				fr.inria.verveine.core.gen.famix.Type varTyp = referedType(param.getType(), context.topMethod());
+				visitVariablesDeclarations(node, varTyp, paramAsVarList, context.topMethod());
+			}
+
+			// Exceptions
+			for (Name excepName : (List<Name>)node.thrownExceptions()) {
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
+				if (excepFmx != null) {
+					dico.createFamixDeclaredException(fmx, excepFmx);
+				}
+			}
+
+			return super.visit(node);
+		}
+		else {
+			this.context.pushMethod(null);
+			return false;
+		}
+	}
+
+	public void endVisit(MethodDeclaration node) {
+		int cyclo = 0;
+		int nos = 0;
+		if (context.topMethod() != null) {
+			cyclo = context.getTopMethodCyclo();
+			nos = context.getTopMethodNOS();
+		}
+		Method fmx = this.context.popMethod();
+		if (fmx != null) {
+			fmx.setNOS(nos);
+			fmx.setCyclo(cyclo);
+		}
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, DefVisiting FieldDeclaration");
+
+		fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topClass());
+		for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
+			dico.addSourceAnchor(att, node);
+			dico.createFamixComment(node.getJavadoc(), att);
+		}
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationExpression node) {
+//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
+			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationStatement node) {
+//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
+			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, fr.inria.verveine.core.gen.famix.Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
+		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
+
+		for (VariableDeclaration vd : fragments) {
+			StructuralEntity fmx;
+			IVariableBinding bnd = vd.resolveBinding();
+			String name = vd.getName().getIdentifier();
+
+			if (node instanceof MethodDeclaration) {
+				// creating the parameters of a method. In this case, 'fragment' is aList<SingleVariableDeclarationFragment> and 'varType' is null
+				fmx = dico.ensureFamixParameter(bnd, name, varTyp, (Method)ctxt);
+			}
+			else if (node instanceof FieldDeclaration) {
+				// creating a class' field
+				fmx = dico.ensureFamixAttribute(bnd, name, varTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(bnd, name, varTyp, (Method) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(bnd, name, varTyp, (Method) ctxt);
+			}
+			else {
+				fmx = null;
+			}
+
+			if (fmx != null) {
+				fmx.setIsStub(false);
+				dico.addFamixAnnotationInstances(bnd, fmx);
+				ret.add(fmx);
+			}
+		}
+
+		return ret;
+	}
+
+	@SuppressWarnings("unchecked")
+	private fr.inria.verveine.core.gen.famix.Type referedType(Type typ, ContainerEntity ctxt) {
+		fr.inria.verveine.core.gen.famix.Type fmxTyp = null;
+
+		if (typ == null) {
+			return null;
+		}
+
+		if (typ.isParameterizedType()) {
+			ITypeBinding parameterizedBnd = typ.resolveBinding();
+			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
+			String tname = dico.findTypeName(typ);
+			ParameterizableClass generic = null;
+			generic = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
+
+			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, generic, /*owner*/ctxt);
+			for (Type targ : (List<Type>) ((ParameterizedType)typ).typeArguments()) {
+				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), /*owner*/null, ctxt);
+				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
+			}
+		}
+		else {
+			fmxTyp = dico.ensureFamixType(typ.resolveBinding(), dico.findTypeName(typ), /*owner*/null, ctxt);
+		}
+		return fmxTyp;
+	}
+
+	public boolean visit(MethodInvocation node) {
+		Expression callingExpr = node.getExpression();
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(callingExpr));
+		if (callingExpr instanceof SimpleName) {
+			// we might have a hidden FieldAccess here
+			IBinding bnd = ((Name) callingExpr).resolveBinding();
+			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
+				BehaviouralEntity accessor = this.context.topMethod();
+				// note: using a field without anything before, owner must be the currently parsed class
+				createAccessedAttribute((IVariableBinding)bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass(), accessor);
+			}
+		}
+
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperMethodInvocation node) {
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, this.context.topClass(), context.top()));
+
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		
+		// ConstructorInvocation (i.e. 'this(...)' ) happen in constructor, so the name is the same
+		String name = context.topMethod().getName();
+		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), name, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
+		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SELF_NAME, context.topClass(), context.topMethod());
+		context.setLastInvocation( dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation()) );
+
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		
+		// ConstructorInvocation (i.e. 'super(...)' ) happen in constructor, so the name is that of the superclass
+		Method invoked = this.dico.ensureFamixMethod(node.resolveConstructorBinding(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/context.topClass());  // cast needed to desambiguate the call
+		ImplicitVariable receiver = dico.ensureFamixImplicitVariable(Dictionary.SUPER_NAME, context.topClass(), context.topMethod());
+		context.setLastInvocation( dico.addFamixInvocation(context.topMethod(), invoked, receiver, context.getLastInvocation()) );
+
+		return super.visit(node);
+	}
+
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param calledBnd -- a binding for the method
+	 * @param calledName of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
+	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
+		BehaviouralEntity sender = this.context.topMethod();
+		if (sender != null) {
+			Method invoked = null;
+			if (receiver instanceof StructuralEntity) {
+				fr.inria.verveine.core.gen.famix.Type varTyp = ((StructuralEntity)receiver).getDeclaredType();
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/varTyp);  // cast needed to desambiguate the call
+			}
+			else {
+				// method static of a class called on the class
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
+			}
+			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+		}
+	}
+
+	public boolean visit(FieldAccess node) {
+		BehaviouralEntity accessor = this.context.topMethod();
+		IVariableBinding bnd = node.resolveFieldBinding();
+		// FIXME if bnd == null we have a problem
+		createAccessedAttribute(bnd, node.getName().getIdentifier(), null, null, accessor);
+
+		return super.visit(node);
+	}
+
+	/*
+	 * Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
+	 */
+	public boolean visit(QualifiedName node) {
+		IBinding bnd = node.resolveBinding();
+		if (bnd instanceof IVariableBinding) {
+			// apparently this is a field
+			BehaviouralEntity accessor = this.context.topMethod();
+			createAccessedAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null, accessor);
+		}
+		return super.visit(node);
+	}
+
+	/* 
+	 * Another FieldAccess in disguise: SomeClass.class
+	 */
+	public boolean visit(TypeLiteral node) {
+		fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
+		BehaviouralEntity accessor = this.context.topMethod();
+		createAccessedAttribute(null, "class", javaMetaClass, javaMetaClass, accessor);
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(CatchClause node) {
+		Method meth = this.context.topMethod();
+		Type excepClass = node.getException().getType();
+		if (meth != null) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
+			if (excepClass instanceof SimpleType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
+			}
+			else if (excepClass instanceof QualifiedType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), /*owner*/null, /*isGeneric*/false);
+			}
+			if (excepFmx != null) {
+				dico.createFamixCaughtException(meth, excepFmx);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(ThrowStatement node) {
+		this.context.addTopMethodNOS(1);
+
+		Method meth = this.context.topMethod();
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), /*name*/(String)null, /*owner*/(ContainerEntity)null, /*isGeneric*/false);
+		if (excepFmx != null) {
+			dico.createFamixThrownException(meth, excepFmx);
+		}
+		return super.visit(node);
+	}
+
+	public boolean visit(AssertStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(Assignment node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ContinueStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(DoStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(EnhancedForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(IfStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ReturnStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchCase node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SynchronizedStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(TryStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(WhileStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	
+
+	/**
+	 * Finds and/or create the Famix Entity receiving a message
+	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
+	 * @param expr -- the Java expression describing the receiver
+	 * @return the Famix Entity or null if could not find it
+	 */
+	@SuppressWarnings("static-access")
+	private NamedEntity getReceiver(Expression expr) {
+		// msg(), same as ThisExpression
+		if (expr == null) {
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
+		}
+
+		// array[i].msg()
+		else if (expr instanceof ArrayAccess) {
+			return getReceiver(((ArrayAccess) expr).getArray());
+		}
+
+		// new type[].msg() -- TODO similar to ClassInstanceCreation
+		else if (expr instanceof ArrayCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ArrayCreation");
+			return null;
+		}
+
+		// (variable = value).msg()
+		else if (expr instanceof Assignment) {
+			return getReceiver(((Assignment) expr).getLeftHandSide());
+		}
+
+		// ((type)expr).msg()
+		else if (expr instanceof CastExpression) {
+			return getReceiver(((CastExpression) expr).getExpression());
+		}
+
+		// new Class().msg() -- TODO anonymous object of a known class ...
+		else if (expr instanceof ClassInstanceCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ClassInstanceCreation");
+			return null;
+		}
+
+		// (cond-expr ? then-expr : else-expr).msg()
+		else if (expr instanceof ConditionalExpression) {
+			// can be one or the other (then-expr/else-expr) so we choose one
+			NamedEntity ret = getReceiver(((ConditionalExpression) expr).getThenExpression());
+			if (ret == null) {
+				// can as well try the other
+				ret = getReceiver(((ConditionalExpression) expr).getElseExpression());
+			}
+			return ret;
+		}
+
+		// field.msg()
+		else if (expr instanceof FieldAccess) {
+			Attribute ret = createAccessedAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), /*type*/null, /*owner*/null, /*accessor*/null);
+			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
+				ret.setParentType(dico.ensureFamixClassArray());
+			}
+
+			return ret;
+		}
+
+		// (left-expr oper right-expr).msg()
+		else if (expr instanceof InfixExpression) {
+			// anonymous receiver
+			return null;
+		}
+
+		// msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof MethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: MethodInvocation");
+
+			return null;
+		}
+
+		// name.msg()
+		else if (expr instanceof Name) {
+			// can be a class or a variable name
+			IBinding bnd = ((Name) expr).resolveBinding();
+			if (bnd == null) {
+				return null;
+			}
+			NamedEntity ret = null;
+			if (bnd instanceof ITypeBinding) {
+				// msg() is a static method of Name
+				//TODO why returning a variable here? Should not it be the class itself?
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
+			}
+			else if (bnd instanceof IVariableBinding) {
+				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
+				if ( ((IVariableBinding)bnd).isField() ) {
+					ret = createAccessedAttribute((IVariableBinding)bnd, varName, /*typ*/null, /*owner*/null, /*accessor*/null);
+					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
+						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
+					}
+
+					return ret;
+				}
+				else if ( ((IVariableBinding)bnd).isParameter() ) {
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
+				}
+				else { // suppose it's a local variable
+					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
+				}
+			}
+			
+			return ret;
+		}
+
+		// (expr).msg()
+		else if (expr instanceof ParenthesizedExpression) {
+			return getReceiver(((ParenthesizedExpression) expr).getExpression());
+		}
+
+		// "string".msg() -- TODO similar to ClassInstanceCreation, anonymous String object
+		else if (expr instanceof StringLiteral) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: StringLiteral");
+			return null;
+		}
+
+		// super.field.msg()
+		else if (expr instanceof SuperFieldAccess) {
+			Attribute ret = createAccessedAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), /*typ*/null, /*owner*/null, /*accessor*/null);
+			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
+				ret.setParentType(dico.ensureFamixClassArray());
+			}
+
+			return ret;
+		}
+
+		// super.msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof SuperMethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: SuperMethodInvocation");
+			
+			return null;
+		}
+		
+		// this.msg()
+		else if (expr instanceof ThisExpression) {
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
+		}
+
+		// type.class.msg()
+		else if (expr instanceof TypeLiteral) {
+			// similar to a field access
+			Attribute ret;
+			fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
+			ret =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
+
+			return ret;
+		}
+
+		// ... OTHER POSSIBLE EXPRESSIONS ?
+		else  {
+			System.err.println("WARNING: Unexpected receiver expression: "+expr.getClass().getName()+" (method called is" + expr.getClass().getName() + ".aMethod(...))");
+		}
+
+		return null;
+	}
+
+	private Attribute createAccessedAttribute(IVariableBinding bnd, String attName, fr.inria.verveine.core.gen.famix.Type typ, fr.inria.verveine.core.gen.famix.Type owner, BehaviouralEntity accessor) {
+		Attribute accessed;
+		if (bnd != null) {
+			bnd = bnd.getVariableDeclaration();
+		}
+		accessed =  dico.ensureFamixAttribute(bnd, attName, typ, owner);
+		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+			accessed.setParentType(dico.ensureFamixClassArray());
+		}
+		
+		if ( (accessed != null) && (accessor != null) ) {
+			context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+		}
+		return accessed;
+	}
+
+}
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 116)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 117)
@@ -628,15 +628,17 @@
 	 * @param fmx
 	 */
 	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
-		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
-			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
-			
-			Collection<AnnotationInstanceAttribute> annAtts = new ArrayList<AnnotationInstanceAttribute>(); 
-			for (IMemberValuePairBinding annPV : annBnd.getDeclaredMemberValuePairs()) {
-				annAtts.add( createFamixAnnotationInstanceAttribute(ensureFamixAnnotationTypeAttribute(annPV.getMethodBinding(), annPV.getName(), annType), annPV.getValue().toString()));
+		if (bnd != null) {
+			for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
+				AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
+
+				Collection<AnnotationInstanceAttribute> annAtts = new ArrayList<AnnotationInstanceAttribute>(); 
+				for (IMemberValuePairBinding annPV : annBnd.getDeclaredMemberValuePairs()) {
+					annAtts.add( createFamixAnnotationInstanceAttribute(ensureFamixAnnotationTypeAttribute(annPV.getMethodBinding(), annPV.getName(), annType), annPV.getValue().toString()));
+				}
+
+				super.addFamixAnnotationInstance(fmx, annType, annAtts);
 			}
-			
-			super.addFamixAnnotationInstance(fmx, annType, annAtts);
 		}
 	}
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 116)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 117)
@@ -28,8 +28,7 @@
 //		System.out.println("  ******* TRACE, Requestor is visiting : "+sourceFilePath+" *******");
 		
 		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
-		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
-		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
+		ast.accept(new VerveineVisitor(this.famixDictionnary));
 	}
 
 	private Object relativePath(String fullPath) {
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/test_src/Dictionary/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 76)
+++ verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 77)
@@ -30,12 +30,6 @@
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.ThrownException;
 
-/**
- * A dictionnary of Famix entities to help create them and find them back
- * @author anquetil
- *
- * @param <B> The super class of all bindings. Different for JDT, PDT, ... bindings
- */
 public class Dictionary<B> {
 
 	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
@@ -43,39 +37,24 @@
 	public static final String SELF_NAME = "self";
 	public static final String SUPER_NAME = "super";
 
-	/**
-	 * The FAMIX repository where all FAMIX entities are created and stored
-	 */
 	protected Repository famixRepo;
 
-	/**
-	 * A dictionary to map an IBinding to FAMIX Entity
-	 */
 	protected Map<B,NamedEntity> mapBind;
 
-	/**
-	 * Another dictionary to map a name to FAMIX Entities with this name
-	 */
 	protected Map<String,Collection<NamedEntity>> mapName;
 
-	/**
-	 * Yet another dictionary for implicit variables
-	 * 'self' and 'super' have the same binding than their associated class so they can't be kept easily in bindFmxDico
-	 */
 	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
 
-	/**
-	 * Used to keep the two possible ImplicitVariable for a given Class binding
-	 * @author anquetil
-	 */
 	protected class ImplicitVars {
 		public ImplicitVariable self_iv;
 		public ImplicitVariable super_iv;
 	}
+
+	/* method added to test a specific bug with constructor declaration having a null binding */
+	public Dictionary(T arg) {
+		System.out.println(arg + " is not used");
+	}
 	
-	/** Constructor taking a FAMIX repository
-	 * @param famixRepo
-	 */
 	public Dictionary(Repository famixRepo) {
 		this.famixRepo = famixRepo;
 		
@@ -160,12 +139,6 @@
 		mapName.put(name, l_ent);
 	}
 	
-	/**
-	 * Returns all the Famix Entity with the given name and class 
-	 * @param fmxClass -- the subtype of Famix Entity we are looking for
-	 * @param name -- the name of the entity
-	 * @return the Collection of Famix Entities with the given name and class (possibly empty)
-	 */
 	@SuppressWarnings("unchecked")
 	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
 		Collection<T> ret = new LinkedList<T>();
@@ -182,14 +155,6 @@
 		return ret;
 	}
 
-	/**
-	 * Returns the Famix Entity associated to the given binding.
-	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
-	 * In such a case, this method will always retrieve the Class associated to the binding.
-	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
-	 * @param bnd -- the binding
-	 * @return the Famix Entity associated to the binding or null if not found
-	 */
 	public NamedEntity getEntityByBinding(B bnd) {
 		if (bnd == null) {
 			return null;
@@ -199,13 +164,6 @@
 		}
 	}
 
-	/**
-	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
-	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
-	 * @param fmxClass -- the FAMIX class of the instance to create
-	 * @param name -- the name of the new instance
-	 * @return the FAMIX Entity or null in case of a FAMIX error
-	 */
 	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
 
@@ -229,17 +187,6 @@
 		return fmx;
 	}
 	
-	/**
-	 * Returns a FAMIX Entity of the type <b>fmxClass</b> and maps it to its binding <b>bnd</b> (if not null).
-	 * The Entity is created if it did not exist.
-	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use ensureFamixImplicitVariable instead.
-	 * @param fmxClass -- the FAMIX class of the instance to create
-	 * @param bnd -- the binding to map to the new instance
-	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
-	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
-	 * 
-	 * TODO Make public and remove ensureFamixClass(name), ensureFamixAttribute(name), ... ????
-	 */
 	@SuppressWarnings("unchecked")
 	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
@@ -272,22 +219,10 @@
 		return fmx;
 	}
 
-	/**
-	 * Adds an already created Entity to the FAMIX repository
-	 * Used mainly for non-NamedEntity, for example relationships
-	 * @param e -- the FAMIX entity to add to the repository
-	 */
 	public void famixRepoAdd(Entity e) {
 		this.famixRepo.add(e);
 	}
 
-	///// ensure Famix Entities /////
-	
-	/**
-	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Class
-	 * @return the FAMIX Class or null in case of a FAMIX error
-	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
 		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
 		if (fmx != null) {
@@ -302,38 +237,18 @@
 		return fmx;
 	}
 
-	/**
-	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Method
-	 * @return the FAMIX Method or null in case of a FAMIX error
-	 */
 	public Method ensureFamixMethod(String name) {
 		return (Method) ensureFamixEntity(Method.class, null, name);
 	}
 
-	/**
-	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Attribute
-	 * @return the FAMIX Attribute or null in case of a FAMIX error
-	 */
 	public Attribute ensureFamixAttribute(String name) {
 		return (Attribute) ensureFamixEntity(Attribute.class, null, name);
 	}
 
-	/**
-	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX LocalVariable
-	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
-	 */
 	public LocalVariable ensureFamixLocalVariable(String name) {
 		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
 	}
 
-	/**
-	 * Creates and returns a FAMIX Comment
-	 * @param cmt -- the content (String) of the comment 
-	 * @return the FAMIX Comment
-	 */
 	public Comment createFamixComment(String cmt) {
 		Comment fmx = new Comment();
 		fmx.setContent(cmt);
@@ -342,12 +257,6 @@
 		return fmx;
 	}
 
-	/**
-	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
-	 * @param cmt -- the content (String) of the comment 
-	 * @param owner -- the entity concerned by this comment
-	 * @return the FAMIX Comment
-	 */
 	public Comment createFamixComment(String cmt, SourcedEntity owner) {
 		Comment fmx = new Comment();
 		fmx.setContent(cmt);
@@ -356,14 +265,7 @@
 		
 		return fmx;
 	}
-	
-	/**
-	 * Creates and returns a FAMIX Parameter and associates it with an BehaviouralEntity
-	 * @param identifier -- the name of the parameter
-	 * @param owner -- the entity concerned by this parameter
-	 * @param type -- the type of the parameter
-	 * @return the FAMIX parameter
-	 */
+
 	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, String type) {
 		Parameter fmx = new Parameter();
 		fmx.setName(identifier);
@@ -374,14 +276,6 @@
 		return fmx;
 	}
 	
-	///// ensure Famix Relationships /////
-
-	/**
-	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
-	 * @param sup -- the super class
-	 * @param sub -- the sub class
-	 * @return the Inheritance relationship
-	 */
 	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
 		return ensureFamixInheritance(sup, sub, null);
 	}
@@ -400,12 +294,6 @@
 		return inh;
 	}
 
-	/**
-	 * Returns a Famix Reference between two Famix Entities creating it if needed
-	 * @param src -- source of the reference
-	 * @param tgt -- target of the reference
-	 * @return the Reference
-	 */
 	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
 		return ensureFamixReference(src, tgt, null);
 	}
@@ -420,13 +308,6 @@
 		return ref;
 	}
 
-	/**
-	 * Returns a Famix Invocation between two Famix Entities creating it if needed
-	 * @param sender of the invocation
-	 * @param invoked -- method invoked
-	 * @param receiver of the invocation
-	 * @return the Invocation
-	 */
 	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
 		return ensureFamixInvocation(sender, invoked, receiver, null);
 	}
@@ -444,7 +325,6 @@
 	}
 
 	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
-		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
@@ -468,13 +348,7 @@
 			next.setPrevious(prev);  // not yet implemented in importer
 		}
 	}
-	
-	/**
-	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
-	 * @param meth -- the method throwing the exception
-	 * @param excep -- the exception declared to be thrown
-	 * @return the DeclaredException
-	 */
+
 	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
 		DeclaredException decl = new DeclaredException();
 		decl.setExceptionClass(excep);
@@ -483,12 +357,6 @@
 		return decl;
 	}
 
-	/**
-	 * Returns a Famix CaughtException between a method and an Exception that is caught
-	 * @param meth -- the method catching the exception
-	 * @param excep -- the exception caught
-	 * @return the CaughtException
-	 */
 	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
 		CaughtException decl = new CaughtException();
 		decl.setExceptionClass(excep);
@@ -497,14 +365,6 @@
 		return decl;
 	}
 
-	/**
-	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
-	 * Note: DeclaredException indicates that the method declares it can throw the exception,
-	 * here we state that the exception is actually thrown
-	 * @param meth -- the method throwing the exception
-	 * @param excep -- the exception thrown
-	 * @return the ThrownException
-	 */
 	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
 		ThrownException decl = new ThrownException();
 		decl.setExceptionClass(excep);
@@ -513,24 +373,10 @@
 		return decl;
 	}
 
-	///// Special Case: ImplicitVariables /////
-
-	/**
-	 * Returns the Famix ImplicitVariable associated to the given binding and name (self or super).
-	 * See also {@link Dictionary#getEntityByBinding(Object)}
-	 * @param bnd -- the binding
-	 * @return the Famix Entity associated to the binding or null if not found
-	 */
 	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
 		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByBinding(bnd), iv_name);
 	}
-	
-	/**
-	 * Returns the Famix ImplicitVariable associated to the given Famix Class.
-	 * @param clazz -- the FamixClass
-	 * @param name -- name of the ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
-	 * @return the Famix ImplicitVariable associated to the Class or null if not found
-	 */
+
 	public ImplicitVariable getImplicitVariableByClass(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
 		ImplicitVars iv = mapImpVar.get(clazz);
 		ImplicitVariable ret = null;
@@ -549,13 +395,6 @@
 		return ret;
 	}
 
-	/**
-	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
-	 * If this ImplicitVariable does not exist yet, it is created
-	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
-	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
-	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
-	 */
 	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
 		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
 		
@@ -584,17 +423,6 @@
 		return fmx;
 	}
 
-	///// Special Case: "Uniq" Entities /////
-
-	/**
-	 * Creates or recovers a Famix Named Entity uniq for the given name.
-	 * For some specific entities we don't allow two of them with the same name.
-	 * This is the case e.g. for the default package, or the Java class "Object" and its package "java.lang".
-	 * @param fmxClass -- the FAMIX class of the instance to create
-	 * @param bnd -- a potential binding for the entity
-	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
-	 * @return the uniq Famix Entity for this binding and/or name
-	 */
 	@SuppressWarnings("unchecked")
 	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
@@ -621,42 +449,20 @@
 		return fmx;
 	}
 
-	/**
-	 * Returns a FAMIX Namespace with the given <b>name</b>, creating it if it does not exist yet
-	 * We assume that Namespaces must be uniq for a given name
-	 * @param name -- the name of the FAMIX Namespace
-	 * @return the FAMIX Namespace or null in case of a FAMIX error
-	 */
 	public Namespace ensureFamixNamespace(String name) {
 		return  ensureFamixUniqEntity(Namespace.class, null, name);
 	}
 
-	/**
-	 * Creates or recovers a default Famix Namespace.
-	 * Because this package does not really exist, it has no binding.
-	 * @return a Famix Namespace
-	 */
 	public Namespace ensureFamixNamespaceDefault() {
 		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, DEFAULT_PCKG_NAME);
 
 		return fmx;
 	}
 
-	/**
-	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
-	 * We assume that PrimitiveType must be uniq for a given name
-	 * @param name -- the name of the FAMIX PrimitiveType
-	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
-	 */
 	public PrimitiveType ensureFamixPrimitiveType(String name) {
 		return  ensureFamixUniqEntity(PrimitiveType.class, null, name);
 	}
-	
-	/**
-	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
-	 * Because this package does not really exist, it has no binding.
-	 * @return a Famix class
-	 */
+
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
 		if (fmx != null) {
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 76)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 77)
@@ -128,7 +128,6 @@
 		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "ImplicitVars"), it.next());
 	}
 
-
 	@Test
 	public void testMethodParameterArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 76)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 77)
@@ -176,11 +176,10 @@
 			System.err.println("         Method="+node.getName().getIdentifier());
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
-			//fmx.setSignature(fmx.getName()+" (???)");
 			fmx.setSignature(dico.stubMethodSignature(node));
-			//fmx.setDeclaredType( dico.ensureFamixClassObject(null));
-			// Has no binding? It might be a Generic type
-			fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
+			if (! node.isConstructor()) {
+				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
+			}
 		}
 		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
 			fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 76)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 77)
@@ -393,12 +393,10 @@
 		owner = this.ensureFamixClass(bnd.getDeclaringClass());
 
 		// return type
-		if (bnd.isConstructor()) {
-			// TODO what to put in metamodel?
-		}
-		else {
+		if (! bnd.isConstructor()) {
 			rettyp = this.ensureFamixType(bnd.getReturnType());
 		}
+		// TODO   else what?
 
 		// method signature
 		sig = bnd.getName() + "(";
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 13)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 14)
@@ -10,8 +10,12 @@
  * @author anquetil
  */
 public class EntityStack {
+	public static final int EMPTY_CYCLO = 0;
+	public static final int EMPTY_NOS = 0;
+	
 	private Namespace fmxPckg;
 	private Stack<ClassStack> fmxClass;
+	private String lastComment = null;
 	
 	// for debugging
 	private boolean tracing = false;;
@@ -22,25 +26,76 @@
 	public class ClassStack {
 		private fr.inria.verveine.core.gen.famix.Class fmxClass;
 		private Method fmxMethod;
+		private int metric_cyclo = EMPTY_CYCLO;  // Cyclomatic Complexity
+		private int metric_nos = EMPTY_NOS;    // Number Of Statements
 		
-		public ClassStack(fr.inria.verveine.core.gen.famix.Class e) {
+ 		public ClassStack(fr.inria.verveine.core.gen.famix.Class e) {
 			fmxClass = e;
-			fmxMethod = null;
+			clearFmxMethod();
 		}
 
 		public fr.inria.verveine.core.gen.famix.Class getFmxClass() {
 			return fmxClass;
 		}
 
+		/**
+		 * Returns the Famix  Method on top of the context stack
+		 */
 		public Method getFmxMethod() {
 			return fmxMethod;
 		}
 
+		/**
+		 * Returns the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public int getFmxMethodCyclo() {
+			return metric_cyclo;
+		}
+
+		/**
+		 * Returns the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public int getFmxMethodNOS() {
+			return metric_nos;
+		}
+		
+		/**
+		 * Reset the Famix Method on top of the context stack
+		 */
 		public void setFmxMethod(Method fmxMethod) {
+			clearFmxMethod();
 			this.fmxMethod = fmxMethod;
 		}
 
 		/**
+		 * Sets the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public void setFmxMethodCyclo(int c) {
+			metric_cyclo = c;
+		}
+
+		/**
+		 * Sets to the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public void setFmxMethodNOS(int n) {
+			metric_nos = n;
+		}
+		
+		/**
+		 * Adds to the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public void addFmxMethodCyclo(int c) {
+			metric_cyclo += c;
+		}
+
+		/**
+		 * Adds to the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public void addFmxMethodNOS(int n) {
+			metric_nos += n;
+		}
+		
+		/**
 		 * Empties the context stack of Famix classes
 		 */
 		public void clearFmxClass() {
@@ -49,10 +104,12 @@
 		}
 		
 		/**
-		 * Empties the context stack of Famix Methods
+		 * Empties the Famix Method on top of the context stack
 		 */
 		public void clearFmxMethod() {
 			fmxMethod = null;
+			metric_cyclo = EMPTY_CYCLO;
+			metric_nos = EMPTY_NOS;
 		}
 
 	}
@@ -69,6 +126,29 @@
 		this.tracing = tracing;
 	}
 
+	public void setLastComment(String lastComment) {
+		this.lastComment = lastComment;
+	}
+
+	public void clearLastComment() {
+		this.lastComment = null;
+	}
+
+	public String getLastComment() {
+		return lastComment;
+	}
+
+	private ClassStack getTopClass() {
+		if (fmxClass.isEmpty()) {
+			return null;
+		}
+		else {
+			return fmxClass.peek();
+		}
+	}
+
+	// WRITE ON THE STACK
+	
 	/**
 	 * Pushes an entity on top of the "context stack"
 	 * @param e -- the entity
@@ -86,14 +166,16 @@
 	}
 
 	/**
-	 * Pushes a Famix method on top of the "context stack" for the current Famix class
+	 * Sets the Famix namespace on top of the "context stack"
+	 * Not really a push, but keep the same convention as the others
 	 * @param e -- the Famix method
 	 */
-	public void pushMethod(Method e) {
+	public void pushPckg(Namespace e) {
 		if (this.tracing) {
-			System.out.println("TRACE: pushMethod "+e.getName());
+			System.out.println("TRACE: pushPckg "+e.getName());
 		}
-		getTopClass().setFmxMethod(e);
+		clearClasses();
+		fmxPckg = e;
 	}
 
 	/**
@@ -108,30 +190,44 @@
 	}
 
 	/**
-	 * Sets the Famix namespace on top of the "context stack"
-	 * Not really a push, but keep the same convention as the others
+	 * Pushes a Famix method on top of the "context stack" for the current Famix class
 	 * @param e -- the Famix method
 	 */
-	public void pushPckg(Namespace e) {
+	public void pushMethod(Method e) {
 		if (this.tracing) {
-			System.out.println("TRACE: pushPckg "+e.getName());
+			System.out.println("TRACE: pushMethod "+e.getName());
 		}
+		getTopClass().setFmxMethod(e);
+	}
+
+	/**
+	 * Empties the context stack of package and associated classes
+	 */
+	public void clearPckg() {
 		clearClasses();
-		fmxPckg = e;
+		fmxPckg = null;
 	}
 
 	/**
-	 * Pops the top Famix method of the current class on top of the "context stack"
-	 * Note: does not check that there is such a class or method, so could possibly throw an Exception
+	 * Empties the context stack of Famix classes
+	 */
+	public void clearClasses() {
+		fmxClass = new Stack<ClassStack>();
+	}
+	
+	// READ FROM THE STACK
+
+	/**
+	 * Removes and returns the Famix package from the "context stack"
+	 * Also empties the class stack (which was presumably associated to this package)
+	 * Note: does not check that there is such a namespace
 	 * @return the Famix method
 	 */
-	public Method popMethod() {
-		ClassStack tmp = getTopClass();
-		Method ret = tmp.getFmxMethod();
-		tmp.clearFmxMethod();
-		
+	public Namespace popPckg() {
+		Namespace ret = fmxPckg;
+		clearPckg();
 		if (this.tracing) {
-			System.out.println("TRACE: popMethod "+ret.getName());
+			System.out.println("TRACE: popPckg "+ret.getName());
 		}
 		return ret;
 	}
@@ -150,44 +246,51 @@
 	}
 
 	/**
-	 * Removes and returns the Famix package from the "context stack"
-	 * Also empties the class stack (which was presumably associated to this package)
-	 * Note: does not check that there is such a namespace
+	 * Pops the top Famix method of the current class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an Exception
 	 * @return the Famix method
 	 */
-	public Namespace popPckg() {
-		Namespace ret = fmxPckg;
-		clearPckg();
+	public Method popMethod() {
+		ClassStack tmp = getTopClass();
+		Method ret = tmp.getFmxMethod();
+		tmp.clearFmxMethod();
+		
 		if (this.tracing) {
-			System.out.println("TRACE: popPckg "+ret.getName());
+			System.out.println("TRACE: popMethod "+ret.getName());
 		}
 		return ret;
 	}
 
 	/**
-	 * Empties the context stack of Famix classes
-	 */
-	public void clearClasses() {
-		fmxClass = new Stack<ClassStack>();
-	}
-	
-	/**
-	 * Empties the context stack of package and associated classes
+	 * Returns the Famix entity on top of the "context stack"
+	 * Note: does not check that there is such an entity
+	 * @return the Famix entity
 	 */
-	public void clearPckg() {
-		clearClasses();
-		fmxPckg = null;
+	public ContainerEntity top() {
+		ContainerEntity ret = null;
+		ClassStack topc = getTopClass();
+		if (topc != null) {
+			ret = topc.getFmxMethod();
+			if (ret == null) {
+				ret = topc.getFmxClass();
+			}
+		}
+		else {
+			ret = topPckg();
+		}
+
+		return ret;
 	}
-	
+
 	/**
-	 * Returns the Famix method  of the Famix class on top of the "context stack"
-	 * Note: does not check that there is such a class or method, so could possibly throw an EmptyStackException
-	 * @return the Famix method
+	 * Returns the Famix package on top of the "context stack"
+	 * Note: does not check that there is such a package
+	 * @return the Famix namespace
 	 */
-	public Method topMethod() {
-		return getTopClass().getFmxMethod();
+	public Namespace topPckg() {
+		return fmxPckg;
 	}
-	
+
 	/**
 	 * Returns the Famix class on top of the "context stack"
 	 * Note: does not check that there is such a class, so could possibly throw an EmptyStackException
@@ -198,42 +301,75 @@
 	}
 	
 	/**
-	 * Returns the Famix package on top of the "context stack"
-	 * Note: does not check that there is such a package
-	 * @return the Famix namespace
+	 * Returns the Famix method  of the Famix class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an EmptyStackException
+	 * @return the Famix method
 	 */
-	public Namespace topPckg() {
-		return fmxPckg;
+	public Method topMethod() {
+		return getTopClass().getFmxMethod();
 	}
 
+	// PROPERTIES OF THE TOP METHOD
+
 	/**
-	 * Returns the Famix entity on top of the "context stack"
-	 * Note: does not check that there is such an entity
-	 * @return the Famix entity
+	 * Returns the Cyclomatic complexity of the Famix Method on top of the context stack
 	 */
-	public ContainerEntity top() {
-		ContainerEntity ret = null;
-		ClassStack topc = getTopClass();
-		if (topc != null) {
-			ret = topc.getFmxMethod();
-			if (ret == null) {
-				ret = topc.getFmxClass();
-			}
+	public int getTopMethodCyclo() {
+		if (getTopClass() != null) {
+			return getTopClass().getFmxMethodCyclo();
 		}
 		else {
-			ret = topPckg();
+			return EMPTY_CYCLO;
 		}
-
-		return ret;
 	}
 
-	private ClassStack getTopClass() {
-		if (fmxClass.isEmpty()) {
-			return null;
+	/**
+	 * Returns the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public int getTopMethodNOS() {
+		if (getTopClass() != null) {
+			return getTopClass().getFmxMethodNOS();
 		}
 		else {
-			return fmxClass.peek();
+			return EMPTY_NOS;
 		}
 	}
+
+	/**
+	 * Sets the Cyclomatic complexity of the Famix Method on top of the context stack
+	 */
+	public void setTopMethodCyclo(int c) {
+		if (getTopClass() != null) {
+			getTopClass().setFmxMethodCyclo(c);
+		}
+	}
+
+	/**
+	 * Sets to the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public void setTopMethodNOS(int n) {
+		if (getTopClass() != null) {
+			getTopClass().setFmxMethodNOS(n);
+		}
+	}
+	
+	/**
+	 * Adds to the Cyclomatic complexity of the Famix Method on top of the context stack
+	 */
+	public void addTopMethodCyclo(int c) {
+		if (getTopClass() != null) {
+			getTopClass().addFmxMethodCyclo(c);
+		}
+	}
+
+	/**
+	 * Adds to the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public void addTopMethodNOS(int n) {
+		if (getTopClass() != null) {
+			getTopClass().addFmxMethodNOS(n);
+		}
+	}
+	
 }
 
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 13)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 14)
@@ -10,6 +10,7 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
@@ -21,6 +22,7 @@
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
 /**
@@ -242,6 +244,15 @@
 		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
 	}
 
+	public Comment createFamixComment(String cmt, SourcedEntity owner) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		fmx.setContainer(owner);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+	
 	///// ensure Famix Relationships /////
 
 	/**
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 13)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 14)
@@ -13,6 +13,9 @@
 public class BehaviouralEntity extends ContainerEntity {
 
 
+	private int cyclo = 0;  // metric: Cyclomatic complexity
+	private int nos = 0;    // metric Number Of Statement
+
 
     private Collection<Access> accesses; 
 
@@ -304,6 +307,24 @@
     public void setSignature(String signature) {
         this.signature = signature;
     }
+
+    public void setCyclo(int cyclo) {
+		this.cyclo = cyclo;
+	}
+
+	@FameProperty(name = "CYCLO")
+	public int getCyclo() {
+		return cyclo;
+	}
+
+    @FameProperty(name = "NOS")
+	public int getNOS() {
+		return nos;
+	}
+
+	public void setNOS(int nos) {
+		this.nos = nos;
+	}
     
 
 
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 115)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 116)
@@ -178,6 +178,11 @@
 	 */
 	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
+
+		if (name == null) {
+			return null;
+		}
+		
 		try {
 			fmx = fmxClass.newInstance();
 		} catch (Exception e) {
@@ -227,7 +232,7 @@
 		// so we cannot recover just from the name
 
 		fmx = createFamixEntity(fmxClass, name);
-		if (bnd != null) {
+		if ( (bnd != null) && (fmx != null) ) {
 			mapToKey.put(bnd, fmx);
 		}
 		
@@ -326,19 +331,25 @@
 	}
 
 	public AnnotationInstanceAttribute createFamixAnnotationInstanceAttribute(AnnotationTypeAttribute att, String value) {
-		AnnotationInstanceAttribute fmx = new AnnotationInstanceAttribute();
-		fmx.setAnnotationTypeAttribute(att);
-		fmx.setValue(value);
-		this.famixRepo.add(fmx);
+		AnnotationInstanceAttribute fmx = null;
+		if ( (att != null) && (value != null) ) {
+			fmx = new AnnotationInstanceAttribute();
+			fmx.setAnnotationTypeAttribute(att);
+			fmx.setValue(value);
+			this.famixRepo.add(fmx);
+		}
 		return fmx;
 	}
 
 	public AnnotationInstance addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
-		AnnotationInstance inst = new AnnotationInstance();
-		inst.setAnnotationType(annType);
-		inst.setAnnotatedEntity(fmx);
-		inst.addAttributes(annAtts);
-		this.famixRepo.add(inst);
+		AnnotationInstance inst = null;
+		if ( (fmx != null) && (annType != null) ) {
+			inst = new AnnotationInstance();
+			inst.setAnnotationType(annType);
+			inst.setAnnotatedEntity(fmx);
+			inst.addAttributes(annAtts);
+			this.famixRepo.add(inst);
+		}
 		return inst;
 	}
 
@@ -403,11 +414,14 @@
 	 * @return the FAMIX Comment
 	 */
 	public Comment createFamixComment(String cmt, SourcedEntity owner) {
-		Comment fmx = new Comment();
-		fmx.setContent(cmt);
-		fmx.setContainer(owner);
-		this.famixRepo.add(fmx);
+		Comment fmx = null;
 		
+		if ( (cmt != null) && (owner != null) ) {
+			fmx = new Comment();
+			fmx.setContent(cmt);
+			fmx.setContainer(owner);
+			this.famixRepo.add(fmx);
+		}
 		return fmx;
 	}
 	
@@ -436,6 +450,10 @@
 	 * @return the Inheritance relationship
 	 */
 	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
+		if ( (sup == null) || (sub == null) ) {
+			return null;
+		}
+			
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
 				return i;
@@ -457,6 +475,9 @@
 	 * @return the Reference
 	 */
 	public Reference addFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+		if ( (src == null) || (tgt == null) ) {
+			return null;
+		}
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
 		ref.setSource(src);
@@ -475,6 +496,9 @@
 	 * @return the Invocation
 	 */
 	public Invocation addFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+		if ( (sender == null) || (invoked == null) || (receiver == null) ) {
+			return null;
+		}
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
@@ -495,7 +519,9 @@
 	 * @return the Invocation
 	 */
 	public Access addFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
-		/* We keep multiple accesses from one method to a field */
+		if ( (accessor == null) || (var == null) ) {
+			return null;
+		}
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
@@ -518,7 +544,10 @@
 	 * @param excep -- the exception declared to be thrown
 	 * @return the DeclaredException
 	 */
-	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+	public DeclaredException createFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		if ( (meth == null) || (excep == null) ) {
+			return null;
+		}
 		DeclaredException decl = new DeclaredException();
 		decl.setExceptionClass(excep);
 		decl.setDefiningMethod(meth);
@@ -532,7 +561,10 @@
 	 * @param excep -- the exception caught
 	 * @return the CaughtException
 	 */
-	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+	public CaughtException createFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		if ( (meth == null) || (excep == null) ) {
+			return null;
+		}
 		CaughtException decl = new CaughtException();
 		decl.setExceptionClass(excep);
 		decl.setDefiningMethod(meth);
@@ -548,7 +580,10 @@
 	 * @param excep -- the exception thrown
 	 * @return the ThrownException
 	 */
-	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+	public ThrownException createFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		if ( (meth == null) || (excep == null) ) {
+			return null;
+		}
 		ThrownException decl = new ThrownException();
 		decl.setExceptionClass(excep);
 		decl.setDefiningMethod(meth);
@@ -642,6 +677,11 @@
 	@SuppressWarnings("unchecked")
 	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B key, String name) {
 		T fmx = null;
+		
+		if (name == null) {
+			return null;
+		}
+		
 		if (key != null) {
 			fmx = (T) getEntityByKey(key);
 		}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 115)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 116)
@@ -112,7 +112,7 @@
 		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo, Attribute.class).size());//10+{System.out}
 		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo, Namespace.class).size());//2+{moose,java.lang,java.io,java}
 		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo, Parameter.class).size());
-		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());
 		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo, Inheritance.class).size());//6 internal + 24 from imported packages/classes
 		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo, Access.class).size());// 16 "internal" attributes + 9 System.out
 		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo, LocalVariable.class).size());
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 115)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 116)
@@ -7,10 +7,16 @@
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
+import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
 public abstract class VerveineJTest_Basic {
@@ -55,4 +61,80 @@
 		}
 	}
 
+	/**
+	 * Test of some "basic" Java entities that we know should be here such as: java.lang, java.io, Object, String, System
+	 * (and respective superclasses and implemented interfaces)
+	 */
+	@Test
+	public void testJavaCore() {
+		
+		// namespaces
+		Namespace java = TestVerveineUtils.detectElement(repo,Namespace.class, "java");
+		assertNotNull(java);
+
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace javaLang = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
+		assertNotNull(javaLang);
+		assertEquals(java, javaLang.getBelongsTo());
+		 // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
+
+		Namespace javaIO = TestVerveineUtils.detectElement(repo,Namespace.class, "io");
+		assertNotNull(javaIO);
+		assertEquals(java, javaIO.getBelongsTo());
+
+		// Object
+		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
+		assertNotNull(obj);
+		assertSame(javaLang, obj.getContainer());
+		assertEquals(0, obj.getSuperInheritances().size());
+
+		// String
+		fr.inria.verveine.core.gen.famix.Class charSeq = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "CharSequence");
+		assertNotNull(charSeq);
+		assertSame(javaLang, charSeq.getContainer());
+		assertTrue(charSeq.getIsInterface());
+		assertEquals(0, charSeq.getSuperInheritances().size());
+
+		fr.inria.verveine.core.gen.famix.Class serial = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Serializable");
+		assertNotNull(serial);
+		assertSame(javaIO, serial.getContainer());
+		assertTrue(serial.getIsInterface());
+		assertEquals(0, serial.getSuperInheritances().size());
+
+		ParameterizableClass comp = TestVerveineUtils.detectElement(repo,ParameterizableClass.class, "Comparable");
+		assertNotNull(comp);
+		assertSame(javaLang, comp.getContainer());
+		assertTrue(comp.getIsInterface());
+		assertEquals(0, comp.getSuperInheritances().size());
+
+		ParameterizedType compStr = TestVerveineUtils.detectElement(repo,ParameterizedType.class, "Comparable");
+		assertNotNull(compStr);
+		assertSame(comp, compStr.getParameterizableClass());
+		assertEquals(0, compStr.getSuperInheritances().size());
+		
+		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
+		assertNotNull(str);
+		assertSame(javaLang, str.getContainer());
+		assertEquals(4, str.getSuperInheritances().size());
+		for (Inheritance inh : str.getSuperInheritances()) {
+			assertTrue( "Unexpected super-class for String: "+inh.getSuperclass().getName(),
+					(inh.getSuperclass() == obj) ||
+					(inh.getSuperclass() == charSeq) ||
+					(inh.getSuperclass() == serial) ||
+					(inh.getSuperclass() == compStr) );
+		}
+
+		// System
+		fr.inria.verveine.core.gen.famix.Class syst = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "System");
+		assertNotNull(syst);
+		assertSame(javaLang, syst.getContainer());
+		assertEquals(1, syst.getSuperInheritances().size());
+		assertEquals(obj, syst.getSuperInheritances().iterator().next().getSuperclass());
+		assertEquals(2, syst.getAttributes().size());
+		for (Attribute att : syst.getAttributes()) {
+			assertTrue( "Unexpected super-class for String: "+att.getName(),
+					att.getName().equals("out") || att.getName().equals("err") );
+
+		}
+	}
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 115)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 116)
@@ -196,7 +196,7 @@
 			for (Name excepName : (List<Name>)node.thrownExceptions()) {
 				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
 				if (excepFmx != null) {
-					dico.ensureFamixDeclaredException(meth, excepFmx);
+					dico.createFamixDeclaredException(meth, excepFmx);
 				}
 			}
 			return super.visit(node);
@@ -315,7 +315,7 @@
 				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), /*owner*/null, /*isGeneric*/false);
 			}
 			if (excepFmx != null) {
-				dico.ensureFamixCaughtException(meth, excepFmx);
+				dico.createFamixCaughtException(meth, excepFmx);
 			}
 		}
 
@@ -327,7 +327,7 @@
 		Method meth = this.context.topMethod();
 		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), /*name*/(String)null, /*owner*/(ContainerEntity)null, /*isGeneric*/false);
 		if (excepFmx != null) {
-			dico.ensureFamixThrownException(meth, excepFmx);
+			dico.createFamixThrownException(meth, excepFmx);
 		}
 		return super.visit(node);
 	}
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 21)
+++ verveine.core/.classpath	(revision 22)
@@ -4,5 +4,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java
===================================================================
--- verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 21)
+++ verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 22)
@@ -13,7 +13,9 @@
  */
 public class TestVerveineUtils {
 
-	/** Returns a Collection of all FAMIXEntities in repository of the given fmxClass
+	/**
+	 * Returns a Collection of all FAMIXEntities in repository of the given fmxClass.
+	 * Same method as listAll(Class<T extends Entity>) defined in VerveineParser
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T extends Entity> Collection<T> selectElementsOfType(Repository repository, Class<T> fmxClass) {
Index: verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 22)
@@ -0,0 +1,75 @@
+package fr.inria.verveine.core;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Vector;
+
+import org.eclipse.jdt.core.compiler.CompilationProgress;
+import org.eclipse.jdt.internal.compiler.batch.Main;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.FAMIXModel;
+
+public class VerveineParser extends Main {
+
+	public final static String OUTPUT_FILE = "output.mse";
+	
+	private Repository famixRepo;
+
+	public VerveineParser() {
+		super(new PrintWriter(System.out), new PrintWriter(System.err), false/*systemExitWhenFinished*/, null/*customDefaultOptions*/, null/*compilationProgress*/);
+	}
+
+	@Override
+	public boolean compile(String[] argv) {
+
+		setFamixRepo(new Repository(FAMIXModel.metamodel()));
+
+		boolean ret = super.compile(argv);
+
+		return ret;
+	}
+
+	/**
+	 * Outputting repository to a file
+	 */
+	public void outputMSE() {
+		// * --- Outputting to a file -----------------------------------------------
+		try {
+			famixRepo.exportMSE(new FileWriter(OUTPUT_FILE));
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
+		super(outWriter, errWriter, systemExitWhenFinished,	customDefaultOptions, compilationProgress);
+	}
+
+	/**
+	 * Returns a Collection of all FAMIXEntities in the repository of the given fmxClass
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends Entity> Collection<T> listAll(Class<T> fmxClass) {
+		Collection<T> selection = new Vector<T>();
+		for (Object obj : getFamixRepo().getElements()) {
+			if (fmxClass.isInstance(obj)) {
+				selection.add((T) obj);
+			}
+		}
+		return selection;
+	}
+
+	public Repository getFamixRepo() {
+		return famixRepo;
+	}
+
+	public void setFamixRepo(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+	}
+
+}
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 114)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 115)
@@ -38,8 +38,6 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -48,16 +46,10 @@
  * @since May 28, 2010
  *
  */
-public class VerveineJTest_LanModel {
+public class VerveineJTest_LanModel extends VerveineJTest_Basic {
 
 	private static final String A_CLASS_NAME = "--aClassName--";
 
-	private Repository repo;
-
-	public VerveineJTest_LanModel() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
 	/**
 	 * @throws java.lang.Exception
 	 */
@@ -104,7 +96,7 @@
 				};
 		
 		VerveineJParser parser = new VerveineJParser();
-		this.repo = parser.getFamixRepo();
+		repo = parser.getFamixRepo();
 		parser.setOptions(args);
 		parser.parse();
 		
@@ -129,21 +121,6 @@
 	}
 
 	@Test
-	public void testBelongsTo() {
-		for ( Type e : repo.all(Type.class) ) {
-			if (! (e instanceof PrimitiveType) ) {
-				assertNotNull("a Type '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
-			}
-		}
-		for ( BehaviouralEntity e : repo.all(BehaviouralEntity.class) ) {
-			assertNotNull("a BehaviouralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
-		}
-		for ( StructuralEntity e : repo.all(StructuralEntity.class) ) {
-			assertNotNull("a StructuralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
-		}
-	}
-
-	@Test
 	public void testClassProperties() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(nodeClass);
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 114)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 115)
@@ -14,7 +14,6 @@
 import org.junit.Test;
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
-import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
 import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
@@ -41,9 +40,7 @@
  * @since November 25, 2010
  *
  */
-public class VerveineJTest_AdHoc {
-
-	private Repository repo;
+public class VerveineJTest_AdHoc extends VerveineJTest_Basic {
 
 	/**
 	 * @throws java.lang.Exception
@@ -52,10 +49,25 @@
 	public void setUp() throws Exception {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
 		VerveineJParser parser = new VerveineJParser();
-		this.repo = parser.getFamixRepo();
+		repo = parser.getFamixRepo();
 		parser.setOptions(new String[] {"test_src/ad_hoc"});
 		parser.parse();
-		repo.exportMSE(new FileWriter(VerveineJParser.OUTPUT_FILE));
+		parser.outputMSE();
+	}
+
+	@Test
+	public void testDictionary() {
+		fr.inria.verveine.core.gen.famix.Class dico = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Dictionary");
+		assertNotNull(dico);
+
+		assertEquals(3, dico.getAttributes().size());
+		//fails because FieldDeclaration and FieldAccess have different bindings (so they are created twice) :-(
+		for (Attribute a : dico.getAttributes()) {
+			assertEquals(dico, a.getBelongsTo());
+			Type t = a.getDeclaredType();
+			assertEquals("Map", t.getName());
+			assertEquals(ParameterizedType.class, t.getClass());
+		}
 	}
 
 	@Test
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Basic.java	(revision 115)
@@ -0,0 +1,58 @@
+package tests.fr.inria.verveine.extractor.java;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.Type;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+public abstract class VerveineJTest_Basic {
+
+	protected Repository repo;
+	protected VerveineJParser parser;
+
+	@Test
+	public void testAssociation() {
+		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Association.class) ) {
+			assertNotNull(ass.getClass().getSimpleName()+(ass.getTo()==null?"":" to: "+ass.getTo().getName())+" as no From", ass.getFrom());
+			assertNotNull(ass.getClass().getSimpleName()+" from: "+ass.getFrom().getName()+" as no To", ass.getTo());
+		}
+		
+		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Association.class) ) {
+			Association n = ass.getNext();
+			if (n!=null) {
+				assertSame(ass, n.getPrevious());
+			}
+		}
+		
+		for (Association ass : TestVerveineUtils.selectElementsOfType(repo, Association.class) ) {
+			Association p = ass.getPrevious();
+			if (p!=null) {
+				assertSame(ass, p.getNext());
+			}
+		}
+	}
+
+	@Test
+	public void testBelongsTo() {
+		for ( Type e : repo.all(Type.class) ) {
+			if (! (e instanceof PrimitiveType) ) {
+				assertNotNull("a Type '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+			}
+		}
+		for ( BehaviouralEntity e : repo.all(BehaviouralEntity.class) ) {
+			assertNotNull("a BehaviouralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+		for ( StructuralEntity e : repo.all(StructuralEntity.class) ) {
+			assertNotNull("a StructuralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+	}
+
+}
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 114)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 115)
@@ -50,6 +50,7 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
 /**
@@ -234,11 +235,8 @@
 			IBinding bnd = ((Name) callingExpr).resolveBinding();
 			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
 				BehaviouralEntity accessor = this.context.topMethod();
-				Attribute accessed = this.dico.ensureFamixAttribute((IVariableBinding)bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass());
-				// cast needed to ensure calling the proper ensureFamixAttribute() (in JavaDictionnary)
-				// 'owner' note: using a field without anything before, it must belongs to the currently parsed class
-				
-				context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				// note: using a field without anything before, owner must be the currently parsed class
+				createAccessedAttribute((IVariableBinding)bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass(), accessor);
 			}
 		}
 		return super.visit(node);
@@ -274,11 +272,9 @@
 
 	public boolean visit(FieldAccess node) {
 		BehaviouralEntity accessor = this.context.topMethod();
-		Attribute accessed = this.dico.ensureFamixAttribute(node.resolveFieldBinding(), node.getName().getIdentifier(), null, null);
-		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
-			accessed.setParentType(dico.ensureFamixClassArray());
-		}
-		context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+		IVariableBinding bnd = node.resolveFieldBinding();
+		// FIXME if bnd == null we have a problem
+		createAccessedAttribute(bnd, node.getName().getIdentifier(), null, null, accessor);
 
 		return super.visit(node);
 	}
@@ -291,11 +287,7 @@
 		if (bnd instanceof IVariableBinding) {
 			// apparently this is a field
 			BehaviouralEntity accessor = this.context.topMethod();
-			Attribute accessed = this.dico.ensureFamixAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null);  // cast needed to access the proper method
-			if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
-				accessed.setParentType(dico.ensureFamixClassArray());
-			}
-			context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+			createAccessedAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null, accessor);
 		}
 		return super.visit(node);
 	}
@@ -304,15 +296,9 @@
 	 * Another FieldAccess in disguise: SomeClass.class
 	 */
 	public boolean visit(TypeLiteral node) {
-		Attribute accessed;
 		fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
 		BehaviouralEntity accessor = this.context.topMethod();
-		accessed =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
-		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
-			accessed.setParentType(dico.ensureFamixClassArray());
-		}
-		context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
-
+		createAccessedAttribute(null, "class", javaMetaClass, javaMetaClass, accessor);
 		return super.visit(node);
 	}
 
@@ -399,7 +385,7 @@
 
 		// field.msg()
 		else if (expr instanceof FieldAccess) {
-			Attribute ret = dico.ensureFamixAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), null, null);
+			Attribute ret = createAccessedAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), /*type*/null, /*owner*/null, /*accessor*/null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
@@ -436,7 +422,7 @@
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);
+					ret = createAccessedAttribute((IVariableBinding)bnd, varName, /*typ*/null, /*owner*/null, /*accessor*/null);
 					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
 						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
 					}
@@ -467,7 +453,7 @@
 
 		// super.field.msg()
 		else if (expr instanceof SuperFieldAccess) {
-			Attribute ret = dico.ensureFamixAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
+			Attribute ret = createAccessedAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), /*typ*/null, /*owner*/null, /*accessor*/null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
@@ -505,4 +491,19 @@
 		return null;
 	}
 
+	private Attribute createAccessedAttribute(IVariableBinding bnd, String attName, fr.inria.verveine.core.gen.famix.Type typ, fr.inria.verveine.core.gen.famix.Type owner, BehaviouralEntity accessor) {
+		Attribute accessed;
+		if (bnd != null) {
+			bnd = bnd.getVariableDeclaration();
+		}
+		accessed =  dico.ensureFamixAttribute(bnd, attName, typ, owner);
+		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+			accessed.setParentType(dico.ensureFamixClassArray());
+		}
+		
+		if ( (accessed != null) && (accessor != null) ) {
+			context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+		}
+		return accessed;
+	}
 }
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 27)
+++ verveine.core/.classpath	(revision 28)
@@ -5,6 +5,5 @@
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
-	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 27)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 28)
@@ -2,6 +2,7 @@
 
 import java.util.Stack;
 
+import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -113,6 +114,19 @@
 
 	}
 	
+	/**
+	 * last Association registered to set the previous/next
+	 */
+	Association lastAssoc = null;
+	
+	public Association getLastAssoc() {
+		return lastAssoc;
+	}
+
+	public void setLastAssoc(Association lastAssoc) {
+		this.lastAssoc = lastAssoc;
+	}
+
 	public EntityStack() {
 		clearPckg();  // initializes (to empty) Pckgs, classes and methods
 	}
@@ -162,6 +176,7 @@
 			System.out.println("TRACE: pushPckg "+e.getName());
 		}
 		clearClasses();
+		setLastAssoc(null);
 		fmxPckg = e;
 	}
 
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 27)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 28)
@@ -8,6 +8,7 @@
 import ch.akuhn.fame.Repository;
 
 import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.CaughtException;
@@ -383,22 +384,20 @@
 	 * @return the Reference
 	 */
 	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
-		/* We want to keep multiple references between the same entities...
-		   for (Reference r : src.getOutgoingReferences()) {
-			if (r.getTarget() == tgt) {
-				return r;
-			}
-		}
-		*/
-
+		return ensureFamixReference(src, tgt, null);
+	}
+	
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
 		ref.setSource(src);
+		chainPrevNext(prev,ref);
 		famixRepoAdd(ref);
 		
 		return ref;
 	}
 
+
 	/**
 	 * Returns a Famix Invocation between two Famix Entities creating it if needed
 	 * @param sender of the invocation
@@ -407,41 +406,47 @@
 	 * @return the Invocation
 	 */
 	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
-		/* We keep multiple invocations from one method to another
-		   for (Invocation i : sender.getOutgoingInvocations()) {
-			if  (i.getReceiver() == receiver) {
-				if (i.getCandidates().contains(invoked)) {
-					return i;
-				}				
-			}
-		}
-		*/
-		
+		return ensureFamixInvocation(sender, invoked, receiver, null);
+	}
+
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
 		invok.setSignature(invoked.getSignature());
 		invok.addCandidates(invoked);
+		chainPrevNext(prev,invok);
 		famixRepoAdd(invok);
 		
 		return invok;
 	}
-	
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
 		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
 		acc.setIsWrite(new Boolean(isWrite));
+		chainPrevNext(prev, acc);
 		famixRepoAdd(acc);
 		
 		return acc;
 	}
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
+		return ensureFamixAccess(accessor, var, isWrite, null);
+	}
 	
 	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
-		return ensureFamixAccess(accessor, var, false);  // must be some default and this one seems safer than the opposite
+		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
 	}
 
+	private void chainPrevNext(Association prev, Association next) {
+		if (prev != null) {
+			// next.setPrevious(prev);  // not yet implemented in importer
+		}
+	}
+	
 	/**
 	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
 	 * @param meth -- the method throwing the exception
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.extractor.java.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 113)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 114)
@@ -134,5 +134,3 @@
 	public void add(NamedEntity f) {
 	}
 }
-
-}
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 113)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 114)
@@ -191,10 +191,8 @@
 	public void testParameterizableClass() {
 		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
 		assertNotNull(dico);
-
 		assertEquals("Dictionary", dico.getName());
 		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
-// FIXME: Collection<NamedEntity> belongsTo getEntityByName !!
 
 		assertEquals(1, dico.getParameters().size());
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 113)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 114)
@@ -46,6 +46,7 @@
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -192,7 +193,7 @@
 
 			// Exceptions
 			for (Name excepName : (List<Name>)node.thrownExceptions()) {
-				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
 				if (excepFmx != null) {
 					dico.ensureFamixDeclaredException(meth, excepFmx);
 				}
@@ -233,7 +234,8 @@
 			IBinding bnd = ((Name) callingExpr).resolveBinding();
 			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
 				BehaviouralEntity accessor = this.context.topMethod();
-				Attribute accessed = this.dico.ensureFamixAttribute(bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass());
+				Attribute accessed = this.dico.ensureFamixAttribute((IVariableBinding)bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass());
+				// cast needed to ensure calling the proper ensureFamixAttribute() (in JavaDictionnary)
 				// 'owner' note: using a field without anything before, it must belongs to the currently parsed class
 				
 				context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
@@ -321,10 +323,10 @@
 		if (meth != null) {
 			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
 			if (excepClass instanceof SimpleType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), /*owner*/null, /*isGeneric*/false);
 			}
 			else if (excepClass instanceof QualifiedType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), /*owner*/null, /*isGeneric*/false);
 			}
 			if (excepFmx != null) {
 				dico.ensureFamixCaughtException(meth, excepFmx);
@@ -337,7 +339,7 @@
 	@Override
 	public boolean visit(ThrowStatement node) {
 		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), /*name*/(String)null, /*owner*/(ContainerEntity)null, /*isGeneric*/false);
 		if (excepFmx != null) {
 			dico.ensureFamixThrownException(meth, excepFmx);
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 113)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 114)
@@ -106,14 +106,15 @@
 		super.endVisit(node);
 	}
 
+	/*
+	 * Can only be a class or interface declaration
+	 */
 	public boolean visit(TypeDeclaration node) {
-		// Can only be a class or interface declaration
-
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		@SuppressWarnings("unchecked")
-		List<TypeParameter> tparams = node.typeParameters();
-		fr.inria.verveine.core.gen.famix.Class fmx = (Class) dico.ensureFamixType(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), /*ctxt*/context.top());
+		List<TypeParameter> tparams = (List<TypeParameter>)node.typeParameters();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), tparams.size()>0); //   /*ctxt*/context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 
@@ -242,15 +243,17 @@
 				paramTypes.add(param.getType());
 		}
 
-		// creating/recovering it (creates it with a null return type because might need this FamixMethod to create the return type.
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/null, context.topClass());
-		fr.inria.verveine.core.gen.famix.Type fmxTyp = referedType(node.getReturnType2(), fmx);
+		// creating/recovering it
+		// creates it with a fake return type because we might need this FamixMethod to create the return type (if it is a ParameterizedType)
+		// we reset the return type to its proper value later
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/dico.ensureFamixClassObject(null), context.topClass());
 
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
 			this.context.pushMethod(fmx);
-			fmx.setDeclaredType(fmxTyp);
+			fr.inria.verveine.core.gen.famix.Type fmxRetTyp = referedType(node.getReturnType2(), fmx);
+			fmx.setDeclaredType(fmxRetTyp);
 			if (node.getBody() != null) {
 				context.setTopMethodCyclo(1);
 			}
@@ -380,12 +383,12 @@
 			ITypeBinding parameterizedBnd = typ.resolveBinding();
 			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
 			String tname = dico.findTypeName(typ);
-			ParameterizableClass tmpGeneric = null;
-			tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
+			ParameterizableClass generic = null;
+			generic = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
 
-			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, tmpGeneric, /*owner*/ctxt);
+			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, generic, /*owner*/ctxt);
 			for (Type targ : (List<Type>) ((ParameterizedType)typ).typeArguments()) {
-				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), null, ctxt);
+				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), /*owner*/null, ctxt);
 				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
 			}
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 113)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 114)
@@ -155,7 +155,7 @@
 		}
 
 		if (bnd.isParameterizedType()) {
-			return ensureFamixParameterizedType(bnd, name, /*generic*/null, owner);
+			return ensureFamixParameterizedType(bnd, name, /*generic*/null, ctxt);
 		}
 
 		// it seems wise to test isClass after isGenericType, isParameterizedType, ... ? 
@@ -205,6 +205,7 @@
 
 		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
 		if (fmx != null) {
+//			System.out.println("ensureClass, recovered from bnd:"+fmx.toString());
 			return fmx;
 		}
 
@@ -230,7 +231,7 @@
 			}
 		}
 
-		if (name.equals(OBJECT_NAME)) {
+		if (name.equals(OBJECT_NAME)) { // TODO && owner == java.lang
 			return ensureFamixClassObject(bnd);
 		}
 
@@ -238,6 +239,7 @@
 		for (Type candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
 			if ( checkAndMapClass(bnd, candidate) ) {
 				fmx = (Class) candidate;
+//				System.out.println("ensureClass, recovered from name:"+fmx.toString());
 				break;
 			}
 		}
@@ -376,7 +378,8 @@
 
 		// --------------- generic
 		if (generic == null) {
-			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+//			System.out.println("ensureParameterized, trying to recover generic: "+name);
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, /*owner*/null, /*isGeneric*/true);
 		}
 
 		// --------------- recover from name ?
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 26)
+++ verveine.core/.classpath	(revision 27)
@@ -5,5 +5,6 @@
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
+	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 112)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 113)
@@ -234,7 +234,7 @@
 	@Override
 	public String toString() {
 	// mainly for debugging purposes (in Eclipse debugger)
-		return "a " + this.getClass().getCanonicalName() + " named: " + this.getName();
+		return "a " + this.getClass().getSimpleName() + " named: " + this.getName();
 	}
     
 
Index: verveine.core/export-verveine-core.jardesc
===================================================================
--- verveine.core/export-verveine-core.jardesc	(revision 0)
+++ verveine.core/export-verveine-core.jardesc	(revision 79)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<jardesc>
+    <jar path="verveine.core/lib/verveine.core.jar"/>
+    <options buildIfNeeded="true" compress="true" descriptionLocation="/verveine.core/export-verveine-core.jardesc" exportErrors="true" exportWarnings="true" includeDirectoryEntries="false" overwrite="false" saveDescription="true" storeRefactorings="false" useSourceFolders="false"/>
+    <storedRefactorings deprecationInfo="true" structuralOnly="false"/>
+    <selectedProjects/>
+    <manifest generateManifest="true" manifestLocation="/Fame/META-INF/MANIFEST.MF" manifestVersion="1.0" reuseManifest="false" saveManifest="false" usesManifest="true">
+        <sealing sealJar="false">
+            <packagesToSeal/>
+            <packagesToUnSeal/>
+        </sealing>
+    </manifest>
+    <selectedElements exportClassFiles="true" exportJavaFiles="false" exportOutputFolder="false">
+        <javaElement handleIdentifier="=verveine.core/src&lt;fr.inria.verveine.core"/>
+        <file path="/verveine.core/.project"/>
+        <javaElement handleIdentifier="=verveine.core/src&lt;test.fr.inria.verveine.core"/>
+        <file path="/verveine.core/.classpath"/>
+    </selectedElements>
+</jardesc>
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 59)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 60)
@@ -1,6 +1,8 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import java.util.Collection;
+
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
@@ -29,7 +31,14 @@
         this.isInterface = isInterface;
     }
     
-
-
-}
-
+    private Collection<Type> parameterTypes;
+    
+    @FameProperty(name = "parameterTypes")
+    public Collection<Type> getParameterTypes() {
+    	return parameterTypes;
+    }
+    
+    public void setParameterTypes(Collection<Type> parameterTypes) {
+    	this.parameterTypes = parameterTypes;
+    }
+}
\ No newline at end of file
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 24)
+++ verveine.extractor.java/.classpath	(revision 25)
@@ -14,6 +14,6 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
-	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
+	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 24)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 25)
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2010 Simon Denier
+ * Copyright (c) 2010 Nicolas Anquetil
  */
 package tests.fr.inria.verveine.extractor.java;
 
@@ -11,8 +11,10 @@
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
+import java.io.File;
 import java.util.Collection;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -35,7 +37,7 @@
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
 /**
- * @author Simon Denier
+ * @author Nicolas Anquetil
  * @since May 28, 2010
  *
  */
@@ -50,12 +52,49 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
+		String[] files = new String[] {
+				"AbstractDestinationAddress.java",
+				"Node.java",
+				"Packet.java",
+				"SingleDestinationAddress.java",
+				"WorkStation.java",
+				"server/FileServer.java",
+				"server/IPrinter.java",
+				"server/OutputServer.java",
+				"server/PrintServer.java"
+		};
+		
+		// separate parsing of each source file
+		for (String f : files) {
+			parseFile(f);
+		}
+	}
+
+	/**
+	 * Parses the file received in parameter independently from any other
+	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
+	 * @param file -- name of the file to parse
+	 */
+	private void parseFile(String file) {
+		String[] args = new String[] {
+				"-cp",
+				"test_src/LANModel/",
+				"test_src/LANModel/moose/lan/"+file
+				};
+		
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/LANModel"});
-		parser.renameNamespaces();
+		parser.compile(args);
 		repo = parser.getFamixRepo();
+		
+		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
+		parser.outputMSE();  // to create a new one
 	}
 
+	@After
+	public void tearDown() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
 	@Test
 	public void testEntitiesNumber() {
 		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 24)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 25)
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2010 Simon Denier
+ * Copyright (c) 2010 Anquetil Nicolas
  */
 package tests.fr.inria.verveine.extractor.java;
 
@@ -7,6 +7,10 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
+
+import java.io.File;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -19,14 +23,20 @@
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
 /**
- * @author Simon Denier
- * @since May 28, 2010
+ * @author Nicolas Anquetil
+ * @since November 25, 2010
  *
  */
 public class VerveineJTest_AdHoc {
 
 	private Repository repo;
 
+	public VerveineJTest_AdHoc() {
+		// make sure we don't have any pre-existing mse lying in the way
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+
 	/**
 	 * @throws java.lang.Exception
 	 */
@@ -34,10 +44,14 @@
 	public void setUp() throws Exception {
 		VerveineJParser parser = new VerveineJParser();
 		parser.compile(new String[] {"test_src/ad_hoc"});
-		parser.renameNamespaces();
 		repo = parser.getFamixRepo();
 	}
 
+	@After
+	public void tearDown() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
 	@Test
 	public void testExceptions() {
 		// there are two "lire" methods, but both serve our purpose here so we just take the first that will be returned
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 24)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 25)
@@ -158,6 +158,10 @@
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
 			return null;
 		}
+		
+		if (bnd.getName().equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
+		}
 
 		while (bnd.isArray()) {
 			bnd = bnd.getComponentType();
@@ -243,24 +247,24 @@
 			wasBound = false;
 			// trying to recover from name and other informations
 			for (fr.inria.verveine.core.gen.famix.Class candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, identifier) ) {
-				if ( (! candidate.getIsStub()) &&
-						(candidate.getBelongsTo() == owner) ) {
+				if ( //(! candidate.getIsStub()) &&
+						(candidate.getContainer() == owner) ) {
 					// could test superclass also...
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
 					break;
 				}
-				else if ( candidate.getIsStub() ) {
+/*				else if ( candidate.getIsStub() ) {
 					// find out whether this candidate is defined in the same namespace as the binding received in parameter
 					ContainerEntity ownerBnd = owner;  // the owner of the bounded entity received as parameter
-					ContainerEntity ownerStub = candidate.getBelongsTo();  // the owner of the current candidate
+					ContainerEntity ownerStub = candidate.getContainer();  // the owner of the current candidate
 					while ( (ownerBnd != null) &&
 							(ownerStub != null) &&
 							(! (ownerBnd instanceof Namespace)) &&
 							(ownerBnd.getClass() == ownerStub.getClass()) &&
 							ownerBnd.getName().equals(ownerStub.getName()) ) {
-								ownerBnd = ownerBnd.getBelongsTo();
-								ownerStub = ownerStub.getBelongsTo();
+								ownerBnd = ownerBnd.getContainer();
+								ownerStub = ownerStub.getContainer();
 					}
 					if ( (ownerBnd instanceof Namespace) &&
 						(ownerStub instanceof Namespace) &&
@@ -269,7 +273,7 @@
 						mapBind.put(bnd, fmx);
 						break;
 					}
-				}
+				}*/
 			}
 		}
 		
@@ -415,7 +419,7 @@
 			wasBound = false;
 			// trying to recover from name and other informationsparentBehaviouralEntity
 			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
-				if ( (! candidate.getIsStub()) &&
+				if ( //(! candidate.getIsStub()) &&
 					 (candidate.getParentType() == owner) &&
 					 (candidate.getDeclaredType() == typ) ) {
 					fmx = candidate;
@@ -446,11 +450,16 @@
 	 * @param mod -- a description of the modifiers as understood by org.eclipse.jdt.core.dom.Modifier
 	 */
 	private void setNamedEntityModifiers(NamedEntity fmx, int mod) {
-		fmx.setIsAbstract(Modifier.isAbstract(mod));
-		fmx.setIsFinal(Modifier.isFinal(mod));
-		fmx.setIsPrivate(Modifier.isPrivate(mod));
-		fmx.setIsProtected(Modifier.isProtected(mod));
-		fmx.setIsPublic(Modifier.isPublic(mod));
+		if (Modifier.isAbstract(mod)) {
+			// don't know why there are two different ways to mark abstract classes !!!
+			// But this is a pain!
+			fmx.addModifiers("abstract");
+		}
+		fmx.setIsAbstract(new Boolean(Modifier.isAbstract(mod)));
+		fmx.setIsFinal(new Boolean(Modifier.isFinal(mod)));
+		fmx.setIsPrivate(new Boolean(Modifier.isPrivate(mod)));
+		fmx.setIsProtected(new Boolean(Modifier.isProtected(mod)));
+		fmx.setIsPublic(new Boolean(Modifier.isPublic(mod)));
 	}
 
 	/**
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 24)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 25)
@@ -19,15 +19,28 @@
 	public static void main(String[] args) {
 		VerveineJParser parser = new VerveineJParser();
 		parser.compile(args);
-		parser.renameNamespaces();
 		parser.outputMSE();
 	}
+	
+	@Override
+	public boolean compile(String[] argv) {
+		boolean ret;
+		if (this.linkToExisting()) {
+			this.expandNamespacesNames();
+		}
+		
+		ret = super.compile(argv);
+		
+		this.compressNamespacesNames();
+		
+		return ret;
+	}
 
 	/**
-	 * As explained in JavaDictionary, Namespaces are created with their fully qualified name
+	 * As explained in JavaDictionary, Namespaces are created with their fully qualified name.
 	 * We need now to give them their simple name
 	 */
-	public void renameNamespaces() {
+	protected void compressNamespacesNames() {
 		for (Namespace ns : listAll(Namespace.class)) {
 			String name = ns.getName();
 			int last = name.lastIndexOf('.');
@@ -37,6 +50,32 @@
 		}
 	}
 
+	/**
+	 * @see VerveineJParser.compressNamespacesNames()
+	 */
+	protected void expandNamespacesNames() {
+		for (Namespace ns : listAll(Namespace.class)) {
+			expandNamespaceName(ns);
+		}		
+	}
+	
+	private void expandNamespaceName(Namespace ns) {
+		String name = ns.getName();
+		if (name.indexOf('.') > 0) {
+			return;
+		}
+		else {
+			Namespace parent = (Namespace) ns.getParentScope();
+			if (parent == null) {
+				return;
+			}
+			else {
+				expandNamespaceName(parent);
+				ns.setName(parent.getName()+"."+ns.getName());
+			}
+		}
+	}
+
 	/*
 	 *  Low-level API performing the actual parsing
 	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 111)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 112)
@@ -26,16 +26,20 @@
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -60,7 +64,8 @@
 	@Before
 	public void setUp() throws Exception {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
-		String[] files = new String[] {
+
+		/*String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -76,14 +81,14 @@
 		// separate parsing of each source file --------
 		for (String f : files) {
 			parseFile(f);
-		}
+		}*/
 
 		// or parsing the entire project in one pass ---
-		/*VerveineJParser parser = new VerveineJParser();
+		VerveineJParser parser = new VerveineJParser();
 		repo = parser.getFamixRepo();
 		parser.setOptions(new String[] {"test_src/LANModel/"});
 		parser.parse();
-		parser.outputMSE();*/
+		parser.outputMSE();
 	}
 
 	/**
@@ -124,6 +129,21 @@
 	}
 
 	@Test
+	public void testBelongsTo() {
+		for ( Type e : repo.all(Type.class) ) {
+			if (! (e instanceof PrimitiveType) ) {
+				assertNotNull("a Type '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+			}
+		}
+		for ( BehaviouralEntity e : repo.all(BehaviouralEntity.class) ) {
+			assertNotNull("a BehaviouralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+		for ( StructuralEntity e : repo.all(StructuralEntity.class) ) {
+			assertNotNull("a StructuralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+	}
+
+	@Test
 	public void testClassProperties() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(nodeClass);
@@ -280,7 +300,7 @@
 		assertNotNull(ns);
 		assertEquals(9, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
-			
+
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
 		assertNotNull(obj);
 		assertTrue(obj.getIsStub());
@@ -481,7 +501,7 @@
 			}
 		}
 		assertNotNull(output);
-		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		assertEquals(4, output.getAccesses().size());
 		for (Access acc : output.getAccesses()) {
 			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
 						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 111)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 112)
@@ -93,7 +93,7 @@
 		AnnotationType fmProp = l_FmProp.iterator().next();
 		assertNotNull(fmProp);
 		assertEquals("FameProperty", fmProp.getName());
-		//TODO assertFalse(fmProp.getIsStub());
+		// FIXME assertFalse(fmProp.getIsStub());
 		
 		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
 		assertNotNull(fmPckg);
@@ -158,7 +158,7 @@
 		}
 
 	}
-	
+
 	@Test
 	public void testClassVar() {
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
@@ -177,7 +177,7 @@
 			}
 		}
 		
-		assertEquals(2, meth.getAccesses().size());
+		assertEquals(2, meth.getAccesses().size());  // ImplicitVariable.class + mapBind
 		boolean classFieldFound = false;
 		for (Access acc : meth.getAccesses()) {
 			if (acc.getTo().getName().equals("class")) {
@@ -194,6 +194,8 @@
 
 		assertEquals("Dictionary", dico.getName());
 		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
+// FIXME: Collection<NamedEntity> belongsTo getEntityByName !!
+
 		assertEquals(1, dico.getParameters().size());
 
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
@@ -203,10 +205,9 @@
 		assertSame(dico, dicoParam.getContainer());
 		assertSame(dicoParam, dico.getParameters().iterator().next());
 
-		/* Collection<Object> is not seen as parameterizable by JDT 		 */
-		 ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
-		 assertNotNull(collec);
-
+		/* Collection<Object> is not seen as parameterizable by JDT */
+		ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
+		assertNotNull(collec);
 	}
 
 	@Test
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 112)
@@ -226,7 +226,19 @@
 	}
 
 	public boolean visit(MethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
+		Expression callingExpr = node.getExpression();
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(callingExpr));
+		if (callingExpr instanceof SimpleName) {
+			// we might have a hidden FieldAccess here
+			IBinding bnd = ((Name) callingExpr).resolveBinding();
+			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
+				BehaviouralEntity accessor = this.context.topMethod();
+				Attribute accessed = this.dico.ensureFamixAttribute(bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass());
+				// 'owner' note: using a field without anything before, it must belongs to the currently parsed class
+				
+				context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+			}
+		}
 		return super.visit(node);
 	}
 
@@ -245,7 +257,15 @@
 	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/null);  // cast needed to desambiguate the call
+			Method invoked = null;
+			if (receiver instanceof StructuralEntity) {
+				fr.inria.verveine.core.gen.famix.Type varTyp = ((StructuralEntity)receiver).getDeclaredType();
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/varTyp);  // cast needed to desambiguate the call
+			}
+			else {
+				// method static of a class called on the class
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
+			}
 			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
@@ -261,14 +281,15 @@
 		return super.visit(node);
 	}
 
-	/* Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
+	/*
+	 * Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
 	 */
 	public boolean visit(QualifiedName node) {
 		IBinding bnd = node.resolveBinding();
 		if (bnd instanceof IVariableBinding) {
 			// apparently this is a field
 			BehaviouralEntity accessor = this.context.topMethod();
-			Attribute accessed = this.dico.ensureFamixAttribute(bnd, node.getName().getIdentifier(), null, null);
+			Attribute accessed = this.dico.ensureFamixAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null);  // cast needed to access the proper method
 			if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 				accessed.setParentType(dico.ensureFamixClassArray());
 			}
@@ -277,6 +298,22 @@
 		return super.visit(node);
 	}
 
+	/* 
+	 * Another FieldAccess in disguise: SomeClass.class
+	 */
+	public boolean visit(TypeLiteral node) {
+		Attribute accessed;
+		fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
+		BehaviouralEntity accessor = this.context.topMethod();
+		accessed =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
+		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+			accessed.setParentType(dico.ensureFamixClassArray());
+		}
+		context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+
+		return super.visit(node);
+	}
+
 	@Override
 	public boolean visit(CatchClause node) {
 		Method meth = this.context.topMethod();
@@ -360,12 +397,10 @@
 
 		// field.msg()
 		else if (expr instanceof FieldAccess) {
-			BehaviouralEntity accessor = this.context.topMethod();
 			Attribute ret = dico.ensureFamixAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), null, null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -394,17 +429,15 @@
 			if (bnd instanceof ITypeBinding) {
 				// msg() is a static method of Name
 				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.ensureFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
 			}
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
 					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);
-					BehaviouralEntity accessor = this.context.topMethod();
 					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
 						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
 					}
-					context.setLastAccess( dico.addFamixAccess(accessor, (Attribute) ret, /*isWrite*/false, context.getLastAccess()) );
 
 					return ret;
 				}
@@ -432,12 +465,10 @@
 
 		// super.field.msg()
 		else if (expr instanceof SuperFieldAccess) {
-			BehaviouralEntity accessor = this.context.topMethod();
 			Attribute ret = dico.ensureFamixAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -459,12 +490,7 @@
 			// similar to a field access
 			Attribute ret;
 			fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
-			BehaviouralEntity accessor = this.context.topMethod();
 			ret =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
-			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
-				ret.setParentType(dico.ensureFamixClassArray());
-			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 112)
@@ -120,7 +120,7 @@
 			this.context.pushClass(fmx);
 
 			dico.addSourceAnchor(fmx, node);
-			dico.ensureFamixComment(node.getJavadoc(), fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 			
 			for (TypeParameter tp : tparams) {
 				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
@@ -236,14 +236,6 @@
 		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
-		//Type retTyp = node.getReturnType2();
-		/*fr.inria.verveine.core.gen.famix.Type fmxTyp;
-		if (retTyp == null) {
-			fmxTyp = null;
-		}
-		else {
-			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner* /null, context.top());
-		}*/
 
 		Collection<Type> paramTypes = new ArrayList<Type>();
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
@@ -251,13 +243,9 @@
 		}
 
 		// creating/recovering it (creates it with a null return type because might need this FamixMethod to create the return type.
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, null, context.topClass());
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/null, context.topClass());
 		fr.inria.verveine.core.gen.famix.Type fmxTyp = referedType(node.getReturnType2(), fmx);
 
-		//if (retTyp != null && retTyp.isParameterizedType()) {
-			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)retTyp).typeArguments()));
-		//}
-		
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
@@ -268,7 +256,7 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			dico.ensureFamixComment(node.getJavadoc(), fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 
 			// creating the method's parameters
 			List<VariableDeclaration> paramAsVarList;
@@ -309,7 +297,7 @@
 		fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topClass());
 		for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
 			dico.addSourceAnchor(att, node);
-			dico.ensureFamixComment(node.getJavadoc(), att);
+			dico.createFamixComment(node.getJavadoc(), att);
 		}
 		return super.visit(node);
 	}
@@ -346,7 +334,6 @@
 		return super.visit(node);
 	}
 
-	@SuppressWarnings("unchecked")
 	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, fr.inria.verveine.core.gen.famix.Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
 		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
 
@@ -381,14 +368,10 @@
 		return ret;
 	}
 
-	/**
-	 * @param typ
-	 * @param ctxt
-	 * @return
-	 */
+	@SuppressWarnings("unchecked")
 	private fr.inria.verveine.core.gen.famix.Type referedType(Type typ, ContainerEntity ctxt) {
 		fr.inria.verveine.core.gen.famix.Type fmxTyp = null;
-		
+
 		if (typ == null) {
 			return null;
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 112)
@@ -235,7 +235,7 @@
 		}
 
 		// --------------- recover from name ?
-		for (Type candidate : this.getEntityByName(Type.class, name)) {
+		for (Type candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
 			if ( checkAndMapClass(bnd, candidate) ) {
 				fmx = (Class) candidate;
 				break;
@@ -330,10 +330,20 @@
 			return super.ensureFamixParameterizedType(null, name, generic, owner);
 		}
 
+		fmx = (ParameterizedType)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
 		}
+		// remove parameter types from name
+		int i = name.indexOf('<');
+		if (i > 0) {
+			name = name.substring(0, i);
+		}
 
 		// --------------- owner
 		if (owner == null) {
@@ -366,12 +376,7 @@
 
 		// --------------- generic
 		if (generic == null) {
-			String genName = name;
-			int i = name.indexOf('<');
-			if (i > 0) {
-				genName = name.substring(0, i);
-			}
-			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), genName, owner, /*isGeneric*/true);
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
 		}
 
 		// --------------- recover from name ?
@@ -412,6 +417,11 @@
 			return super.ensureFamixEnum(null, name, owner);
 		}
 
+		fmx = (fr.inria.verveine.core.gen.famix.Enum)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -474,6 +484,11 @@
 			return super.ensureFamixEnumValue(null, name, owner);
 		}
 
+		fmx = (EnumValue)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -514,6 +529,11 @@
 			return super.ensureFamixAnnotationType(null, name, owner);
 		}
 
+		fmx = (AnnotationType)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -561,6 +581,11 @@
 			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
 		}
 
+		fmx = (AnnotationTypeAttribute)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -934,7 +959,7 @@
 	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
+	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, Type owner) {
 		Method fmx = null;
 		String sig;
 		boolean first;
@@ -975,6 +1000,11 @@
 			return super.ensureFamixMethod(null, name, sig, ret, owner);
 		}
 
+		fmx = (Method)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1089,6 +1119,11 @@
 			return super.ensureFamixAttribute(null, name, type, owner);
 		}
 
+		fmx = (Attribute)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1170,6 +1205,11 @@
 			return super.createFamixParameter(null, name, typ, owner);
 		}
 
+		fmx = (Parameter)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1224,6 +1264,11 @@
 			return super.ensureFamixLocalVariable(null, name, typ, owner);
 		}
 
+		fmx = (LocalVariable)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1260,10 +1305,10 @@
 	}
 	
 	/**
-	 * Returns a Famix UnknownVariable. The Entity is created if it does not exist.
+	 * Creates and returns a Famix UnknownVariable.
 	 */
-	public UnknownVariable ensureFamixUnknownVariable(Type type, String name) {
-//		System.err.println("TRACE -- ensureFamixUnknownVariable: "+name);
+	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
+//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
 		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
@@ -1271,7 +1316,7 @@
 		return fmx;
 	}
 
-	public Comment ensureFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
 		Comment cmt = null;
 		if (jdoc != null) {
 			cmt = createFamixComment(jdoc.toString(), fmx);
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 112)
@@ -20,11 +20,18 @@
 
 public class VerveineJParser extends VerveineParser {
 
+	public static final String DEFAULT_CODE_VERSION = JavaCore.VERSION_1_5;
+	
+
+	protected String codeVers = null;
+	
+	
 	/**
 	 * The arguments that were passed to the parser
 	 * Needed to relativize the source file names
 	 */
-	private Collection<String> sourceFiles;
+	private Collection<String> argPath;
+	private Collection<String> argFiles;
 	
 	private ASTParser jdtParser = null;
 	
@@ -35,35 +42,91 @@
 	}
 	
 	public void setOptions(String[] args) {
-		// we assume java 1.5 code for now, this should be configurable
+		Collection<String> classPath = new ArrayList<String>();
+		argPath = new ArrayList<String>();
+		argFiles = new ArrayList<String>();
+
+        int i = 0;
+        while (i < args.length && args[i].startsWith("-")) {
+        	String arg;
+            arg = args[i++];
+
+            if (arg.equals("-h")) {
+            	usage();
+            }
+            else if (arg.matches("-1\\.[1-7]") || arg.matches("-[1-7]")) {
+            	setCodeVersion(arg);
+            }
+            else if (arg.equals("-cp")) {
+                if (i < args.length) {
+                	classPath.add(args[++i]);
+                }
+                else {
+                	System.err.println("-cp requires a classPath");
+                }
+
+            }
+        }
+        while (i < args.length) {
+        	String arg;
+            arg = args[i++];
+        	if ( arg.endsWith(".java") && new File(arg).isFile() ) {
+        		argFiles.add(arg);
+        	}
+        	else {
+        		argPath.add(arg);
+        	}
+        }
+
+		jdtParser.setEnvironment(classPath.toArray(new String[0]), argPath.toArray(new String[0]), null, true);
+		jdtParser.setResolveBindings(true);
+		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
+
 		@SuppressWarnings("unchecked")
 		Map<String,String> options = JavaCore.getOptions();
-		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
-		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5);
-		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
+		
+		if (codeVers == null) {
+			codeVers = DEFAULT_CODE_VERSION;
+		}
+		options.put(JavaCore.COMPILER_COMPLIANCE, codeVers);
+		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, codeVers);
+		options.put(JavaCore.COMPILER_SOURCE, codeVers);
+
 		jdtParser.setCompilerOptions(options);
+	}
 
-		Collection<String> classPath = new ArrayList<String>();
-		Collection<String> sourcePath = new ArrayList<String>();
-		sourceFiles = new ArrayList<String>();
-		for (int i=0; i < args.length; i++) {
-			String current = args[i];
-			if (current.equals("-cp")) {
-				classPath.add(args[++i]);
-			}
-			else if (current.endsWith(".java")) {
-				sourceFiles.add(current);
-			}
-			else {
-				sourcePath.add(current);
-			}
+	protected void usage() {
+		System.err.println("Usage: VerveineJ [-h] [-cp CLASSPATH] [-1.1 | -1 | -1.2 | -2 | ... | -1.7 | -7] <files-to-parse> | <dirs-to-parse>");
+		System.exit(0);
+
+	}
+	protected void setCodeVersion(String arg) {
+		if (codeVers != null) {
+			System.err.println("Trying to set twice code versions: "+ codeVers + " and "+ arg);
+			usage();
 		}
-		
-		jdtParser.setEnvironment(classPath.toArray(new String[0]), sourcePath.toArray(new String[0]), null, true);
-		jdtParser.setResolveBindings(true);
-		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
-		
-		collectJavaFiles(sourcePath, sourceFiles);
+		else if (arg.equals("-1.1") || arg.equals("-1")) {
+			codeVers = JavaCore.VERSION_1_1;
+		}
+		else if (arg.equals("-1.2") || arg.equals("-2")) {
+			codeVers = JavaCore.VERSION_1_2;
+		}
+		else if (arg.equals("-1.3") || arg.equals("-3")) {
+			codeVers = JavaCore.VERSION_1_3;
+		}
+		else if (arg.equals("-1.4") || arg.equals("-4")) {
+			codeVers = JavaCore.VERSION_1_4;
+		}
+		else if (arg.equals("-1.5") || arg.equals("-5")) {
+			codeVers = JavaCore.VERSION_1_5;
+		}
+		else if (arg.equals("-1.6") || arg.equals("-6")) {
+			codeVers = JavaCore.VERSION_1_6;
+		}
+		else if (arg.equals("-1.7") || arg.equals("-7")) {
+			codeVers = JavaCore.VERSION_1_7;
+		}
+
 	}
 
 	private void collectJavaFiles(Collection<String> paths, Collection<String> files) {
@@ -93,11 +156,17 @@
 	}
 
 	public void parse() {
+		ArrayList<String> sourceFiles = new ArrayList<String>();
+
 		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
 		}
 
-		FamixRequestor req = new FamixRequestor(getFamixRepo(), new String[0]);
+		FamixRequestor req = new FamixRequestor(getFamixRepo(), argPath, argFiles);
+
+		sourceFiles.addAll(argFiles);
+		collectJavaFiles(argPath, sourceFiles);
+
 		jdtParser.createASTs(sourceFiles.toArray(new String[0]), null, new String[0], req, null);
 		
 		this.compressNamespacesNames();
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 112)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.Collection;
+
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.FileASTRequestor;
 
@@ -11,11 +13,13 @@
 	
 	protected JavaDictionary famixDictionnary;
 
-	private String[] initialArgs;
+	private Collection<String> argsDir;
+	private Collection<String> argsFile;
 	
-	public FamixRequestor(Repository r, String[] initialArgs) {
+	public FamixRequestor(Repository r, Collection<String> argsDir, Collection<String> argsFile) {
 		this.famixRepo = r;
-		this.initialArgs = initialArgs;
+		this.argsDir = argsDir;
+		this.argsFile = argsFile;
 
 		this.famixDictionnary = new JavaDictionary(famixRepo);
 	}
@@ -28,13 +32,19 @@
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
 
-	private Object relativePath(String sourceFilePath) {
-		for (String arg : initialArgs) {
-			int i = sourceFilePath.indexOf(arg);
-			if (i >= 0) {
-				return sourceFilePath.substring(i);
+	private Object relativePath(String fullPath) {
+		for (String f : argsFile) {
+			if (fullPath.endsWith(f)) {
+				return f;
+			}
+		}
+
+		for (String d : argsDir) {
+			int i = fullPath.indexOf(d);
+			if (i >= 0) {  // if fullPath contains d
+				return fullPath.substring(i);
 			}
 		}
-		return sourceFilePath;
+		return fullPath;
 	}
 }
Index: verveine.extractor.java/build.xml
===================================================================
--- verveine.extractor.java/build.xml	(revision 111)
+++ verveine.extractor.java/build.xml	(revision 112)
@@ -6,7 +6,7 @@
 	<property name="build.dir"    location="bin" />
 	<property name="docs.dir"     location="docs" />
 	<property name="dist.dir"     location="lib" />
-	<property name="verveine.jar" location="${dist.dir}/verveine.extractor,java.jar" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.extractor.java.jar" />
 
 	<!-- Variables used for JUnit testin -->
 	<property name="test.dir" location="src/tests/fr/inria/verveine/extractor/java/" />
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 53)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 54)
@@ -104,6 +104,7 @@
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
+		//fmx.setTypeArguments(dico.ensureFamixTypes(node.typeParameters()));
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -160,7 +161,7 @@
 		this.context.popClass();
 		super.endVisit(node);
 	}
-
+	
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
@@ -173,16 +174,23 @@
 			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
-			fmx.setSignature(fmx.getName()+" (???)");
-			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+			//fmx.setSignature(fmx.getName()+" (???)");
+			fmx.setSignature(dico.stubMethodSignature(node));
+			//fmx.setDeclaredType( dico.ensureFamixClassObject(null));
+			// Has no binding? It might be a Generic type
+			fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
 		}
-
-		if (fmx != null) {			
+		if (fmx != null) {
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding());
+//				System.err.println(param.getName().getIdentifier());
+//				System.err.println(param.resolveBinding()==null);
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
+				} else {
+					// Has no binding? It might be a Generic parameter
+					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, param.getType().toString());
 				}
 			}
 			
@@ -232,7 +240,9 @@
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
 				// should try to find type name from 'node.getType()' ?
-				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				// Has no binding? It might be a Generic type
+				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
 			}
 			
 			dico.addSourceAnchor(fmx, node);
@@ -281,8 +291,9 @@
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
 				// should try to find type name from 'node.getType()' ?
-				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-
+				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				// Has no binding? It might be a Generic type
+				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
 		}
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 17)
+++ verveine.extractor.java/.classpath	(revision 18)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/verveine.core/src/fr/inria/verveine/core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
@@ -14,6 +14,6 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
-	<classpathentry kind="lib" path="lib/famix.jar"/>
+	<classpathentry kind="lib" path="lib/famix.jar" sourcepath="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 17)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 18)
@@ -1,11 +1,14 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.core.dom.ASTVisitor;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
 import org.eclipse.jdt.core.dom.ArrayAccess;
 import org.eclipse.jdt.core.dom.ArrayCreation;
 import org.eclipse.jdt.core.dom.Assignment;
 import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.ConditionalExpression;
@@ -24,10 +27,14 @@
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.QualifiedName;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleType;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
 import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.TypeLiteral;
 
@@ -126,8 +133,19 @@
 		super.endVisit(node);
 	}
 
+	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		this.context.pushMethod((Method)dico.ensureFamixMethod(node.resolveBinding()));
+		Method meth = dico.ensureFamixMethod(node.resolveBinding());
+		this.context.pushMethod(meth);
+		for (Name excepName : (List<Name>)node.thrownExceptions()) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding());
+			if (excepFmx == null) {
+				excepFmx = this.dico.ensureFamixClass(excepName.getFullyQualifiedName());
+			}
+			if (excepFmx != null) {
+				dico.ensureFamixDeclaredException(meth, excepFmx);
+			}
+		}
 		return super.visit(node);	
 	}
 
@@ -165,6 +183,39 @@
 		return super.visit(node);
 	}
 
+	@Override
+	public boolean visit(CatchClause node) {
+		Method meth = this.context.topMethod();
+		Type excepClass = node.getException().getType();
+		if (meth != null) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding());
+			if (excepFmx == null) {
+				if (excepClass instanceof SimpleType) {
+					excepFmx = this.dico.ensureFamixClass(((SimpleType) excepClass).getName().getFullyQualifiedName());
+				}
+				else if (excepClass instanceof QualifiedType) {
+					excepFmx = this.dico.ensureFamixClass(((QualifiedType) excepClass).getName().getIdentifier());
+				}
+			}
+			if (excepFmx != null) {
+				dico.ensureFamixCaughtException(meth, excepFmx);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(ThrowStatement node) {
+		Method meth = this.context.topMethod();
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding());
+		if (excepFmx != null) {
+			dico.ensureFamixThrownException(meth, excepFmx);
+		}
+		return super.visit(node);
+	}
+
+
 	/**
 	 * Finds and/or create the Famix Entity receiving a message
 	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 17)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 18)
@@ -115,7 +115,6 @@
 	}
 
 	public Type ensureFamixType(ITypeBinding bnd) {
-
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
 			return null;
@@ -169,7 +168,8 @@
 		}
 		
 		if (bnd.isPrimitive()) {
-			System.err.println("Warning: cannot create Famix Class from aprimitive type");
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
+			System.err.println("Warning: cannot create Famix Class from a primitive type");
 			return null;
 		}
 		
@@ -255,9 +255,12 @@
 					break;
 				}
 				else if ( candidate.getIsStub() ) {
-					ContainerEntity ownerBnd = owner;
-					ContainerEntity ownerStub = candidate.getBelongsTo();
-					while ( (! (ownerBnd instanceof Namespace)) &&
+					// find out whether this candidate is defined in the same namespace as the binding received in parameter
+					ContainerEntity ownerBnd = owner;  // the owner of the bounded entity received as parameter
+					ContainerEntity ownerStub = candidate.getBelongsTo();  // the owner of the current candidate
+					while ( (ownerBnd != null) &&
+							(ownerStub != null) &&
+							(! (ownerBnd instanceof Namespace)) &&
 							(ownerBnd.getClass() == ownerStub.getClass()) &&
 							ownerBnd.getName().equals(ownerStub.getName()) ) {
 								ownerBnd = ownerBnd.getBelongsTo();
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 110)
+++ verveine.core/.classpath	(revision 111)
@@ -3,7 +3,7 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 110)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 111)
@@ -362,11 +362,11 @@
 	 * @return the Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class topClass() {
-		return getTopType().getFmxClass();
+		return ( getTopType() == null) ? null : getTopType().getFmxClass();
 	}
 
 	public AnnotationType topAnnotationType() {
-		return getTopType().getFmxAnnotationType();
+		return ( getTopType() == null) ? null : getTopType().getFmxAnnotationType();
 	}
 	
 	/**
@@ -375,11 +375,11 @@
 	 * @return the Famix method
 	 */
 	public Method topMethod() {
-		return getTopType().getFmxMethod();
+		return ( getTopType() == null) ? null : getTopType().getFmxMethod();
 	}
 
 	public AnnotationTypeAttribute topAnnotationMember() {
-		return getTopType().getFmxAnnotationAttribute();
+		return ( getTopType() == null) ? null : getTopType().getFmxAnnotationAttribute();
 	}
 
 	// PROPERTIES OF THE TOP METHOD
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 110)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 111)
@@ -456,7 +456,7 @@
 	 * @param prev -- previous reference relationship in the same context
 	 * @return the Reference
 	 */
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+	public Reference addFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
 		ref.setSource(src);
@@ -474,7 +474,7 @@
 	 * @param prev -- previous invocation relationship in the same context
 	 * @return the Invocation
 	 */
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+	public Invocation addFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
@@ -494,7 +494,7 @@
 	 * @param prev -- previous access relationship in the same context
 	 * @return the Invocation
 	 */
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
+	public Access addFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
 		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
 		acc.setAccessor(accessor);
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 110)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 111)
@@ -376,7 +376,6 @@
 
 	}
 
-
 	@Test
 	public void testInvocation() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
@@ -452,7 +451,6 @@
 
 	}
 
-	
 	@Test
 	public void testAccess() {
 		Attribute att;
@@ -491,7 +489,6 @@
 		}
 	}
 
-
 	@Test
 	public void testSourceAnchors() {
 		SourceAnchor anc = null;
@@ -542,7 +539,6 @@
 		
 	}
 
-
 	@Test
 	public void testModifiers() {
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
@@ -577,7 +573,6 @@
 		assertFalse(a.getIsFinal());
 	}
 
-
 	@Test
 	public void testComment() {	
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
@@ -597,7 +592,6 @@
 		assertEquals(34, ((FileAnchor)anc).getEndLine());
 
 	}
-
 	
 	@Test
 	public void testMetric() {
@@ -619,7 +613,6 @@
 			}
 		}		
 	}
-
 	
 	@Test
 	public void testAnnotation() {
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 110)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 111)
@@ -4,10 +4,7 @@
 package tests.fr.inria.verveine.extractor.java;
 
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -18,6 +15,7 @@
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
 import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
@@ -33,6 +31,7 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.ParameterType;
 import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.ThrownException;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.VerveineJParser;
@@ -159,18 +158,44 @@
 		}
 
 	}
+	
+	@Test
+	public void testClassVar() {
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		assertNotNull(meth);
+		
+		assertEquals(3, meth.getParameters().size());
+		for (Parameter p : meth.getParameters()) {
+			if (p.getName().equals("fmxClass")) {
+				assertEquals(ParameterizedType.class, p.getDeclaredType().getClass());
+				assertEquals("Class", p.getDeclaredType().getName());
+			}
+			else {
+				assertTrue("Unknown parameter for ensureFamixEntity: "+p.getName(),
+							p.getName().equals("name") || p.getName().equals("bnd") );
+				break;
+			}
+		}
+		
+		assertEquals(2, meth.getAccesses().size());
+		boolean classFieldFound = false;
+		for (Access acc : meth.getAccesses()) {
+			if (acc.getTo().getName().equals("class")) {
+				classFieldFound = true;
+			}
+		}
+		assertTrue("ensureFamixEntity does not access <someClass>.class", classFieldFound);
+	}
 
 	@Test
 	public void testParameterizableClass() {
 		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
 		assertNotNull(dico);
-		for (Type t : dico.getTypes()) {
-			System.out.println("dico type: "+t.getName());
-		}
+
 		assertEquals("Dictionary", dico.getName());
 		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
 		assertEquals(1, dico.getParameters().size());
-		
+
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
 		assertNotNull(dicoParam);
 		assertEquals("B", dicoParam.getName());
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 110)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 111)
@@ -45,9 +45,11 @@
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest and links betgween them
@@ -123,7 +125,7 @@
 			importName = dico.removeLastName(importName);
 		}
 		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		context.setLastReference( dico.addFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
@@ -244,13 +246,18 @@
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
 			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/null);  // cast needed to desambiguate the call
-			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
 	public boolean visit(FieldAccess node) {
-		fieldAccess(node.resolveFieldBinding());
-		
+		BehaviouralEntity accessor = this.context.topMethod();
+		Attribute accessed = this.dico.ensureFamixAttribute(node.resolveFieldBinding(), node.getName().getIdentifier(), null, null);
+		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+			accessed.setParentType(dico.ensureFamixClassArray());
+		}
+		context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+
 		return super.visit(node);
 	}
 
@@ -260,7 +267,12 @@
 		IBinding bnd = node.resolveBinding();
 		if (bnd instanceof IVariableBinding) {
 			// apparently this is a field
-			fieldAccess((IVariableBinding) bnd);
+			BehaviouralEntity accessor = this.context.topMethod();
+			Attribute accessed = this.dico.ensureFamixAttribute(bnd, node.getName().getIdentifier(), null, null);
+			if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+				accessed.setParentType(dico.ensureFamixClassArray());
+			}
+			context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 		}
 		return super.visit(node);
 	}
@@ -348,9 +360,12 @@
 
 		// field.msg()
 		else if (expr instanceof FieldAccess) {
-			Attribute ret = null;
-			IVariableBinding bnd = ((FieldAccess) expr).resolveFieldBinding();
-			ret = dico.ensureFamixAttribute(bnd, ((FieldAccess) expr).getName().getIdentifier(), null, null);
+			BehaviouralEntity accessor = this.context.topMethod();
+			Attribute ret = dico.ensureFamixAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), null, null);
+			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
+				ret.setParentType(dico.ensureFamixClassArray());
+			}
+			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -384,7 +399,14 @@
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);//TODO should be ensureAttribute
+					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);
+					BehaviouralEntity accessor = this.context.topMethod();
+					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
+						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
+					}
+					context.setLastAccess( dico.addFamixAccess(accessor, (Attribute) ret, /*isWrite*/false, context.getLastAccess()) );
+
+					return ret;
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
 					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -410,9 +432,12 @@
 
 		// super.field.msg()
 		else if (expr instanceof SuperFieldAccess) {
-			Attribute ret = null;
-			IVariableBinding bnd = ((SuperFieldAccess) expr).resolveFieldBinding();
-			ret = dico.ensureFamixAttribute(bnd, ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
+			BehaviouralEntity accessor = this.context.topMethod();
+			Attribute ret = dico.ensureFamixAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
+			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
+				ret.setParentType(dico.ensureFamixClassArray());
+			}
+			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -431,8 +456,17 @@
 
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
-			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null,  context.top());
+			// similar to a field access
+			Attribute ret;
+			fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
+			BehaviouralEntity accessor = this.context.topMethod();
+			ret =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
+			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
+				ret.setParentType(dico.ensureFamixClassArray());
+			}
+			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
+
+			return ret;
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
@@ -443,22 +477,4 @@
 		return null;
 	}
 
-	/**
-	 * Handles an access to a field by creating the corresponding Famix Entity
-	 * @param bnd -- a binding for the field (i.e attribute)
-	 */
-	private void fieldAccess(IVariableBinding bnd) {
-		// TODO could be accessing annotation type attribute
-		BehaviouralEntity accessor = this.context.topMethod();
-		if (accessor != null) {
-			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
-			if (accessed != null) {
-				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
-				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
-					accessed.setParentType(dico.ensureFamixClassArray());
-				}
-			}
-		}
-	}
-
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 110)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 111)
@@ -23,7 +23,6 @@
 import org.eclipse.jdt.core.dom.ForStatement;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
@@ -43,21 +42,17 @@
 import org.eclipse.jdt.core.dom.TypeParameter;
 import org.eclipse.jdt.core.dom.VariableDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
 import org.eclipse.jdt.core.dom.WhileStatement;
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
-import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.EnumValue;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.ParameterType;
 import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
@@ -241,31 +236,33 @@
 		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
-		Type retTyp = node.getReturnType2();
-		Collection<Type> paramTypes = new ArrayList<Type>();
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				paramTypes.add(param.getType());
-		}
-
-		fr.inria.verveine.core.gen.famix.Type fmxTyp;
+		//Type retTyp = node.getReturnType2();
+		/*fr.inria.verveine.core.gen.famix.Type fmxTyp;
 		if (retTyp == null) {
 			fmxTyp = null;
 		}
 		else {
-			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
+			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner* /null, context.top());
+		}*/
+
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
 		}
 
-		// creating/recovering it
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, fmxTyp, context.topClass());
-		
-		if (retTyp != null && retTyp.isParameterizedType()) {
+		// creating/recovering it (creates it with a null return type because might need this FamixMethod to create the return type.
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, null, context.topClass());
+		fr.inria.verveine.core.gen.famix.Type fmxTyp = referedType(node.getReturnType2(), fmx);
+
+		//if (retTyp != null && retTyp.isParameterizedType()) {
 			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)retTyp).typeArguments()));
-		}
+		//}
 		
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
 			this.context.pushMethod(fmx);
+			fmx.setDeclaredType(fmxTyp);
 			if (node.getBody() != null) {
 				context.setTopMethodCyclo(1);
 			}
@@ -279,7 +276,8 @@
 				// Note: method and ParamTyp bindings are null for ParameterType :-(
 				paramAsVarList = new ArrayList<VariableDeclaration>(1);
 				paramAsVarList.add(param);
-				visitVariablesDeclarations(node, param.getType(), paramAsVarList, context.topMethod());
+				fr.inria.verveine.core.gen.famix.Type varTyp = referedType(param.getType(), context.topMethod());
+				visitVariablesDeclarations(node, varTyp, paramAsVarList, context.topMethod());
 			}
 			return super.visit(node);
 		}
@@ -308,7 +306,8 @@
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 
-		for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
+		fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topClass());
+		for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
 			dico.addSourceAnchor(att, node);
 			dico.ensureFamixComment(node.getJavadoc(), att);
 		}
@@ -322,7 +321,8 @@
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
 		if (! node.getType().isPrimitiveType()) {
-			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
+			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
 				dico.addSourceAnchor(att, node);
 			}
 		}
@@ -337,7 +337,8 @@
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
 		if (! node.getType().isPrimitiveType()) {
-			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+			fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topMethod());
+			for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
 				dico.addSourceAnchor(att, node);
 			}
 		}
@@ -346,43 +347,26 @@
 	}
 
 	@SuppressWarnings("unchecked")
-	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
+	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, fr.inria.verveine.core.gen.famix.Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
 		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
 
-		fr.inria.verveine.core.gen.famix.Type fmxTyp;
-		if (varTyp.isParameterizedType()) {
-			ITypeBinding parameterizedBnd = varTyp.resolveBinding();
-			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
-			String tname = dico.findTypeName(varTyp);
-			ParameterizableClass tmpGeneric = null;
-			tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
-
-			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, tmpGeneric, /*owner*/ctxt);
-			for (Type targ : (List<Type>) ((ParameterizedType)varTyp).typeArguments()) {
-				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), null, ctxt);
-				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
-			}
-		}
-		else {
-			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
-		}
 		for (VariableDeclaration vd : fragments) {
 			StructuralEntity fmx;
 			if (node instanceof MethodDeclaration) {
 				// creating the parameters of a method. In this case, 'fragment' is aList<SingleVariableDeclarationFragment> and 'varType' is null
-				fmx = dico.ensureFamixParameter(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method)ctxt);
+				fmx = dico.ensureFamixParameter(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method)ctxt);
 			}
 			else if (node instanceof FieldDeclaration) {
 				// creating a class' field
-				fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
+				fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
 			}
 			else if (node instanceof VariableDeclarationExpression) {
 				// creating a method's local variable
-				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method) ctxt);
 			}
 			else if (node instanceof VariableDeclarationExpression) {
 				// creating a method's local variable
-				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), varTyp, (Method) ctxt);
 			}
 			else {
 				fmx = null;
@@ -397,6 +381,37 @@
 		return ret;
 	}
 
+	/**
+	 * @param typ
+	 * @param ctxt
+	 * @return
+	 */
+	private fr.inria.verveine.core.gen.famix.Type referedType(Type typ, ContainerEntity ctxt) {
+		fr.inria.verveine.core.gen.famix.Type fmxTyp = null;
+		
+		if (typ == null) {
+			return null;
+		}
+
+		if (typ.isParameterizedType()) {
+			ITypeBinding parameterizedBnd = typ.resolveBinding();
+			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
+			String tname = dico.findTypeName(typ);
+			ParameterizableClass tmpGeneric = null;
+			tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
+
+			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, tmpGeneric, /*owner*/ctxt);
+			for (Type targ : (List<Type>) ((ParameterizedType)typ).typeArguments()) {
+				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), null, ctxt);
+				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
+			}
+		}
+		else {
+			fmxTyp = dico.ensureFamixType(typ.resolveBinding(), dico.findTypeName(typ), /*owner*/null, ctxt);
+		}
+		return fmxTyp;
+	}
+
 	// METRICS: CYCLO, NOS
 	
 	public boolean visit(AssertStatement node) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 110)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 111)
@@ -20,10 +20,12 @@
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
+import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
@@ -55,6 +57,7 @@
 	public static final String SOURCE_FILENAME_PROPERTY = "verveine-source-filename";
 
 	public static final String OBJECT_NAME = "Object";
+	public static final String METACLASS_NAME = "Class";
 	public static final String OBJECT_PACKAGE_NAME = "java.lang";
 	public static final String ARRAYS_NAME = "default[]";
 	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
@@ -208,7 +211,7 @@
 		// --------------- name
 		if (name == null) {
 			if (! bnd.isAnonymous()) {
-				name = bnd.getErasure().getName();  // for generics, will give the "core" type name, for naormal type, won't change anything
+				name = bnd.getErasure().getName();  // for generics, will give the "core" type name, for normal type, won't change anything
 			}
 			else { // anonymous class
 				if (bnd.getSuperclass() != null) {
@@ -231,6 +234,14 @@
 			return ensureFamixClassObject(bnd);
 		}
 
+		// --------------- recover from name ?
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
+				break;
+			}
+		}
+
 		// --------------- owner
 		if (owner == null) {
 			IMethodBinding parentMtd = bnd.getDeclaringMethod();
@@ -275,13 +286,7 @@
 			sups.add( ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/owner));
 		}
 
-		// --------------- recover from name ?
-		for (Type candidate : this.getEntityByName(Type.class, name)) {
-			if ( checkAndMapClass(bnd, candidate) ) {
-				fmx = (Class) candidate;
-				break;
-			}
-		}
+		// ---------------- create 
 		if (fmx == null) {
 			if (isGeneric) {
 				fmx = super.ensureFamixParameterizableClass(bnd, name, owner);
@@ -308,8 +313,14 @@
 		return fmx;
 	}
 
+/*	public ParameterizableClass ensureFamixParameterizableType(ITypeBinding bnd, String name, ContainerEntity owner) {
+		ParameterizableClass fmx = null;
+		
+		return fmx;
+	}*/
+	
 	public ParameterizedType ensureFamixParameterizedType(ITypeBinding bnd, String name, ParameterizableClass generic, ContainerEntity owner) {
-		ParameterizedType fmx = null;
+			ParameterizedType fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
@@ -355,7 +366,12 @@
 
 		// --------------- generic
 		if (generic == null) {
-			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+			String genName = name;
+			int i = name.indexOf('<');
+			if (i > 0) {
+				genName = name.substring(0, i);
+			}
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), genName, owner, /*isGeneric*/true);
 		}
 
 		// --------------- recover from name ?
@@ -1302,6 +1318,15 @@
 		return fa;
 	}
 
+	public Access fieldAccess(BehaviouralEntity accessor, Attribute accessed, boolean isWrite, Access lastAccess) {
+		Access ret = null;
+		// TODO could be accessing annotation type attribute
+		if ( (accessor != null) && (accessed != null) ) {
+			ret = super.addFamixAccess(accessor, accessed, isWrite, lastAccess);
+		}
+		return ret;
+	}
+
 	/**
 	 * Creates or recovers a stub Famix Method
 	 * @param name of the method
@@ -1333,19 +1358,23 @@
 		
 		if (fmx != null) {
 			fmx.setContainer( ensureFamixNamespaceJavaLang(null));
-			
-			fmx.setIsAbstract(Boolean.FALSE);
-			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsInterface(Boolean.FALSE);
-			fmx.setIsPrivate(Boolean.FALSE);
-			fmx.setIsProtected(Boolean.FALSE);
-			fmx.setIsPublic(Boolean.TRUE);
 		}
 		// Note: "Object" has no superclass
 
 		return fmx;
 	}
 
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixMetaClass(ITypeBinding bnd) {
+		Namespace javaLang = ensureFamixNamespaceJavaLang( (bnd == null) ? null : bnd.getPackage());
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixClass(bnd, METACLASS_NAME, javaLang, /*isGeneric*/true);
+
+		if ( (fmx != null) && (fmx.getSuperInheritances() == null) ) {
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx, null);
+		}
+
+		return fmx;
+	}
+	
 	/**
 	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
 	 * @return a Famix class
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 33)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 34)
@@ -385,7 +385,6 @@
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
 			}
-			//context.setLastAccess( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastAccess) );
 		}
 	}
 
Index: verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 109)
+++ verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 110)
@@ -29,7 +29,7 @@
  * 
  * @author akuhn
  * 
- * /
+ */
 @Retention(RetentionPolicy.RUNTIME)
 @Target( { ElementType.METHOD, ElementType.FIELD })
 public @interface FameProperty {
@@ -43,5 +43,5 @@
     String opposite() default "";
 
     Class<?> type() default Void.class;
-*/
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 109)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 110)
@@ -448,6 +448,7 @@
 	 * @param bnd -- a binding for the field (i.e attribute)
 	 */
 	private void fieldAccess(IVariableBinding bnd) {
+		// TODO could be accessing annotation type attribute
 		BehaviouralEntity accessor = this.context.topMethod();
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
Index: verveine.extractor.java/build.xml
===================================================================
--- verveine.extractor.java/build.xml	(revision 109)
+++ verveine.extractor.java/build.xml	(revision 110)
@@ -74,7 +74,7 @@
   				  <include name="*.jar"/>
 				</fileset>
 			</classpath>
-			<formatter type="plain" />
+			<formatter type="xml" />
 			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel" todir="${test.report.dir}" />
 			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc" todir="${test.report.dir}" />
 		</junit>
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 30)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 31)
@@ -365,6 +365,10 @@
 	 * @return the Inheritance relationship
 	 */
 	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
+		return ensureFamixInheritance(sup, sub, null);
+	}
+	
+	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Inheritance prev) {
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
 				return i;
@@ -373,6 +377,7 @@
 		Inheritance inh = new Inheritance();
 		inh.setSuperclass(sup);
 		inh.setSubclass(sub);
+		chainPrevNext(prev,inh);
 		famixRepoAdd(inh);
 		return inh;
 	}
Index: verveine.extractor.java/memusage.txt
===================================================================
--- verveine.extractor.java/memusage.txt	(revision 108)
+++ verveine.extractor.java/memusage.txt	(revision 109)
@@ -1,54 +0,0 @@
-
-memory usage for Eclipse 3.1
-$ time ./verveinej3_1.sh 2> toto.log >&2
-$ time ./verveinej-mono-3_1.sh 2> toto.log >&2
-
-120.51user 3.31system 2:25.05elapsed 85%CPU 
-(0avgtext+0avgdata 9.646.080maxresident)k
-292144inputs+221248outputs (2356major+700607minor)pagefaults 0swaps
-8522 toto.log
-
-120.79user 2.95system 1:53.51elapsed 109%CPU 
-(0avgtext+0avgdata 9.175.040maxresident)k
-142416inputs+220976outputs (87major+622960minor)pagefaults 0swaps
-8522 toto.log
-3.340.182 output.mse
-
-112.33user 4.35system 1:40.17elapsed 116%CPU 
-(0avgtext+0avgdata 9.777.152maxresident)k
-68760inputs+221504outputs (190major+682907minor)pagefaults 0swaps
-
-$ for i in `grep FAMIX output.mse | sed -e 's/ (id:.*//' | sed -e 's/^        (//' | sort -u`; do echo -n "$i   "; grep -c $i output.mse ; done
-FAMIX.Access   60984
-FAMIX.Attribute   27473
-FAMIX.CaughtException   3690
-FAMIX.Class   7906
-FAMIX.Comment   37000
-FAMIX.DeclaredException   3848
-FAMIX.FileAnchor   124493
-FAMIX.ImplicitVariable   4996
-FAMIX.Inheritance   7136
-FAMIX.Invocation   169940
-FAMIX.LocalVariable   37753
-FAMIX.Method   53602
-FAMIX.Namespace   377
-FAMIX.Parameter   52480
-FAMIX.PrimitiveType   9
-FAMIX.Reference   30799
-FAMIX.ThrownException   2414
-FAMIX.UnknownVariable   23090
-FAMIX   647990
-
-$ grep -c 'null binding' toto.log 
-8413
-
-
-=======================================
-SEPARATE
-
-2041.59user 115.58system 27:47.42elapsed 129%CPU 
-(0avgtext+0avgdata 7.086.080maxresident)k
-135200inputs+6149832outputs (110major+16978083minor)pagefaults 0swaps
-
-
-FAMIX.Attribute   27520
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 108)
+++ verveine.extractor.java/.classpath	(revision 109)
@@ -2,11 +2,6 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
-		<attributes>
-			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
-		</attributes>
-	</classpathentry>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
@@ -14,8 +9,10 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
+	<classpathentry kind="lib" path="lib/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
+	<classpathentry kind="lib" path="lib/junit.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/junit.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/junit.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/test_src/ad_hoc/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 109)
@@ -1,70 +0,0 @@
-package OMGL2;
-import java.io.BufferedReader;
-import java.io.IOException;
-
-
-@Override
-@Deprecated
-public class Client {
-	
-	@Override
-	@Deprecated
-	private String num;
-	@Deprecated
-	private String nom;
-
-	@Deprecated
-	public Client(String num, String nom) {
-		this.setNum(num);
-		this.setNom(nom);
-	}
-	
-	@Override
-	@Deprecated
-	public static Client lire(BufferedReader in) throws ReadException {
-		String nom = "";
-		String num = "";
-		char c = ' ';
-		
-		try {
-			for (int i=0; (i<5) && in.ready(); i++) {
-				c = (char)in.read();
-				num += c;
-			}
-			while ( in.ready() && (c != '.')) {
-				c = (char)in.read();
-				if (c != '.') {
-					nom += c;
-				}
-			}
-		} catch (IOException e) {
-			throw new ReadException();
-			return null;
-		}
-		
-		return new Client(num, nom);
-		
-	}
-	
-	public String toString() {
-		return "client: ["+getNum()+"] "+getNom();
-	}
-	
-	@Override
-	@Deprecated
-	public void setNum(String num) {
-		this.num = num;
-	}
-
-	public String getNum() {
-		return num;
-	}
-
-	public void setNom(String nom) {
-		this.nom = nom;
-	}
-
-	public String getNom() {
-		return nom;
-	}
-}
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 109)
@@ -1,42 +1,17 @@
-package fr.inria.verveine.core;
+package ad_hoc;
 
 import java.util.Collection;
 import java.util.Hashtable;
 import java.util.LinkedList;
 import java.util.Map;
 
-import ch.akuhn.fame.Repository;
-
-import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Association;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.CaughtException;
-import fr.inria.verveine.core.gen.famix.Comment;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.DeclaredException;
-import fr.inria.verveine.core.gen.famix.Entity;
-import fr.inria.verveine.core.gen.famix.ImplicitVariable;
-import fr.inria.verveine.core.gen.famix.Inheritance;
-import fr.inria.verveine.core.gen.famix.Invocation;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.PrimitiveType;
-import fr.inria.verveine.core.gen.famix.Reference;
-import fr.inria.verveine.core.gen.famix.SourcedEntity;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-import fr.inria.verveine.core.gen.famix.ThrownException;
-
 public class Dictionary<B> {
 
 	protected Map<B,NamedEntity> mapBind;
 
 	protected Map<String,Collection<NamedEntity>> mapName;
 
-	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+	protected Map<NamedEntity,ImplicitVars> mapImpVar;
 
 	protected class ImplicitVars {
 		public ImplicitVariable self_iv;
@@ -53,10 +28,10 @@
 		
 		this.mapBind = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
-		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		this.mapImpVar = new Hashtable<NamedEntity,ImplicitVars>();
 		
 		if (! this.famixRepo.isEmpty()) {
-			recoverExistingRepository();
+			// nothing
 		}
 	}
 	
@@ -141,3 +116,23 @@
 	}
 	
 }
+
+class NamedEntity {
+	public boolean isInstance(NamedEntity obj) {
+		return false;
+	}
+	public void setName(String f) {
+	}
+	public void setIsStub(Boolean f) {
+	}
+}
+
+class Repository {
+	public boolean isEmtpy() {
+		return false;
+	}
+	public void add(NamedEntity f) {
+	}
+}
+
+}
\ No newline at end of file
Index: verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 109)
@@ -2,7 +2,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
-
+/*
 public class Card {
 
 	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
@@ -37,4 +37,5 @@
     public static ArrayList<Card> newDeck() {
         return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
     }
+ */
 }
Index: verveine.extractor.java/test_src/ad_hoc/Element.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 109)
@@ -16,14 +16,7 @@
 //  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
 //  
 
-package ch.akuhn.fame.fm3;
-
-import ch.akuhn.fame.FameDescription;
-import ch.akuhn.fame.FamePackage;
-import ch.akuhn.fame.FameProperty;
-import ch.akuhn.fame.Named;
-import ch.akuhn.fame.Nested;
-import ch.akuhn.fame.internal.Warnings;
+package ad_hoc;
 
 /**
  * Abstract superclass of MSE metamodel.
@@ -50,7 +43,7 @@
  */
 @FamePackage("FM3")
 @FameDescription("Element")
-public abstract class Element implements Named, Nested {
+public abstract class Element {
 
     private String name;
 
@@ -83,7 +76,5 @@
     public String toString() {
         return this.getFullname();
     }
-    
-    public abstract void checkConstraints(Warnings warnings);
 
 }
Index: verveine.extractor.java/test_src/ad_hoc/ReadClient.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/ReadClient.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/ReadClient.java	(revision 109)
@@ -0,0 +1,71 @@
+package ad_hoc;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+@Override
+@Deprecated
+public class Client {
+	
+	@Override
+	@Deprecated
+	private String num;
+	@Deprecated
+	private String nom;
+
+	@Deprecated
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+	
+	@Override
+	@Deprecated
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+	
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	@Override
+	@Deprecated
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: verveine.extractor.java/test_src/ad_hoc/ReadException.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 109)
@@ -1,4 +1,5 @@
-package OMGL2;
+package ad_hoc;
+
 public class ReadException extends Exception {
 
 }
Index: verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 108)
+++ verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 109)
@@ -16,7 +16,7 @@
 //  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
 //  
 
-package ch.akuhn.fame;
+package ad_hoc;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -29,7 +29,7 @@
  * 
  * @author akuhn
  * 
- */
+ * /
 @Retention(RetentionPolicy.RUNTIME)
 @Target( { ElementType.METHOD, ElementType.FIELD })
 public @interface FameProperty {
@@ -43,5 +43,5 @@
     String opposite() default "";
 
     Class<?> type() default Void.class;
-
+*/
 }
Index: verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel.txt
===================================================================
--- verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel.txt	(revision 0)
+++ verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel.txt	(revision 109)
@@ -0,0 +1,29 @@
+Testsuite: tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel
+Tests run: 16, Failures: 2, Errors: 0, Time elapsed: 10.845 sec
+
+Testcase: testEntitiesNumber took 2.874 sec
+	FAILED
+expected:<25> but was:<33>
+junit.framework.AssertionFailedError: expected:<25> but was:<33>
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel.testEntitiesNumber(Unknown Source)
+
+Testcase: testClassProperties took 0.933 sec
+Testcase: testNamedEntities took 0.883 sec
+Testcase: testInheritance took 0.632 sec
+Testcase: testMethodProperties took 0.802 sec
+Testcase: testFieldType took 0.753 sec
+Testcase: testStubs took 0.425 sec
+	FAILED
+expected:<9> but was:<17>
+junit.framework.AssertionFailedError: expected:<9> but was:<17>
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel.testStubs(Unknown Source)
+
+Testcase: testParameter took 0.41 sec
+Testcase: testImplicitVar took 0.399 sec
+Testcase: testInvocation took 0.393 sec
+Testcase: testAccess took 0.39 sec
+Testcase: testSourceAnchors took 0.395 sec
+Testcase: testModifiers took 0.393 sec
+Testcase: testComment took 0.383 sec
+Testcase: testMetric took 0.375 sec
+Testcase: testAnnotation took 0.376 sec
Index: verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.txt
===================================================================
--- verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.txt	(revision 0)
+++ verveine.extractor.java/testrep/TEST-tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.txt	(revision 109)
@@ -0,0 +1,43 @@
+Testsuite: tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc
+Tests run: 8, Failures: 5, Errors: 0, Time elapsed: 3.495 sec
+------------- Standard Output ---------------
+dico type: Map
+dico type: Map
+dico type: ImplicitVars
+dico type: B
+dico type: Map
+------------- ---------------- ---------------
+
+Testcase: testExceptions took 1.638 sec
+Testcase: testAnnotation took 0.241 sec
+	FAILED
+expected:<1> but was:<0>
+junit.framework.AssertionFailedError: expected:<1> but was:<0>
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.testAnnotation(Unknown Source)
+
+Testcase: testParameterizableClass took 0.305 sec
+	FAILED
+expected:<6> but was:<5>
+junit.framework.AssertionFailedError: expected:<6> but was:<5>
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.testParameterizableClass(Unknown Source)
+
+Testcase: testParameterTypeAsType took 0.282 sec
+Testcase: testMethodParameterArgumentTypes took 0.28 sec
+	FAILED
+
+junit.framework.AssertionFailedError: 
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.testMethodParameterArgumentTypes(Unknown Source)
+
+Testcase: testMethodLocalVariableArgumentTypes took 0.237 sec
+	FAILED
+expected:<1> but was:<0>
+junit.framework.AssertionFailedError: expected:<1> but was:<0>
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.testMethodLocalVariableArgumentTypes(Unknown Source)
+
+Testcase: testMethodReturnArgumentTypes took 0.237 sec
+Testcase: testEnumDecl took 0.239 sec
+	FAILED
+
+junit.framework.AssertionFailedError: 
+	at tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc.testEnumDecl(Unknown Source)
+
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 108)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 109)
@@ -15,7 +15,6 @@
 import java.io.File;
 import java.util.Collection;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -28,6 +27,7 @@
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
@@ -59,7 +59,8 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
-		/*String[] files = new String[] {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+		String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -71,14 +72,18 @@
 				"server/PrintServer.java"
 		};
 
+
 		// separate parsing of each source file --------
 		for (String f : files) {
 			parseFile(f);
-		}*/
+		}
+
 		// or parsing the entire project in one pass ---
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
+		/*VerveineJParser parser = new VerveineJParser();
 		repo = parser.getFamixRepo();
+		parser.setOptions(new String[] {"test_src/LANModel/"});
+		parser.parse();
+		parser.outputMSE();*/
 	}
 
 	/**
@@ -86,40 +91,36 @@
 	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
 	 * @param file -- name of the file to parse
 	 */
-/*	private void parseFile(String file) {
+	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
-				"test_src/LANModel//moose/lan/",
+				"test_src/LANModel/",
 				"test_src/LANModel/moose/lan/"+file
 				};
 		
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(args);
+		parser.parse();
 		
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
 	}
-*/
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
+
 	@Test
 	public void testEntitiesNumber() {
-		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
-		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
-		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
-		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
+		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo, fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
+		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo, PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo, Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo, Attribute.class).size());//10+{System.out}
+		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo, Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo, Parameter.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo, Inheritance.class).size());//6 internal + 24 from imported packages/classes
+		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo, Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo, LocalVariable.class).size());
+		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo, AnnotationType.class).size()); //Override
+		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo, AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
 	}
 
 	@Test
@@ -277,7 +278,7 @@
 		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
 		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
-		assertEquals(8, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Appendable,CharSequence
+		assertEquals(9, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
@@ -340,6 +341,43 @@
 	}
 
 	@Test
+	public void testImplicitVar() {
+		boolean testRan = false;
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("isDestinationFor" )) {
+				testRan = true;
+				assertEquals(1, m.getOutgoingInvocations().size());
+				Invocation invok = m.getOutgoingInvocations().iterator().next();
+				assertEquals(ImplicitVariable.class, invok.getReceiver().getClass());
+				ImplicitVariable iv = (ImplicitVariable) invok.getReceiver();
+				assertEquals("self", iv.getName());
+				assertSame(m, iv.getBelongsTo());
+			}
+		}
+		assertTrue("Test for SELF did not run, cause: SingleDestinationAddress.isDestinationFor() method not found", testRan);
+
+		testRan = false;
+		clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "WorkStation");
+		assertNotNull(clazz);
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name" )) {
+				testRan = true;
+				assertEquals(1, m.getOutgoingInvocations().size());
+				Invocation invok = m.getOutgoingInvocations().iterator().next();
+				assertEquals(ImplicitVariable.class, invok.getReceiver().getClass());
+				ImplicitVariable iv = (ImplicitVariable) invok.getReceiver();
+				assertEquals("super", iv.getName());
+				assertSame(m, iv.getBelongsTo());
+			}
+		}
+		assertTrue("Test for SELF did not run, cause: SingleDestinationAddress.isDestinationFor() method not found", testRan);
+
+	}
+
+
+	@Test
 	public void testInvocation() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(nodeClass);
@@ -413,6 +451,7 @@
 		}
 
 	}
+
 	
 	@Test
 	public void testAccess() {
@@ -452,6 +491,7 @@
 		}
 	}
 
+
 	@Test
 	public void testSourceAnchors() {
 		SourceAnchor anc = null;
@@ -463,7 +503,7 @@
 		assertNotNull(anc);
 		assertSame(clazz, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/server/PrintServer.java"));
+		assertEquals("test_src/LANModel/moose/lan/server/PrintServer.java", ((FileAnchor)anc).getFileName());
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
 		assertEquals(31, ((FileAnchor)anc).getEndLine());
 
@@ -502,6 +542,7 @@
 		
 	}
 
+
 	@Test
 	public void testModifiers() {
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
@@ -536,6 +577,7 @@
 		assertFalse(a.getIsFinal());
 	}
 
+
 	@Test
 	public void testComment() {	
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
@@ -555,6 +597,7 @@
 		assertEquals(34, ((FileAnchor)anc).getEndLine());
 
 	}
+
 	
 	@Test
 	public void testMetric() {
@@ -576,6 +619,7 @@
 			}
 		}		
 	}
+
 	
 	@Test
 	public void testAnnotation() {
@@ -602,6 +646,7 @@
 		}
 		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
 		assertNotNull(clazz);
+		assertEquals(5, clazz.getMethods().size());
 		for (Method method : clazz.getMethods()) {
 			annInstances = method.getAnnotationInstances();
 			if (method.getName().equals("isDestinationFor")) {
@@ -615,4 +660,5 @@
 			}
 		}	
 	}
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 108)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 109)
@@ -10,9 +10,9 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.File;
+import java.io.FileWriter;
 import java.util.Collection;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -46,32 +46,24 @@
 
 	private Repository repo;
 
-	public VerveineJTest_AdHoc() {
-		// make sure we don't have any pre-existing mse lying in the way
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
-
 	/**
 	 * @throws java.lang.Exception
 	 */
 	@Before
 	public void setUp() throws Exception {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/ad_hoc"});
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(new String[] {"test_src/ad_hoc"});
+		parser.parse();
+		repo.exportMSE(new FileWriter(VerveineJParser.OUTPUT_FILE));
 	}
 
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
 	@Test
 	public void testExceptions() {
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
 		assertNotNull(meth);
-		
+
 		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
 		assertNotNull(excepClass);
 
@@ -79,7 +71,7 @@
 		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
 		assertSame(meth, exD.getDefiningMethod());
 		assertSame(excepClass, exD.getExceptionClass());
-		
+
 		assertEquals(1, meth.getThrownExceptions().size());
 		ThrownException exT = meth.getThrownExceptions().iterator().next();
 		assertSame(meth, exT.getDefiningMethod());
@@ -169,19 +161,27 @@
 	}
 
 	@Test
-	public void testClassParameterTypes() {
-		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
-		assertNotNull(dicoClass);
-		assertEquals("Dictionary", dicoClass.getName());
-		assertEquals(2, dicoClass.getTypes().size());
-		assertEquals(1, dicoClass.getParameters().size());
+	public void testParameterizableClass() {
+		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dico);
+		for (Type t : dico.getTypes()) {
+			System.out.println("dico type: "+t.getName());
+		}
+		assertEquals("Dictionary", dico.getName());
+		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
+		assertEquals(1, dico.getParameters().size());
 		
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
 		assertNotNull(dicoParam);
 		assertEquals("B", dicoParam.getName());
 		
-		assertSame(dicoClass, dicoParam.getContainer());
-		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
+		assertSame(dico, dicoParam.getContainer());
+		assertSame(dicoParam, dico.getParameters().iterator().next());
+
+		/* Collection<Object> is not seen as parameterizable by JDT 		 */
+		 ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
+		 assertNotNull(collec);
+
 	}
 
 	@Test
@@ -206,17 +206,6 @@
 	}
 	
 	@Test
-	public void testFieldArgumentTypes() {
-		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
-		assertNotNull(famixAtt);
-		assertEquals("mapBind", famixAtt.getName());
-		//assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		//Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
-		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
-		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
-	}
-	
-	@Test
 	public void testMethodParameterArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
 		assertNotNull(fmxMethod);
@@ -321,8 +310,7 @@
 			}
 		}
 	}
-	
-	
+
 	@Test
 	public void testMethodReturnArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 108)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 109)
@@ -73,15 +73,24 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
+//		System.err.println("TRACE, RefVisiting CompilationUnit");
+
 		PackageDeclaration pckg = node.getPackage();
+		Namespace fmx = null;
 		if (pckg==null) {
-			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
+			 fmx = dico.ensureFamixNamespaceDefault();
 		}
 		else {
-			this.context.pushPckg( (Namespace)dico.getEntityByKey(pckg.resolveBinding()) );
+			fmx = (Namespace)dico.getEntityByKey(pckg.resolveBinding());
 		}
-		return super.visit(node);
-
+		if (pckg != null) {
+			this.context.pushPckg(fmx);
+			return super.visit(node);
+		}
+		else {
+			this.context.pushPckg(null);
+			return false;
+		}
 	}
 
 	public void endVisit(CompilationUnit node) {
@@ -114,19 +123,26 @@
 			importName = dico.removeLastName(importName);
 		}
 		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.createFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
 
 	public boolean visit(TypeDeclaration node) {
+//		System.err.println("TRACE, RefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
-		this.context.pushClass(fmx );
+		if (fmx != null) {
+			this.context.pushClass(fmx );
 
-		dico.addFamixAnnotationInstances(bnd, fmx);
+			dico.addFamixAnnotationInstances(bnd, fmx);
 
-		return super.visit(node);
+			return super.visit(node);
+		}
+		else {
+			this.context.pushClass(null);
+			return false;
+		}
 	}
 
 	public void endVisit(TypeDeclaration node) {
@@ -135,15 +151,24 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
+//		System.err.println("TRACE, RefVisiting ClassInstanceCreation");
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
 			ITypeBinding bnd = decl.resolveBinding();
 			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
-			this.context.pushClass(fmx);
-
-			dico.addFamixAnnotationInstances(bnd, fmx);
+			if (fmx != null) {
+				this.context.pushClass(fmx);
+				dico.addFamixAnnotationInstances(bnd, fmx);
+				return super.visit(node);
+			}
+			else {
+				this.context.pushClass(null );
+				return false;
+			}
 		}
-		return super.visit(node);
+		else {// TODO appears to be a new: class reference
+			return super.visit(node);
+		}
 	}
 
 	public void endVisit(AnonymousClassDeclaration node) {
@@ -153,6 +178,8 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
+//		System.err.println("TRACE, RefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+
 		IMethodBinding bnd = node.resolveBinding();
 		Method meth = (Method) dico.getEntityByKey(bnd);
 
@@ -165,12 +192,16 @@
 			for (Name excepName : (List<Name>)node.thrownExceptions()) {
 				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
 				if (excepFmx != null) {
-					dico.createFamixDeclaredException(meth, excepFmx);
+					dico.ensureFamixDeclaredException(meth, excepFmx);
 				}
 			}
+			return super.visit(node);
+		}
+		else {
+			this.context.pushMethod(null);
+			return false;
 		}
 
-		return super.visit(node);
 	}
 
 	public void endVisit(MethodDeclaration node) {
@@ -180,7 +211,7 @@
 
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
-//		System.err.println("TRACE, RefVisiting FieldDeclaration");
+//		System.err.println("TRACE, RefVisiting FieldDeclaration: ");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
 			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
@@ -199,7 +230,7 @@
 
 	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(dico.SUPER_NAME, this.context.topClass(), context.top()));
 		return super.visit(node);
 	}
 
@@ -212,19 +243,8 @@
 	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			/* TODO old code, may not be valid anymore ...
-			   if (invoked == null) {
-				if (receiver != null && receiver.getName().equals("self")) {
-					receiver = this.context.topClass();
-				}
-				invoked = this.dico.ensureFamixMethod(calledName, receiver, list);
-				//invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			if (invoked == null) {
-				invoked = this.dico.ensureFamixStubMethod(calledName);
-			}*/
-			context.setLastInvocation( dico.createFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/null);  // cast needed to desambiguate the call
+			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
@@ -258,7 +278,7 @@
 				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
-				dico.createFamixCaughtException(meth, excepFmx);
+				dico.ensureFamixCaughtException(meth, excepFmx);
 			}
 		}
 
@@ -270,7 +290,7 @@
 		Method meth = this.context.topMethod();
 		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
-			dico.createFamixThrownException(meth, excepFmx);
+			dico.ensureFamixThrownException(meth, excepFmx);
 		}
 		return super.visit(node);
 	}
@@ -285,7 +305,7 @@
 	private NamedEntity getReceiver(Expression expr) {
 		// msg(), same as ThisExpression
 		if (expr == null) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
 		}
 
 		// array[i].msg()
@@ -359,12 +379,12 @@
 			if (bnd instanceof ITypeBinding) {
 				// msg() is a static method of Name
 				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null), bnd.getName());
+				ret = dico.ensureFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
 			}
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
+					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);//TODO should be ensureAttribute
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
 					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -406,13 +426,13 @@
 		
 		// this.msg()
 		else if (expr instanceof ThisExpression) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
 		}
 
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
 			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null);
+			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null,  context.top());
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
@@ -432,7 +452,7 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
-				context.setLastAccess( dico.createFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 108)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 109)
@@ -23,10 +23,12 @@
 import org.eclipse.jdt.core.dom.ForStatement;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -38,6 +40,8 @@
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeParameter;
+import org.eclipse.jdt.core.dom.VariableDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -47,11 +51,16 @@
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -77,7 +86,7 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
-//		System.err.println("TRACE, DefVisiting CompilationUnit");
+//		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
 		Namespace fmx = null;
 		PackageDeclaration pckg = node.getPackage();
 		if (pckg==null) {
@@ -87,9 +96,14 @@
 			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
 			fmx.setIsStub(false);
 		}
-		this.context.pushPckg(fmx);
-		return super.visit(node);
 
+		if (pckg != null) {
+			return super.visit(node);
+		}
+		else {
+			this.context.pushPckg(null);
+			return false;
+		}
 	}
 
 	public void endVisit(CompilationUnit node) {
@@ -98,21 +112,34 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		// Can only be a class or interface declaration
+
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
+		@SuppressWarnings("unchecked")
+		List<TypeParameter> tparams = node.typeParameters();
+		fr.inria.verveine.core.gen.famix.Class fmx = (Class) dico.ensureFamixType(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), /*ctxt*/context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 
 			this.context.pushClass(fmx);
 
 			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+			dico.ensureFamixComment(node.getJavadoc(), fmx);
+			
+			for (TypeParameter tp : tparams) {
+				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
+				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note: owner of the ParameterType is the ParameterizableClass
+				if (fmxParam != null) {
+					fmxParam.setIsStub(false);
+				}
+			}
+			return super.visit(node);
 		}
-
-		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
-		
-		return super.visit(node);
+		else {
+			this.context.pushClass(null);
+			return false;
+		}
 	}
 
 	public void endVisit(TypeDeclaration node) {
@@ -121,56 +148,68 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-		//System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
 		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
+			fmx = (Class) this.dico.ensureFamixType(decl.resolveBinding(), /*name*/"anonymous("+dico.findTypeName(node.getType())+")", /*owner*/context.top(), /*ctxt*/context.top());  //  isGeneric = false
 			if (fmx != null) {
 				fmx.setIsStub(false);
-			}
 
-			dico.addSourceAnchor(fmx, node);
+				dico.addSourceAnchor(fmx, node);
+				this.context.pushClass(fmx);
+				return super.visit(node);
+			}
+			else {
+				this.context.pushClass(null);
+				return false;
+			}
 		}
-		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
 	public void endVisit(ClassInstanceCreation node) {
-		this.context.popClass();
+		if (node.getAnonymousClassDeclaration() != null) {
+			this.context.popClass();
+		}
 		super.endVisit(node);
 	}
 
 	public boolean visit(AnnotationTypeDeclaration node) {
-		//System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(Boolean.FALSE);
 			
 			context.pushAnnotationType(fmx);
+			return super.visit(node);
 		}
-
-		return super.visit(node);
+		else {
+			context.pushAnnotationType(null);
+			return false;
+		}
 	}
 
-
 	public void endVisit(AnnotationTypeDeclaration node) {
 		this.context.popAnnotationType();
 		super.endVisit(node);
 	}
 
 	public boolean visit(AnnotationTypeMemberDeclaration node) {
-		//System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
 		IMethodBinding bnd = node.resolveBinding();
 		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
 			context.pushAnnotationMember(fmx);
+			return super.visit(node);
 		}
-
-		return super.visit(node);
+		else {
+			context.pushAnnotationMember(null);
+			return false;
+		}
 	}
 
 	public void endVisit(AnnotationTypeMemberDeclaration node) {
@@ -189,8 +228,11 @@
 				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
 				ev.setIsStub(Boolean.FALSE);
 			}
+			return super.visit(node);
 		}
-		return super.visit(node);
+		else {
+			return false;
+		}
 	}
 
 	@SuppressWarnings("unchecked")
@@ -204,13 +246,20 @@
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				paramTypes.add(param.getType());
 		}
+
+		fr.inria.verveine.core.gen.famix.Type fmxTyp;
+		if (retTyp == null) {
+			fmxTyp = null;
+		}
+		else {
+			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
+		}
+
 		// creating/recovering it
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes,
-											(retTyp == null) ? null : dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-											context.topClass());
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, fmxTyp, context.topClass());
 		
-		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
-			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+		if (retTyp != null && retTyp.isParameterizedType()) {
+			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)retTyp).typeArguments()));
 		}
 		
 		if (fmx != null) {
@@ -222,82 +271,130 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+			dico.ensureFamixComment(node.getJavadoc(), fmx);
 
 			// creating the method's parameters
+			List<VariableDeclaration> paramAsVarList;
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				fr.inria.verveine.core.gen.famix.Type paramTyp = dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null);
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), param.getName().getIdentifier(), paramTyp, fmx);
-				if (fmxParam != null) {
-					fmxParam.setIsStub(false);
-				}
-				if (param.getType().isParameterizedType()) {
-					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
-				}
+				// Note: method and ParamTyp bindings are null for ParameterType :-(
+				paramAsVarList = new ArrayList<VariableDeclaration>(1);
+				paramAsVarList.add(param);
+				visitVariablesDeclarations(node, param.getType(), paramAsVarList, context.topMethod());
 			}
+			return super.visit(node);
 		}
-		return super.visit(node);	
+		else {
+			this.context.pushMethod(null);
+			return false;
+		}
 	}
 
 	public void endVisit(MethodDeclaration node) {
-		int cyclo = context.getTopMethodCyclo();
-		int nos = context.getTopMethodNOS();
+		int cyclo = 0;
+		int nos = 0;
+		if (context.topMethod() != null) {
+			cyclo = context.getTopMethodCyclo();
+			nos = context.getTopMethodNOS();
+		}
 		Method fmx = this.context.popMethod();
-		fmx.setNOS(nos);
-		fmx.setCyclo(cyclo);
+		if (fmx != null) {
+			fmx.setNOS(nos);
+			fmx.setCyclo(cyclo);
+		}
 		super.endVisit(node);
 	}
-	
+
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
-		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
-
-			if (fmx != null) {
-				fmx.setIsStub(false);
-			}
-			if (node.getType().isParameterizedType()) {
-				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
-			}
 
-			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+		for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
+			dico.addSourceAnchor(att, node);
+			dico.ensureFamixComment(node.getJavadoc(), att);
 		}
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
-		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
-		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
 		return super.visit(node);
 	}
 
-	private void visitVariablesDeclarations(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
-		// we don't declare (local) variables that have a primitive type
-		// because we are assuming here that the user is not interested in them 
-		if (nodeTyp.isPrimitiveType()) {
-			return;
+	@SuppressWarnings("unchecked")
+	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
+		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
+
+		fr.inria.verveine.core.gen.famix.Type fmxTyp;
+		if (varTyp.isParameterizedType()) {
+			ITypeBinding parameterizedBnd = varTyp.resolveBinding();
+			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
+			String tname = dico.findTypeName(varTyp);
+			ParameterizableClass tmpGeneric = null;
+			tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
+
+			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, tmpGeneric, /*owner*/ctxt);
+			for (Type targ : (List<Type>) ((ParameterizedType)varTyp).typeArguments()) {
+				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), null, ctxt);
+				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
+			}
+		}
+		else {
+			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
 		}
+		for (VariableDeclaration vd : fragments) {
+			StructuralEntity fmx;
+			if (node instanceof MethodDeclaration) {
+				// creating the parameters of a method. In this case, 'fragment' is aList<SingleVariableDeclarationFragment> and 'varType' is null
+				fmx = dico.ensureFamixParameter(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method)ctxt);
+			}
+			else if (node instanceof FieldDeclaration) {
+				// creating a class' field
+				fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+			}
+			else {
+				fmx = null;
+			}
 
-		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), dico.ensureFamixType(null, nodeTyp.toString(), null), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
-				dico.addSourceAnchor(fmx, node);
-			}
-			if (nodeTyp.isParameterizedType()) {
-				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+				ret.add(fmx);
 			}
 		}
+
+		return ret;
 	}
 
 	// METRICS: CYCLO, NOS
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 108)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 109)
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedList;
-import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ArrayType;
@@ -18,7 +17,6 @@
 import org.eclipse.jdt.core.dom.Modifier;
 import org.eclipse.jdt.core.dom.QualifiedType;
 import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.TypeParameter;
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
@@ -38,6 +36,9 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
@@ -90,7 +91,7 @@
 			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
 			 * all is said and done. */
 			fmx = super.ensureFamixNamespace( bnd, name);
-			parent = this.ensureFamixNamespace(null, removeLastName(name));
+			parent = ensureFamixNamespace(null, removeLastName(name));
 			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
 				parent.addChildScopes(fmx);
@@ -100,39 +101,40 @@
 		return fmx;
 	}
 
-	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
-		Collection<Type> fmxTypes = new ArrayList<Type>();
-		
-		Type fmxType = null;
-		for (org.eclipse.jdt.core.dom.Type type : types) {
-			ITypeBinding bnd = type.resolveBinding();
-			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, findTypeName(type), null);
-			} else {
-				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
-			}
-			fmxTypes.add(fmxType);
-		}
-		return fmxTypes;
-	}
-
 	/**
 	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
 	 */
-	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner, ContainerEntity ctxt) {
+		Type fmx = null;
 
 		if (bnd == null) {
-			return super.ensureFamixType(null, name, owner);
+			if (name == null) {
+				return null;
+			}
+			fmx = searchTypeInContext(name, ctxt);
+			if (fmx != null) {
+				return fmx;
+			}
+
+			if ( (owner != null) && (owner instanceof ParameterizableClass) ) {
+				return ensureFamixParameterType(null, name, (ParameterizableClass) owner);
+			}
+			else {
+				return super.ensureFamixType(null, name, owner);
+			}
+		}
+
+		// bnd != null
+
+		fmx = (Type) getEntityByKey(bnd);
+		if (fmx != null) {
+			return fmx;
 		}
 
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
 
-		if (bnd.isClass() || bnd.isInterface()) {
-			return this.ensureFamixClass(bnd, name, owner);
-		}
-		
 		if (bnd.isPrimitive()) {
 			return ensureFamixPrimitiveType(bnd, name);
 		}
@@ -141,25 +143,236 @@
 			return ensureFamixEnum(bnd, name, owner);
 		}
 		
+		if (bnd.isTypeVariable() ) {
+			return ensureFamixParameterType(bnd, name, (ParameterizableClass) owner);
+		}
+
+		if (bnd.isRawType() || bnd.isGenericType()) {
+			return ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+		}
+
+		if (bnd.isParameterizedType()) {
+			return ensureFamixParameterizedType(bnd, name, /*generic*/null, owner);
+		}
+
+		// it seems wise to test isClass after isGenericType, isParameterizedType, ... ? 
+		if (bnd.isClass() || bnd.isInterface()) {
+			return ensureFamixClass(bnd, name, owner, /*isGeneric*/false);
+		}
+
+
 		return super.ensureFamixType(bnd, name, owner);
 	}
-	
-	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
-		Collection<Type> fmxTypes = new ArrayList<Type>();
-		Type fmxType = null;
+
+	/**
+	 * Returns a Famix Class associated with the ITypeBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner, boolean isGeneric) {
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixNamespaceDefault();
+			}
+			
+			if (isGeneric) {
+				return super.ensureFamixParameterizableClass(null, name, owner);
+			}
+			else {
+				return super.ensureFamixClass(null, name, owner);
+			}
+		}
+
+		// --------------- some special cases
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+
+		if (bnd.isPrimitive()) {
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
+			return null;
+		}
+
+		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
+		// --------------- name
+		if (name == null) {
+			if (! bnd.isAnonymous()) {
+				name = bnd.getErasure().getName();  // for generics, will give the "core" type name, for naormal type, won't change anything
+			}
+			else { // anonymous class
+				if (bnd.getSuperclass() != null) {
+					name = bnd.getSuperclass().getName();
+				}
+				if ( (name == null) || name.equals(OBJECT_NAME)) {
+					ITypeBinding[] intfcs = bnd.getInterfaces();
+					if ( (intfcs != null) && (intfcs.length > 0) ) {
+						name = bnd.getInterfaces()[0].getName();
+					}
+					else {
+						name = "???";
+					}
+				}
+				name = "anonymous(" + name + ")";
+			}
+		}
+
+		if (name.equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+					if (tmpOwn instanceof ParameterizedType) {
+						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+					}
+					else {
+						owner = tmpOwn;
+					}
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- superclasses (including interfaces)
+		Collection<Type> sups = new LinkedList<Type>();
+		if (! bnd.isInterface()) {
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd != null) {
+				sups.add(ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
+			}
+			else {
+				sups.add( ensureFamixClassObject(null));
+			}
+		}
+		for (ITypeBinding intbnd : bnd.getInterfaces()) {
+			sups.add( ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/owner));
+		}
+
+		// --------------- recover from name ?
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			if (isGeneric) {
+				fmx = super.ensureFamixParameterizableClass(bnd, name, owner);
+			}
+			else {
+				fmx = super.ensureFamixClass(bnd, name, owner);
+			}
+		}
 		
-		for (TypeParameter type : types) {
-			ITypeBinding bnd = type.resolveBinding();
-			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, null, null);
-			} else {
-				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setIsInterface(bnd.isInterface());
+			Inheritance lastInheritance = null;
+			for (Type sup : sups) {
+				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
-			fmxTypes.add(fmxType);
+			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
+			if (fmx.getIsAbstract()) {
+				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
+				fmx.addModifiers("abstract");
+			}
 		}
-		return fmxTypes;
-	}
 	
+		return fmx;
+	}
+
+	public ParameterizedType ensureFamixParameterizedType(ITypeBinding bnd, String name, ParameterizableClass generic, ContainerEntity owner) {
+		ParameterizedType fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixParameterizedType(null, name, generic, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+					if (tmpOwn instanceof ParameterizedType) {
+						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+					}
+					else {
+						owner = tmpOwn;
+					}
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- generic
+		if (generic == null) {
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+		}
+
+		// --------------- recover from name ?
+		for (ParameterizedType candidate : getEntityByName(ParameterizedType.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixParameterizedType(bnd, name, generic, owner);
+		}
+
+		return fmx;
+	}
+
 	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
 		if (name == null) {
 			if (bnd == null) {
@@ -365,6 +578,11 @@
 		return fmx;
 	}
 
+	/**
+	 * Adds possible annotation instances to a Famix NamedEntity with the given binding
+	 * @param bnd
+	 * @param fmx
+	 */
 	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
 		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
 			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
@@ -378,14 +596,8 @@
 		}
 	}
 
-	/**
-	 * Returns a Famix Class associated with the ITypeBinding.
-	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner) {
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
+	public ParameterType ensureFamixParameterType(ITypeBinding bnd,	String name, ParameterizableClass owner) {
+		ParameterType fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
@@ -393,115 +605,41 @@
 				return null;
 			}
 			if (owner == null) {
-				owner = ensureFamixNamespaceDefault();
+				return super.ensureFamixParameterType(null, name, null);
 			}
-			return super.ensureFamixClass(null, name, owner);
-		}
-
-		// --------------- some special cases
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
-		}
-
-		if (bnd.isPrimitive()) {
-			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
-			return null;
+			
+			return super.ensureFamixParameterType(null, name, owner);
 		}
 
-		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		fmx = (ParameterType)getEntityByKey(bnd);	// to avoid useless computations if we can
 		if (fmx != null) {
 			return fmx;
 		}
 
 		// --------------- name
 		if (name == null) {
-			if (! bnd.isAnonymous()) {
-				name = bnd.getName();
-			}
-			else { // anonymous class
-				if (bnd.getSuperclass() != null) {
-					name = bnd.getSuperclass().getName();
-				}
-				if ( (name == null) || name.equals(OBJECT_NAME)) {
-					ITypeBinding[] intfcs = bnd.getInterfaces();
-					if ( (intfcs != null) && (intfcs.length > 0) ) {
-						name = bnd.getInterfaces()[0].getName();
-					}
-					else {
-						name = "???";
-					}
-				}
-				name = "anonymous(" + name + ")";
-			}
-		}
-		
-		if (name.equals(OBJECT_NAME)) {
-			return ensureFamixClassObject(bnd);
+			name = bnd.getName();
 		}
 
 		// --------------- owner
 		if (owner == null) {
-			IMethodBinding parentMtd = bnd.getDeclaringMethod();
-			if (parentMtd != null) {
-				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			}
-			else {
-				ITypeBinding parentClass = bnd.getDeclaringClass();
-				if (parentClass != null) {
-					owner = this.ensureFamixClass(parentClass, null, null);
-				}
-				else {
-					IPackageBinding parentPckg = bnd.getPackage();
-					if (parentPckg != null) {
-						owner = this.ensureFamixNamespace(parentPckg, null);
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
-				}
-			}
-		}
-
-		// --------------- superclasses (including interfaces)
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
-		if (! bnd.isInterface()) {
-			ITypeBinding supbnd = bnd.getSuperclass();
-			if (supbnd != null) {
-				sups.add(this.ensureFamixClass(supbnd, null, null));
-			}
-			else {
-				sups.add( ensureFamixClassObject(null));
+			ITypeBinding parentClass = bnd.getDeclaringClass();
+			if (parentClass != null) {
+				owner = (ParameterizableClass) this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);  // isGeneric=true
 			}
 		}
-		for (ITypeBinding intbnd : bnd.getInterfaces()) {
-			sups.add( ensureFamixClass(intbnd, null, null));
-		}
 
 		// --------------- recover from name ?
 		for (Type candidate : this.getEntityByName(Type.class, name)) {
-			if ( checkAndMapClass(bnd, candidate) ) {
-				fmx = (Class) candidate;
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = (ParameterType) candidate;
 				break;
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixClass(bnd, name, owner);
-		}
-		
-		if (fmx!=null) {
-			// we just created it or it was not bound, so we make sure it has the right information in it
-			fmx.setIsInterface(bnd.isInterface());
-			Inheritance lastInheritance = null;
-			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
-			}
-			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
-			if (fmx.getIsAbstract()) {
-				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
-				fmx.addModifiers("abstract");
-			}
+			fmx = super.ensureFamixParameterType(bnd, name, owner);
 		}
-	
+
 		return fmx;
 	}
 
@@ -561,10 +699,6 @@
 			return false;
 		}
 		
-		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
-			return checkAndMapClass(bnd, (Type) candidate);
-		}
-
 		if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
 			// names are equal so it's OK
 			mapToKey.put(bnd, candidate);
@@ -580,7 +714,12 @@
 				return false;
 			}
 		}
-		
+
+		// Annotation are interfaces too, so we should check this one after isAnnotation
+		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
+			return checkAndMapClass(bnd, (Type) candidate);
+		}
+
 		return false;
 	}
 
@@ -689,15 +828,25 @@
 					sig += parBnd.getName();
 					first = false;
 				}
-				sig += ")";
 			}
+			sig += ")";
 			if (! ((Method) candidate).getSignature().equals(sig)) {
 				return false;
 			}
 
 			// ... and the signature should include the return type
-			if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
-				return false;
+			if (bnd.isConstructor()) {
+				if ( ((Method) candidate).getDeclaredType() != null) {
+					return false;
+				}
+			}
+			else {
+				if ( ((Method) candidate).getDeclaredType() == null) {
+					return false;
+				}
+				if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
+					return false;
+				}
 			}
 		}
 
@@ -742,7 +891,7 @@
 
 		ContainerEntity candidateOwner = candidate.getBelongsTo();
 		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidateOwner  instanceof Method) ) {
+		if ( (methBnd != null) && (candidateOwner instanceof Method) ) {
 			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
@@ -835,13 +984,22 @@
 
 		// --------------- return type
 		if ( (ret == null) && (! bnd.isConstructor()) ) {
-			ret = this.ensureFamixType(bnd.getReturnType(), null, null);
+			ret = this.ensureFamixType(bnd.getReturnType(), null, null, owner);
 		}
 		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
-			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if (classBnd != null) {
+				Type tmpOwn = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);
+				if (tmpOwn instanceof ParameterizedType) {
+					owner = ((ParameterizedType) tmpOwn).getParameterizableClass();
+				}
+				else {
+					owner = (Class)tmpOwn; 
+				}
+			}
 		}
 		
 		// --------------- recover from name ?
@@ -866,6 +1024,10 @@
 	}
 	
 	public String findTypeName(org.eclipse.jdt.core.dom.Type t) {
+		if (t == null) {
+			return null;
+		}
+		
 		if (t.isPrimitiveType()) {
 			return t.toString();
 		}
@@ -879,10 +1041,15 @@
 			return findTypeName( ((ArrayType)t).getElementType() );
 		}
 		else if (t.isParameterizedType()) {
-			return "?";  // TODO
+			return findTypeName(((org.eclipse.jdt.core.dom.ParameterizedType)t).getType());
 		}
 		else { // it is a WildCardType
-			return "?"; // TODO
+			if ( ((org.eclipse.jdt.core.dom.WildcardType)t).isUpperBound() ) {
+				return findTypeName( ((org.eclipse.jdt.core.dom.WildcardType)t).getBound() );
+			}
+			else {
+				return OBJECT_NAME;
+			}
 		}
 	}
 
@@ -913,12 +1080,21 @@
 
 		// --------------- return type
 		if (type == null) {
-			type = this.ensureFamixType(bnd.getType(), null, null);
+			type = this.ensureFamixType(bnd.getType(), null, null, owner);
 		}
 
 		// --------------- owner
 		if (owner == null) {
-			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if (classBnd != null) {
+				Type tmpOwn = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);
+				if (tmpOwn instanceof ParameterizedType) {
+					owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+				}
+				else {
+					owner = tmpOwn;
+				}
+			}
 		}
 		
 		// --------------- recover from name ?
@@ -975,7 +1151,7 @@
 			if (owner == null) {
 				owner = ensureFamixStubMethod("<"+name+"_owner>");
 			}
-			return super.ensureFamixParameter(null, name, typ, owner);
+			return super.createFamixParameter(null, name, typ, owner);
 		}
 
 		// --------------- name
@@ -985,7 +1161,7 @@
 
 		// --------------- return type
 		if (typ == null) {
-			typ = this.ensureFamixType(bnd.getType(), null, null);
+			typ = this.ensureFamixType(bnd.getType(), null, null, owner.getParentType());  // context of the parameter def = the class definition
 		}
 
 		// --------------- owner
@@ -1001,7 +1177,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixParameter(bnd, name, typ, owner);
+			fmx = super.createFamixParameter(bnd, name, typ, owner);
 		}
 		
 		if (fmx != null) {
@@ -1039,7 +1215,7 @@
 
 		// --------------- return type
 		if (typ == null) {
-			typ = this.ensureFamixType(bnd.getType(), null, null);
+			typ = this.ensureFamixType(bnd.getType(), null, null, owner);
 		}
 
 		// --------------- owner
@@ -1068,18 +1244,18 @@
 	}
 	
 	/**
-	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * Returns a Famix UnknownVariable. The Entity is created if it does not exist.
 	 */
-	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
-//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
-		UnknownVariable fmx = (UnknownVariable) createFamixNamedEntity(UnknownVariable.class, name);
+	public UnknownVariable ensureFamixUnknownVariable(Type type, String name) {
+//		System.err.println("TRACE -- ensureFamixUnknownVariable: "+name);
+		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
 		}
 		return fmx;
 	}
 
-	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+	public Comment ensureFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
 		Comment cmt = null;
 		if (jdoc != null) {
 			cmt = createFamixComment(jdoc.toString(), fmx);
@@ -1218,6 +1394,4 @@
 		return ret;
 	}
 
-
-
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 108)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 109)
@@ -1,9 +1,13 @@
 package fr.inria.verveine.extractor.java;
 
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTParser;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 import fr.inria.verveine.core.VerveineParser;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -20,35 +24,83 @@
 	 * The arguments that were passed to the parser
 	 * Needed to relativize the source file names
 	 */
-	private String[] initialArgs;
+	private Collection<String> sourceFiles;
 	
-	public static void main(String[] args) {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		parser.outputMSE();
+	private ASTParser jdtParser = null;
+	
+	public VerveineJParser() {
+		super();
+
+		jdtParser = ASTParser.newParser(AST.JLS3);
+	}
+	
+	public void setOptions(String[] args) {
+		// we assume java 1.5 code for now, this should be configurable
+		@SuppressWarnings("unchecked")
+		Map<String,String> options = JavaCore.getOptions();
+		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
+		jdtParser.setCompilerOptions(options);
+
+		Collection<String> classPath = new ArrayList<String>();
+		Collection<String> sourcePath = new ArrayList<String>();
+		sourceFiles = new ArrayList<String>();
+		for (int i=0; i < args.length; i++) {
+			String current = args[i];
+			if (current.equals("-cp")) {
+				classPath.add(args[++i]);
+			}
+			else if (current.endsWith(".java")) {
+				sourceFiles.add(current);
+			}
+			else {
+				sourcePath.add(current);
+			}
+		}
+		
+		jdtParser.setEnvironment(classPath.toArray(new String[0]), sourcePath.toArray(new String[0]), null, true);
+		jdtParser.setResolveBindings(true);
+		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
+		
+		collectJavaFiles(sourcePath, sourceFiles);
+	}
+
+	private void collectJavaFiles(Collection<String> paths, Collection<String> files) {
+		for (String p : paths) {
+			collectJavaFiles(new File(p), files);
+		}
 	}
 
-	private void setInitialArgs(String[] args) {
-		this.initialArgs = args;
+	private void collectJavaFiles(File f, Collection<String> files) {
+		if (f.isFile() && f.getName().endsWith(".java")) {
+			files.add(f.getAbsolutePath());
+		}
+		else if (f.isDirectory()){
+			for (File child : f.listFiles()) {
+				collectJavaFiles(child, files);
+			}
+		}
+		// else ignore it?
+		
 	}
 
-	public String[] getInitialArgs() {
-		return this.initialArgs;
+	public static void main(String[] args) {
+		VerveineJParser parser = new VerveineJParser();
+		parser.setOptions(args);
+		parser.parse();
+		parser.outputMSE();
 	}
 
-	@Override
-	public boolean compile(String[] argv) {
-		boolean ret;
-		/*if (this.linkToExisting()) {
+	public void parse() {
+		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
-		}*/
+		}
 
-		setInitialArgs(argv);
-		ret = super.compile(argv);
+		FamixRequestor req = new FamixRequestor(getFamixRepo(), new String[0]);
+		jdtParser.createASTs(sourceFiles.toArray(new String[0]), null, new String[0], req, null);
 		
 		this.compressNamespacesNames();
-		
-		return ret;
 	}
 
 	/**
@@ -90,41 +142,5 @@
 			}
 		}
 	}
-
-	/*
-	 *  Low-level API performing the actual parsing
-	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
-	 *  SHOULD NOT USE an internal JDT class. But I don't know how to do it otherwise
-	 */
-	public void performCompilation() {
-
-		this.compilerOptions = new CompilerOptions(this.options);
-		this.compilerOptions.performMethodsFullRecovery = false;
-		this.compilerOptions.performStatementsRecovery = false;
-
-		// NA --- beginning of parsing code --------------------------------------------------
-		String[] tmpclasspath=null;
-		if (this.checkedClasspaths!=null) {
-			tmpclasspath = new String[this.checkedClasspaths.length];
-			int i = 0;
-			for (Classpath cp : this.checkedClasspaths) {
-				tmpclasspath[i++] = cp.getPath();
-			}
-		}
-
-		ASTParser pars = ASTParser.newParser(AST.JLS3);
-		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
-				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
-				/*encodings*/null, 
-				/*includeRunningVMBootclasspath*/true);
-		pars.setResolveBindings(true);
-		pars.setKind(ASTParser.K_COMPILATION_UNIT);
-		pars.createASTs(/*sourceFilePaths*/this.filenames, 
-				/*encodings*/this.encodings, 
-				/*bindingKeys*/new String[0], 
-				/*requestor*/new FamixRequestor(getFamixRepo(), getInitialArgs()), 
-				/*monitor*/null);
-		// NA --- end of parsing code --------------------------------------------------
-	}
 	
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 108)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 109)
@@ -21,9 +21,9 @@
 	}
 
 	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
+//		System.out.println("  ******* TRACE, Requestor is visiting : "+sourceFilePath+" *******");
 		
 		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
-		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
 		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
Index: verveine.extractor.java/build.xml
===================================================================
--- verveine.extractor.java/build.xml	(revision 0)
+++ verveine.extractor.java/build.xml	(revision 109)
@@ -0,0 +1,83 @@
+<?xml version="1.0"?>
+<project name="verveine.extractor.java" default="jar" basedir=".">
+	<!-- Sets variables which can later be used. -->
+	<!-- The value of a property is accessed via ${} -->
+	<property name="src.dir"      location="src" />
+	<property name="build.dir"    location="bin" />
+	<property name="docs.dir"     location="docs" />
+	<property name="dist.dir"     location="lib" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.extractor,java.jar" />
+
+	<!-- Variables used for JUnit testin -->
+	<property name="test.dir" location="src/tests/fr/inria/verveine/extractor/java/" />
+	<property name="test.report.dir" location="testrep" />
+
+
+	<!-- Create a classpath container which can be later used in the ant task -->
+	<path id="build.classpath">
+		<fileset dir="${dist.dir}">
+			<include name="*.jar" />
+		</fileset>
+	</path>
+
+
+	<!-- Deletes the existing build, docs and dist directory-->
+	<target name="clean">
+		<delete dir="${build.dir}" />
+		<delete dir="${docs.dir}" />
+		<delete file="${verveine.jar}" />
+	</target>
+
+	<!-- Creates the  build, docs and dist directory-->
+	<target name="makedir">
+		<mkdir dir="${build.dir}" />
+		<mkdir dir="${docs.dir}" />
+		<mkdir dir="${test.report.dir}" />
+	</target>
+
+	<!-- copies the jar from verveine.core -->
+	<target name="corejars" depends="makedir">
+		<copy todir="${dist.dir}" file="../verveine.core/lib/famix.jar"/>
+		<copy todir="${dist.dir}" file="../verveine.core/lib/verveine.core.jar"/>
+	</target>
+
+	<!-- Compiles the java code (including the usage of library for JUnit -->
+	<target name="compile" depends="clean, corejars">
+		<javac srcdir="${src.dir}" destdir="${build.dir}" classpathref="build.classpath">
+		</javac>
+	</target>
+
+	<!-- Creates Javadoc -->
+	<target name="docs" depends="compile">
+		<javadoc packagenames="src" sourcepath="${src.dir}" destdir="${docs.dir}">
+			<!-- Define which files / directory should get included, we include all -->
+			<fileset dir="${src.dir}">
+				<include name="**" />
+			</fileset>
+		</javadoc>
+	</target>
+
+	<!--Creates the deployable jar file  -->
+	<target name="jar" depends="compile">
+		<jar destfile="${verveine.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/extractor/java/*.class"/>
+		</jar>
+	</target>
+
+	<!-- Run the JUnit Tests -->
+	<!-- Output is XML, could also be plain-->
+	<target name="junit" depends="compile">
+		<junit printsummary="on" fork="true" haltonfailure="no">
+			<classpath>
+				<pathelement path="${build.dir}"/>
+				<fileset dir="${dist.dir}">
+  				  <include name="*.jar"/>
+				</fileset>
+			</classpath>
+			<formatter type="plain" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel" todir="${test.report.dir}" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc" todir="${test.report.dir}" />
+		</junit>
+	</target>
+
+</project>
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 107)
+++ verveine.core/.classpath	(revision 108)
@@ -2,8 +2,8 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 108)
@@ -8,15 +8,12 @@
 import java.util.Map;
 import java.util.Vector;
 
-import org.eclipse.jdt.core.compiler.CompilationProgress;
-import org.eclipse.jdt.internal.compiler.batch.Main;
-
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.FAMIXModel;
 import fr.inria.verveine.core.gen.famix.SourceLanguage;
 
-public class VerveineParser extends Main {
+public class VerveineParser {
 
 	public final static String OUTPUT_FILE = "output.mse";
 	
@@ -25,21 +22,6 @@
 	SourceLanguage myLgge = null;
 
 	public VerveineParser() {
-		this(new PrintWriter(System.out),
-				new PrintWriter(System.err),
-				false/*systemExitWhenFinished*/,
-				null/*customDefaultOptions*/,
-				null/*compilationProgress*/);
-		
-	}
-
-	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
-		super(outWriter,
-				errWriter,
-				systemExitWhenFinished,
-				customDefaultOptions,
-				compilationProgress);
-		
 		Repository repo = new Repository(FAMIXModel.metamodel());
 		setFamixRepo(repo);
 		if (myLgge != null) {
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 108)
@@ -18,6 +18,7 @@
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.Enum;
 import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
@@ -30,6 +31,7 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.ParameterType;
 import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
@@ -64,14 +66,14 @@
 	/**
 	 * Another dictionary to map a name to FAMIX Entities with this name
 	 */
-	private Map<String,Collection<NamedEntity>> mapName;
+	protected Map<String,Collection<NamedEntity>> mapName;
 
 	/**
 	 * Yet another dictionary for implicit variables ('self' and 'super')
 	 * Because they are implicit, they may not have a binding provided by the parser,
 	 * or may have the same binding than their associated class so they can't be kept easily in {@link Dictionary#mapToKey}
 	 */
-	private Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
 
 	/**
 	 * Used to keep the two possible ImplicitVariable for a given Class binding
@@ -87,7 +89,7 @@
 	 */
 	public Dictionary(Repository famixRepo) {
 		this.famixRepo = famixRepo;
-
+		
 		this.mapToKey = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
 		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
@@ -97,35 +99,29 @@
 		}
 	}
 
-	private void recoverExistingRepository() {
-		for (Object obj : famixRepo.getElements()) {
-			if (obj instanceof NamedEntity) {
-				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
-			}
-		}
-		
-		for (Access acc : famixRepo.all(Access.class)) {
-			try {
-				if (acc.getIsWrite()) { }
-			}
-			catch (NullPointerException e) {
-				acc.setIsWrite(Boolean.FALSE);
-			}
-		}
-
-		for (Method meth : famixRepo.all(Method.class)) {
-			try { if (meth.getIsStub()) { } }
-			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
+	/**
+	 * Resets the dictionnary in a proper state after loading entities from an existing MSE file:
+	 * <UL>
+	 * <li>map all named entities to their names in <b>mapName</b></li>
+	 * <li>reset some boolean properties (e.g. <b>isStub</b>) that are false (they are not saved in the mse file and therefore not initialized)</li>
+	 * </ul>
+	 */
+	protected void recoverExistingRepository() {
+		for (NamedEntity ent : famixRepo.all(NamedEntity.class)) {
+			mapEntityToName( ent.getName(), ent);
+			// for the Exception to be raised, the return value must be tested
+			try { if (ent.getIsStub()) {} }
+			catch (NullPointerException e) { ent.setIsStub(Boolean.FALSE); }
 		}
 
-		for (Attribute att : famixRepo.all(Attribute.class)) {
-			try { if (att.getIsStub()) { } }
-			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
+		for (Access acc : famixRepo.all(Access.class)) {
+			// for the Exception to be raised, the return value must be tested
+			try { if (acc.getIsWrite()) {}	}
+			catch (NullPointerException e) { acc.setIsWrite(Boolean.FALSE); }
 		}
-
 	}
 	
-	private void mapEntityToName(String name, NamedEntity ent) {
+	protected void mapEntityToName(String name, NamedEntity ent) {
 		Collection<NamedEntity> l_ent = mapName.get(name);
 		if (l_ent == null) {
 			l_ent = new LinkedList<NamedEntity>();
@@ -160,7 +156,7 @@
 	 * Returns the Famix Entity associated to the given binding.
 	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
 	 * In such a case, this method will always retrieve the Class associated to the binding.
-	 * To get an ImplicitVariable from the binding, uses {@link Dictionary#getImplicitVariableByKey(Object, String)}
+	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
@@ -175,12 +171,12 @@
 
 	/**
 	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
-	 * The Entity is always created (see {@link Dictionary#ensureFamixNamedEntity(Class, Object, String)}).
+	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
 	 * @param fmxClass -- the FAMIX class of the instance to create
 	 * @param name -- the name of the new instance must not be null (and this is not tested)
 	 * @return the FAMIX Entity or null in case of a FAMIX error
 	 */
-	protected <T extends NamedEntity> T createFamixNamedEntity(Class<T> fmxClass, String name) {
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
 		try {
 			fmx = fmxClass.newInstance();
@@ -212,7 +208,7 @@
 	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
 	 */
 	@SuppressWarnings("unchecked")
-	protected <T extends NamedEntity> T ensureFamixNamedEntity(Class<T> fmxClass, B bnd, String name) {
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
 
 		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
@@ -230,7 +226,7 @@
 		// e.g. 2 parameters of 2 different methods but having the same name
 		// so we cannot recover just from the name
 
-		fmx = createFamixNamedEntity(fmxClass, name);
+		fmx = createFamixEntity(fmxClass, name);
 		if (bnd != null) {
 			mapToKey.put(bnd, fmx);
 		}
@@ -238,31 +234,38 @@
 		return fmx;
 	}
 
+	/**
+	 * Adds an already created Entity to the FAMIX repository
+	 * Used mainly for non-NamedEntity, for example relationships
+	 * @param e -- the FAMIX entity to add to the repository
+	 */
+	public void famixRepoAdd(Entity e) {
+		this.famixRepo.add(e);
+	}
+
 	///// ensure Famix Entities /////
 
 	/**
 	 * Returns a FAMIX Type with the given <b>name</b>, creating it if it does not exist yet.
 	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
-	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
-	 * @param name -- the name of the Famix Type (MUST NOT be null, but this is not checked)
-	 * @param owner -- entity defining the Famix Type (should not be null, but it will work if it is) 
+	 * @param name -- the name of the FAMIX Class
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public Type ensureFamixType(B key, String name, ContainerEntity owner) {
-		Type fmx = ensureFamixNamedEntity(Type.class, key, name);
+		Type fmx = ensureFamixEntity(Type.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
 
 	/**
 	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet.
-	 * @param key to which the entity Famix be mapped (may be null, but then it will be difficult to recover the entity)
-	 * @param name -- the name of the FAMIX Class (MUST NOT be null, but this is not checked)
-	 * @param owner -- entity defining the Famix class (should not be null, but it will work if it is) 
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Method (MUST NOT be null, but this is not checked)
+	 * @param owner -- type defining the method (should not be null, but it will work if it is) 
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(B key, String name, ContainerEntity owner) {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixNamedEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
@@ -273,9 +276,16 @@
 	 * @param name -- the name of the FAMIX Class
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
-	public ParameterizableClass ensureFamixParameterizableClass(String name) {
-		ParameterizableClass fmx = ensureFamixNamedEntity(ParameterizableClass.class, null, name);
-		fmx.setIsInterface(Boolean.FALSE);
+	public ParameterizableClass ensureFamixParameterizableClass(B key, String name, ContainerEntity owner) {
+		ParameterizableClass fmx = ensureFamixEntity(ParameterizableClass.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public ParameterizedType ensureFamixParameterizedType(B key, String name, ParameterizableClass generic, ContainerEntity owner) {
+		ParameterizedType fmx = ensureFamixEntity(ParameterizedType.class, key, name);
+		fmx.setContainer(owner);
+		fmx.setParameterizableClass(generic);
 		return fmx;
 	}
 
@@ -285,58 +295,63 @@
 	 * @param name -- the name of the FAMIX ParameterType
 	 * @return the FAMIX ParameterType or null in case of a FAMIX error
 	 */
-	public ParameterType ensureFamixParameterType(String name) {
-		return ensureFamixNamedEntity(ParameterType.class, null, name);
+	public ParameterType ensureFamixParameterType(B key, String name, ContainerEntity owner) {
+		ParameterType fmx = ensureFamixEntity(ParameterType.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
 	}
 
-	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(B key, String name, ContainerEntity owner) {
-		fr.inria.verveine.core.gen.famix.Enum fmx = ensureFamixNamedEntity(fr.inria.verveine.core.gen.famix.Enum.class, key, name);
+	public Enum ensureFamixEnum(B key, String name,	ContainerEntity owner) {
+		Enum fmx = ensureFamixEntity(Enum.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
 
 	public EnumValue ensureFamixEnumValue(B key, String name, Enum owner) {
-		EnumValue fmx = ensureFamixNamedEntity(EnumValue.class, key, name);
+		EnumValue fmx = ensureFamixEntity(EnumValue.class, key, name);
 		fmx.setParentEnum(owner);
 		return fmx;
-
 	}
 
-	public AnnotationType ensureFamixAnnotationType(B key, String name, ContainerEntity owner) {
-		AnnotationType fmx = ensureFamixNamedEntity(AnnotationType.class, key, name);
+	public AnnotationType ensureFamixAnnotationType(B key, String name,	ContainerEntity owner) {
+		AnnotationType fmx = ensureFamixEntity(AnnotationType.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
 
 	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(B key, String name, AnnotationType owner) {
-		AnnotationTypeAttribute fmx = ensureFamixNamedEntity(AnnotationTypeAttribute.class, key, name);
+		AnnotationTypeAttribute fmx = ensureFamixEntity(AnnotationTypeAttribute.class, key, name);
 		fmx.setParentAnnotationType(owner);
 		return fmx;
 	}
 
-	public AnnotationInstance createFamixAnnotationInstance(AnnotationType annType) {
-		AnnotationInstance fmx = new AnnotationInstance();
-		fmx.setAnnotationType(annType);
-		famixRepo.add(fmx);
-		return fmx;
-	}
-
-	public void addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
-		AnnotationInstance annInst = createFamixAnnotationInstance(annType);
-		if (annAtts != null) {
-			annInst.addAttributes(annAtts);
-		}
-		fmx.addAnnotationInstances( annInst);
-	}
-	
-	public AnnotationInstanceAttribute createFamixAnnotationInstanceAttribute(AnnotationTypeAttribute att, String val) {
+	public AnnotationInstanceAttribute createFamixAnnotationInstanceAttribute(AnnotationTypeAttribute att, String value) {
 		AnnotationInstanceAttribute fmx = new AnnotationInstanceAttribute();
 		fmx.setAnnotationTypeAttribute(att);
-		fmx.setValue(val);
-		famixRepo.add(fmx);
+		fmx.setValue(value);
+		this.famixRepo.add(fmx);
 		return fmx;
 	}
 
+	public AnnotationInstance addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
+		AnnotationInstance inst = new AnnotationInstance();
+		inst.setAnnotationType(annType);
+		inst.setAnnotatedEntity(fmx);
+		inst.addAttributes(annAtts);
+		this.famixRepo.add(inst);
+		return inst;
+	}
+
+	/**
+	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that PrimitiveType must be uniq for a given name
+	 * @param name -- the name of the FAMIX PrimitiveType
+	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
+	 */
+	public PrimitiveType ensureFamixPrimitiveType(B key, String name) {
+		return  ensureFamixUniqEntity(PrimitiveType.class, key, name);
+	}
+	
 	/**
 	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
 	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
@@ -347,7 +362,7 @@
 	 * @return the FAMIX Method or null in case of a FAMIX error
 	 */
 	public Method ensureFamixMethod(B key, String name, String sig, Type ret, Type owner) {
-		Method fmx = (Method) ensureFamixNamedEntity(Method.class, key, name);
+		Method fmx = (Method) ensureFamixEntity(Method.class, key, name);
 		fmx.setSignature(sig);
 		fmx.setDeclaredType(ret);
 		fmx.setParentType(owner);
@@ -357,13 +372,13 @@
 	/**
 	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
 	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
-	 * @param name -- the name of the Famix Attribute (MUST NOT be null, but this is not checked)
-	 * @param type -- Famix Type of the Famix Attribute (should not be null, but it will work if it is)
-	 * @param owner -- Class defining the Famix Attribute (should not be null, but it will work if it is)
-	 * @return the FAMIX Attribute or null in case of a Famix error
+	 * @param name -- the name of the FAMIX Attribute (MUST NOT be null, but this is not checked)
+	 * @param type -- Famix Type of the Attribute (should not be null, but it will work if it is)
+	 * @param owner -- type defining the Attribute (should not be null, but it will work if it is)
+	 * @return the FAMIX Attribute or null in case of a FAMIX error
 	 */
 	public Attribute ensureFamixAttribute(B key, String name, Type type, Type owner) {
-		Attribute fmx = ensureFamixNamedEntity(Attribute.class, key, name);
+		Attribute fmx = ensureFamixEntity(Attribute.class, key, name);
 		fmx.setParentType(owner);
 		fmx.setDeclaredType(type);
 		return fmx;
@@ -371,14 +386,11 @@
 
 	/**
 	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
-	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
-	 * @param name -- the name of the Famix Variable (MUST NOT be null, but this is not checked)
-	 * @param type -- Famix Type of the Famix Variable (should not be null, but it will work if it is)
-	 * @param owner -- Entity defining the Famix Variable (should not be null, but it will work if it is)
+	 * @param name -- the name of the FAMIX LocalVariable
 	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
 	 */
 	public LocalVariable ensureFamixLocalVariable(B key, String name, Type type, BehaviouralEntity owner) {
-		LocalVariable fmx = ensureFamixNamedEntity(LocalVariable.class, key, name);
+		LocalVariable fmx = ensureFamixEntity(LocalVariable.class, key, name);
 		fmx.setParentBehaviouralEntity(owner);
 		fmx.setDeclaredType(type);
 		return fmx;
@@ -400,15 +412,14 @@
 	}
 	
 	/**
-	 * Creates and returns a Famix Parameter and associates it with a BehaviouralEntity
-	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
-	 * @param name -- the name of the Famix Parameter (MUST NOT be null, but this is not checked)
-	 * @param type -- Famix Type of the Famix Parameter (should not be null, but it will work if it is)
-	 * @param owner -- Class defining the Famix Parameter (should not be null, but it will work if it is)
-	 * @return the Famix parameter or null in case of a Famix error
+	 * Creates and returns a FAMIX Parameter and associates it with a BehaviouralEntity
+	 * @param name -- the name of the parameter
+	 * @param owner -- the entity concerned by this parameter
+	 * @param type -- the type of the parameter
+	 * @return the FAMIX parameter
 	 */
-	public Parameter ensureFamixParameter(B key, String name, Type type, BehaviouralEntity owner) {
-		Parameter fmx = ensureFamixNamedEntity(Parameter.class, key, name);
+	public Parameter createFamixParameter(B key, String name, Type type, BehaviouralEntity owner) {
+		Parameter fmx = ensureFamixEntity(Parameter.class, key, name);
 		fmx.setParentBehaviouralEntity(owner);
 		fmx.setDeclaredType(type);
 		
@@ -418,11 +429,10 @@
 	///// ensure Famix Relationships /////
 
 	/**
-	 * Returns a Famix Inheritance relationship between two Famix Classes (or Interfaces) creating it if needed.
-	 * All References in a context are linked one to the other
+	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
 	 * @param sup -- the super class
 	 * @param sub -- the sub class
-	 * @param prev -- previous Inheritance link in the same context or null if it is the first
+	 * @param prev -- previous inheritance relationship in the same context
 	 * @return the Inheritance relationship
 	 */
 	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
@@ -435,115 +445,115 @@
 		inh.setSuperclass(sup);
 		inh.setSubclass(sub);
 		chainPrevNext(prev,inh);
-		this.famixRepo.add(inh);
-
+		famixRepoAdd(inh);
 		return inh;
 	}
 
 	/**
-	 * Creates a Famix Reference between two Famix Entities. All References in a context are linked one to the other
+	 * Returns a Famix Reference between two Famix Entities creating it if needed
 	 * @param src -- source of the reference
 	 * @param tgt -- target of the reference
-	 * @param prev -- previous Reference in the same context or null if it is the first
+	 * @param prev -- previous reference relationship in the same context
 	 * @return the Reference
 	 */
-	public Reference createFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
 		ref.setSource(src);
 		chainPrevNext(prev,ref);
-		this.famixRepo.add(ref);
+		famixRepoAdd(ref);
 		
 		return ref;
 	}
 
 	/**
-	 * Creates a Famix Invocation between two Famix Entities.  All Invocations in a context are linked one to the other
+	 * Returns a Famix Invocation between two Famix Entities creating it if needed
 	 * @param sender of the invocation
 	 * @param invoked -- method invoked
 	 * @param receiver of the invocation
-	 * @param prev -- previous Invocation in the same context or null if it is the first
+	 * @param prev -- previous invocation relationship in the same context
 	 * @return the Invocation
 	 */
-	public Invocation createFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
 		invok.setSignature(invoked.getSignature());
 		invok.addCandidates(invoked);
 		chainPrevNext(prev,invok);
-		this.famixRepo.add(invok);
+		famixRepoAdd(invok);
 		
 		return invok;
 	}
 
 	/**
-	 * Creates a Famix Access between two Famix Entities. All Accesses in a context are linked one to the other
-	 * @param accessor
-	 * @param var -- variable accessed
-	 * @param isWrite -- whether the variable is written or read
-	 * @param prev -- previous Access in the same context or null if it is the first
-	 * @return the Access
+	 * Returns a Famix Access between two Famix Entities creating it if needed
+	 * @param accessor -- the entity (presumably a method) accessing the attribute
+	 * @param var -- the variable accessed
+	 * @param isWrite -- whether this is an access for reading or writing in the variable
+	 * @param prev -- previous access relationship in the same context
+	 * @return the Invocation
 	 */
-	public Access createFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
+		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
 		acc.setIsWrite(new Boolean(isWrite));
 		chainPrevNext(prev, acc);
-		this.famixRepo.add(acc);
+		famixRepoAdd(acc);
 		
 		return acc;
 	}
 
 	private void chainPrevNext(Association prev, Association next) {
 		if (prev != null) {
-			next.setPrevious(prev);
+			next.setPrevious(prev);  // not yet implemented in importer
 		}
 	}
 	
 	/**
-	 * Creates a Famix DeclaredException between a method and an Exception that it declares to throw
+	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
 	 * @param meth -- the method throwing the exception
 	 * @param excep -- the exception declared to be thrown
 	 * @return the DeclaredException
 	 */
-	public DeclaredException createFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		DeclaredException fmx = new DeclaredException();
-		fmx.setExceptionClass(excep);
-		fmx.setDefiningMethod(meth);
-		this.famixRepo.add(fmx);
-		return fmx;
+	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		DeclaredException decl = new DeclaredException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
 	}
 
 	/**
-	 * CReates a Famix CaughtException between a method and an Exception that is caught
+	 * Returns a Famix CaughtException between a method and an Exception that is caught
 	 * @param meth -- the method catching the exception
 	 * @param excep -- the exception caught
 	 * @return the CaughtException
 	 */
-	public CaughtException createFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		CaughtException fmx = new CaughtException();
-		fmx.setExceptionClass(excep);
-		fmx.setDefiningMethod(meth);
-		this.famixRepo.add(fmx);
-		return fmx;
+	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		CaughtException decl = new CaughtException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
 	}
 
 	/**
-	 * Creates a Famix ThrownException between a method and an Exception that it (actually) throws.
-	 * Note: DeclaredException indicates only that the method <em>declares</em> it can throw the exception,
-	 * here we state that the exception is <em>actually thrown</em>
+	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
+	 * Note: DeclaredException indicates that the method declares it can throw the exception,
+	 * here we state that the exception is actually thrown
 	 * @param meth -- the method throwing the exception
 	 * @param excep -- the exception thrown
 	 * @return the ThrownException
 	 */
-	public ThrownException createFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		ThrownException fmx = new ThrownException();
-		fmx.setExceptionClass(excep);
-		fmx.setDefiningMethod(meth);
-		this.famixRepo.add(fmx);
-		return fmx;
+	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		ThrownException decl = new ThrownException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
 	}
 
 	///// Special Case: ImplicitVariables /////
@@ -554,7 +564,7 @@
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
-	public ImplicitVariable getImplicitVariableByKey(B bnd, String iv_name) {
+	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
 		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd), iv_name);
 	}
 	
@@ -585,17 +595,19 @@
 	/**
 	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
 	 * If this ImplicitVariable does not exist yet, it is created
-	 * @param clazz -- the Famix Class for this ImplicitVariable (must not be null)
 	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param owner -- the ContainerEntity where the implicit variable appears (usually a method inside <b>clazz</b>)
 	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
 	 */
-	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+	public ImplicitVariable ensureFamixImplicitVariable(String name, fr.inria.verveine.core.gen.famix.Class clazz, ContainerEntity owner) {
 		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
 		
 		if (fmx == null) {
-			fmx = (ImplicitVariable) createFamixNamedEntity(ImplicitVariable.class, name);
+			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
 			if (fmx!=null) {
-				fmx.setContainer(clazz);
+				fmx.setContainer(owner);
+				fmx.setIsStub(Boolean.FALSE);
 
 				ImplicitVars iv = mapImpVar.get(clazz);				
 				if (iv == null) {
@@ -640,7 +652,7 @@
 				fmx = l.iterator().next();
 			}
 			else {
-				fmx = createFamixNamedEntity(fmxClass, name);
+				fmx = createFamixEntity(fmxClass, name);
 			}
 			
 			if (key != null) {
@@ -675,16 +687,6 @@
 	}
 
 	/**
-	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
-	 * We assume that PrimitiveType must be uniq for a given name
-	 * @param name -- the name of the FAMIX PrimitiveType
-	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
-	 */
-	public PrimitiveType ensureFamixPrimitiveType(B key, String name) {
-		return ensureFamixNamedEntity(PrimitiveType.class, key, name);
-	}
-	
-	/**
 	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
 	 * @return a Famix class
 	 */
@@ -697,5 +699,18 @@
 		return fmx;
 	}
 
-	
+	public Type searchTypeInContext(String name, ContainerEntity ctxt) {
+		if (ctxt == null) {
+			return null;
+		}
+		
+		for (Type candidate : ctxt.getTypes()) {
+			if (candidate.getName().equals(name) ) {
+				return candidate;
+			}
+		}
+		
+		return searchTypeInContext(name, ctxt.getBelongsTo());
+	}
+
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 108)
@@ -12,11 +12,11 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
 		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 108)
@@ -12,31 +12,31 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 108)
@@ -12,12 +12,12 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.Multiplication.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
-		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
-		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.CodeLine.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 108)
@@ -12,10 +12,10 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.moose.Group.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.Model.class);
 		metamodel.with(fr.inria.verveine.core.gen.moose.Entity.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Model.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 107)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 108)
@@ -12,10 +12,10 @@
 
 
 
-    private Type container;
+    private ContainerEntity container;
     
     @FameProperty(name = "container")
-    public Type getContainer() {
+    public ContainerEntity getContainer() {
         return container;
     }
 
@@ -24,7 +24,7 @@
 		return getContainer();
 	}
 
-    public void setContainer(Type container) {
+    public void setContainer(ContainerEntity container) {
         this.container = container;
     }
     
Index: verveine.core/build.xml
===================================================================
--- verveine.core/build.xml	(revision 0)
+++ verveine.core/build.xml	(revision 108)
@@ -0,0 +1,63 @@
+<?xml version="1.0"?>
+<project name="verveine.core" default="jar" basedir=".">
+	<!-- Sets variables which can later be used. -->
+	<!-- The value of a property is accessed via ${} -->
+	<property name="src.dir"      location="src" />
+	<property name="build.dir"    location="bin" />
+	<property name="docs.dir"     location="docs" />
+	<property name="dist.dir"     location="lib" />
+	<property name="famix.jar"    location="${dist.dir}/famix.jar" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.core.jar" />
+
+	<!-- Create a classpath container which can be later used in the ant task
+	-->
+	<path id="build.classpath">
+		<fileset dir="${dist.dir}">
+			<include name="*.jar" />
+		</fileset>
+	</path>
+
+
+	<!-- Deletes the existing build, docs and dist directory-->
+	<target name="clean">
+		<delete dir="${build.dir}" />
+		<delete dir="${docs.dir}" />
+		<delete file="${famix.jar}" />
+		<delete file="${verveine.jar}" />
+	</target>
+
+	<!-- Creates the  build, docs and dist directory-->
+	<target name="makedir">
+		<mkdir dir="${build.dir}" />
+		<mkdir dir="${docs.dir}" />
+	</target>
+
+	<!-- Compiles the java code (including the usage of library for JUnit -->
+	<target name="compile" depends="clean, makedir">
+		<javac srcdir="${src.dir}" destdir="${build.dir}" classpathref="build.classpath">
+		</javac>
+	</target>
+
+	<!-- Creates Javadoc -->
+	<target name="docs" depends="compile">
+		<javadoc packagenames="src" sourcepath="${src.dir}" destdir="${docs.dir}">
+			<!-- Define which files / directory should get included, we include all -->
+			<fileset dir="${src.dir}">
+				<include name="**" />
+			</fileset>
+		</javadoc>
+	</target>
+
+	<!--Creates the deployable jar files  -->
+	<target name="jar" depends="compile">
+		<jar destfile="${famix.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/core/gen/famix/*.class"/>
+			<include name="fr/inria/verveine/core/gen/moose/*.class"/>
+		</jar>
+		<jar destfile="${verveine.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/core/*.class"/>
+			<include name="test/fr/inria/verveine/core/*.class"/>
+		</jar>
+	</target>
+
+</project>
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 43)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 44)
@@ -15,6 +15,8 @@
 import org.eclipse.jdt.core.dom.EnhancedForStatement;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.ForStatement;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
@@ -37,6 +39,7 @@
 import org.eclipse.jdt.core.dom.WhileStatement;
 
 import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
@@ -151,7 +154,8 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
-		Method fmx = dico.ensureFamixMethod(node.resolveBinding());
+		IMethodBinding bnd = node.resolveBinding();
+		Method fmx = dico.ensureFamixMethod(bnd);
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -178,6 +182,11 @@
 				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 				dico.addSourceAnchor(cmt, jdoc);
 			}
+			//Annotation
+			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+				dico.createFamixAnnotationInstance(fmx, annType);
+			}
 			this.context.pushMethod(fmx);
 			if (node.getBody() != null) {
 				context.setTopMethodCyclo(1);
@@ -195,7 +204,7 @@
 		fmx.setCyclo(cyclo);
 		super.endVisit(node);
 	}
-
+	
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 8)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 9)
@@ -19,6 +19,7 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
@@ -204,7 +205,7 @@
 	}
 
 	///// ensure Famix Entities /////
-
+	
 	/**
 	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
 	 * @param name -- the name of the FAMIX Class
@@ -439,7 +440,7 @@
 	 * @return the FAMIX Namespace or null in case of a FAMIX error
 	 */
 	public Namespace ensureFamixNamespace(String name) {
-		return (Namespace) ensureFamixUniqEntity(Namespace.class, null, name);
+		return  ensureFamixUniqEntity(Namespace.class, null, name);
 	}
 
 	/**
@@ -454,6 +455,16 @@
 	}
 
 	/**
+	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that PrimitiveType must be uniq for a given name
+	 * @param name -- the name of the FAMIX PrimitiveType
+	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
+	 */
+	public PrimitiveType ensureFamixPrimitiveType(String name) {
+		return  ensureFamixUniqEntity(PrimitiveType.class, null, name);
+	}
+	
+	/**
 	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
 	 * Because this package does not really exist, it has no binding.
 	 * @return a Famix class
Index: branches/postMoose4_3Refactoring/verveine.core/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/.classpath	(revision 105)
+++ branches/postMoose4_3Refactoring/verveine.core/.classpath	(revision 106)
@@ -4,6 +4,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: branches/postMoose4_3Refactoring/verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.core/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.core/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 105)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 106)
@@ -8,15 +8,12 @@
 import java.util.Map;
 import java.util.Vector;
 
-import org.eclipse.jdt.core.compiler.CompilationProgress;
-import org.eclipse.jdt.internal.compiler.batch.Main;
-
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.FAMIXModel;
 import fr.inria.verveine.core.gen.famix.SourceLanguage;
 
-public class VerveineParser extends Main {
+public class VerveineParser {
 
 	public final static String OUTPUT_FILE = "output.mse";
 	
@@ -25,21 +22,6 @@
 	SourceLanguage myLgge = null;
 
 	public VerveineParser() {
-		this(new PrintWriter(System.out),
-				new PrintWriter(System.err),
-				false/*systemExitWhenFinished*/,
-				null/*customDefaultOptions*/,
-				null/*compilationProgress*/);
-		
-	}
-
-	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
-		super(outWriter,
-				errWriter,
-				systemExitWhenFinished,
-				customDefaultOptions,
-				compilationProgress);
-		
 		Repository repo = new Repository(FAMIXModel.metamodel());
 		setFamixRepo(repo);
 		if (myLgge != null) {
Index: branches/postMoose4_3Refactoring/verveine.core/build.xml
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/build.xml	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/build.xml	(revision 106)
@@ -0,0 +1,67 @@
+<?xml version="1.0"?>
+<project name="verveine.core" default="main" basedir=".">
+	<!-- Sets variables which can later be used. -->
+	<!-- The value of a property is accessed via ${} -->
+	<property name="src.dir"      location="src" />
+	<property name="build.dir"    location="bin" />
+	<property name="docs.dir"     location="docs" />
+	<property name="dist.dir"     location="lib" />
+	<property name="famix.jar"    location="${dist.dir}/famix.jar" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.core.jar" />
+
+	<!-- Create a classpath container which can be later used in the ant task
+	-->
+	<path id="build.classpath">
+		<fileset dir="${dist.dir}">
+			<include name="*.jar" />
+		</fileset>
+	</path>
+
+
+	<!-- Deletes the existing build, docs and dist directory-->
+	<target name="clean">
+		<delete dir="${build.dir}" />
+		<delete dir="${docs.dir}" />
+		<delete file="${famix.jar}" />
+		<delete file="${verveine.jar}" />
+	</target>
+
+	<!-- Creates the  build, docs and dist directory-->
+	<target name="makedir">
+		<mkdir dir="${build.dir}" />
+		<mkdir dir="${docs.dir}" />
+	</target>
+
+	<!-- Compiles the java code (including the usage of library for JUnit -->
+	<target name="compile" depends="clean, makedir">
+		<javac srcdir="${src.dir}" destdir="${build.dir}" classpathref="build.classpath">
+		</javac>
+	</target>
+
+	<!-- Creates Javadoc -->
+	<target name="docs" depends="compile">
+		<javadoc packagenames="src" sourcepath="${src.dir}" destdir="${docs.dir}">
+			<!-- Define which files / directory should get included, we include all -->
+			<fileset dir="${src.dir}">
+				<include name="**" />
+			</fileset>
+		</javadoc>
+	</target>
+
+	<!--Creates the deployable jar files  -->
+	<target name="jar" depends="compile">
+		<jar destfile="${famix.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/core/gen/famix/*.class"/>
+			<include name="fr/inria/verveine/core/gen/moose/*.class"/>
+		</jar>
+		<jar destfile="${verveine.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/core/*.class"/>
+			<include name="test/fr/inria/verveine/core/*.class"/>
+		</jar>
+	</target>
+
+	<target name="main" depends="jar">
+		<description>Main target</description>
+	</target>
+
+</project>
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 79)
+++ verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 80)
@@ -42,13 +42,13 @@
 
 	public boolean linkToExisting() {
 		File existingMSE = new File(OUTPUT_FILE);
-		if (! existingMSE.exists()) {
-			return false;
-		}
-		else {
+		if (existingMSE.exists()) {
 			this.getFamixRepo().importMSEFile(OUTPUT_FILE);
 			return true;
 		}
+		else {
+			return false;
+		}
 	}
 	
 	/**
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 79)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 80)
@@ -5,6 +5,8 @@
 import java.util.LinkedList;
 import java.util.Map;
 
+import org.eclipse.jdt.core.dom.ITypeBinding;
+
 import ch.akuhn.fame.Repository;
 
 import fr.inria.verveine.core.gen.famix.Access;
@@ -24,11 +26,14 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.core.gen.famix.Type;
 
 /**
  * A dictionnary of Famix entities to help create them and find them back
@@ -208,7 +213,7 @@
 	 */
 	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
-
+//System.out.println("creating FMX Entity:"+ name +"   type: "+ fmxClass.getCanonicalName());
 		try {
 			fmx = fmxClass.newInstance();
 		} catch (Exception e) {
@@ -243,7 +248,7 @@
 	@SuppressWarnings("unchecked")
 	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
-		
+
 		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
 			return null;
 		}
@@ -282,18 +287,12 @@
 	}
 
 	///// ensure Famix Entities /////
-	
-	/**
-	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Class
-	 * @return the FAMIX Class or null in case of a FAMIX error
-	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+
+	protected <T extends fr.inria.verveine.core.gen.famix.Type> T ensureFamixType(Class<T> fmxClass, String name) {
+		T fmx = ensureFamixEntity(fmxClass, null, name);
 		if (fmx != null) {
 			fmx.setIsAbstract(Boolean.FALSE);
 			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsInterface(Boolean.FALSE);
 			fmx.setIsPrivate(Boolean.FALSE);
 			fmx.setIsProtected(Boolean.FALSE);
 			fmx.setIsPublic(Boolean.FALSE);
@@ -301,12 +300,58 @@
 
 		return fmx;
 	}
+	
+	/**
+	 * Returns a FAMIX Type with the given <b>name</b>, creating it if it does not exist yet.
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public Type ensureFamixType(String name) {
+		return ensureFamixType(Type.class, name);
+	}
+
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet.
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixType(fr.inria.verveine.core.gen.famix.Class.class, name);
+		fmx.setIsInterface(Boolean.FALSE);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public ParameterizableClass ensureFamixParameterizableClass(String name) {
+		ParameterizableClass fmx = ensureFamixType(ParameterizableClass.class, name);
+		fmx.setIsInterface(Boolean.FALSE);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX ParameterType (created by a FAMIX ParameterizableClass) with the given <b>name</b>, creating it if it does not exist yet
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public
+	 * @param name -- the name of the FAMIX ParameterType
+	 * @return the FAMIX ParameterType or null in case of a FAMIX error
+	 */
+	public ParameterType ensureFamixParameterType(String name) {
+		ParameterType fmx = ensureFamixType(ParameterType.class, name);
+		return fmx;
+	}
 
 	/**
 	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
 	 * @param name -- the name of the FAMIX Method
 	 * @return the FAMIX Method or null in case of a FAMIX error
 	 */
+
 	public Method ensureFamixMethod(String name) {
 		return (Method) ensureFamixEntity(Method.class, null, name);
 	}
@@ -358,17 +403,17 @@
 	}
 	
 	/**
-	 * Creates and returns a FAMIX Parameter and associates it with an BehaviouralEntity
+	 * Creates and returns a FAMIX Parameter and associates it with a BehaviouralEntity
 	 * @param identifier -- the name of the parameter
 	 * @param owner -- the entity concerned by this parameter
 	 * @param type -- the type of the parameter
 	 * @return the FAMIX parameter
 	 */
-	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, String type) {
+	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, Type type) {
 		Parameter fmx = new Parameter();
 		fmx.setName(identifier);
 		fmx.setParentBehaviouralEntity(owner);
-		fmx.setDeclaredType(ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type));
+		fmx.setDeclaredType(type);
 		this.famixRepo.add(fmx);
 		
 		return fmx;
@@ -382,11 +427,11 @@
 	 * @param sub -- the sub class
 	 * @return the Inheritance relationship
 	 */
-	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
+	public Inheritance ensureFamixInheritance(Type sup, Type sub) {
 		return ensureFamixInheritance(sup, sub, null);
 	}
 	
-	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Association prev) {
+	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
 				return i;
@@ -671,5 +716,6 @@
 
 		return fmx;
 	}
+
 	
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 79)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 80)
@@ -50,7 +50,7 @@
     @FameProperty(name = "attributes", derived = true)
     public Collection<AnnotationInstanceAttribute> getAttributes() {
         // TODO: this is a derived property, implement this method manually.
-        throw new UnsupportedOperationException("Not yet implemented!");  
+    	return null;
     }
         
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 79)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 80)
@@ -11,12 +11,18 @@
 @FameDescription("ParameterizableClass")
 public class ParameterizableClass extends Class {
 
-
-
     @FameProperty(name = "parameters", derived = true)
     public Collection<ParameterType> getParameters() {
-        // TODO: this is a derived property, implement this method manually.
-        throw new UnsupportedOperationException("Not yet implemented!");  
+        // this is a derived property, implement this method manually.
+    	Collection<ParameterType> ret = new LinkedList<ParameterType>();
+    	
+        for (Type inner : getTypes()) {
+        	if (inner instanceof ParameterType) {
+        		ret.add((ParameterType) inner);
+        	}
+        }
+        
+        return ret;
     }
         
 
Index: verveine.core/export-famix.jardesc
===================================================================
--- verveine.core/export-famix.jardesc	(revision 0)
+++ verveine.core/export-famix.jardesc	(revision 80)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<jardesc>
+    <jar path="verveine.core/lib/famix.jar"/>
+    <options buildIfNeeded="true" compress="true" descriptionLocation="/verveine.core/export-famix.jardesc" exportErrors="true" exportWarnings="true" includeDirectoryEntries="false" overwrite="false" saveDescription="true" storeRefactorings="false" useSourceFolders="false"/>
+    <storedRefactorings deprecationInfo="true" structuralOnly="false"/>
+    <selectedProjects/>
+    <manifest generateManifest="true" manifestLocation="/Fame/META-INF/MANIFEST.MF" manifestVersion="1.0" reuseManifest="false" saveManifest="false" usesManifest="true">
+        <sealing sealJar="false">
+            <packagesToSeal/>
+            <packagesToUnSeal/>
+        </sealing>
+    </manifest>
+    <selectedElements exportClassFiles="true" exportJavaFiles="false" exportOutputFolder="false">
+        <javaElement handleIdentifier="=verveine.core/src&lt;fr.inria.verveine.core.gen.famix"/>
+        <javaElement handleIdentifier="=verveine.core/src&lt;fr.inria.verveine.core.gen.moose"/>
+    </selectedElements>
+</jardesc>
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 19)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 20)
@@ -558,7 +558,15 @@
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
-		fmx.setContainer( ensureFamixNamespaceDefault());
+		if (fmx != null) {
+			fmx.setContainer( ensureFamixNamespaceDefault());
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.FALSE);
+		}
 
 		return fmx;
 	}
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 107)
@@ -397,19 +397,6 @@
 	}
 
 	/**
-	 * Creates and returns a FAMIX Comment
-	 * @param cmt -- the content (String) of the comment 
-	 * @return the FAMIX Comment
-	 */
-	public Comment createFamixComment(String cmt) {
-		Comment fmx = new Comment();
-		fmx.setContent(cmt);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
-	}
-
-	/**
 	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
 	 * @param cmt -- the content (String) of the comment 
 	 * @param owner -- the entity concerned by this comment
@@ -445,12 +432,9 @@
 	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
 	 * @param sup -- the super class
 	 * @param sub -- the sub class
+	 * @param prev -- previous inheritance relationship in the same context
 	 * @return the Inheritance relationship
 	 */
-	public Inheritance ensureFamixInheritance(Type sup, Type sub) {
-		return ensureFamixInheritance(sup, sub, null);
-	}
-	
 	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
@@ -469,12 +453,9 @@
 	 * Returns a Famix Reference between two Famix Entities creating it if needed
 	 * @param src -- source of the reference
 	 * @param tgt -- target of the reference
+	 * @param prev -- previous reference relationship in the same context
 	 * @return the Reference
 	 */
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
-		return ensureFamixReference(src, tgt, null);
-	}
-	
 	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
@@ -490,12 +471,9 @@
 	 * @param sender of the invocation
 	 * @param invoked -- method invoked
 	 * @param receiver of the invocation
+	 * @param prev -- previous invocation relationship in the same context
 	 * @return the Invocation
 	 */
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
-		return ensureFamixInvocation(sender, invoked, receiver, null);
-	}
-
 	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
@@ -508,6 +486,14 @@
 		return invok;
 	}
 
+	/**
+	 * Returns a Famix Access between two Famix Entities creating it if needed
+	 * @param accessor -- the entity (presumably a method) accessing the attribute
+	 * @param var -- the variable accessed
+	 * @param isWrite -- whether this is an access for reading or writing in the variable
+	 * @param prev -- previous access relationship in the same context
+	 * @return the Invocation
+	 */
 	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
 		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
@@ -609,17 +595,18 @@
 	/**
 	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
 	 * If this ImplicitVariable does not exist yet, it is created
-	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
 	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param owner -- the ContainerEntity where the implicit variable appears (usually a method inside <b>clazz</b>)
 	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
 	 */
-	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+	public ImplicitVariable ensureFamixImplicitVariable(String name, fr.inria.verveine.core.gen.famix.Class clazz, ContainerEntity owner) {
 		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
 		
 		if (fmx == null) {
 			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
 			if (fmx!=null) {
-				fmx.setContainer(clazz);
+				fmx.setContainer(owner);
 				fmx.setIsStub(Boolean.FALSE);
 
 				ImplicitVars iv = mapImpVar.get(clazz);				
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 107)
@@ -12,10 +12,10 @@
 
 
 
-    private Type container;
+    private ContainerEntity container;
     
     @FameProperty(name = "container")
-    public Type getContainer() {
+    public ContainerEntity getContainer() {
         return container;
     }
 
@@ -24,7 +24,7 @@
 		return getContainer();
 	}
 
-    public void setContainer(Type container) {
+    public void setContainer(ContainerEntity container) {
         this.container = container;
     }
     
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/Card.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/Card.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/Card.java	(revision 107)
@@ -0,0 +1,41 @@
+package ad_hoc;
+
+import java.util.ArrayList;
+import java.util.List;
+/*
+public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
+
+public class Card {
+
+	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
+        SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
+
+    private final Rank rank;
+    private final Suit suit;
+    private Card(Rank rank, Suit suit) {
+        this.rank = rank;
+        this.suit = suit;
+    }
+
+    public Rank rank() { return rank; }
+    public Suit suit() { return suit; }
+    public String toString() { return rank + " of " + suit; }
+
+    private static final List<Card> protoDeck = new ArrayList<Card>();
+
+    // Initialize prototype deck
+    static {
+        for (Suit s : Suit.values())
+            for (Rank r : Rank.values()) {
+            	if (r == Rank.QUEEN) {
+            		System.out.println("God save the Queen!");
+            		}
+            	protoDeck.add(new Card(r, s));
+            }
+    }
+
+    public static ArrayList<Card> newDeck() {
+        return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
+    }
+}
+*/
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 107)
@@ -1,40 +0,0 @@
-package ad_hoc;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class Card {
-
-	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
-
-	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
-        SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
-
-    private final Rank rank;
-    private final Suit suit;
-    private Card(Rank rank, Suit suit) {
-        this.rank = rank;
-        this.suit = suit;
-    }
-
-    public Rank rank() { return rank; }
-    public Suit suit() { return suit; }
-    public String toString() { return rank + " of " + suit; }
-
-    private static final List<Card> protoDeck = new ArrayList<Card>();
-
-    // Initialize prototype deck
-    static {
-        for (Suit s : Suit.values())
-            for (Rank r : Rank.values()) {
-            	if (r == Rank.QUEEN) {
-            		System.out.println("God save the Queen!");
-            		}
-            	protoDeck.add(new Card(r, s));
-            }
-    }
-
-    public static ArrayList<Card> newDeck() {
-        return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
-    }
-}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 107)
@@ -29,7 +29,7 @@
  * 
  * @author akuhn
  * 
- */
+ *
 @Retention(RetentionPolicy.RUNTIME)
 @Target( { ElementType.METHOD, ElementType.FIELD })
 public @interface FameProperty {
@@ -43,5 +43,5 @@
     String opposite() default "";
 
     Class<?> type() default Void.class;
-
+*/
 }
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 107)
@@ -15,7 +15,6 @@
 import java.io.File;
 import java.util.Collection;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -28,6 +27,7 @@
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
@@ -36,7 +36,6 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -60,6 +59,7 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
 		String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
@@ -72,7 +72,6 @@
 				"server/PrintServer.java"
 		};
 
-		new File(VerveineJParser.OUTPUT_FILE).delete();
 
 		// separate parsing of each source file --------
 		for (String f : files) {
@@ -80,9 +79,11 @@
 		}
 
 		// or parsing the entire project in one pass ---
-		//VerveineJParser parser = new VerveineJParser();
-		//parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
-		//repo = parser.getFamixRepo();
+		/*VerveineJParser parser = new VerveineJParser();
+		repo = parser.getFamixRepo();
+		parser.setOptions(new String[] {"test_src/LANModel/"});
+		parser.parse();
+		parser.outputMSE();*/
 	}
 
 	/**
@@ -340,6 +341,43 @@
 	}
 
 	@Test
+	public void testImplicitVar() {
+		boolean testRan = false;
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("isDestinationFor" )) {
+				testRan = true;
+				assertEquals(1, m.getOutgoingInvocations().size());
+				Invocation invok = m.getOutgoingInvocations().iterator().next();
+				assertEquals(ImplicitVariable.class, invok.getReceiver().getClass());
+				ImplicitVariable iv = (ImplicitVariable) invok.getReceiver();
+				assertEquals("self", iv.getName());
+				assertSame(m, iv.getBelongsTo());
+			}
+		}
+		assertTrue("Test for SELF did not run, cause: SingleDestinationAddress.isDestinationFor() method not found", testRan);
+
+		testRan = false;
+		clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "WorkStation");
+		assertNotNull(clazz);
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name" )) {
+				testRan = true;
+				assertEquals(1, m.getOutgoingInvocations().size());
+				Invocation invok = m.getOutgoingInvocations().iterator().next();
+				assertEquals(ImplicitVariable.class, invok.getReceiver().getClass());
+				ImplicitVariable iv = (ImplicitVariable) invok.getReceiver();
+				assertEquals("super", iv.getName());
+				assertSame(m, iv.getBelongsTo());
+			}
+		}
+		assertTrue("Test for SELF did not run, cause: SingleDestinationAddress.isDestinationFor() method not found", testRan);
+
+	}
+
+
+	@Test
 	public void testInvocation() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(nodeClass);
@@ -413,6 +451,7 @@
 		}
 
 	}
+
 	
 	@Test
 	public void testAccess() {
@@ -452,6 +491,7 @@
 		}
 	}
 
+
 	@Test
 	public void testSourceAnchors() {
 		SourceAnchor anc = null;
@@ -463,7 +503,7 @@
 		assertNotNull(anc);
 		assertSame(clazz, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/server/PrintServer.java"));
+		assertEquals("test_src/LANModel/moose/lan/server/PrintServer.java", ((FileAnchor)anc).getFileName());
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
 		assertEquals(31, ((FileAnchor)anc).getEndLine());
 
@@ -502,6 +542,7 @@
 		
 	}
 
+
 	@Test
 	public void testModifiers() {
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
@@ -536,6 +577,7 @@
 		assertFalse(a.getIsFinal());
 	}
 
+
 	@Test
 	public void testComment() {	
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
@@ -555,6 +597,7 @@
 		assertEquals(34, ((FileAnchor)anc).getEndLine());
 
 	}
+
 	
 	@Test
 	public void testMetric() {
@@ -576,6 +619,7 @@
 			}
 		}		
 	}
+
 	
 	@Test
 	public void testAnnotation() {
@@ -616,4 +660,5 @@
 			}
 		}	
 	}
+
 }
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 107)
@@ -230,7 +230,7 @@
 
 	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(dico.SUPER_NAME, this.context.topClass(), context.top()));
 		return super.visit(node);
 	}
 
@@ -305,7 +305,7 @@
 	private NamedEntity getReceiver(Expression expr) {
 		// msg(), same as ThisExpression
 		if (expr == null) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
 		}
 
 		// array[i].msg()
@@ -426,7 +426,7 @@
 		
 		// this.msg()
 		else if (expr instanceof ThisExpression) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(dico.SELF_NAME, this.context.topClass(), context.top());
 		}
 
 		// type.class.msg()
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 107)
@@ -23,10 +23,12 @@
 import org.eclipse.jdt.core.dom.ForStatement;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -116,7 +118,7 @@
 		ITypeBinding bnd = node.resolveBinding();
 		@SuppressWarnings("unchecked")
 		List<TypeParameter> tparams = node.typeParameters();
-		fr.inria.verveine.core.gen.famix.Class fmx = (Class) dico.ensureFamixType(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), /*ctxt*/context.top());  // isGeneric = (tparams.size()>0)
+		fr.inria.verveine.core.gen.famix.Class fmx = (Class) dico.ensureFamixType(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), /*ctxt*/context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 
@@ -127,9 +129,7 @@
 			
 			for (TypeParameter tp : tparams) {
 				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
-				// FIXME But types created with ensureFamixType cannot be ParameterizableClasses because the bindings of JDT
-				//       don't contain the proper information (isGeneric() return false :-) )
-				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note owner of the ParameterType is the ParameterizableClass
+				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note: owner of the ParameterType is the ParameterizableClass
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
 				}
@@ -345,22 +345,23 @@
 		return super.visit(node);
 	}
 
+	@SuppressWarnings("unchecked")
 	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
 		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
 
 		fr.inria.verveine.core.gen.famix.Type fmxTyp;
 		if (varTyp.isParameterizedType()) {
-			ITypeBinding tbnd = varTyp.resolveBinding();
+			ITypeBinding parameterizedBnd = varTyp.resolveBinding();
+			ITypeBinding parameterizableBnd = (parameterizedBnd == null) ? null : parameterizedBnd.getErasure();
 			String tname = dico.findTypeName(varTyp);
 			ParameterizableClass tmpGeneric = null;
-			if (tbnd != null) {
-				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(tbnd.getErasure(), tname, /*owner*/null, /*isGeneric*/true);
-			}
-			else {
-				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(null, tname, /*owner*/null, /*isGeneric*/true);
+			tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(parameterizableBnd, tname, /*owner*/null, /*isGeneric*/true);
+
+			fmxTyp = dico.ensureFamixParameterizedType(parameterizedBnd, tname, tmpGeneric, /*owner*/ctxt);
+			for (Type targ : (List<Type>) ((ParameterizedType)varTyp).typeArguments()) {
+				fr.inria.verveine.core.gen.famix.Type fmxTArg = dico.ensureFamixType(targ.resolveBinding(), dico.findTypeName(targ), null, ctxt);
+				((fr.inria.verveine.core.gen.famix.ParameterizedType)fmxTyp).addArguments(fmxTArg);
 			}
-			// varType.typeArguments()
-			fmxTyp = dico.ensureFamixParameterizedType(tbnd, tname, tmpGeneric, /*owner*/ctxt);
 		}
 		else {
 			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 107)
@@ -226,7 +226,7 @@
 				name = "anonymous(" + name + ")";
 			}
 		}
-		
+
 		if (name.equals(OBJECT_NAME)) {
 			return ensureFamixClassObject(bnd);
 		}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 106)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 107)
@@ -1,5 +1,5 @@
 <?xml version="1.0"?>
-<project name="verveine.extractor.java" default="main" basedir=".">
+<project name="verveine.extractor.java" default="compile" basedir=".">
 	<!-- Sets variables which can later be used. -->
 	<!-- The value of a property is accessed via ${} -->
 	<property name="src.dir"      location="src" />
@@ -80,9 +80,4 @@
 		</junit>
 	</target>
 
-
-	<target name="main" depends="junit">
-		<description>Main target</description>
-	</target>
-
 </project>
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 16)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 17)
@@ -10,8 +10,10 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
 import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
@@ -24,6 +26,7 @@
 import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
 
 /**
  * A dictionnary of Famix entities to help create them and find them back
@@ -214,7 +217,17 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
-		return (fr.inria.verveine.core.gen.famix.Class) ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+		if (fmx != null) {
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.FALSE);
+		}
+
+		return fmx;
 	}
 
 	/**
@@ -355,6 +368,50 @@
 		return acc;
 	}
 
+	/**
+	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception declared to be thrown
+	 * @return the DeclaredException
+	 */
+	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		DeclaredException decl = new DeclaredException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix CaughtException between a method and an Exception that is caught
+	 * @param meth -- the method catching the exception
+	 * @param excep -- the exception caught
+	 * @return the CaughtException
+	 */
+	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		CaughtException decl = new CaughtException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
+	 * Note: DeclaredException indicates that the method declares it can throw the exception,
+	 * here we state that the exception is actually thrown
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception thrown
+	 * @return the ThrownException
+	 */
+	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		ThrownException decl = new ThrownException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
 	///// Special Case: ImplicitVariables /////
 
 	/**
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh	(revision 102)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh	(revision 103)
@@ -9,7 +9,8 @@
 
 # Directory for verveine source
 BASELIB=`dirname $0`/lib
-
+VVCORE=`dirname $0`/../verveine.core/bin
+VVJAVA=`dirname $0`/../verveine.extractor.java/bin
 
 # JVM options e.g. -Xmx2500m to augment maximum memory size of the vm to 2.5Go.
 JOPT=""
@@ -35,11 +36,10 @@
 	JOPT=""
 fi
 
-CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.extractor.java.jar"
+CLASSPATH="${CLASSPATH}:${VVJAVA}"
 CLASSPATH="${CLASSPATH}:${BASELIB}/fame.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/akuhn-util-r28011.jar"
-CLASSPATH="${CLASSPATH}:${BASELIB}/famix.jar"
-CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.core.jar"
+CLASSPATH="${CLASSPATH}:${VVCORE}"
 CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.jdt.core_3.6.0.v_A58.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.jobs_3.5.0.v20100515.jar"
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 102)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 103)
@@ -112,18 +112,18 @@
 		for (fr.inria.verveine.core.gen.famix.Class c : TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class)) {
 			//System.out.println("class -- "+c.getName());
 		}
-		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
-		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
-		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
-		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
+		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo, fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
+		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo, PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo, Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo, Attribute.class).size());//10+{System.out}
+		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo, Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo, Parameter.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo, Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo, Inheritance.class).size());//6 internal + 24 from imported packages/classes
+		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo, Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo, LocalVariable.class).size());
+		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo, AnnotationType.class).size()); //Override
+		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo, AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
 	}
 
 	@Test
@@ -606,6 +606,7 @@
 		}
 		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
 		assertNotNull(clazz);
+		assertEquals(5, clazz.getMethods().size());
 		for (Method method : clazz.getMethods()) {
 			annInstances = method.getAnnotationInstances();
 			if (method.getName().equals("isDestinationFor")) {
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 102)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 103)
@@ -5,7 +5,6 @@
 
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 102)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 103)
@@ -84,7 +84,7 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
-//		System.err.println("TRACE, DefVisiting CompilationUnit");
+		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
 		Namespace fmx = null;
 		PackageDeclaration pckg = node.getPackage();
 		if (pckg==null) {
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 25)
+++ verveine.extractor.java/.classpath	(revision 26)
@@ -15,5 +15,6 @@
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/verveinej.sh
===================================================================
--- verveine.extractor.java/verveinej.sh	(revision 25)
+++ verveine.extractor.java/verveinej.sh	(revision 26)
@@ -37,6 +37,7 @@
 
 CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.extractor.java.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/fame.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/akuhn-util-r28011.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/famix.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.core.jar"
 CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.jdt.core_3.6.0.v_A58.jar"
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 25)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 26)
@@ -47,6 +47,10 @@
 
 	private Repository repo;
 
+	public VerveineJTest_LanModel() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
 	/**
 	 * @throws java.lang.Exception
 	 */
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 105)
@@ -2,11 +2,6 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/">
-		<attributes>
-			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
-		</attributes>
-	</classpathentry>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
@@ -15,7 +10,9 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
+	<classpathentry kind="lib" path="lib/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
+	<classpathentry kind="lib" path="lib/junit.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/junit.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/junit.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 105)
@@ -36,6 +36,7 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -97,8 +98,9 @@
 				};
 		
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(args);
+		parser.parse();
 		
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
@@ -106,9 +108,6 @@
 
 	@Test
 	public void testEntitiesNumber() {
-		for (Method c : TestVerveineUtils.selectElementsOfType(repo,Method.class)) {
-			//System.out.println("meth -- "+c.getBelongsTo()+"::"+c.getSignature());
-		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo, fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
 		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo, PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo, Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
@@ -278,7 +277,7 @@
 		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
 		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
-		assertEquals(8, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Appendable,CharSequence
+		assertEquals(9, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 105)
@@ -53,8 +53,9 @@
 	public void setUp() throws Exception {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/ad_hoc"});
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(new String[] {"test_src/ad_hoc"});
+		parser.parse();
 		repo.exportMSE(new FileWriter(VerveineJParser.OUTPUT_FILE));
 	}
 
@@ -163,8 +164,11 @@
 	public void testParameterizableClass() {
 		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
 		assertNotNull(dico);
+		for (Type t : dico.getTypes()) {
+			System.out.println("dico type: "+t.getName());
+		}
 		assertEquals("Dictionary", dico.getName());
-		assertEquals(2, dico.getTypes().size());
+		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
 		assertEquals(1, dico.getParameters().size());
 		
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 105)
@@ -251,10 +251,6 @@
 		if (retTyp == null) {
 			fmxTyp = null;
 		}
-		else if (retTyp.isParameterizedType()) {
-			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
-			fmxTyp = dico.ensureFamixParameterizedType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
-		}
 		else {
 			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
 		}
@@ -307,7 +303,7 @@
 		}
 		super.endVisit(node);
 	}
-	
+
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
@@ -354,9 +350,17 @@
 
 		fr.inria.verveine.core.gen.famix.Type fmxTyp;
 		if (varTyp.isParameterizedType()) {
-			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
-			fmxTyp = dico.ensureFamixParameterizedType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
-			// TODO treat ParameterTypes
+			ITypeBinding tbnd = varTyp.resolveBinding();
+			String tname = dico.findTypeName(varTyp);
+			ParameterizableClass tmpGeneric = null;
+			if (tbnd != null) {
+				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(tbnd.getErasure(), tname, /*owner*/null, /*isGeneric*/true);
+			}
+			else {
+				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(null, tname, /*owner*/null, /*isGeneric*/true);
+			}
+			// varType.typeArguments()
+			fmxTyp = dico.ensureFamixParameterizedType(tbnd, tname, tmpGeneric, /*owner*/ctxt);
 		}
 		else {
 			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 105)
@@ -152,7 +152,7 @@
 		}
 
 		if (bnd.isParameterizedType()) {
-			return ensureFamixParameterizedType(bnd, name, (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true), owner);
+			return ensureFamixParameterizedType(bnd, name, /*generic*/null, owner);
 		}
 
 		// it seems wise to test isClass after isGenericType, isParameterizedType, ... ? 
@@ -261,18 +261,18 @@
 		}
 
 		// --------------- superclasses (including interfaces)
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		Collection<Type> sups = new LinkedList<Type>();
 		if (! bnd.isInterface()) {
 			ITypeBinding supbnd = bnd.getSuperclass();
 			if (supbnd != null) {
-				sups.add((Class)ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
+				sups.add(ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
 			}
 			else {
 				sups.add( ensureFamixClassObject(null));
 			}
 		}
 		for (ITypeBinding intbnd : bnd.getInterfaces()) {
-			sups.add( (Class)ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); // intbnd.isGenericType()));
+			sups.add( ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/owner));
 		}
 
 		// --------------- recover from name ?
@@ -295,7 +295,7 @@
 			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setIsInterface(bnd.isInterface());
 			Inheritance lastInheritance = null;
-			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+			for (Type sup : sups) {
 				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
@@ -353,6 +353,11 @@
 			}
 		}
 
+		// --------------- generic
+		if (generic == null) {
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+		}
+
 		// --------------- recover from name ?
 		for (ParameterizedType candidate : getEntityByName(ParameterizedType.class, name) ) {
 			if ( checkAndMapType(bnd, candidate) ) {
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 105)
@@ -1,9 +1,13 @@
 package fr.inria.verveine.extractor.java;
 
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTParser;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 import fr.inria.verveine.core.VerveineParser;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -20,35 +24,83 @@
 	 * The arguments that were passed to the parser
 	 * Needed to relativize the source file names
 	 */
-	private String[] initialArgs;
+	private Collection<String> sourceFiles;
 	
-	public static void main(String[] args) {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		parser.outputMSE();
+	private ASTParser jdtParser = null;
+	
+	public VerveineJParser() {
+		super();
+
+		jdtParser = ASTParser.newParser(AST.JLS3);
 	}
+	
+	public void setOptions(String[] args) {
+		// we assume java 1.5 code for now, this should be configurable
+		@SuppressWarnings("unchecked")
+		Map<String,String> options = JavaCore.getOptions();
+		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
+		jdtParser.setCompilerOptions(options);
 
-	private void setInitialArgs(String[] args) {
-		this.initialArgs = args;
+		Collection<String> classPath = new ArrayList<String>();
+		Collection<String> sourcePath = new ArrayList<String>();
+		sourceFiles = new ArrayList<String>();
+		for (int i=0; i < args.length; i++) {
+			String current = args[i];
+			if (current.equals("-cp")) {
+				classPath.add(args[++i]);
+			}
+			else if (current.endsWith(".java")) {
+				sourceFiles.add(current);
+			}
+			else {
+				sourcePath.add(current);
+			}
+		}
+		
+		jdtParser.setEnvironment(classPath.toArray(new String[0]), sourcePath.toArray(new String[0]), null, true);
+		jdtParser.setResolveBindings(true);
+		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
+		
+		collectJavaFiles(sourcePath, sourceFiles);
 	}
 
-	public String[] getInitialArgs() {
-		return this.initialArgs;
+	private void collectJavaFiles(Collection<String> paths, Collection<String> files) {
+		for (String p : paths) {
+			collectJavaFiles(new File(p), files);
+		}
 	}
 
-	@Override
-	public boolean compile(String[] argv) {
-		boolean ret;
+	private void collectJavaFiles(File f, Collection<String> files) {
+		if (f.isFile() && f.getName().endsWith(".java")) {
+			files.add(f.getAbsolutePath());
+		}
+		else if (f.isDirectory()){
+			for (File child : f.listFiles()) {
+				collectJavaFiles(child, files);
+			}
+		}
+		// else ignore it?
+		
+	}
+
+	public static void main(String[] args) {
+		VerveineJParser parser = new VerveineJParser();
+		parser.setOptions(args);
+		parser.parse();
+		parser.outputMSE();
+	}
+
+	public void parse() {
 		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
 		}
 
-		setInitialArgs(argv);
-		ret = super.compile(argv);
+		FamixRequestor req = new FamixRequestor(getFamixRepo(), new String[0]);
+		jdtParser.createASTs(sourceFiles.toArray(new String[0]), null, new String[0], req, null);
 		
 		this.compressNamespacesNames();
-		
-		return ret;
 	}
 
 	/**
@@ -90,41 +142,5 @@
 			}
 		}
 	}
-
-	/*
-	 *  Low-level API performing the actual parsing
-	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
-	 *  SHOULD NOT USE an internal JDT class. But I don't know how to do it otherwise
-	 */
-	public void performCompilation() {
-
-		this.compilerOptions = new CompilerOptions(this.options);
-		this.compilerOptions.performMethodsFullRecovery = false;
-		this.compilerOptions.performStatementsRecovery = false;
-
-		// NA --- beginning of parsing code --------------------------------------------------
-		String[] tmpclasspath=null;
-		if (this.checkedClasspaths!=null) {
-			tmpclasspath = new String[this.checkedClasspaths.length];
-			int i = 0;
-			for (Classpath cp : this.checkedClasspaths) {
-				tmpclasspath[i++] = cp.getPath();
-			}
-		}
-
-		ASTParser pars = ASTParser.newParser(AST.JLS3);
-		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
-				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
-				/*encodings*/null, 
-				/*includeRunningVMBootclasspath*/true);
-		pars.setResolveBindings(true);
-		pars.setKind(ASTParser.K_COMPILATION_UNIT);
-		pars.createASTs(/*sourceFilePaths*/this.filenames, 
-				/*encodings*/this.encodings, 
-				/*bindingKeys*/new String[0], 
-				/*requestor*/new FamixRequestor(getFamixRepo(), getInitialArgs()), 
-				/*monitor*/null);
-		// NA --- end of parsing code --------------------------------------------------
-	}
 	
 }
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 105)
@@ -21,9 +21,9 @@
 	}
 
 	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
+//		System.out.println("  ******* TRACE, Requestor is visiting : "+sourceFilePath+" *******");
 		
 		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
-		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
 		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 105)
@@ -0,0 +1,88 @@
+<?xml version="1.0"?>
+<project name="verveine.extractor.java" default="main" basedir=".">
+	<!-- Sets variables which can later be used. -->
+	<!-- The value of a property is accessed via ${} -->
+	<property name="src.dir"      location="src" />
+	<property name="build.dir"    location="bin" />
+	<property name="docs.dir"     location="docs" />
+	<property name="dist.dir"     location="lib" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.extractor,java.jar" />
+
+	<!-- Variables used for JUnit testin -->
+	<property name="test.dir" location="src/tests/fr/inria/verveine/extractor/java/" />
+	<property name="test.report.dir" location="testrep" />
+
+
+	<!-- Create a classpath container which can be later used in the ant task -->
+	<path id="build.classpath">
+		<fileset dir="${dist.dir}">
+			<include name="*.jar" />
+		</fileset>
+	</path>
+
+
+	<!-- Deletes the existing build, docs and dist directory-->
+	<target name="clean">
+		<delete dir="${build.dir}" />
+		<delete dir="${docs.dir}" />
+		<delete file="${verveine.jar}" />
+	</target>
+
+	<!-- Creates the  build, docs and dist directory-->
+	<target name="makedir">
+		<mkdir dir="${build.dir}" />
+		<mkdir dir="${docs.dir}" />
+		<mkdir dir="${test.report.dir}" />
+	</target>
+
+	<!-- copies the jar from verveine.core -->
+	<target name="corejars" depends="makedir">
+		<copy todir="${dist.dir}" file="../verveine.core/lib/famix.jar"/>
+		<copy todir="${dist.dir}" file="../verveine.core/lib/verveine.core.jar"/>
+	</target>
+
+	<!-- Compiles the java code (including the usage of library for JUnit -->
+	<target name="compile" depends="clean, corejars">
+		<javac srcdir="${src.dir}" destdir="${build.dir}" classpathref="build.classpath">
+		</javac>
+	</target>
+
+	<!-- Creates Javadoc -->
+	<target name="docs" depends="compile">
+		<javadoc packagenames="src" sourcepath="${src.dir}" destdir="${docs.dir}">
+			<!-- Define which files / directory should get included, we include all -->
+			<fileset dir="${src.dir}">
+				<include name="**" />
+			</fileset>
+		</javadoc>
+	</target>
+
+	<!--Creates the deployable jar file  -->
+	<target name="jar" depends="compile">
+		<jar destfile="${verveine.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/extractor/java/*.class"/>
+		</jar>
+	</target>
+
+	<!-- Run the JUnit Tests -->
+	<!-- Output is XML, could also be plain-->
+	<target name="junit" depends="compile">
+		<junit printsummary="on" fork="true" haltonfailure="no">
+			<classpath>
+				<pathelement path="${build.dir}"/>
+				<fileset dir="${dist.dir}">
+  				  <include name="*.jar"/>
+				</fileset>
+			</classpath>
+			<formatter type="plain" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel" todir="${test.report.dir}" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc" todir="${test.report.dir}" />
+		</junit>
+	</target>
+
+
+	<target name="main" depends="junit">
+		<description>Main target</description>
+	</target>
+
+</project>
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 47)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 48)
@@ -9,6 +9,7 @@
 import static org.junit.Assert.assertSame;
 
 import java.io.File;
+import java.util.Collection;
 
 import org.junit.After;
 import org.junit.Before;
@@ -16,6 +17,9 @@
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.CaughtException;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
 import fr.inria.verveine.core.gen.famix.Method;
@@ -77,5 +81,108 @@
 		assertSame(meth, exC.getDefiningMethod());
 		assertSame(excepClass, exC.getExceptionClass());
 	}
-
-}
+	
+	@Test
+	public void testAnnotation() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<AnnotationInstance> annInstances;
+		
+		AnnotationType annTypeOverride = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
+		assertNotNull(annTypeOverride);
+		assertEquals("Override", annTypeOverride.getName());
+		
+		AnnotationType annTypeDeprecated = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Deprecated");
+		assertNotNull(annTypeDeprecated);
+		assertEquals("Deprecated", annTypeDeprecated.getName());
+		
+		//Annotations to the class
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Client");
+		assertNotNull(clazz);
+		annInstances = clazz.getAnnotationInstances();
+		assertEquals(2, annInstances.size());
+		for (AnnotationInstance annotationInstance : annInstances) {
+			assertSame(clazz, annotationInstance.getAnnotatedEntity());
+			if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+				assertEquals("Override", annotationInstance.getAnnotationType().getName());
+				assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+			} else {
+				assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+				assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+			}
+		}
+		//Annotations to the attributes
+		for (Attribute attribute : clazz.getAttributes()) {
+			annInstances = attribute.getAnnotationInstances();
+			if (attribute.getName().equals("num")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
+					assertSame(attribute, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (attribute.getName().equals("nom")) {
+				assertEquals(1, annInstances.size());
+				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
+					assertSame(attribute, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+		//Annotations to the methods
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("Client")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (method.getName().equals("lire")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (method.getName().equals("setNum")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			}else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+	}
+}
\ No newline at end of file
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 12)
+++ verveine.extractor.java/.classpath	(revision 13)
@@ -13,7 +13,7 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 12)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 13)
@@ -25,6 +25,7 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
@@ -225,6 +226,13 @@
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(clazz);
 		assertFalse(clazz.getIsStub());
+		
+		/* [].length notused in the default test case 
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
+		assertNotNull(att);
+		clazz = (Class) att.getParentType();
+		assertNotNull(clazz);
+		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
 	}
 
 	@Test
@@ -438,7 +446,6 @@
 		assertFalse(a.getIsFinal());
 	}
 
-
 	@Test
 	public void testMetric() {	
 		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 101)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 102)
@@ -5,10 +5,7 @@
 import java.util.LinkedList;
 import java.util.Map;
 
-import org.eclipse.jdt.core.dom.ITypeBinding;
-
 import ch.akuhn.fame.Repository;
-
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
 import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
@@ -338,14 +335,16 @@
 		AnnotationInstanceAttribute fmx = new AnnotationInstanceAttribute();
 		fmx.setAnnotationTypeAttribute(att);
 		fmx.setValue(value);
+		this.famixRepo.add(fmx);
 		return fmx;
 	}
 
 	public AnnotationInstance addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
 		AnnotationInstance inst = new AnnotationInstance();
-		inst.setAnnotatedEntity(annType);
+		inst.setAnnotationType(annType);
 		inst.setAnnotatedEntity(fmx);
 		inst.addAttributes(annAtts);
+		this.famixRepo.add(inst);
 		return inst;
 	}
 
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 15)
+++ verveine.extractor.java/.classpath	(revision 16)
@@ -13,7 +13,7 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 15)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 16)
@@ -25,7 +25,7 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
@@ -447,6 +447,27 @@
 	}
 
 	@Test
+	public void testComment() {	
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		Collection<Comment> cmts = clazz.getComments();
+		assertEquals(1, cmts.size());
+		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(10, ((FileAnchor)anc).getEndLine());
+
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
+		assertNotNull(meth);
+		cmts = meth.getComments();
+		assertEquals(1, cmts.size());
+		anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(31, ((FileAnchor)anc).getStartLine());
+		assertEquals(34, ((FileAnchor)anc).getEndLine());
+
+	}
+	
+
+	@Test
 	public void testMetric() {	
 		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
 			assertNotNull(m);
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 15)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 16)
@@ -27,7 +27,6 @@
 import org.eclipse.jdt.core.dom.SwitchCase;
 import org.eclipse.jdt.core.dom.SwitchStatement;
 import org.eclipse.jdt.core.dom.SynchronizedStatement;
-import org.eclipse.jdt.core.dom.TagElement;
 import org.eclipse.jdt.core.dom.ThrowStatement;
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
@@ -39,6 +38,7 @@
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -109,9 +109,10 @@
 			fmx.setContainer( context.top());
 		}
 		dico.addSourceAnchor(fmx, node);
-		if (context.getLastComment() != null) {
-			dico.createFamixComment(context.getLastComment(), fmx);
-			context.clearLastComment();
+		Javadoc jdoc = node.getJavadoc();
+		if (jdoc != null) {
+			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
+			dico.addSourceAnchor(cmt, jdoc);
 		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
@@ -172,9 +173,10 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
-			if (context.getLastComment() != null) {
-				dico.createFamixComment(context.getLastComment(), fmx);
-				context.clearLastComment();
+			Javadoc jdoc = node.getJavadoc();
+			if (jdoc != null) {
+				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
+				dico.addSourceAnchor(cmt, jdoc);
 			}
 			this.context.pushMethod(fmx);
 			if (node.getBody() != null) {
@@ -212,9 +214,10 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
-			if (context.getLastComment() != null) {
-				dico.createFamixComment(context.getLastComment(), fmx);
-				context.clearLastComment();
+			Javadoc jdoc = node.getJavadoc();
+			if (jdoc != null) {
+				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
+				dico.addSourceAnchor(cmt, jdoc);
 			}
 		}
 		return super.visit(node);
@@ -256,18 +259,6 @@
 		}
 	}
 
-	@Override
-	@SuppressWarnings("unchecked")
-	public boolean visit(Javadoc node) {
-		String comment = "/** ";
-		for (TagElement tag : (List<TagElement>)node.tags()) {
-			comment += tag.toString();
-		}
-		comment += "\n */";
-		this.context.setLastComment(comment);
-		return super.visit(node);
-	}
-
 
 	// METRICS: CYCLO, NOS
 	
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 104)
@@ -99,32 +99,26 @@
 		}
 	}
 
+	/**
+	 * Resets the dictionnary in a proper state after loading entities from an existing MSE file:
+	 * <UL>
+	 * <li>map all named entities to their names in <b>mapName</b></li>
+	 * <li>reset some boolean properties (e.g. <b>isStub</b>) that are false (they are not saved in the mse file and therefore not initialized)</li>
+	 * </ul>
+	 */
 	protected void recoverExistingRepository() {
-		for (Object obj : famixRepo.getElements()) {
-			if (obj instanceof NamedEntity) {
-				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
-			}
-		}
-		
-		for (Access acc : famixRepo.all(Access.class)) {
-			try {
-				if (acc.getIsWrite()) { }
-			}
-			catch (NullPointerException e) {
-				acc.setIsWrite(Boolean.FALSE);
-			}
-		}
-
-		for (Method meth : famixRepo.all(Method.class)) {
-			try { if (meth.getIsStub()) { } }
-			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
+		for (NamedEntity ent : famixRepo.all(NamedEntity.class)) {
+			mapEntityToName( ent.getName(), ent);
+			// for the Exception to be raised, the return value must be tested
+			try { if (ent.getIsStub()) {} }
+			catch (NullPointerException e) { ent.setIsStub(Boolean.FALSE); }
 		}
 
-		for (Attribute att : famixRepo.all(Attribute.class)) {
-			try { if (att.getIsStub()) { } }
-			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
+		for (Access acc : famixRepo.all(Access.class)) {
+			// for the Exception to be raised, the return value must be tested
+			try { if (acc.getIsWrite()) {}	}
+			catch (NullPointerException e) { acc.setIsWrite(Boolean.FALSE); }
 		}
-
 	}
 	
 	protected void mapEntityToName(String name, NamedEntity ent) {
@@ -526,14 +520,6 @@
 		return acc;
 	}
 
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
-		return ensureFamixAccess(accessor, var, isWrite, null);
-	}
-	
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
-		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
-	}
-
 	private void chainPrevNext(Association prev, Association next) {
 		if (prev != null) {
 			next.setPrevious(prev);  // not yet implemented in importer
@@ -726,13 +712,6 @@
 		return fmx;
 	}
 
-
-
-
-
-
-
-
 	public Type searchTypeInContext(String name, ContainerEntity ctxt) {
 		if (ctxt == null) {
 			return null;
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 104)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/">
 		<attributes>
 			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
 		</attributes>
@@ -14,7 +14,7 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 104)
@@ -59,7 +59,7 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
-		/*String[] files = new String[] {
+		String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -71,15 +71,17 @@
 				"server/PrintServer.java"
 		};
 
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+
 		// separate parsing of each source file --------
 		for (String f : files) {
 			parseFile(f);
-		}*/
-		
+		}
+
 		// or parsing the entire project in one pass ---
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
-		repo = parser.getFamixRepo();
+		//VerveineJParser parser = new VerveineJParser();
+		//parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
+		//repo = parser.getFamixRepo();
 	}
 
 	/**
@@ -102,15 +104,10 @@
 		parser.outputMSE();  // to create a new one
 	}
 
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
 	@Test
 	public void testEntitiesNumber() {
-		for (fr.inria.verveine.core.gen.famix.Class c : TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class)) {
-			//System.out.println("class -- "+c.getName());
+		for (Method c : TestVerveineUtils.selectElementsOfType(repo,Method.class)) {
+			//System.out.println("meth -- "+c.getBelongsTo()+"::"+c.getSignature());
 		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo, fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
 		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo, PrimitiveType.class).size());//int,boolean,void
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 104)
@@ -73,7 +73,7 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
-		System.err.println("TRACE, RefVisiting CompilationUnit");
+//		System.err.println("TRACE, RefVisiting CompilationUnit");
 
 		PackageDeclaration pckg = node.getPackage();
 		Namespace fmx = null;
@@ -129,7 +129,7 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		System.err.println("TRACE, RefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, RefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
 		if (fmx != null) {
@@ -151,7 +151,7 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-		System.err.println("TRACE, RefVisiting ClassInstanceCreation");
+//		System.err.println("TRACE, RefVisiting ClassInstanceCreation");
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
 			ITypeBinding bnd = decl.resolveBinding();
@@ -178,7 +178,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		System.err.println("TRACE, RefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, RefVisiting MethodDeclaration: "+node.getName().getIdentifier());
 
 		IMethodBinding bnd = node.resolveBinding();
 		Method meth = (Method) dico.getEntityByKey(bnd);
@@ -211,7 +211,7 @@
 
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
-		System.err.println("TRACE, RefVisiting FieldDeclaration: ");
+//		System.err.println("TRACE, RefVisiting FieldDeclaration: ");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
 			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
@@ -243,7 +243,7 @@
 	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/null);  // cast needed to desambiguate the call
 			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
@@ -384,7 +384,7 @@
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.ensureFamixAttribute(bnd, varName, null, null);//TODO should be ensureAttribute
+					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);//TODO should be ensureAttribute
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
 					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 104)
@@ -84,7 +84,7 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
-		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
+//		System.err.println("TRACE, DefVisiting CompilationUnit: "+node.getProperty(dico.SOURCE_FILENAME_PROPERTY));
 		Namespace fmx = null;
 		PackageDeclaration pckg = node.getPackage();
 		if (pckg==null) {
@@ -112,7 +112,7 @@
 	public boolean visit(TypeDeclaration node) {
 		// Can only be a class or interface declaration
 
-		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		@SuppressWarnings("unchecked")
 		List<TypeParameter> tparams = node.typeParameters();
@@ -127,6 +127,8 @@
 			
 			for (TypeParameter tp : tparams) {
 				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
+				// FIXME But types created with ensureFamixType cannot be ParameterizableClasses because the bindings of JDT
+				//       don't contain the proper information (isGeneric() return false :-) )
 				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note owner of the ParameterType is the ParameterizableClass
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
@@ -146,7 +148,7 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
 		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
@@ -174,7 +176,7 @@
 	}
 
 	public boolean visit(AnnotationTypeDeclaration node) {
-		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
@@ -195,7 +197,7 @@
 	}
 
 	public boolean visit(AnnotationTypeMemberDeclaration node) {
-		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
 		IMethodBinding bnd = node.resolveBinding();
 		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
 		if (fmx != null) {
@@ -217,7 +219,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(EnumDeclaration node) {
-		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
 		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(Boolean.FALSE);
@@ -235,7 +237,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
 		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
@@ -308,7 +310,7 @@
 	
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
-		System.err.println("TRACE, DefVisiting FieldDeclaration");
+//		System.err.println("TRACE, DefVisiting FieldDeclaration");
 
 		for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
 			dico.addSourceAnchor(att, node);
@@ -319,7 +321,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
-		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+//		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
@@ -334,7 +336,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
-		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+//		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 103)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 104)
@@ -164,7 +164,6 @@
 		return super.ensureFamixType(bnd, name, owner);
 	}
 
-
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding.
 	 * The Entity is created if it does not exist.<br>
@@ -824,8 +823,8 @@
 					sig += parBnd.getName();
 					first = false;
 				}
-				sig += ")";
 			}
+			sig += ")";
 			if (! ((Method) candidate).getSignature().equals(sig)) {
 				return false;
 			}
@@ -887,7 +886,7 @@
 
 		ContainerEntity candidateOwner = candidate.getBelongsTo();
 		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidateOwner  instanceof Method) ) {
+		if ( (methBnd != null) && (candidateOwner instanceof Method) ) {
 			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 28)
+++ verveine.extractor.java/.classpath	(revision 29)
@@ -15,6 +15,5 @@
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
-	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 28)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 29)
@@ -410,7 +410,7 @@
 		assertNotNull(anc);
 		assertSame(clazz, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
+		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/server/PrintServer.java"));
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
 		assertEquals(31, ((FileAnchor)anc).getEndLine());
 
@@ -421,7 +421,7 @@
 		assertNotNull(anc);
 		assertSame(clazz, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/Node.java"));
 		assertEquals(6, ((FileAnchor)anc).getStartLine());
 		assertEquals(70, ((FileAnchor)anc).getEndLine());
 		
@@ -432,7 +432,7 @@
 		assertNotNull(anc);
 		assertSame(meth, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
+		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/SingleDestinationAddress.java"));
 		assertEquals(39, ((FileAnchor)anc).getStartLine());
 		assertEquals(41, ((FileAnchor)anc).getEndLine());
 		
@@ -443,7 +443,7 @@
 		assertNotNull(anc);
 		assertSame(att, anc.getElement());
 		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
+		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/Packet.java"));
 		assertEquals(15, ((FileAnchor)anc).getStartLine());
 		assertEquals(15, ((FileAnchor)anc).getEndLine());
 		
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 28)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 29)
@@ -104,7 +104,7 @@
 			importBnd = ((ITypeBinding)importBnd).getPackage();
 		}
 
-		this.dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd));
+		context.setLastAssoc( dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd), context.getLastAssoc()) );
 		
 		return super.visit(node);
 	}
@@ -380,7 +380,7 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
 			if (accessed != null) {
-				dico.ensureFamixAccess(accessor, accessed);
+				context.setLastAssoc( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAssoc()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
@@ -401,9 +401,7 @@
 			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(name);
 			}
-			/* An example of how to include location information to an invocation
-			 * But would require to pass the ASTNode in parameter to this method */
-			/*dico.addSourceAnchor(*/ dico.ensureFamixInvocation(sender, invoked, receiver) /*,node)*/ ;
+			context.setLastAssoc( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastAssoc()) );
 		}
 	}
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 28)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 29)
@@ -16,19 +16,35 @@
 
 public class VerveineJParser extends VerveineParser {
 
+	/**
+	 * The arguments that were passed to the parser
+	 * Needed to relativize the source file names
+	 */
+	private String[] initialArgs;
+	
 	public static void main(String[] args) {
 		VerveineJParser parser = new VerveineJParser();
 		parser.compile(args);
 		parser.outputMSE();
 	}
+
+	private void setInitialArgs(String[] args) {
+		this.initialArgs = args;
+	}
+
+	public String[] getInitialArgs() {
+		return this.initialArgs;
+	}
 	
+
 	@Override
 	public boolean compile(String[] argv) {
 		boolean ret;
 		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
 		}
-		
+
+		setInitialArgs(argv);
 		ret = super.compile(argv);
 		
 		this.compressNamespacesNames();
@@ -107,7 +123,7 @@
 		pars.createASTs(/*sourceFilePaths*/this.filenames, 
 				/*encodings*/this.encodings, 
 				/*bindingKeys*/new String[0], 
-				/*requestor*/new FamixRequestor(getFamixRepo()), 
+				/*requestor*/new FamixRequestor(getFamixRepo(), getInitialArgs()), 
 				/*monitor*/null);
 		// NA --- end of parsing code --------------------------------------------------
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 28)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 29)
@@ -10,16 +10,30 @@
 	protected Repository famixRepo;
 	
 	protected JavaDictionary famixDictionnary;
+
+	private String[] initialArgs;
 	
-	public FamixRequestor(Repository r) {
+	public FamixRequestor(Repository r, String[] initialArgs) {
 		this.famixRepo = r;
+		this.initialArgs = initialArgs;
 		this.famixDictionnary = new JavaDictionary(famixRepo);
 	}
 
 	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
-		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, sourceFilePath);
+		
+		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
 		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
 		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
+
+	private Object relativePath(String sourceFilePath) {
+		for (String arg : initialArgs) {
+			int i = sourceFilePath.indexOf(arg);
+			if (i >= 0) {
+				return sourceFilePath.substring(i);
+			}
+		}
+		return sourceFilePath;
+	}
 }
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt	(revision 100)
@@ -1,54 +0,0 @@
-
-memory usage for Eclipse 3.1
-$ time ./verveinej3_1.sh 2> toto.log >&2
-$ time ./verveinej-mono-3_1.sh 2> toto.log >&2
-
-120.51user 3.31system 2:25.05elapsed 85%CPU 
-(0avgtext+0avgdata 9.646.080maxresident)k
-292144inputs+221248outputs (2356major+700607minor)pagefaults 0swaps
-8522 toto.log
-
-120.79user 2.95system 1:53.51elapsed 109%CPU 
-(0avgtext+0avgdata 9.175.040maxresident)k
-142416inputs+220976outputs (87major+622960minor)pagefaults 0swaps
-8522 toto.log
-3.340.182 output.mse
-
-112.33user 4.35system 1:40.17elapsed 116%CPU 
-(0avgtext+0avgdata 9.777.152maxresident)k
-68760inputs+221504outputs (190major+682907minor)pagefaults 0swaps
-
-$ for i in `grep FAMIX output.mse | sed -e 's/ (id:.*//' | sed -e 's/^        (//' | sort -u`; do echo -n "$i   "; grep -c $i output.mse ; done
-FAMIX.Access   60984
-FAMIX.Attribute   27473
-FAMIX.CaughtException   3690
-FAMIX.Class   7906
-FAMIX.Comment   37000
-FAMIX.DeclaredException   3848
-FAMIX.FileAnchor   124493
-FAMIX.ImplicitVariable   4996
-FAMIX.Inheritance   7136
-FAMIX.Invocation   169940
-FAMIX.LocalVariable   37753
-FAMIX.Method   53602
-FAMIX.Namespace   377
-FAMIX.Parameter   52480
-FAMIX.PrimitiveType   9
-FAMIX.Reference   30799
-FAMIX.ThrownException   2414
-FAMIX.UnknownVariable   23090
-FAMIX   647990
-
-$ grep -c 'null binding' toto.log 
-8413
-
-
-=======================================
-SEPARATE
-
-2041.59user 115.58system 27:47.42elapsed 129%CPU 
-(0avgtext+0avgdata 7.086.080maxresident)k
-135200inputs+6149832outputs (110major+16978083minor)pagefaults 0swaps
-
-
-FAMIX.Attribute   27520
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 100)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/">
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
 		<attributes>
 			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
 		</attributes>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 100)
@@ -165,7 +165,7 @@
 	public void testNamedEntities() {
 		JavaDictionary dico = new JavaDictionary(repo);
 		
-		assertNotSame(dico.createFamixClass(null, A_CLASS_NAME, null),dico.createFamixClass(null, A_CLASS_NAME, null));
+		assertNotSame(dico.ensureFamixClass(null, A_CLASS_NAME, null),dico.ensureFamixClass(null, A_CLASS_NAME, null));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
 		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
@@ -177,9 +177,9 @@
 		assertEquals(0, obj.getSuperInheritances().size());
 		assertSame(javaLang, obj.getContainer());
 		
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.createFamixClassStubOwner();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
 		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
-		assertSame(fmx, dico.createFamixClassStubOwner());
+		assertSame(fmx, dico.ensureFamixClassStubOwner());
 	}
 
 	@Test
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 100)
@@ -78,7 +78,7 @@
 		PackageDeclaration pckg = node.getPackage();
 		Namespace fmx = null;
 		if (pckg==null) {
-			 fmx = dico.createFamixNamespaceDefault();
+			 fmx = dico.ensureFamixNamespaceDefault();
 		}
 		else {
 			fmx = (Namespace)dico.getEntityByKey(pckg.resolveBinding());
@@ -123,7 +123,7 @@
 			importName = dico.removeLastName(importName);
 		}
 		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.createFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
@@ -166,7 +166,7 @@
 				return false;
 			}
 		}
-		else {
+		else {// TODO appears to be a new: class reference
 			return super.visit(node);
 		}
 	}
@@ -190,9 +190,9 @@
 
 			// Exceptions
 			for (Name excepName : (List<Name>)node.thrownExceptions()) {
-				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.createFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
 				if (excepFmx != null) {
-					dico.createFamixDeclaredException(meth, excepFmx);
+					dico.ensureFamixDeclaredException(meth, excepFmx);
 				}
 			}
 			return super.visit(node);
@@ -230,7 +230,7 @@
 
 	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
 		return super.visit(node);
 	}
 
@@ -244,18 +244,7 @@
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
 			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			/* TODO old code, may not be valid anymore ...
-			   if (invoked == null) {
-				if (receiver != null && receiver.getName().equals("self")) {
-					receiver = this.context.topClass();
-				}
-				invoked = this.dico.ensureFamixMethod(calledName, receiver, list);
-				//invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			if (invoked == null) {
-				invoked = this.dico.ensureFamixStubMethod(calledName);
-			}*/
-			context.setLastInvocation( dico.createFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
@@ -283,13 +272,13 @@
 		if (meth != null) {
 			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
 			if (excepClass instanceof SimpleType) {
-				excepFmx = this.dico.createFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
 			}
 			else if (excepClass instanceof QualifiedType) {
-				excepFmx = this.dico.createFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
-				dico.createFamixCaughtException(meth, excepFmx);
+				dico.ensureFamixCaughtException(meth, excepFmx);
 			}
 		}
 
@@ -299,9 +288,9 @@
 	@Override
 	public boolean visit(ThrowStatement node) {
 		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.createFamixClass(node.getExpression().resolveTypeBinding(), null, null);
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
-			dico.createFamixThrownException(meth, excepFmx);
+			dico.ensureFamixThrownException(meth, excepFmx);
 		}
 		return super.visit(node);
 	}
@@ -316,7 +305,7 @@
 	private NamedEntity getReceiver(Expression expr) {
 		// msg(), same as ThisExpression
 		if (expr == null) {
-			return this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
 		}
 
 		// array[i].msg()
@@ -390,12 +379,12 @@
 			if (bnd instanceof ITypeBinding) {
 				// msg() is a static method of Name
 				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
+				ret = dico.ensureFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
 			}
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.createFamixAttribute(bnd, varName, null, null);
+					ret = dico.ensureFamixAttribute(bnd, varName, null, null);//TODO should be ensureAttribute
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
 					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -437,7 +426,7 @@
 		
 		// this.msg()
 		else if (expr instanceof ThisExpression) {
-			return this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
 		}
 
 		// type.class.msg()
@@ -463,7 +452,7 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
-				context.setLastAccess( dico.createFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 100)
@@ -88,7 +88,7 @@
 		Namespace fmx = null;
 		PackageDeclaration pckg = node.getPackage();
 		if (pckg==null) {
-			fmx = dico.createFamixNamespaceDefault();
+			fmx = dico.ensureFamixNamespaceDefault();
 		}
 		else {
 			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
@@ -112,7 +112,7 @@
 	public boolean visit(TypeDeclaration node) {
 		// Can only be a class or interface declaration
 
-		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		@SuppressWarnings("unchecked")
 		List<TypeParameter> tparams = node.typeParameters();
@@ -123,11 +123,11 @@
 			this.context.pushClass(fmx);
 
 			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+			dico.ensureFamixComment(node.getJavadoc(), fmx);
 			
 			for (TypeParameter tp : tparams) {
 				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
-				ParameterType fmxParam = dico.createFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note owner of the ParameterType is the ParameterizableClass
+				ParameterType fmxParam = dico.ensureFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note owner of the ParameterType is the ParameterizableClass
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
 				}
@@ -146,7 +146,7 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-		//System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
 		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
@@ -174,7 +174,7 @@
 	}
 
 	public boolean visit(AnnotationTypeDeclaration node) {
-		//System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+		System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
@@ -195,7 +195,7 @@
 	}
 
 	public boolean visit(AnnotationTypeMemberDeclaration node) {
-		//System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+		System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
 		IMethodBinding bnd = node.resolveBinding();
 		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
 		if (fmx != null) {
@@ -217,8 +217,8 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(EnumDeclaration node) {
-//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Enum fmx = dico.createFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(Boolean.FALSE);
 			
@@ -235,7 +235,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
 		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
@@ -273,7 +273,7 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+			dico.ensureFamixComment(node.getJavadoc(), fmx);
 
 			// creating the method's parameters
 			List<VariableDeclaration> paramAsVarList;
@@ -308,18 +308,18 @@
 	
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
-//		System.err.println("TRACE, DefVisiting FieldDeclaration");
+		System.err.println("TRACE, DefVisiting FieldDeclaration");
 
 		for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
 			dico.addSourceAnchor(att, node);
-			dico.createFamixComment(node.getJavadoc(), att);
+			dico.ensureFamixComment(node.getJavadoc(), att);
 		}
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
-		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+		System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
@@ -334,7 +334,7 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
-		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+		System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
 
 		// we don't declare (local) variables that have a primitive type
 		// because we are assuming that the user is not interested in them 
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 99)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 100)
@@ -70,7 +70,7 @@
 
 	/**
 	 * Returns a Famix Namespace associated with its IPackageBinding and/or name.
-	 * The Entity is created if it does not exist (see also {@link Dictionary#createFamixNamespace(Object, String)}).
+	 * The Entity is created if it does not exist (see also {@link Dictionary#ensureFamixNamespace(Object, String)}).
 	 * Also creates or recovers recusively it's parent namespaces.<br>
 	 * At least one of <b>bnd</b> and <b>name</b> must be non null.
 	 * @param bnd -- the JDT Binding that may be used as a uniq key to recover this namespace
@@ -90,7 +90,7 @@
 			 * (for example when creating parent packages of a package we have a binding for).
 			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
 			 * all is said and done. */
-			fmx = createFamixNamespace( bnd, name);
+			fmx = super.ensureFamixNamespace( bnd, name);
 			parent = ensureFamixNamespace(null, removeLastName(name));
 			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
@@ -102,7 +102,7 @@
 	}
 
 	/**
-	 * Recovers or creates a Famix Type (see also {@link Dictionary#createFamixType(Object, String, ContainerEntity)}
+	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
 	 */
 	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner, ContainerEntity ctxt) {
 		Type fmx = null;
@@ -117,10 +117,10 @@
 			}
 
 			if ( (owner != null) && (owner instanceof ParameterizableClass) ) {
-				return createFamixParameterType(null, name, (ParameterizableClass) owner);
+				return ensureFamixParameterType(null, name, (ParameterizableClass) owner);
 			}
 			else {
-				return super.createFamixType(null, name, owner);
+				return super.ensureFamixType(null, name, owner);
 			}
 		}
 
@@ -136,15 +136,15 @@
 		}
 
 		if (bnd.isPrimitive()) {
-			return createFamixPrimitiveType(bnd, name);
+			return ensureFamixPrimitiveType(bnd, name);
 		}
 
 		if (bnd.isEnum()) {
-			return createFamixEnum(bnd, name, owner);
+			return ensureFamixEnum(bnd, name, owner);
 		}
 		
 		if (bnd.isTypeVariable() ) {
-			return createFamixParameterType(bnd, name, (ParameterizableClass) owner);
+			return ensureFamixParameterType(bnd, name, (ParameterizableClass) owner);
 		}
 
 		if (bnd.isRawType() || bnd.isGenericType()) {
@@ -161,13 +161,14 @@
 		}
 
 
-		return super.createFamixType(bnd, name, owner);
+		return super.ensureFamixType(bnd, name, owner);
 	}
 
+
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#createFamixClass(Object, String, ContainerEntity)}.
+	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner, boolean isGeneric) {
@@ -179,14 +180,14 @@
 				return null;
 			}
 			if (owner == null) {
-				owner = createFamixNamespaceDefault();
+				owner = ensureFamixNamespaceDefault();
 			}
 			
 			if (isGeneric) {
-				return super.createFamixParameterizableClass(null, name, owner);
+				return super.ensureFamixParameterizableClass(null, name, owner);
 			}
 			else {
-				return super.createFamixClass(null, name, owner);
+				return super.ensureFamixClass(null, name, owner);
 			}
 		}
 
@@ -240,7 +241,13 @@
 			else {
 				ITypeBinding parentClass = bnd.getDeclaringClass();
 				if (parentClass != null) {
-					owner = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+					if (tmpOwn instanceof ParameterizedType) {
+						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+					}
+					else {
+						owner = tmpOwn;
+					}
 				}
 				else {
 					IPackageBinding parentPckg = bnd.getPackage();
@@ -248,7 +255,7 @@
 						owner = this.ensureFamixNamespace(parentPckg, null);
 					}
 					else {
-						owner = this.createFamixNamespaceDefault();
+						owner = this.ensureFamixNamespaceDefault();
 					}
 				}
 			}
@@ -278,10 +285,10 @@
 		}
 		if (fmx == null) {
 			if (isGeneric) {
-				fmx = super.createFamixParameterizableClass(bnd, name, owner);
+				fmx = super.ensureFamixParameterizableClass(bnd, name, owner);
 			}
 			else {
-				fmx = super.createFamixClass(bnd, name, owner);
+				fmx = super.ensureFamixClass(bnd, name, owner);
 			}
 		}
 		
@@ -290,7 +297,7 @@
 			fmx.setIsInterface(bnd.isInterface());
 			Inheritance lastInheritance = null;
 			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-				lastInheritance = createFamixInheritance(sup, fmx, lastInheritance);
+				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
 			if (fmx.getIsAbstract()) {
@@ -310,7 +317,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.createFamixParameterizedType(null, name, generic, owner);
+			return super.ensureFamixParameterizedType(null, name, generic, owner);
 		}
 
 		// --------------- name
@@ -327,7 +334,13 @@
 			else {
 				ITypeBinding parentClass = bnd.getDeclaringClass();
 				if (parentClass != null) {
-					owner = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null); //parentClass.isGenericType());
+					Type tmpOwn = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+					if (tmpOwn instanceof ParameterizedType) {
+						owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+					}
+					else {
+						owner = tmpOwn;
+					}
 				}
 				else {
 					IPackageBinding parentPckg = bnd.getPackage();
@@ -335,7 +348,7 @@
 						owner = this.ensureFamixNamespace(parentPckg, null);
 					}
 					else {
-						owner = this.createFamixNamespaceDefault();
+						owner = this.ensureFamixNamespaceDefault();
 					}
 				}
 			}
@@ -350,13 +363,13 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.createFamixParameterizedType(bnd, name, generic, owner);
+			fmx = super.ensureFamixParameterizedType(bnd, name, generic, owner);
 		}
 
 		return fmx;
 	}
 
-	public PrimitiveType createFamixPrimitiveType(ITypeBinding bnd, String name) {
+	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
 		if (name == null) {
 			if (bnd == null) {
 				return null;
@@ -365,10 +378,10 @@
 				name = bnd.getName();
 			}
 		}
-		return super.createFamixPrimitiveType(bnd, name);
+		return super.ensureFamixPrimitiveType(bnd, name);
 	}
 
-	public fr.inria.verveine.core.gen.famix.Enum createFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
+	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
 		fr.inria.verveine.core.gen.famix.Enum fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
@@ -376,7 +389,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.createFamixEnum(null, name, owner);
+			return super.ensureFamixEnum(null, name, owner);
 		}
 
 		// --------------- name
@@ -393,7 +406,7 @@
 			else {
 				ITypeBinding parentClass = bnd.getDeclaringClass();
 				if (parentClass != null) {
-					owner = this.createFamixClass(parentClass, null, null);
+					owner = this.ensureFamixClass(parentClass, null, null);
 				}
 				else {
 					IPackageBinding parentPckg = bnd.getPackage();
@@ -401,7 +414,7 @@
 						owner = this.ensureFamixNamespace(parentPckg, null);
 					}
 					else {
-						owner = this.createFamixNamespaceDefault();
+						owner = this.ensureFamixNamespaceDefault();
 					}
 				}
 			}
@@ -416,7 +429,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.createFamixEnum(bnd, name, owner);
+			fmx = super.ensureFamixEnum(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -438,7 +451,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of creating an EnumValue without a declaring Enum type? 
 			}
-			return super.createFamixEnumValue(null, name, owner);
+			return super.ensureFamixEnumValue(null, name, owner);
 		}
 
 		// --------------- name
@@ -448,7 +461,7 @@
 
 		// --------------- owner
 		if (owner == null) {
-			owner = createFamixEnum(bnd.getDeclaringClass(), null, null);
+			owner = ensureFamixEnum(bnd.getDeclaringClass(), null, null);
 		}
 		
 		// --------------- recover from name ?
@@ -459,7 +472,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.createFamixEnumValue(bnd, name, owner);
+			fmx = super.ensureFamixEnumValue(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -478,7 +491,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.createFamixAnnotationType(null, name, owner);
+			return super.ensureFamixAnnotationType(null, name, owner);
 		}
 
 		// --------------- name
@@ -493,7 +506,7 @@
 				owner = this.ensureFamixNamespace(parentPckg, null);
 			}
 			else {
-				owner = this.createFamixNamespaceDefault();
+				owner = this.ensureFamixNamespaceDefault();
 			}
 		}
 
@@ -506,7 +519,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.createFamixAnnotationType(bnd, name, owner);
+			fmx = super.ensureFamixAnnotationType(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -525,7 +538,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.createFamixAnnotationTypeAttribute(null, name, owner);
+			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
 		}
 
 		// --------------- name
@@ -550,7 +563,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.createFamixAnnotationTypeAttribute(bnd, name, owner);
+			fmx = super.ensureFamixAnnotationTypeAttribute(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -561,6 +574,11 @@
 		return fmx;
 	}
 
+	/**
+	 * Adds possible annotation instances to a Famix NamedEntity with the given binding
+	 * @param bnd
+	 * @param fmx
+	 */
 	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
 		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
 			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
@@ -574,7 +592,7 @@
 		}
 	}
 
-	public ParameterType createFamixParameterType(ITypeBinding bnd,	String name, ParameterizableClass owner) {
+	public ParameterType ensureFamixParameterType(ITypeBinding bnd,	String name, ParameterizableClass owner) {
 		ParameterType fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
@@ -583,10 +601,10 @@
 				return null;
 			}
 			if (owner == null) {
-				return super.createFamixParameterType(null, name, null);
+				return super.ensureFamixParameterType(null, name, null);
 			}
 			
-			return super.createFamixParameterType(null, name, owner);
+			return super.ensureFamixParameterType(null, name, owner);
 		}
 
 		fmx = (ParameterType)getEntityByKey(bnd);	// to avoid useless computations if we can
@@ -615,7 +633,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.createFamixParameterType(bnd, name, owner);
+			fmx = super.ensureFamixParameterType(bnd, name, owner);
 		}
 
 		return fmx;
@@ -677,10 +695,6 @@
 			return false;
 		}
 		
-		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
-			return checkAndMapClass(bnd, (Type) candidate);
-		}
-
 		if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
 			// names are equal so it's OK
 			mapToKey.put(bnd, candidate);
@@ -696,7 +710,12 @@
 				return false;
 			}
 		}
-		
+
+		// Annotation are interfaces too, so we should check this one after isAnnotation
+		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
+			return checkAndMapClass(bnd, (Type) candidate);
+		}
+
 		return false;
 	}
 
@@ -892,7 +911,7 @@
 	/**
 	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
 	 * The Entity is created if it does not exist.
-	 * Params: see {@link Dictionary#createFamixMethod(Object, String, String, Type, Type)}.
+	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
@@ -931,9 +950,9 @@
 				sig = name + sig;
 			}
 			if (owner == null) {
-				owner= createFamixClassStubOwner();
+				owner= ensureFamixClassStubOwner();
 			}
-			return super.createFamixMethod(null, name, sig, ret, owner);
+			return super.ensureFamixMethod(null, name, sig, ret, owner);
 		}
 
 		// --------------- name
@@ -969,7 +988,13 @@
 		if (owner == null) {
 			ITypeBinding classBnd = bnd.getDeclaringClass();
 			if (classBnd != null) {
-				owner = (Class) ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);  // classBnd.isGenericType());
+				Type tmpOwn = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);
+				if (tmpOwn instanceof ParameterizedType) {
+					owner = ((ParameterizedType) tmpOwn).getParameterizableClass();
+				}
+				else {
+					owner = (Class)tmpOwn; 
+				}
 			}
 		}
 		
@@ -981,7 +1006,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = createFamixMethod(bnd, name, sig, ret, owner);
+			fmx = ensureFamixMethod(bnd, name, sig, ret, owner);
 		}
 		
 		if (fmx!=null) {
@@ -1027,7 +1052,7 @@
 	/**
 	 * Returns a Famix Attribute associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#createFamixAttribute(Object, String, Type, Type)}.
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
@@ -1041,7 +1066,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of creating an attribute for which we ignore the declaring class? 
 			}
-			return super.createFamixAttribute(null, name, type, owner);
+			return super.ensureFamixAttribute(null, name, type, owner);
 		}
 
 		// --------------- name
@@ -1058,7 +1083,13 @@
 		if (owner == null) {
 			ITypeBinding classBnd = bnd.getDeclaringClass();
 			if (classBnd != null) {
-				owner = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);   // classBnd.isGenericType());
+				Type tmpOwn = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);
+				if (tmpOwn instanceof ParameterizedType) {
+					owner = ((ParameterizedType) tmpOwn).getParameterizableClass(); 
+				}
+				else {
+					owner = tmpOwn;
+				}
 			}
 		}
 		
@@ -1070,7 +1101,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.createFamixAttribute(bnd, name, type, owner);
+			fmx = super.ensureFamixAttribute(bnd, name, type, owner);
 		}
 		
 		if (fmx!=null) {
@@ -1103,7 +1134,7 @@
 	/**
 	 * Returns a Famix Parameter associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#createFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
+	 * Params: see {@link Dictionary#ensureFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Parameter ensureFamixParameter(IVariableBinding bnd, String name, Type typ, Method owner) {
@@ -1157,7 +1188,7 @@
 	/**
 	 * Returns a Famix LocalVariable associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#createFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
+	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
 	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
 	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, String name, Type typ, Method owner) {
@@ -1170,7 +1201,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of a local variable for which we ignore the declaring method?
 			}
-			return super.createFamixLocalVariable(null, name, typ, owner);
+			return super.ensureFamixLocalVariable(null, name, typ, owner);
 		}
 
 		// --------------- name
@@ -1196,7 +1227,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.createFamixLocalVariable(bnd, name, typ, owner);
+			fmx = super.ensureFamixLocalVariable(bnd, name, typ, owner);
 		}
 		
 		if (fmx != null) {
@@ -1209,18 +1240,18 @@
 	}
 	
 	/**
-	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * Returns a Famix UnknownVariable. The Entity is created if it does not exist.
 	 */
-	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
-//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
-		UnknownVariable fmx = (UnknownVariable) createFamixNamedEntity(UnknownVariable.class, name);
+	public UnknownVariable ensureFamixUnknownVariable(Type type, String name) {
+//		System.err.println("TRACE -- ensureFamixUnknownVariable: "+name);
+		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
 		}
 		return fmx;
 	}
 
-	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+	public Comment ensureFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
 		Comment cmt = null;
 		if (jdoc != null) {
 			cmt = createFamixComment(jdoc.toString(), fmx);
@@ -1273,7 +1304,7 @@
 	 * @return the Famix Method
 	 */
 	public Method ensureFamixStubMethod(String name) {
-		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, createFamixClassStubOwner());  // cast needed to desambiguate the call
+		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, ensureFamixClassStubOwner());  // cast needed to desambiguate the call
 	}
 
 	/**
@@ -1294,7 +1325,7 @@
 	 * @return a Famix class for "Object"
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class fmx =  createFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
 		
 		if (fmx != null) {
 			fmx.setContainer( ensureFamixNamespaceJavaLang(null));
@@ -1315,9 +1346,9 @@
 	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
 	 * @return a Famix class
 	 */
-	public fr.inria.verveine.core.gen.famix.Class createFamixClassStubOwner() {
-		fr.inria.verveine.core.gen.famix.Class fmx = super.createFamixClassStubOwner();
-		createFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 
 		return fmx;
 	}
@@ -1329,10 +1360,10 @@
 	 * @return a Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
-		fr.inria.verveine.core.gen.famix.Class fmx = createFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
 		if (fmx != null) {
-			createFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
-			fmx.setContainer( createFamixNamespaceDefault());
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+			fmx.setContainer( ensureFamixNamespaceDefault());
 			
 			fmx.setIsAbstract(Boolean.FALSE);
 			fmx.setIsFinal(Boolean.FALSE);
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 60)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 61)
@@ -25,6 +25,17 @@
         this.declaredType = declaredType;
     }
     
+    private Collection<Type> declaredArgumentTypes;
+    
+    @FameProperty(name = "declaredArgumentTypes")
+    public Collection<Type> getDeclaredArgumentTypes() {
+        return declaredArgumentTypes;
+    }
+
+    public void setDeclaredArgumentTypes(Collection<Type> declaredArgumentTypes) {
+        this.declaredArgumentTypes = declaredArgumentTypes;
+    }
+    
     private Collection<Access> incomingAccesses; 
 
     @FameProperty(name = "incomingAccesses", opposite = "variable", derived = true)
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 29)
+++ verveine.core/.classpath	(revision 30)
@@ -3,7 +3,6 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 29)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 30)
@@ -2,10 +2,14 @@
 
 import java.util.Stack;
 
+import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Reference;
 
 /** A stack of FAMIX Entities so that we know in what container each new Entity is declared
  * @author anquetil
@@ -29,6 +33,7 @@
 		private int metric_cyclo = EMPTY_CYCLO;  // Cyclomatic Complexity
 		private int metric_nos = EMPTY_NOS;    // Number Of Statements
 		
+		
  		public ClassStack(fr.inria.verveine.core.gen.famix.Class e) {
 			fmxClass = e;
 			clearFmxMethod();
@@ -110,21 +115,61 @@
 			fmxMethod = null;
 			metric_cyclo = EMPTY_CYCLO;
 			metric_nos = EMPTY_NOS;
+			setLastInvocation(null);
 		}
 
 	}
 	
 	/**
-	 * last Association registered to set the previous/next
+	 * last Invocation registered to set the previous/next
+	 */
+	Invocation lastInvocation = null;
+	
+	/**
+	 * last Access registered to set the previous/next
+	 */
+	Access lastAccess = null;
+	
+	/**
+	 * last Inheritance registered to set the previous/next
+	 */
+	Inheritance lastInheritance = null;
+	
+	/**
+	 * last Reference registered to set the previous/next
 	 */
-	Association lastAssoc = null;
+	Reference lastReference = null;
 	
-	public Association getLastAssoc() {
-		return lastAssoc;
+	public Access getLastAccess() {
+		return lastAccess;
 	}
 
-	public void setLastAssoc(Association lastAssoc) {
-		this.lastAssoc = lastAssoc;
+	public void setLastAccess(Access lastAccess) {
+		this.lastAccess = lastAccess;
+	}
+
+	public Inheritance getLastInheritance() {
+		return lastInheritance;
+	}
+
+	public void setLastInheritance(Inheritance lastInheritance) {
+		this.lastInheritance = lastInheritance;
+	}
+
+	public Reference getLastReference() {
+		return lastReference;
+	}
+
+	public void setLastReference(Reference lastReference) {
+		this.lastReference = lastReference;
+	}
+
+	public Invocation getLastInvocation() {
+		return lastInvocation;
+	}
+
+	public void setLastInvocation(Invocation lastInvocation) {
+		this.lastInvocation = lastInvocation;
 	}
 
 	public EntityStack() {
@@ -176,7 +221,7 @@
 			System.out.println("TRACE: pushPckg "+e.getName());
 		}
 		clearClasses();
-		setLastAssoc(null);
+		//setLastAssoc(null);
 		fmxPckg = e;
 	}
 
@@ -200,6 +245,7 @@
 			System.out.println("TRACE: pushMethod "+e.getName());
 		}
 		getTopClass().setFmxMethod(e);
+		
 	}
 
 	/**
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 29)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 30)
@@ -409,7 +409,7 @@
 		return ensureFamixInvocation(sender, invoked, receiver, null);
 	}
 
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Invocation prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
@@ -443,7 +443,7 @@
 
 	private void chainPrevNext(Association prev, Association next) {
 		if (prev != null) {
-			// next.setPrevious(prev);  // not yet implemented in importer
+			next.setPrevious(prev);  // not yet implemented in importer
 		}
 	}
 	
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 29)
+++ verveine.extractor.java/.classpath	(revision 30)
@@ -10,10 +10,9 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
-	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 29)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 30)
@@ -8,6 +8,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
@@ -359,6 +360,29 @@
 				}
 			}
 		}
+		
+		// test that the chain (next/previous) of invocations is correct
+		for (Method mNode : nodeClass.getMethods()) {
+			if (mNode.getName().equals("accept")) {
+				Invocation invok = mNode.getOutgoingInvocations().iterator().next();
+				assertNull(invok.getPrevious());
+				assertNull(invok.getNext());
+			}
+			else if (mNode.getName().equals("send"))  {
+				int nbNull = 0;
+				for (Invocation invok : mNode.getOutgoingInvocations()) {
+					Invocation previous = (Invocation) invok.getPrevious();
+					if (previous == null) {
+						nbNull++;
+					}
+					else {
+						assertSame(mNode, previous.getSender());
+					}					
+				}
+				assertEquals(1, nbNull);
+			}
+		}
+
 	}
 	
 	@Test
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 29)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 30)
@@ -104,7 +104,7 @@
 			importBnd = ((ITypeBinding)importBnd).getPackage();
 		}
 
-		context.setLastAssoc( dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd), context.getLastAssoc()) );
+		context.setLastReference( dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd), context.getLastReference()) );
 		
 		return super.visit(node);
 	}
@@ -380,11 +380,12 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
 			if (accessed != null) {
-				context.setLastAssoc( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAssoc()) );
+				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
 			}
+			//context.setLastAccess( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastAccess) );
 		}
 	}
 
@@ -401,7 +402,7 @@
 			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(name);
 			}
-			context.setLastAssoc( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastAssoc()) );
+			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 63)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 64)
@@ -24,6 +24,7 @@
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -104,7 +105,6 @@
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
-		//fmx.setTypeArguments(dico.ensureFamixTypes(node.typeParameters()));
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -115,6 +115,8 @@
 			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
 			fmx.setContainer( context.top());
 		}
+		fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
+		
 		dico.addSourceAnchor(fmx, node);
 		Javadoc jdoc = node.getJavadoc();
 		if (jdoc != null) {
@@ -171,7 +173,7 @@
 			fmx.setIsStub(false);
 		}
 		else {
-			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
+			System.err.println("         Method="+node.getName().getIdentifier());
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
 			//fmx.setSignature(fmx.getName()+" (???)");
@@ -180,18 +182,23 @@
 			// Has no binding? It might be a Generic type
 			fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
 		}
+		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
+			fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+		}
 		if (fmx != null) {
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-//				System.err.println(param.getName().getIdentifier());
-//				System.err.println(param.resolveBinding()==null);
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
 				} else {
 					// Has no binding? It might be a Generic parameter
+					System.err.println("         Parameter="+param.getName().getIdentifier());
 					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, param.getType().toString());
 				}
+				if (param.getType().isParameterizedType()) {
+					fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
+				}
 			}
 			
 			dico.addSourceAnchor(fmx, node);
@@ -232,11 +239,13 @@
 //			System.err.println("            Field: "+vd.getName().getIdentifier());
 			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
+			
+			//((ParameterizedType)node.getType()).typeArguments();
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 			else {
-				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
 				// should try to find type name from 'node.getType()' ?
@@ -244,7 +253,9 @@
 				// Has no binding? It might be a Generic type
 				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
 			}
-			
+			if (node.getType().isParameterizedType()) {
+				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
+			}
 			dico.addSourceAnchor(fmx, node);
 			Javadoc jdoc = node.getJavadoc();
 			if (jdoc != null) {
@@ -282,12 +293,12 @@
 		}
 
 		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding());
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 			else {
-				System.err.println("         Variable="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
 				// should try to find type name from 'node.getType()' ?
@@ -296,6 +307,9 @@
 				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
+			if (nodeTyp.isParameterizedType()) {
+				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+			}
 		}
 	}
 
@@ -399,4 +413,4 @@
 		return super.visit(node);
 	}
 
-}
+}
\ No newline at end of file
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 11)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 12)
@@ -368,6 +368,17 @@
 		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
 		assertEquals(31, ((FileAnchor)anc).getEndLine());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(70, ((FileAnchor)anc).getEndLine());
 		
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
 		assertNotNull(meth);
@@ -426,4 +437,27 @@
 		assertTrue(a.getIsProtected());
 		assertFalse(a.getIsFinal());
 	}
+
+
+	@Test
+	public void testMetric() {	
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
+			assertNotNull(m);
+			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
+			assertNotNull(owner);
+			if (owner.getName().equals("OutputServer")) {
+			assertEquals(2, m.getCyclo());
+				assertEquals(6, m.getNOS());
+			}
+			else if (owner.getName().equals("Node")) {
+				assertEquals(1, m.getCyclo());
+				assertEquals(1, m.getNOS());
+			}
+			else if (owner.getName().equals("WorkStation")) {
+				assertEquals(2, m.getCyclo());
+				assertEquals(7, m.getNOS());
+			}
+		}		
+	}
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 12)
@@ -320,16 +320,29 @@
 		return null;
 	}
 
+	/**
+	 * Handles an access to a field by creating the corresponding Famix Entity
+	 * @param bnd -- a binding for the field (i.e attribute)
+	 */
 	private void fieldAccess(IVariableBinding bnd) {
 		BehaviouralEntity accessor = this.context.topMethod();
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
 			if (accessed != null) {
 				dico.ensureFamixAccess(accessor, accessed);
+				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+					accessed.setParentType(dico.ensureFamixClassArray());
+				}
 			}
 		}
 	}
 
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param bnd -- a binding for the method
+	 * @param name of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
 	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 12)
@@ -5,17 +5,37 @@
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTVisitor;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.AssertStatement;
+import org.eclipse.jdt.core.dom.Assignment;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConstructorInvocation;
+import org.eclipse.jdt.core.dom.ContinueStatement;
+import org.eclipse.jdt.core.dom.DoStatement;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.ForStatement;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.SwitchCase;
+import org.eclipse.jdt.core.dom.SwitchStatement;
+import org.eclipse.jdt.core.dom.SynchronizedStatement;
+import org.eclipse.jdt.core.dom.TagElement;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WhileStatement;
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
@@ -89,6 +109,10 @@
 			fmx.setContainer( context.top());
 		}
 		dico.addSourceAnchor(fmx, node);
+		if (context.getLastComment() != null) {
+			dico.createFamixComment(context.getLastComment(), fmx);
+			context.clearLastComment();
+		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -138,8 +162,8 @@
 			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
 		}
 
-		// creating the method's parameters
-		if (fmx != null) {
+		if (fmx != null) {			
+			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding());
 				if (fmxParam != null) {
@@ -148,13 +172,25 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
+			if (context.getLastComment() != null) {
+				dico.createFamixComment(context.getLastComment(), fmx);
+				context.clearLastComment();
+			}
 			this.context.pushMethod(fmx);
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
 		}
 		return super.visit(node);	
 	}
 
 	public void endVisit(MethodDeclaration node) {
-		this.context.popMethod();
+		int cyclo = context.getTopMethodCyclo();
+		int nos = context.getTopMethodNOS();
+		Method fmx = this.context.popMethod();
+		fmx.setNOS(nos);
+		fmx.setCyclo(cyclo);
 		super.endVisit(node);
 	}
 
@@ -176,6 +212,10 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
+			if (context.getLastComment() != null) {
+				dico.createFamixComment(context.getLastComment(), fmx);
+				context.clearLastComment();
+			}
 		}
 		return super.visit(node);
 	}
@@ -216,4 +256,116 @@
 		}
 	}
 
+	@Override
+	@SuppressWarnings("unchecked")
+	public boolean visit(Javadoc node) {
+		String comment = "/** ";
+		for (TagElement tag : (List<TagElement>)node.tags()) {
+			comment += tag.toString();
+		}
+		comment += "\n */";
+		this.context.setLastComment(comment);
+		return super.visit(node);
+	}
+
+
+	// METRICS: CYCLO, NOS
+	
+	public boolean visit(AssertStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(Assignment node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ContinueStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(DoStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(EnhancedForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(IfStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(MethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ReturnStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperMethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchCase node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SynchronizedStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ThrowStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(TryStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(WhileStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 12)
@@ -39,6 +39,7 @@
 
 	public static final String OBJECT_NAME = "Object";
 	public static final String OBJECT_PACKAGE_NAME = "java.lang";
+	public static final String ARRAYS_NAME = "default[]";
 	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
 	public static final String STATIC_INIT_BLOCK_NAME = "<StaticInitializer>";
 
@@ -453,7 +454,6 @@
 		fmx.setIsPublic(Modifier.isPublic(mod));
 	}
 
-
 	/**
 	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
@@ -640,7 +640,10 @@
 		return fmx;
 	}
 
-	@Override
+	/**
+	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
+	 * @return a Famix class
+	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
 		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
@@ -648,5 +651,18 @@
 		return fmx;
 	}
 
+	/**
+	 * Creates or recovers the Famix Class for all arrays (<some-type> [])
+	 * In java arrays or objects of special classes (i.e. "I[" for an array of int).
+	 * JDT does not create a binding for these classes, so we create a stub one here. 
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+		fmx.setContainer( ensureFamixNamespaceDefault());
+
+		return fmx;
+	}
 
 }
Index: branches/postMoose4_3Refactoring/verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 98)
@@ -0,0 +1,47 @@
+package test.fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Vector;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+
+/**
+ * Some utilities to help test extractors derived from verveine.core
+ * @author anquetil
+ */
+public class TestVerveineUtils {
+
+	/**
+	 * Returns a Collection of all FAMIXEntities in repository of the given fmxClass.
+	 * Same method as listAll(Class<T extends Entity>) defined in VerveineParser
+	 */
+	public static <T extends Entity> Collection<T> selectElementsOfType(Repository repository, Class<T> fmxClass) {
+		return( repository.all(fmxClass));
+	}
+
+	/** Returns the first FAMIXEntities in repository of the given fmxClass and with the given name
+	 */
+	public static <T extends NamedEntity> T detectElement(Repository repository, Class<T> fmxClass, String name) {
+		for (T ent : selectElementsOfType(repository, fmxClass)) {
+			if (ent.getName().equals(name) ) {
+				return ent;
+			}
+		}
+		return null;
+	}
+
+	/** Returns a Collection of FAMIXEntities in repository of the given fmxClass and with the given name
+	 */
+	public static <T extends NamedEntity> Collection<T> listElements(Repository repository, Class<T> fmxClass, String name) {
+		Collection<T> selection = new Vector<T>();
+		for (T ent : selectElementsOfType(repository, fmxClass)) {
+			if ( ent.getName().equals(name) ) {
+				selection.add(ent);
+			}
+		}
+		return selection;
+	}
+
+}
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 81)
+++ verveine.core/.classpath	(revision 82)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
 	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 82)
@@ -35,14 +35,19 @@
 import fr.inria.verveine.core.gen.famix.ThrownException;
 import fr.inria.verveine.core.gen.famix.Type;
 
+enum Colors { Black,	Blue, Red };
+
 /**
  * A dictionnary of Famix entities to help create them and find them back
  * @author anquetil
  *
- * @param <B> The super class of all bindings. Different for JDT, PDT, ... bindings
+ *Entities are mapped to keys. Typically the key will be a binding provided by the parser used
+ * @param <B> The class of the keys, typically a JDT binding or a CDT binding, ...
  */
 public class Dictionary<B> {
 
+	Colors toto;
+	
 	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
 	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
 	public static final String SELF_NAME = "self";
@@ -54,9 +59,9 @@
 	protected Repository famixRepo;
 
 	/**
-	 * A dictionary to map an IBinding to FAMIX Entity
+	 * A dictionary to map a key (provided by the user) to FAMIX Entity
 	 */
-	protected Map<B,NamedEntity> mapBind;
+	protected Map<B,NamedEntity> mapToKey;
 
 	/**
 	 * Another dictionary to map a name to FAMIX Entities with this name
@@ -64,8 +69,9 @@
 	protected Map<String,Collection<NamedEntity>> mapName;
 
 	/**
-	 * Yet another dictionary for implicit variables
-	 * 'self' and 'super' have the same binding than their associated class so they can't be kept easily in bindFmxDico
+	 * Yet another dictionary for implicit variables ('self' and 'super')
+	 * Because they are implicit, they may not have a binding provided by the parser,
+	 * or may have the same binding than their associated class so they can't be kept easily in {@link Dictionary#mapToKey}
 	 */
 	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
 
@@ -73,7 +79,7 @@
 	 * Used to keep the two possible ImplicitVariable for a given Class binding
 	 * @author anquetil
 	 */
-	protected class ImplicitVars {
+	private class ImplicitVars {
 		public ImplicitVariable self_iv;
 		public ImplicitVariable super_iv;
 	}
@@ -84,7 +90,7 @@
 	public Dictionary(Repository famixRepo) {
 		this.famixRepo = famixRepo;
 		
-		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapToKey = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
 		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
 		
@@ -109,49 +115,14 @@
 			}
 		}
 
-		for (fr.inria.verveine.core.gen.famix.Class clazz : famixRepo.all(fr.inria.verveine.core.gen.famix.Class.class)) {
-			try { if (clazz.getIsAbstract()) { } }
-			catch (NullPointerException e) { clazz.setIsAbstract(Boolean.FALSE); }
-			try { if (clazz.getIsStub()) { } }
-			catch (NullPointerException e) { clazz.setIsStub(Boolean.FALSE); }
-			try { if (clazz.getIsPublic()) { } }
-			catch (NullPointerException e) { clazz.setIsPublic(Boolean.FALSE); }
-			try { if (clazz.getIsPrivate()) { } }
-			catch (NullPointerException e) { clazz.setIsPrivate(Boolean.FALSE); }
-			try { if (clazz.getIsProtected()) { } }
-			catch (NullPointerException e) { clazz.setIsProtected(Boolean.FALSE); }
-			try { if (clazz.getIsFinal()) { } }
-			catch (NullPointerException e) { clazz.setIsFinal(Boolean.FALSE); }
-		}
-
 		for (Method meth : famixRepo.all(Method.class)) {
-			try { if (meth.getIsAbstract()) { } }
-			catch (NullPointerException e) { meth.setIsAbstract(Boolean.FALSE); }
 			try { if (meth.getIsStub()) { } }
 			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
-			try { if (meth.getIsPublic()) { } }
-			catch (NullPointerException e) { meth.setIsPublic(Boolean.FALSE); }
-			try { if (meth.getIsPrivate()) { } }
-			catch (NullPointerException e) { meth.setIsPrivate(Boolean.FALSE); }
-			try { if (meth.getIsProtected()) { } }
-			catch (NullPointerException e) { meth.setIsProtected(Boolean.FALSE); }
-			try { if (meth.getIsFinal()) { } }
-			catch (NullPointerException e) { meth.setIsFinal(Boolean.FALSE); }
 		}
 
 		for (Attribute att : famixRepo.all(Attribute.class)) {
-			try { if (att.getIsAbstract()) { } }
-			catch (NullPointerException e) { att.setIsAbstract(Boolean.FALSE); }
 			try { if (att.getIsStub()) { } }
 			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
-			try { if (att.getIsPublic()) { } }
-			catch (NullPointerException e) { att.setIsPublic(Boolean.FALSE); }
-			try { if (att.getIsPrivate()) { } }
-			catch (NullPointerException e) { att.setIsPrivate(Boolean.FALSE); }
-			try { if (att.getIsProtected()) { } }
-			catch (NullPointerException e) { att.setIsProtected(Boolean.FALSE); }
-			try { if (att.getIsFinal()) { } }
-			catch (NullPointerException e) { att.setIsFinal(Boolean.FALSE); }
 		}
 
 	}
@@ -191,16 +162,16 @@
 	 * Returns the Famix Entity associated to the given binding.
 	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
 	 * In such a case, this method will always retrieve the Class associated to the binding.
-	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
+	 * To get an ImplicitVariable from the binding, uses {@link Dictionary#getImplicitVariableByBinding(Object, String)}
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
-	public NamedEntity getEntityByBinding(B bnd) {
+	public NamedEntity getEntityByKey(B bnd) {
 		if (bnd == null) {
 			return null;
 		}
 		else {
-			return mapBind.get(bnd);
+			return mapToKey.get(bnd);
 		}
 	}
 
@@ -208,12 +179,11 @@
 	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
 	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
 	 * @param fmxClass -- the FAMIX class of the instance to create
-	 * @param name -- the name of the new instance
+	 * @param name -- the name of the new instance must not be null (and this is not tested)
 	 * @return the FAMIX Entity or null in case of a FAMIX error
 	 */
 	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
-//System.out.println("creating FMX Entity:"+ name +"   type: "+ fmxClass.getCanonicalName());
 		try {
 			fmx = fmxClass.newInstance();
 		} catch (Exception e) {
@@ -237,13 +207,11 @@
 	/**
 	 * Returns a FAMIX Entity of the type <b>fmxClass</b> and maps it to its binding <b>bnd</b> (if not null).
 	 * The Entity is created if it did not exist.
-	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use ensureFamixImplicitVariable instead.
+	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use {@link Dictionary#ensureFamixImplicitVariable} instead.
 	 * @param fmxClass -- the FAMIX class of the instance to create
 	 * @param bnd -- the binding to map to the new instance
 	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
 	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
-	 * 
-	 * TODO Make public and remove ensureFamixClass(name), ensureFamixAttribute(name), ... ????
 	 */
 	@SuppressWarnings("unchecked")
 	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
@@ -254,24 +222,19 @@
 		}
 		
 		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
-		}
-		else {
-			// Unfortunately different entities with the same name and same type may exist
-			// e.g. 2 parameters of 2 different methods but having the same name
-			// so we must recreate a new entity each time
-
-			//fmxEnt = getEntityByName(fmxClass, name);
-		}
-
-		if (fmx != null) {
-			return fmx;
+			fmx = (T) getEntityByKey(bnd);
+			if (fmx != null) {
+				return fmx;
+			}
 		}
+		// else
+		// Unfortunately different entities with the same name and same type may exist
+		// e.g. 2 parameters of 2 different methods but having the same name
+		// so we cannot recover just from the name
 
 		fmx = createFamixEntity(fmxClass, name);
-		// put new entity in mappers
 		if (bnd != null) {
-			mapBind.put(bnd, fmx);
+			mapToKey.put(bnd, fmx);
 		}
 		
 		return fmx;
@@ -288,38 +251,30 @@
 
 	///// ensure Famix Entities /////
 
-	protected <T extends fr.inria.verveine.core.gen.famix.Type> T ensureFamixType(Class<T> fmxClass, String name) {
-		T fmx = ensureFamixEntity(fmxClass, null, name);
-		if (fmx != null) {
-			fmx.setIsAbstract(Boolean.FALSE);
-			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsPrivate(Boolean.FALSE);
-			fmx.setIsProtected(Boolean.FALSE);
-			fmx.setIsPublic(Boolean.FALSE);
-		}
-
-		return fmx;
-	}
-	
 	/**
 	 * Returns a FAMIX Type with the given <b>name</b>, creating it if it does not exist yet.
 	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
-	 * @param name -- the name of the FAMIX Class
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the Famix Type (MUST NOT be null, but this is not checked)
+	 * @param owner -- entity defining the Famix Type (should not be null, but it will work if it is) 
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
-	public Type ensureFamixType(String name) {
-		return ensureFamixType(Type.class, name);
+	public Type ensureFamixType(B key, String name, ContainerEntity owner) {
+		Type fmx = ensureFamixEntity(Type.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
 	}
 
 	/**
 	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet.
-	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
-	 * @param name -- the name of the FAMIX Class
+	 * @param key to which the entity Famix be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Class (MUST NOT be null, but this is not checked)
+	 * @param owner -- entity defining the Famix class (should not be null, but it will work if it is) 
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixType(fr.inria.verveine.core.gen.famix.Class.class, name);
-		fmx.setIsInterface(Boolean.FALSE);
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(B key, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
+		fmx.setContainer(owner);
 		return fmx;
 	}
 
@@ -330,7 +285,7 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public ParameterizableClass ensureFamixParameterizableClass(String name) {
-		ParameterizableClass fmx = ensureFamixType(ParameterizableClass.class, name);
+		ParameterizableClass fmx = ensureFamixEntity(ParameterizableClass.class, null, name);
 		fmx.setIsInterface(Boolean.FALSE);
 		return fmx;
 	}
@@ -342,36 +297,55 @@
 	 * @return the FAMIX ParameterType or null in case of a FAMIX error
 	 */
 	public ParameterType ensureFamixParameterType(String name) {
-		ParameterType fmx = ensureFamixType(ParameterType.class, name);
+		ParameterType fmx = ensureFamixEntity(ParameterType.class, null, name);
 		return fmx;
 	}
 
 	/**
 	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Method
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Method (MUST NOT be null, but this is not checked)
+	 * @param sig -- method's signature, including type of parameters and return type (should not be null, but it will work if it is)
+	 * @param ret -- Famix Type returned by the method (ideally should only be null in case of a constructor, but will accept it in any case)
+	 * @param owner -- type defining the method (should not be null, but it will work if it is)
 	 * @return the FAMIX Method or null in case of a FAMIX error
 	 */
-
-	public Method ensureFamixMethod(String name) {
-		return (Method) ensureFamixEntity(Method.class, null, name);
+	public Method ensureFamixMethod(B key, String name, String sig, Type ret, Type owner) {
+		Method fmx = (Method) ensureFamixEntity(Method.class, key, name);
+		fmx.setSignature(sig);
+		fmx.setDeclaredType(ret);
+		fmx.setParentType(owner);
+		return fmx;
 	}
 
 	/**
 	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX Attribute
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the Famix Attribute (MUST NOT be null, but this is not checked)
+	 * @param type -- Famix Type of the Famix Attribute (should not be null, but it will work if it is)
+	 * @param owner -- Class defining the Famix Attribute (should not be null, but it will work if it is)
 	 * @return the FAMIX Attribute or null in case of a FAMIX error
 	 */
-	public Attribute ensureFamixAttribute(String name) {
-		return (Attribute) ensureFamixEntity(Attribute.class, null, name);
+	public Attribute ensureFamixAttribute(B key, String name, Type type, Type owner) {
+		Attribute fmx = ensureFamixEntity(Attribute.class, key, name);
+		fmx.setParentType(owner);
+		fmx.setDeclaredType(type);
+		return fmx;
 	}
 
 	/**
 	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
-	 * @param name -- the name of the FAMIX LocalVariable
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the Famix Variable (MUST NOT be null, but this is not checked)
+	 * @param type -- Famix Type of the Famix Variable (should not be null, but it will work if it is)
+	 * @param owner -- Entity defining the Famix Variable (should not be null, but it will work if it is)
 	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
 	 */
-	public LocalVariable ensureFamixLocalVariable(String name) {
-		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
+	public LocalVariable ensureFamixLocalVariable(B key, String name, Type type, BehaviouralEntity owner) {
+		LocalVariable fmx = ensureFamixEntity(LocalVariable.class, key, name);
+		fmx.setParentBehaviouralEntity(owner);
+		fmx.setDeclaredType(type);
+		return fmx;
 	}
 
 	/**
@@ -562,12 +536,12 @@
 
 	/**
 	 * Returns the Famix ImplicitVariable associated to the given binding and name (self or super).
-	 * See also {@link Dictionary#getEntityByBinding(Object)}
+	 * See also {@link Dictionary#getEntityByKey(Object)}
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
 	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
-		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByBinding(bnd), iv_name);
+		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd), iv_name);
 	}
 	
 	/**
@@ -597,7 +571,7 @@
 	/**
 	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
 	 * If this ImplicitVariable does not exist yet, it is created
-	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param clazz -- the Famix Class for this ImplicitVariable (must not be null)
 	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
 	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
 	 */
@@ -608,7 +582,6 @@
 			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
 			if (fmx!=null) {
 				fmx.setContainer(clazz);
-				fmx.setIsStub(Boolean.FALSE);
 
 				ImplicitVars iv = mapImpVar.get(clazz);				
 				if (iv == null) {
@@ -636,15 +609,15 @@
 	 * For some specific entities we don't allow two of them with the same name.
 	 * This is the case e.g. for the default package, or the Java class "Object" and its package "java.lang".
 	 * @param fmxClass -- the FAMIX class of the instance to create
-	 * @param bnd -- a potential binding for the entity
+	 * @param key -- a potential binding for the entity
 	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
 	 * @return the uniq Famix Entity for this binding and/or name
 	 */
 	@SuppressWarnings("unchecked")
-	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B bnd, String name) {
+	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B key, String name) {
 		T fmx = null;
-		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
+		if (key != null) {
+			fmx = (T) getEntityByKey(key);
 		}
 		
 		if (fmx == null) {
@@ -656,10 +629,10 @@
 				fmx = createFamixEntity(fmxClass, name);
 			}
 			
-			if (bnd != null) {
+			if (key != null) {
 				// may happen for example if the entity was first created without binding
 				// and we find a binding for it later
-				mapBind.put(bnd, fmx);
+				mapToKey.put(key, fmx);
 			}
 		}
 
@@ -672,8 +645,8 @@
 	 * @param name -- the name of the FAMIX Namespace
 	 * @return the FAMIX Namespace or null in case of a FAMIX error
 	 */
-	public Namespace ensureFamixNamespace(String name) {
-		return  ensureFamixUniqEntity(Namespace.class, null, name);
+	public Namespace ensureFamixNamespace(B key, String name) {
+		return  ensureFamixUniqEntity(Namespace.class, key, name);
 	}
 
 	/**
@@ -693,29 +666,21 @@
 	 * @param name -- the name of the FAMIX PrimitiveType
 	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
 	 */
-	public PrimitiveType ensureFamixPrimitiveType(String name) {
-		return  ensureFamixUniqEntity(PrimitiveType.class, null, name);
+	public PrimitiveType ensureFamixPrimitiveType(B key, String name) {
+		return ensureFamixEntity(PrimitiveType.class, key, name);
 	}
 	
 	/**
 	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
-	 * Because this package does not really exist, it has no binding.
 	 * @return a Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
 		if (fmx != null) {
 			fmx.setContainer( ensureFamixNamespaceDefault());
-			fmx.setIsAbstract(Boolean.FALSE);
-			fmx.setIsFinal(Boolean.FALSE);
-			fmx.setIsInterface(Boolean.FALSE);
-			fmx.setIsPrivate(Boolean.FALSE);
-			fmx.setIsProtected(Boolean.FALSE);
-			fmx.setIsPublic(Boolean.FALSE);
 		}
 
 		return fmx;
 	}
-
 	
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 82)
@@ -30,6 +30,11 @@
         return parentType;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentType();
+	}
+
     public void setParentType(Type parentType) {
         if (this.parentType != null) {
             if (this.parentType.equals(parentType)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 82)
@@ -194,7 +194,12 @@
         return parentType;
     }
 
-    public void setParentType(Type parentType) {
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentType();
+	}
+
+	public void setParentType(Type parentType) {
         if (this.parentType != null) {
             if (this.parentType.equals(parentType)) return;
             this.parentType.getMethods().remove(this);
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 82)
@@ -19,6 +19,11 @@
         return container;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
     public void setContainer(Type container) {
         this.container = container;
     }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 82)
@@ -19,6 +19,11 @@
         return parentBehaviouralEntity;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentBehaviouralEntity();
+	}
+
     public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
         if (this.parentBehaviouralEntity != null) {
             if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 82)
@@ -14,7 +14,16 @@
 
 
 
-    private Boolean isAbstract;
+    public NamedEntity() {
+		super();
+		this.setIsFinal(Boolean.FALSE);
+		this.setIsPrivate(Boolean.FALSE);
+		this.setIsProtected(Boolean.FALSE);
+		this.setIsPublic(Boolean.FALSE);
+		this.setIsAbstract(Boolean.FALSE);
+	}
+
+	private Boolean isAbstract;
     
     @FameProperty(name = "isAbstract")
     public Boolean getIsAbstract() {
@@ -202,12 +211,11 @@
     public boolean hasModifiers() {
         return !getModifiers().isEmpty();
     }
-    
-                
+            
     @FameProperty(name = "belongsTo", derived = true)
     public ContainerEntity getBelongsTo() {
         // TODO: this is a derived property, implement this method manually.
-    	return null;
+        throw new UnsupportedOperationException("NamedEntity.getBelongsTo() Not implemented in this class, use the proper subclass!"); 
     }
     
     private Boolean isFinal;
@@ -222,6 +230,11 @@
     }
     
 
+	@Override
+	public String toString() {
+		return "a " + this.getClass().getCanonicalName() + " named: " + this.getName();
+	}
+    
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 82)
@@ -21,6 +21,11 @@
         return parentScope;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentScope();
+	}
+
     public void setParentScope(ScopingEntity parentScope) {
         if (this.parentScope != null) {
             if (this.parentScope.equals(parentScope)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 82)
@@ -19,6 +19,11 @@
         return parentBehaviouralEntity;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentBehaviouralEntity();
+	}
+
     public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
         if (this.parentBehaviouralEntity != null) {
             if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 82)
@@ -10,9 +10,12 @@
 @FameDescription("Class")
 public class Class extends Type {
 
+    public Class() {
+		super();
+		this.setIsInterface(Boolean.FALSE);
+	}
 
-
-    @FameProperty(name = "isAbstract", derived = true)
+	@FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
         return this.getModifiers().contains("abstract");
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 82)
@@ -11,6 +11,11 @@
 
 
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return null;
+	}
+
 
 
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 82)
@@ -19,6 +19,11 @@
         return parentScope;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentScope();
+	}
+
     public void setParentScope(ScopingEntity parentScope) {
         if (this.parentScope != null) {
             if (this.parentScope.equals(parentScope)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 82)
@@ -21,6 +21,11 @@
         return container;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
     public void setContainer(ContainerEntity container) {
         if (this.container != null) {
             if (this.container.equals(container)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 81)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 82)
@@ -13,8 +13,7 @@
 public class Type extends ContainerEntity {
 
 
-
-    private Collection<Method> methods; 
+	private Collection<Method> methods; 
 
     @FameProperty(name = "methods", opposite = "parentType", derived = true)
     public Collection<Method> getMethods() {
@@ -129,6 +128,11 @@
         return container;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
     public void setContainer(ContainerEntity container) {
         if (this.container != null) {
             if (this.container.equals(container)) return;
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 48)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 49)
@@ -3,18 +3,25 @@
 import java.io.IOException;
 
 
-
-
+@Override
+@Deprecated
 public class Client {
-
+	
+	@Override
+	@Deprecated
 	private String num;
+	@Deprecated
 	private String nom;
 	
+	@Override
+	@Deprecated
 	public Client(String num, String nom) {
 		this.setNum(num);
 		this.setNom(nom);
 	}
-
+	
+	@Override
+	@Deprecated
 	public static Client lire(BufferedReader in) throws ReadException {
 		String nom = "";
 		String num = "";
@@ -39,11 +46,13 @@
 		return new Client(num, nom);
 		
 	}
-
+	
 	public String toString() {
 		return "client: ["+getNum()+"] "+getNom();
 	}
 	
+	@Override
+	@Deprecated
 	public void setNum(String num) {
 		this.num = num;
 	}
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 20)
+++ verveine.extractor.java/.classpath	(revision 21)
@@ -14,6 +14,6 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/famix.jar"/>
-	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/verveinej.sh
===================================================================
--- verveine.extractor.java/verveinej.sh	(revision 20)
+++ verveine.extractor.java/verveinej.sh	(revision 21)
@@ -49,4 +49,4 @@
 CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.osgi_3.6.0.v20100517.jar"
 
 
-java $JOPT -cp $CLASSPATH fr.inria.verveine.extractor.java.BatchParser $VOPT
+java $JOPT -cp $CLASSPATH fr.inria.verveine.extractor.java.VerveineJParser $VOPT
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 20)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 21)
@@ -11,17 +11,13 @@
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
-import java.io.PrintWriter;
 import java.util.Collection;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
-
 import ch.akuhn.fame.Repository;
-
-
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
@@ -35,9 +31,8 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
-
-import fr.inria.verveine.extractor.java.BatchParser;
 import fr.inria.verveine.extractor.java.JavaDictionary;
+import fr.inria.verveine.extractor.java.VerveineJParser;
 
 /**
  * @author Simon Denier
@@ -55,9 +50,9 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
-		BatchParser parser = new BatchParser(new PrintWriter(System.out), new PrintWriter(System.err), true/*systemExit*/, null/*options*/, null/*progress*/);
-		parser.systemExitWhenFinished = false;
+		VerveineJParser parser = new VerveineJParser();
 		parser.compile(new String[] {"test_src/LANModel"});
+		parser.renameNamespaces();
 		repo = parser.getFamixRepo();
 	}
 
@@ -117,8 +112,7 @@
 		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
-		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
-		assertEquals( javaLangName, javaLang.getName());
+		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
 		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
 
 		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
@@ -466,7 +460,6 @@
 
 	}
 	
-
 	@Test
 	public void testMetric() {	
 		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java	(revision 20)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java	(revision 21)
@@ -1,100 +0,0 @@
-package fr.inria.verveine.extractor.java;
-
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-
-import java.util.Map;
-
-import org.eclipse.jdt.core.compiler.CompilationProgress;
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.ASTParser;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
-import org.eclipse.jdt.internal.compiler.batch.Main;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-
-import ch.akuhn.fame.Repository;
-
-import fr.inria.verveine.core.gen.famix.FAMIXModel;
-
-
-//import fr.inria.verveine.NonCloseablePrintStream;
-
-/**
- * A batch parser inspired from org.eclipse.jdt.internal.compiler.batch.Main (JDT-3.6)
- * run with:
- * java -cp lib/org.eclipse.jdt.core_3.6.0.v_A48.jar:../Fame:/usr/local/share/eclipse/plugins/org.eclipse.equinox.common_3.5.1.R35x_v20090807-1100.jar:/usr/local/share/eclipse/plugins/org.eclipse.equinox.preferences_3.2.301.R35x_v20091117.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.jobs_3.4.100.v20090429-1800.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.contenttype_3.4.1.R35x_v20090826-0451.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.resources_3.5.2.R35x_v20091203-1235.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.runtime_3.5.0.v20090525.jar:/usr/local/share/eclipse/plugins/org.eclipse.osgi_3.5.2.R35x_v20100126.jar:../Fame/lib/akuhn-util-r28011.jar:lib/fame.jar:bin fr.inria.verveine.parser.BatchParser [files|directory]_to_parse
- */
-
-public class BatchParser extends Main {
-	
-	private Repository famixRepo;
-
-	public static void main(String[] args) {
-		new BatchParser(new PrintWriter(System.out), new PrintWriter(System.err), true/*systemExit*/, null/*options*/, null/*progress*/).compile(args);
-	}
-
-	public BatchParser(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, @SuppressWarnings("rawtypes") Map customDefaultOptions, CompilationProgress compilationProgress) {
-		super(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, compilationProgress);
-	}
-
-	/*
-	 *  Low-level API performing the actual parsing
-	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
-	 */
-	public void performCompilation() {
-
-		famixRepo = new Repository(FAMIXModel.metamodel());
-
-		this.compilerOptions = new CompilerOptions(this.options);
-		this.compilerOptions.performMethodsFullRecovery = false;
-		this.compilerOptions.performStatementsRecovery = false;
-
-		// NA --- beginning of parsing code --------------------------------------------------
-		String[] tmpclasspath=null;
-		if (this.checkedClasspaths!=null) {
-			tmpclasspath = new String[this.checkedClasspaths.length];
-			int i = 0;
-			for (Classpath cp : this.checkedClasspaths) {
-				tmpclasspath[i++] = cp.getPath();
-			}
-		}
-
-		ASTParser pars = ASTParser.newParser(AST.JLS3);
-		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
-				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
-				/*encodings*/null, 
-				/*includeRunningVMBootclasspath*/true);
-		pars.setResolveBindings(true);
-		pars.setKind(ASTParser.K_COMPILATION_UNIT);
-		pars.createASTs(/*sourceFilePaths*/this.filenames, 
-				/*encodings*/this.encodings, 
-				/*bindingKeys*/new String[0], 
-				/*requestor*/new FamixRequestor(famixRepo), 
-				/*monitor*/null);
-		// NA --- end of parsing code --------------------------------------------------
-
-		/* 
-		 * NA --- Outputting --------------------------------------------------
-		 * To stdout
-		 * Repository.exportMSE() closes the stream when it finishes, we don't want this
-		 * The NonCloseOutputStream class prevents that by redefining an empty close() that does nothing
-		 * (particularly not closing the underlying System.out)
-		 */
-		//famixRepo.exportMSE( new NonCloseablePrintStream(System.out));
-		//System.out.println();
-		
-		
-		// outputting to a file
-		try {
-			famixRepo.exportMSE(new FileWriter("output.mse"));
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-	}
-
-	public Repository getFamixRepo() {
-		return famixRepo;
-	}
-	
-}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 20)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 21)
@@ -80,7 +80,7 @@
 				fmx.setIsStub(false);
 			}
 			else {
-				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ", fallbacks to creating a stub");
 				// try again without binding
 				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
 			}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 20)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 21)
@@ -76,8 +76,12 @@
 	}
 
 	/**
-	 * Creates or recovers a namespace. Also creates or recovers recusively it's parent namespaces
-	 * At least one of bnd and name must be passed, possibly both
+	 * Creates or recovers a namespace. Also creates or recovers recusively it's parent namespaces.
+	 * At least one of <b>bnd</b> and <b>name</b> must be passed.
+	 * <p>Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
+	 * (for example when creating parent packages of a package we have a binding for).
+	 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
+	 * all is said and done.</p>
 	 * @param bnd - the (optional) binding for the namespace
 	 * @param name - the (optional) full name for the namespace
 	 * @return the namespace created or null
@@ -85,30 +89,22 @@
 	private Namespace ensureFamixNamespaceWithParentScope(IPackageBinding bnd, String name) {
 		Namespace fmx = null;
 		Namespace parent = null;
-		String[] nameComps;
 		
 		if (bnd != null) {
-			nameComps = bnd.getNameComponents();
+			name = bnd.getName();
 		}
-		else {
-			if (name != null) {
-				nameComps = name.split("\\.");
-			}
-			else {
-				return null;
+		
+		if ( (name!=null) && (name.length() > 0) ) {
+			fmx = ensureFamixUniqEntity(Namespace.class, bnd, name);
+			// compute parent's name and creates parent
+			int last = name.lastIndexOf('.');
+			if (last > 0) {
+				parent = ensureFamixNamespaceWithParentScope(null, name.substring(0, last));
 			}
-		}
-
-		for (String nameComp : nameComps ) {
-			fmx = ensureFamixUniqEntity(Namespace.class, null, nameComp);
+			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
 				parent.addChildScopes(fmx);
 			}
-			parent = fmx;
-		}
-		
-		if ( (fmx != null) && (bnd != null) ) {
-			mapBind.put(bnd, fmx);
 		}
 
 		return fmx;
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 21)
@@ -0,0 +1,76 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+import fr.inria.verveine.core.VerveineParser;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/**
+ * A batch parser inspired from org.eclipse.jdt.internal.compiler.batch.Main (JDT-3.6)
+ * run with:
+ * java -cp lib/org.eclipse.jdt.core_3.6.0.v_A48.jar:../Fame:/usr/local/share/eclipse/plugins/org.eclipse.equinox.common_3.5.1.R35x_v20090807-1100.jar:/usr/local/share/eclipse/plugins/org.eclipse.equinox.preferences_3.2.301.R35x_v20091117.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.jobs_3.4.100.v20090429-1800.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.contenttype_3.4.1.R35x_v20090826-0451.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.resources_3.5.2.R35x_v20091203-1235.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.runtime_3.5.0.v20090525.jar:/usr/local/share/eclipse/plugins/org.eclipse.osgi_3.5.2.R35x_v20100126.jar:../Fame/lib/akuhn-util-r28011.jar:lib/fame.jar:bin fr.inria.verveine.extractor.java.VerveineJParser [files|directory]_to_parse
+ */
+
+public class VerveineJParser extends VerveineParser {
+
+	public static void main(String[] args) {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(args);
+		parser.renameNamespaces();
+		parser.outputMSE();
+	}
+
+	/**
+	 * As explained in JavaDictionary, Namespaces are created with their fully qualified name
+	 * We need now to give them their simple name
+	 */
+	public void renameNamespaces() {
+		for (Namespace ns : listAll(Namespace.class)) {
+			String name = ns.getName();
+			int last = name.lastIndexOf('.');
+			if (last >= 0) {
+				ns.setName(name.substring(last+1));
+			}
+		}
+	}
+
+	/*
+	 *  Low-level API performing the actual parsing
+	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
+	 *  SHOULD NOT USE an internal JDT class. But I don't know how to do it otherwise
+	 */
+	public void performCompilation() {
+
+		this.compilerOptions = new CompilerOptions(this.options);
+		this.compilerOptions.performMethodsFullRecovery = false;
+		this.compilerOptions.performStatementsRecovery = false;
+
+		// NA --- beginning of parsing code --------------------------------------------------
+		String[] tmpclasspath=null;
+		if (this.checkedClasspaths!=null) {
+			tmpclasspath = new String[this.checkedClasspaths.length];
+			int i = 0;
+			for (Classpath cp : this.checkedClasspaths) {
+				tmpclasspath[i++] = cp.getPath();
+			}
+		}
+
+		ASTParser pars = ASTParser.newParser(AST.JLS3);
+		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
+				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
+				/*encodings*/null, 
+				/*includeRunningVMBootclasspath*/true);
+		pars.setResolveBindings(true);
+		pars.setKind(ASTParser.K_COMPILATION_UNIT);
+		pars.createASTs(/*sourceFilePaths*/this.filenames, 
+				/*encodings*/this.encodings, 
+				/*bindingKeys*/new String[0], 
+				/*requestor*/new FamixRequestor(getFamixRepo()), 
+				/*monitor*/null);
+		// NA --- end of parsing code --------------------------------------------------
+	}
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.core/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/.classpath	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/.classpath	(revision 99)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: branches/postMoose4_3Refactoring/verveine.core/mse/famix30_complete.mse
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/mse/famix30_complete.mse	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/mse/famix30_complete.mse	(revision 99)
@@ -0,0 +1,1017 @@
+(
+	(FM3.Package (id: 1)
+		(name 'Hismo')
+		(classes
+			(FM3.Class (id: 2)
+				(name 'HismoEntityVersion')
+				(package (ref: 1))
+				(superclass (ref: 3)))
+			(FM3.Class (id: 4)
+				(name 'HismoInvocationHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 3)
+				(name 'HismoAbstractVersion')
+				(package (ref: 1))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 7)
+				(name 'HismoClassHierarchy')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 8)
+				(name 'HismoNamespaceHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 9)
+				(name 'HismoCoChangeHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 10)
+				(name 'HismoMethodHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 11)
+				(name 'HismoAttributeHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 12)
+				(name 'HismoFileHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 13)
+				(name 'HismoFolderHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 14)
+				(name 'HismoInheritanceDefinitionHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 15)
+				(name 'HismoModelHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 16)
+				(name 'HismoClassHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 17)
+				(name 'HismoHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 19)
+				(name 'HismoCoChangePattern')
+				(package (ref: 1))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 5)
+				(name 'HismoAbstractHistory')
+				(package (ref: 1))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 20)
+				(name 'HismoPackageHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 21)
+				(name 'HismoNamespaceVersion')
+				(package (ref: 1))
+				(superclass (ref: 2)))
+			(FM3.Class (id: 22)
+				(name 'HismoClassHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 23)
+				(name 'HismoCoChangeVersion')
+				(package (ref: 1))
+				(superclass (ref: 3)))
+			(FM3.Class (id: 24)
+				(name 'HismoNamespaceHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 25)
+				(name 'HismoMethodHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 26)
+				(name 'HismoAccessHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 27)
+				(name 'HismoMethodVersion')
+				(package (ref: 1))
+				(superclass (ref: 2)))
+			(FM3.Class (id: 28)
+				(name 'HismoClassVersion')
+				(package (ref: 1))
+				(superclass (ref: 2)))))
+	(FM3.Package (id: 29)
+		(name 'FILE')
+		(classes
+			(FM3.Class (id: 30)
+				(name 'Folder')
+				(package (ref: 29))
+				(superclass (ref: 31)))
+			(FM3.Class (id: 32)
+				(name 'File')
+				(package (ref: 29))
+				(superclass (ref: 31)))
+			(FM3.Class (id: 33)
+				(name 'FileGroup')
+				(package (ref: 29))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 31)
+				(name 'AbstractFile')
+				(package (ref: 29))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 34)
+						(name 'name')
+						(class (ref: 31))
+						(type (ref: String)))))
+			(FM3.Class (id: 35)
+				(name 'FolderGroup')
+				(package (ref: 29))
+				(superclass (ref: 18)))))
+	(FM3.Package (id: 36)
+		(name 'Moose')
+		(classes
+			(FM3.Class (id: 18)
+				(name 'Group')
+				(package (ref: 36))
+				(superclass (ref: 37)))
+			(FM3.Class (id: 38)
+				(name 'Entity')
+				(abstract true)
+				(package (ref: 36))
+				(superclass (ref: Object)))
+			(FM3.Class (id: 37)
+				(name 'AbsractGroup')
+				(abstract true)
+				(package (ref: 36))
+				(superclass (ref: 38)))
+			(FM3.Class (id: 39)
+				(name 'Model')
+				(package (ref: 36))
+				(superclass (ref: 37))
+				(attributes
+					(FM3.Property (id: 40)
+						(name 'sourceLanguage')
+						(class (ref: 39))
+						(type (ref: String)))))))
+	(FM3.Package (id: 41)
+		(name 'FAMIX')
+		(classes
+			(FM3.Class (id: 42)
+				(name 'ImplicitVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 44)
+						(name 'container')
+						(class (ref: 42))
+						(type (ref: 45)))))
+			(FM3.Class (id: 46)
+				(name 'FileAnchor')
+				(package (ref: 41))
+				(superclass (ref: 47))
+				(attributes
+					(FM3.Property (id: 48)
+						(name 'fileName')
+						(class (ref: 46))
+						(type (ref: String)))
+					(FM3.Property (id: 49)
+						(name 'startLine')
+						(class (ref: 46))
+						(type (ref: Number)))
+					(FM3.Property (id: 50)
+						(name 'endLine')
+						(class (ref: 46))
+						(type (ref: Number)))))
+			(FM3.Class (id: 51)
+				(name 'Access')
+				(package (ref: 41))
+				(superclass (ref: 52))
+				(attributes
+					(FM3.Property (id: 53)
+						(name 'isWrite')
+						(class (ref: 51))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 54)
+						(name 'variable')
+						(class (ref: 51))
+						(opposite (ref: 55))
+						(type (ref: 43)))
+					(FM3.Property (id: 56)
+						(name 'accessor')
+						(class (ref: 51))
+						(opposite (ref: 57))
+						(type (ref: 58)))
+					(FM3.Property (id: 59)
+						(name 'isRead')
+						(class (ref: 51))
+						(derived true)
+						(type (ref: Boolean)))))
+			(FM3.Class (id: 60)
+				(name 'NamedEntity')
+				(package (ref: 41))
+				(superclass (ref: 61))
+				(attributes
+					(FM3.Property (id: 62)
+						(name 'isStub')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 63)
+						(name 'isAbstract')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 64)
+						(name 'name')
+						(class (ref: 60))
+						(type (ref: String)))
+					(FM3.Property (id: 65)
+						(name 'parentPackage')
+						(class (ref: 60))
+						(opposite (ref: 66))
+						(type (ref: 67)))
+					(FM3.Property (id: 68)
+						(name 'modifiers')
+						(class (ref: 60))
+						(multivalued true)
+						(type (ref: String)))
+					(FM3.Property (id: 69)
+						(name 'isProtected')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 70)
+						(name 'belongsTo')
+						(class (ref: 60))
+						(derived true)
+						(type (ref: 71)))
+					(FM3.Property (id: 72)
+						(name 'isPackage')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 73)
+						(name 'isPublic')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 74)
+						(name 'isPrivate')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 75)
+						(name 'receivingInvocations')
+						(class (ref: 60))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 76))
+						(type (ref: 77)))
+					(FM3.Property (id: 78)
+						(name 'isFinal')
+						(class (ref: 60))
+						(type (ref: Boolean)))))
+			(FM3.Class (id: 79)
+				(name 'Comment')
+				(package (ref: 41))
+				(superclass (ref: 61))
+				(attributes
+					(FM3.Property (id: 80)
+						(name 'content')
+						(class (ref: 79))
+						(type (ref: String)))
+					(FM3.Property (id: 81)
+						(name 'container')
+						(class (ref: 79))
+						(opposite (ref: 82))
+						(type (ref: 61)))))
+			(FM3.Class (id: 83)
+				(name 'GlobalVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 84)
+						(name 'parentScope')
+						(class (ref: 83))
+						(type (ref: 85)))
+					(FM3.Property (id: 86)
+						(name 'parentModule')
+						(class (ref: 83))
+						(opposite (ref: 87))
+						(type (ref: 88)))))
+			(FM3.Class (id: 89)
+				(name 'ThrownException')
+				(package (ref: 41))
+				(superclass (ref: 90))
+				(attributes
+					(FM3.Property (id: 91)
+						(name 'definingMethod')
+						(class (ref: 89))
+						(opposite (ref: 92))
+						(type (ref: 93)))))
+			(FM3.Class (id: 94)
+				(name 'ParameterizableClass')
+				(package (ref: 41))
+				(superclass (ref: 95))
+				(attributes
+					(FM3.Property (id: 96)
+						(name 'parameters')
+						(class (ref: 94))
+						(derived true)
+						(multivalued true)
+						(type (ref: 97)))))
+			(FM3.Class (id: 98)
+				(name 'AnnotationInstance')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 99)
+						(name 'annotationType')
+						(class (ref: 98))
+						(opposite (ref: 100))
+						(type (ref: 101)))
+					(FM3.Property (id: 102)
+						(name 'annotatedEntity')
+						(class (ref: 98))
+						(opposite (ref: 103))
+						(type (ref: 6)))
+					(FM3.Property (id: 104)
+						(name 'attributes')
+						(class (ref: 98))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 105))
+						(type (ref: 106)))))
+			(FM3.Class (id: 107)
+				(name 'LocalVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 108)
+						(name 'parentBehaviouralEntity')
+						(class (ref: 107))
+						(opposite (ref: 109))
+						(type (ref: 58)))))
+			(FM3.Class (id: 61)
+				(name 'SourcedEntity')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 82)
+						(name 'comments')
+						(class (ref: 61))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 81))
+						(type (ref: 79)))
+					(FM3.Property (id: 110)
+						(name 'declaredSourceLanguage')
+						(class (ref: 61))
+						(opposite (ref: 111))
+						(type (ref: 112)))
+					(FM3.Property (id: 113)
+						(name 'sourceAnchor')
+						(class (ref: 61))
+						(opposite (ref: 114))
+						(type (ref: 47)))))
+			(FM3.Class (id: 52)
+				(name 'Association')
+				(package (ref: 41))
+				(superclass (ref: 61))
+				(attributes
+					(FM3.Property (id: 115)
+						(name 'next')
+						(class (ref: 52))
+						(derived true)
+						(opposite (ref: 116))
+						(type (ref: 52)))
+					(FM3.Property (id: 117)
+						(name 'to')
+						(class (ref: 52))
+						(derived true)
+						(type (ref: 60)))
+					(FM3.Property (id: 116)
+						(name 'previous')
+						(class (ref: 52))
+						(opposite (ref: 115))
+						(type (ref: 52)))
+					(FM3.Property (id: 118)
+						(name 'from')
+						(class (ref: 52))
+						(derived true)
+						(type (ref: 60)))))
+			(FM3.Class (id: 119)
+				(name 'SourceTextAnchor')
+				(package (ref: 41))
+				(superclass (ref: 47)))
+			(FM3.Class (id: 77)
+				(name 'Invocation')
+				(package (ref: 41))
+				(superclass (ref: 52))
+				(attributes
+					(FM3.Property (id: 120)
+						(name 'sender')
+						(class (ref: 77))
+						(opposite (ref: 121))
+						(type (ref: 58)))
+					(FM3.Property (id: 122)
+						(name 'signature')
+						(class (ref: 77))
+						(type (ref: String)))
+					(FM3.Property (id: 123)
+						(name 'candidates')
+						(class (ref: 77))
+						(multivalued true)
+						(opposite (ref: 124))
+						(type (ref: 58)))
+					(FM3.Property (id: 76)
+						(name 'receiver')
+						(class (ref: 77))
+						(opposite (ref: 75))
+						(type (ref: 60)))
+					(FM3.Property (id: 125)
+						(name 'receiverSourceCode')
+						(class (ref: 77))
+						(type (ref: String)))))
+			(FM3.Class (id: 106)
+				(name 'AnnotationInstanceAttribute')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 126)
+						(name 'value')
+						(class (ref: 106))
+						(type (ref: String)))
+					(FM3.Property (id: 127)
+						(name 'annotationTypeAttribute')
+						(class (ref: 106))
+						(opposite (ref: 128))
+						(type (ref: 129)))
+					(FM3.Property (id: 105)
+						(name 'parentAnnotationInstance')
+						(class (ref: 106))
+						(opposite (ref: 104))
+						(type (ref: 98)))))
+			(FM3.Class (id: 130)
+				(name 'ClassGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 131)
+				(name 'SmalltalkSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 132)
+				(name 'Reference')
+				(package (ref: 41))
+				(superclass (ref: 52))
+				(attributes
+					(FM3.Property (id: 133)
+						(name 'target')
+						(class (ref: 132))
+						(opposite (ref: 134))
+						(type (ref: 71)))
+					(FM3.Property (id: 135)
+						(name 'source')
+						(class (ref: 132))
+						(opposite (ref: 136))
+						(type (ref: 71)))))
+			(FM3.Class (id: 137)
+				(name 'PrimitiveType')
+				(package (ref: 41))
+				(superclass (ref: 45)))
+			(FM3.Class (id: 90)
+				(name 'Exception')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 138)
+						(name 'exceptionClass')
+						(class (ref: 90))
+						(type (ref: 95)))))
+			(FM3.Class (id: 139)
+				(name 'Attribute')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 140)
+						(name 'hasClassScope')
+						(class (ref: 139))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 141)
+						(name 'parentType')
+						(class (ref: 139))
+						(opposite (ref: 142))
+						(type (ref: 45)))))
+			(FM3.Class (id: 143)
+				(name 'UnknownVariable')
+				(package (ref: 41))
+				(superclass (ref: 43)))
+			(FM3.Class (id: 144)
+				(name 'CSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 129)
+				(name 'AnnotationTypeAttribute')
+				(package (ref: 41))
+				(superclass (ref: 60))
+				(attributes
+					(FM3.Property (id: 145)
+						(name 'declaredType')
+						(class (ref: 129))
+						(type (ref: 45)))
+					(FM3.Property (id: 128)
+						(name 'annotationAttributeInstances')
+						(class (ref: 129))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 127))
+						(type (ref: 106)))
+					(FM3.Property (id: 146)
+						(name 'parentAnnotationType')
+						(class (ref: 129))
+						(opposite (ref: 147))
+						(type (ref: 101)))))
+			(FM3.Class (id: 45)
+				(name 'Type')
+				(package (ref: 41))
+				(superclass (ref: 71))
+				(attributes
+					(FM3.Property (id: 148)
+						(name 'superInheritances')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 149))
+						(type (ref: 150)))
+					(FM3.Property (id: 151)
+						(name 'subInheritances')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 152))
+						(type (ref: 150)))
+					(FM3.Property (id: 153)
+						(name 'container')
+						(class (ref: 45))
+						(opposite (ref: 154))
+						(type (ref: 71)))
+					(FM3.Property (id: 155)
+						(name 'methods')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 156))
+						(type (ref: 93)))
+					(FM3.Property (id: 142)
+						(name 'attributes')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 141))
+						(type (ref: 139)))))
+			(FM3.Class (id: 157)
+				(name 'Parameter')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 158)
+						(name 'parentBehaviouralEntity')
+						(class (ref: 157))
+						(opposite (ref: 159))
+						(type (ref: 58)))))
+			(FM3.Class (id: 6)
+				(name 'Entity')
+				(package (ref: 41))
+				(superclass (ref: Object))
+				(attributes
+					(FM3.Property (id: 103)
+						(name 'annotationInstances')
+						(class (ref: 6))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 102))
+						(type (ref: 98)))))
+			(FM3.Class (id: 160)
+				(name 'EnumValue')
+				(package (ref: 41))
+				(superclass (ref: 60))
+				(attributes
+					(FM3.Property (id: 161)
+						(name 'parentEnum')
+						(class (ref: 160))
+						(opposite (ref: 162))
+						(type (ref: 163)))))
+			(FM3.Class (id: 164)
+				(name 'NamespaceGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 165)
+				(name 'Function')
+				(package (ref: 41))
+				(superclass (ref: 58))
+				(attributes
+					(FM3.Property (id: 166)
+						(name 'parentModule')
+						(class (ref: 165))
+						(opposite (ref: 167))
+						(type (ref: 88)))
+					(FM3.Property (id: 168)
+						(name 'parentScope')
+						(class (ref: 165))
+						(type (ref: 85)))))
+			(FM3.Class (id: 169)
+				(name 'LeafEntity')
+				(package (ref: 41))
+				(superclass (ref: 60)))
+			(FM3.Class (id: 170)
+				(name 'CaughtException')
+				(package (ref: 41))
+				(superclass (ref: 90))
+				(attributes
+					(FM3.Property (id: 171)
+						(name 'definingMethod')
+						(class (ref: 170))
+						(opposite (ref: 172))
+						(type (ref: 93)))))
+			(FM3.Class (id: 88)
+				(name 'Module')
+				(package (ref: 41))
+				(superclass (ref: 85)))
+			(FM3.Class (id: 101)
+				(name 'AnnotationType')
+				(package (ref: 41))
+				(superclass (ref: 60))
+				(attributes
+					(FM3.Property (id: 147)
+						(name 'attributes')
+						(class (ref: 101))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 146))
+						(type (ref: 129)))
+					(FM3.Property (id: 173)
+						(name 'container')
+						(class (ref: 101))
+						(opposite (ref: 174))
+						(type (ref: 71)))
+					(FM3.Property (id: 100)
+						(name 'instances')
+						(class (ref: 101))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 99))
+						(type (ref: 98)))))
+			(FM3.Class (id: 175)
+				(name 'PackageGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 176)
+				(name 'Namespace')
+				(package (ref: 41))
+				(superclass (ref: 85)))
+			(FM3.Class (id: 177)
+				(name 'DeclaredException')
+				(package (ref: 41))
+				(superclass (ref: 90))
+				(attributes
+					(FM3.Property (id: 178)
+						(name 'definingMethod')
+						(class (ref: 177))
+						(opposite (ref: 179))
+						(type (ref: 93)))))
+			(FM3.Class (id: 67)
+				(name 'Package')
+				(package (ref: 41))
+				(superclass (ref: 85))
+				(attributes
+					(FM3.Property (id: 66)
+						(name 'childNamedEntities')
+						(class (ref: 67))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 65))
+						(type (ref: 60)))))
+			(FM3.Class (id: 150)
+				(name 'Inheritance')
+				(package (ref: 41))
+				(superclass (ref: 52))
+				(attributes
+					(FM3.Property (id: 152)
+						(name 'superclass')
+						(class (ref: 150))
+						(opposite (ref: 151))
+						(type (ref: 45)))
+					(FM3.Property (id: 149)
+						(name 'subclass')
+						(class (ref: 150))
+						(opposite (ref: 148))
+						(type (ref: 45)))))
+			(FM3.Class (id: 85)
+				(name 'ScopingEntity')
+				(package (ref: 41))
+				(superclass (ref: 71))
+				(attributes
+					(FM3.Property (id: 87)
+						(name 'globalVariables')
+						(class (ref: 85))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 86))
+						(type (ref: 83)))
+					(FM3.Property (id: 167)
+						(name 'functions')
+						(class (ref: 85))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 166))
+						(type (ref: 165)))
+					(FM3.Property (id: 180)
+						(name 'childScopes')
+						(class (ref: 85))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 181))
+						(type (ref: 85)))
+					(FM3.Property (id: 181)
+						(name 'parentScope')
+						(class (ref: 85))
+						(opposite (ref: 180))
+						(type (ref: 85)))))
+			(FM3.Class (id: 182)
+				(name 'AnnotationTypeGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 93)
+				(name 'Method')
+				(package (ref: 41))
+				(superclass (ref: 58))
+				(attributes
+					(FM3.Property (id: 179)
+						(name 'declaredExceptions')
+						(class (ref: 93))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 178))
+						(type (ref: 177)))
+					(FM3.Property (id: 183)
+						(name 'hasClassScope')
+						(class (ref: 93))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 184)
+						(name 'kind')
+						(class (ref: 93))
+						(type (ref: String)))
+					(FM3.Property (id: 172)
+						(name 'caughtExceptions')
+						(class (ref: 93))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 171))
+						(type (ref: 170)))
+					(FM3.Property (id: 92)
+						(name 'thrownExceptions')
+						(class (ref: 93))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 91))
+						(type (ref: 89)))
+					(FM3.Property (id: 156)
+						(name 'parentType')
+						(class (ref: 93))
+						(opposite (ref: 155))
+						(type (ref: 45)))))
+			(FM3.Class (id: 185)
+				(name 'MethodGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 112)
+				(name 'SourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 186)
+						(name 'name')
+						(class (ref: 112))
+						(derived true)
+						(type (ref: String)))
+					(FM3.Property (id: 111)
+						(name 'sourcedEntities')
+						(class (ref: 112))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 110))
+						(type (ref: 61)))))
+			(FM3.Class (id: 97)
+				(name 'ParameterType')
+				(package (ref: 41))
+				(superclass (ref: 45)))
+			(FM3.Class (id: 187)
+				(name 'ParameterizedType')
+				(package (ref: 41))
+				(superclass (ref: 45))
+				(attributes
+					(FM3.Property (id: 188)
+						(name 'arguments')
+						(class (ref: 187))
+						(multivalued true)
+						(type (ref: 45)))
+					(FM3.Property (id: 189)
+						(name 'parameterizableClass')
+						(class (ref: 187))
+						(type (ref: 94)))))
+			(FM3.Class (id: 71)
+				(name 'ContainerEntity')
+				(package (ref: 41))
+				(superclass (ref: 60))
+				(attributes
+					(FM3.Property (id: 154)
+						(name 'types')
+						(class (ref: 71))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 153))
+						(type (ref: 45)))
+					(FM3.Property (id: 136)
+						(name 'outgoingReferences')
+						(class (ref: 71))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 135))
+						(type (ref: 132)))
+					(FM3.Property (id: 134)
+						(name 'incomingReferences')
+						(class (ref: 71))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 133))
+						(type (ref: 132)))
+					(FM3.Property (id: 174)
+						(name 'definedAnnotationTypes')
+						(class (ref: 71))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 173))
+						(type (ref: 101)))))
+			(FM3.Class (id: 163)
+				(name 'Enum')
+				(package (ref: 41))
+				(superclass (ref: 45))
+				(attributes
+					(FM3.Property (id: 162)
+						(name 'values')
+						(class (ref: 163))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 161))
+						(type (ref: 160)))))
+			(FM3.Class (id: 190)
+				(name 'JavaSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 191)
+				(name 'CustomSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112))
+				(attributes
+					(FM3.Property (id: 192)
+						(name 'name')
+						(class (ref: 191))
+						(type (ref: String)))))
+			(FM3.Class (id: 43)
+				(name 'StructuralEntity')
+				(package (ref: 41))
+				(superclass (ref: 169))
+				(attributes
+					(FM3.Property (id: 193)
+						(name 'declaredType')
+						(class (ref: 43))
+						(type (ref: 45)))
+					(FM3.Property (id: 55)
+						(name 'incomingAccesses')
+						(class (ref: 43))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 54))
+						(type (ref: 51)))))
+			(FM3.Class (id: 58)
+				(name 'BehaviouralEntity')
+				(package (ref: 41))
+				(superclass (ref: 71))
+				(attributes
+					(FM3.Property (id: 57)
+						(name 'accesses')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 56))
+						(type (ref: 51)))
+					(FM3.Property (id: 194)
+						(name 'declaredType')
+						(class (ref: 58))
+						(type (ref: 45)))
+					(FM3.Property (id: 124)
+						(name 'incomingInvocations')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 123))
+						(type (ref: 77)))
+					(FM3.Property (id: 121)
+						(name 'outgoingInvocations')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 120))
+						(type (ref: 77)))
+					(FM3.Property (id: 159)
+						(name 'parameters')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 158))
+						(type (ref: 157)))
+					(FM3.Property (id: 109)
+						(name 'localVariables')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 108))
+						(type (ref: 107)))
+					(FM3.Property (id: 195)
+						(name 'signature')
+						(class (ref: 58))
+						(type (ref: String)))))
+			(FM3.Class (id: 196)
+				(name 'GlobalVariableGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 47)
+				(name 'SourceAnchor')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 114)
+						(name 'element')
+						(class (ref: 47))
+						(opposite (ref: 113))
+						(type (ref: 61)))))
+			(FM3.Class (id: 197)
+				(name 'UnknownSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 95)
+				(name 'Class')
+				(package (ref: 41))
+				(superclass (ref: 45))
+				(attributes
+					(FM3.Property (id: 198)
+						(name 'isInterface')
+						(class (ref: 95))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 199)
+						(name 'isAbstract')
+						(class (ref: 95))
+						(derived true)
+						(type (ref: Boolean)))))
+			(FM3.Class (id: 200)
+				(name 'SmalltalkMonticelloSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))))
+	(FM3.Package (id: 201)
+		(name 'Dude')
+		(classes
+			(FM3.Class (id: 202)
+				(name 'DuplicationGroup')
+				(package (ref: 201))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 203)
+				(name 'Duplication')
+				(package (ref: 201))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 204)
+						(name 'multiplicationInvolved')
+						(class (ref: 203))
+						(opposite (ref: 205))
+						(type (ref: 206)))))
+			(FM3.Class (id: 207)
+				(name 'CodeLine')
+				(package (ref: 201))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 208)
+				(name 'CodeFragment')
+				(package (ref: 201))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 206)
+				(name 'Multiplication')
+				(package (ref: 201))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 205)
+						(name 'duplications')
+						(class (ref: 206))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 204))
+						(type (ref: 203)))))
+			(FM3.Class (id: 209)
+				(name 'MultiplicationGroup')
+				(package (ref: 201))
+				(superclass (ref: 18))))))
Index: branches/postMoose4_3Refactoring/verveine.core/mse/famix30_famix.mse
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/mse/famix30_famix.mse	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/mse/famix30_famix.mse	(revision 99)
@@ -0,0 +1,648 @@
+(+	(FM3.Package (id: 1)+		(name 'FAMIX')+		(classes+			(FM3.Class (id: 2)+				(name 'LocalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 4)+						(name 'parentBehaviouralEntity')+						(class (ref: 2))+						(opposite (ref: 5))+						(type (ref: 6)))))+			(FM3.Class (id: 7)+				(name 'GlobalVariableGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 9)+				(name 'SourceAnchor')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 11)+						(name 'element')+						(class (ref: 9))+						(opposite (ref: 12))+						(type (ref: 13)))))+			(FM3.Class (id: 14)+				(name 'PrimitiveType')+				(package (ref: 1))+				(superclass (ref: 15)))+			(FM3.Class (id: 16)+				(name 'Parameter')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 17)+						(name 'parentBehaviouralEntity')+						(class (ref: 16))+						(opposite (ref: 18))+						(type (ref: 6)))))+			(FM3.Class (id: 10)+				(name 'Entity')+				(package (ref: 1))+				(superclass (ref: Object))+				(attributes+					(FM3.Property (id: 19)+						(name 'annotationInstances')+						(class (ref: 10))+						(derived true)+						(multivalued true)+						(opposite (ref: 20))+						(type (ref: 21)))))+			(FM3.Class (id: 22)+				(name 'ImplicitVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 23)+						(name 'container')+						(class (ref: 22))+						(type (ref: 15)))))+			(FM3.Class (id: 24)+				(name 'MethodGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 25)+				(name 'Inheritance')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 27)+						(name 'superclass')+						(class (ref: 25))+						(opposite (ref: 28))+						(type (ref: 15)))+					(FM3.Property (id: 29)+						(name 'subclass')+						(class (ref: 25))+						(opposite (ref: 30))+						(type (ref: 15)))))+			(FM3.Class (id: 3)+				(name 'StructuralEntity')+				(package (ref: 1))+				(superclass (ref: 31))+				(attributes+					(FM3.Property (id: 32)+						(name 'incomingAccesses')+						(class (ref: 3))+						(derived true)+						(multivalued true)+						(opposite (ref: 33))+						(type (ref: 34)))+					(FM3.Property (id: 35)+						(name 'declaredType')+						(class (ref: 3))+						(type (ref: 15)))))+			(FM3.Class (id: 36)+				(name 'Attribute')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 37)+						(name 'parentType')+						(class (ref: 36))+						(opposite (ref: 38))+						(type (ref: 15)))+					(FM3.Property (id: 39)+						(name 'hasClassScope')+						(class (ref: 36))+						(type (ref: Boolean)))))+			(FM3.Class (id: 40)+				(name 'Invocation')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 41)+						(name 'signature')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 42)+						(name 'receiverSourceCode')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 43)+						(name 'candidates')+						(class (ref: 40))+						(multivalued true)+						(opposite (ref: 44))+						(type (ref: 6)))+					(FM3.Property (id: 45)+						(name 'sender')+						(class (ref: 40))+						(opposite (ref: 46))+						(type (ref: 6)))+					(FM3.Property (id: 47)+						(name 'receiver')+						(class (ref: 40))+						(opposite (ref: 48))+						(type (ref: 49)))))+			(FM3.Class (id: 50)+				(name 'Reference')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 51)+						(name 'target')+						(class (ref: 50))+						(opposite (ref: 52))+						(type (ref: 53)))+					(FM3.Property (id: 54)+						(name 'source')+						(class (ref: 50))+						(opposite (ref: 55))+						(type (ref: 53)))))+			(FM3.Class (id: 56)+				(name 'DeclaredException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 58)+						(name 'definingMethod')+						(class (ref: 56))+						(opposite (ref: 59))+						(type (ref: 60)))))+			(FM3.Class (id: 61)+				(name 'ScopingEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 62)+						(name 'functions')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 63))+						(type (ref: 64)))+					(FM3.Property (id: 65)+						(name 'childScopes')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 66))+						(type (ref: 61)))+					(FM3.Property (id: 66)+						(name 'parentScope')+						(class (ref: 61))+						(opposite (ref: 65))+						(type (ref: 61)))+					(FM3.Property (id: 67)+						(name 'globalVariables')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 68))+						(type (ref: 69)))))+			(FM3.Class (id: 53)+				(name 'ContainerEntity')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 52)+						(name 'incomingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 51))+						(type (ref: 50)))+					(FM3.Property (id: 70)+						(name 'definedAnnotationTypes')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 71))+						(type (ref: 72)))+					(FM3.Property (id: 73)+						(name 'types')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 74))+						(type (ref: 15)))+					(FM3.Property (id: 55)+						(name 'outgoingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 54))+						(type (ref: 50)))))+			(FM3.Class (id: 75)+				(name 'Package')+				(package (ref: 1))+				(superclass (ref: 61))+				(attributes+					(FM3.Property (id: 76)+						(name 'childNamedEntities')+						(class (ref: 75))+						(derived true)+						(multivalued true)+						(opposite (ref: 77))+						(type (ref: 49)))))+			(FM3.Class (id: 78)+				(name 'FileAnchor')+				(package (ref: 1))+				(superclass (ref: 9))+				(attributes+					(FM3.Property (id: 79)+						(name 'endLine')+						(class (ref: 78))+						(type (ref: Number)))+					(FM3.Property (id: 80)+						(name 'fileName')+						(class (ref: 78))+						(type (ref: String)))+					(FM3.Property (id: 81)+						(name 'startLine')+						(class (ref: 78))+						(type (ref: Number)))))+			(FM3.Class (id: 6)+				(name 'BehaviouralEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 82)+						(name 'accesses')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 83))+						(type (ref: 34)))+					(FM3.Property (id: 84)+						(name 'declaredType')+						(class (ref: 6))+						(type (ref: 15)))+					(FM3.Property (id: 5)+						(name 'localVariables')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 4))+						(type (ref: 2)))+					(FM3.Property (id: 44)+						(name 'incomingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 43))+						(type (ref: 40)))+					(FM3.Property (id: 18)+						(name 'parameters')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 17))+						(type (ref: 16)))+					(FM3.Property (id: 85)+						(name 'signature')+						(class (ref: 6))+						(type (ref: String)))+					(FM3.Property (id: 46)+						(name 'outgoingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 45))+						(type (ref: 40)))))+			(FM3.Class (id: 57)+				(name 'Exception')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 86)+						(name 'exceptionClass')+						(class (ref: 57))+						(type (ref: 87)))))+			(FM3.Class (id: 15)+				(name 'Type')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 28)+						(name 'subInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 27))+						(type (ref: 25)))+					(FM3.Property (id: 30)+						(name 'superInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 29))+						(type (ref: 25)))+					(FM3.Property (id: 38)+						(name 'attributes')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 37))+						(type (ref: 36)))+					(FM3.Property (id: 88)+						(name 'methods')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 89))+						(type (ref: 60)))+					(FM3.Property (id: 74)+						(name 'container')+						(class (ref: 15))+						(opposite (ref: 73))+						(type (ref: 53)))))+			(FM3.Class (id: 90)+				(name 'ClassGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 91)+				(name 'Namespace')+				(package (ref: 1))+				(superclass (ref: 61)))+			(FM3.Class (id: 60)+				(name 'Method')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 92)+						(name 'caughtExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 93))+						(type (ref: 94)))+					(FM3.Property (id: 89)+						(name 'parentType')+						(class (ref: 60))+						(opposite (ref: 88))+						(type (ref: 15)))+					(FM3.Property (id: 95)+						(name 'hasClassScope')+						(class (ref: 60))+						(type (ref: Boolean)))+					(FM3.Property (id: 96)+						(name 'kind')+						(class (ref: 60))+						(type (ref: String)))+					(FM3.Property (id: 59)+						(name 'declaredExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 58))+						(type (ref: 56)))+					(FM3.Property (id: 97)+						(name 'thrownExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 98))+						(type (ref: 99)))))+			(FM3.Class (id: 100)+				(name 'Comment')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 101)+						(name 'container')+						(class (ref: 100))+						(opposite (ref: 102))+						(type (ref: 13)))+					(FM3.Property (id: 103)+						(name 'content')+						(class (ref: 100))+						(type (ref: String)))))+			(FM3.Class (id: 49)+				(name 'NamedEntity')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 104)+						(name 'modifiers')+						(class (ref: 49))+						(multivalued true)+						(type (ref: String)))+					(FM3.Property (id: 105)+						(name 'isAbstract')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 106)+						(name 'isPublic')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 107)+						(name 'belongsTo')+						(class (ref: 49))+						(derived true)+						(type (ref: 53)))+					(FM3.Property (id: 108)+						(name 'isPrivate')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 109)+						(name 'isPackage')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 110)+						(name 'name')+						(class (ref: 49))+						(type (ref: String)))+					(FM3.Property (id: 77)+						(name 'parentPackage')+						(class (ref: 49))+						(opposite (ref: 76))+						(type (ref: 75)))+					(FM3.Property (id: 48)+						(name 'receivingInvocations')+						(class (ref: 49))+						(derived true)+						(multivalued true)+						(opposite (ref: 47))+						(type (ref: 40)))+					(FM3.Property (id: 111)+						(name 'isProtected')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 112)+						(name 'isStub')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 113)+						(name 'isFinal')+						(class (ref: 49))+						(type (ref: Boolean)))))+			(FM3.Class (id: 21)+				(name 'AnnotationInstance')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 114)+						(name 'annotationType')+						(class (ref: 21))+						(opposite (ref: 115))+						(type (ref: 72)))+					(FM3.Property (id: 20)+						(name 'annotatedEntity')+						(class (ref: 21))+						(opposite (ref: 19))+						(type (ref: 10)))))+			(FM3.Class (id: 116)+				(name 'PackageGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 117)+				(name 'NamespaceGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 64)+				(name 'Function')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 63)+						(name 'parentScope')+						(class (ref: 64))+						(opposite (ref: 62))+						(type (ref: 61)))))+			(FM3.Class (id: 13)+				(name 'SourcedEntity')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 12)+						(name 'sourceAnchor')+						(class (ref: 13))+						(opposite (ref: 11))+						(type (ref: 9)))+					(FM3.Property (id: 102)+						(name 'comments')+						(class (ref: 13))+						(derived true)+						(multivalued true)+						(opposite (ref: 101))+						(type (ref: 100)))))+			(FM3.Class (id: 118)+				(name 'UnknownVariable')+				(package (ref: 1))+				(superclass (ref: 3)))+			(FM3.Class (id: 69)+				(name 'GlobalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 68)+						(name 'parentScope')+						(class (ref: 69))+						(opposite (ref: 67))+						(type (ref: 61)))))+			(FM3.Class (id: 87)+				(name 'Class')+				(package (ref: 1))+				(superclass (ref: 15))+				(attributes+					(FM3.Property (id: 119)+						(name 'isAbstract')+						(class (ref: 87))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 120)+						(name 'isInterface')+						(class (ref: 87))+						(type (ref: Boolean)))))+			(FM3.Class (id: 72)+				(name 'AnnotationType')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 71)+						(name 'container')+						(class (ref: 72))+						(opposite (ref: 70))+						(type (ref: 53)))+					(FM3.Property (id: 115)+						(name 'instances')+						(class (ref: 72))+						(derived true)+						(multivalued true)+						(opposite (ref: 114))+						(type (ref: 21)))))+			(FM3.Class (id: 31)+				(name 'LeafEntity')+				(package (ref: 1))+				(superclass (ref: 49)))+			(FM3.Class (id: 94)+				(name 'CaughtException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 93)+						(name 'definingMethod')+						(class (ref: 94))+						(opposite (ref: 92))+						(type (ref: 60)))))+			(FM3.Class (id: 99)+				(name 'ThrownException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 98)+						(name 'definingMethod')+						(class (ref: 99))+						(opposite (ref: 97))+						(type (ref: 60)))))+			(FM3.Class (id: 34)+				(name 'Access')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 121)+						(name 'isRead')+						(class (ref: 34))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 122)+						(name 'isWrite')+						(class (ref: 34))+						(type (ref: Boolean)))+					(FM3.Property (id: 83)+						(name 'accessor')+						(class (ref: 34))+						(opposite (ref: 82))+						(type (ref: 6)))+					(FM3.Property (id: 33)+						(name 'variable')+						(class (ref: 34))+						(opposite (ref: 32))+						(type (ref: 3)))))+			(FM3.Class (id: 123)+				(name 'SourceTextAnchor')+				(package (ref: 1))+				(superclass (ref: 9)))+			(FM3.Class (id: 26)+				(name 'Association')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 124)+						(name 'previous')+						(class (ref: 26))+						(opposite (ref: 125))+						(type (ref: 26)))+					(FM3.Property (id: 126)+						(name 'to')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 127)+						(name 'from')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 125)+						(name 'next')+						(class (ref: 26))+						(derived true)+						(opposite (ref: 124))+						(type (ref: 26)))))))+)
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.core/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.core/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.core/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.core/lib/fame.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.core/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.core/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 45)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 46)
@@ -5,6 +5,7 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
@@ -14,6 +15,8 @@
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
@@ -128,7 +131,7 @@
 			return ensureFamixClass(bnd);
 		}
 	}
-
+	
 	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
 
 		if (bnd == null) {
@@ -141,6 +144,20 @@
 		mapBind.put(bnd, fmx);
 		return fmx;
 	}
+	
+	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
+
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
+			return null;
+		}
+		
+		AnnotationType fmx = ensureFamixUniqEntity(AnnotationType.class, null, bnd.getName());
+		fmx.setIsStub(true);
+		fmx.setContainer(ensureFamixNamespace(bnd.getPackage()));
+		mapBind.put(bnd, fmx);
+		return fmx;
+	}
 
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
@@ -578,6 +595,21 @@
 		}
 		return fmx;
 	}
+	
+	/**
+	 * Creates and returns a FAMIX AnnotationInstance and associates it with an Entity and an AnnotationType
+	 * @param name -- the name (String) of the annotation 
+	 * @param owner -- the entity concerned by this annotation
+	 * @return the FAMIX AnnotationInstance
+	 */
+	public AnnotationInstance createFamixAnnotationInstance(SourcedEntity owner, AnnotationType annType) {
+		AnnotationInstance fmx = new AnnotationInstance();
+		fmx.setAnnotatedEntity(owner);
+		fmx.setAnnotationType(annType);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
 
 	/**
 	 * Adds location information to a Famix Entity.
@@ -699,5 +731,4 @@
 
 		return fmx;
 	}
-
-}
+}
\ No newline at end of file
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 7)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 8)
@@ -208,16 +208,21 @@
 		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
 		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
-		
+		assertTrue(ns.getIsStub());
+			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
 		assertNotNull(obj);
-		assertFalse(ns.getIsStub());
+		assertTrue(ns.getIsStub());
 		assertSame(ns, obj.getContainer());
 		
 		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
 		assertNotNull(str);
-		assertFalse(str.getIsStub());
+		assertTrue(str.getIsStub());
 		assertSame(ns, str.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsStub());
 	}
 
 	@Test
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 7)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 8)
@@ -1,6 +1,5 @@
 package fr.inria.verveine.extractor.java;
 
-import java.util.Iterator;
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
@@ -23,6 +22,7 @@
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -56,7 +56,10 @@
 		}
 		else {
 			fmx = dico.ensureFamixNamespace(pckg.resolveBinding());
-			if (fmx == null) {
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+			else {
 				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
 				// try again without binding
 				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
@@ -75,7 +78,10 @@
 	public boolean visit(TypeDeclaration node) {
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(node.resolveBinding());
-		if (fmx == null) {
+		if (fmx != null) {
+			fmx.setIsStub(false);
+		}
+		else {
 			// TODO try to find a binded version corresponding to this stub?
 			System.err.println("         Class="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixClass(node.getName().getIdentifier());
@@ -97,7 +103,10 @@
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
 			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding());
-			if (fmx == null) {
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+			else {
 				System.err.println("         Class="+"anonymous(??),  fallback to creating a stub");
 				fmx = dico.ensureFamixClass("anonymous(??)");
 				dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
@@ -114,23 +123,28 @@
 		super.endVisit(node);
 	}
 
+	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
 		Method fmx = dico.ensureFamixMethod(node.resolveBinding());
-		if (fmx == null) {
+		if (fmx != null) {
+			fmx.setIsStub(false);
+		}
+		else {
 			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
 			fmx.setSignature(fmx.getName()+" (???)");
 			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
 		}
-		
+
+		// creating the method's parameters
 		if (fmx != null) {
-			@SuppressWarnings("unchecked")
-			Iterator<SingleVariableDeclaration> iter = node.parameters().iterator();
-			while (iter.hasNext()) {
-				SingleVariableDeclaration param = iter.next();
-				dico.ensureFamixParameter(param.resolveBinding());
+			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding());
+				if (fmxParam != null) {
+					fmxParam.setIsStub(false);
+				}
 			}
 			
 			dico.addSourceAnchor(fmx, node);
@@ -150,7 +164,10 @@
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
 //			System.err.println("            Field: "+vd.getName().getIdentifier());
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
-			if (fmx == null) {
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+			else {
 				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
@@ -184,7 +201,10 @@
 
 		for (VariableDeclarationFragment vd : fragments) {
 			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding());
-			if (fmx == null) {
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+			else {
 				System.err.println("         Variable="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 7)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 8)
@@ -63,20 +63,13 @@
 
 		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, null);
 
-		if (fmx!=null) {
-			fmx.setIsStub(Boolean.FALSE);			
-		}
 		return fmx;
 	}
 
 	@Override
 	public Namespace ensureFamixNamespace(String name) {
 		Namespace fmx = ensureFamixNamespaceWithParentScope(null, name);
-		
-		if (fmx!=null) {
-			fmx.setIsStub(Boolean.FALSE);			
-		}
-		
+
 		return fmx;
 	}
 
@@ -130,6 +123,7 @@
 		ContainerEntity owner = null;
 		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
 		String identifier = null;
+		boolean wasBound = false;
 		
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
@@ -212,7 +206,11 @@
 		// ... trying to recover from binding
 		fmx = (fr.inria.verveine.core.gen.famix.Class) getEntityByBinding(bnd);
 		
-		if (fmx == null) {
+		if (fmx != null) {
+			wasBound = true;
+		}
+		else {
+			wasBound = false;
 			// trying to recover from name and other informations
 			for (fr.inria.verveine.core.gen.famix.Class candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, identifier) ) {
 				if ( (! candidate.getIsStub()) &&
@@ -244,11 +242,11 @@
 		
 		if (fmx == null) {
 			// could not recover it, creating a new entity
-			fmx = (fr.inria.verveine.core.gen.famix.Class) ensureFamixStub(fr.inria.verveine.core.gen.famix.Class.class, bnd, bnd.getName());
+			fmx = (fr.inria.verveine.core.gen.famix.Class) ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, bnd.getName());
 		}
 		
-		if ((fmx!=null) && fmx.getIsStub()) {
-			// apparently we just created it or it already existed as a stub, so add information to it
+		if ((fmx!=null) && (! wasBound)) {
+			// apparently we just created it or it already existed but was not bound, so add information to it
 			fmx.setIsInterface(bnd.isInterface());
 			fmx.setContainer(owner);
 			if (sups.size() > 0) {
@@ -263,7 +261,6 @@
 				fmx.addModifiers("abstract");
 			}
 			fmx.setName(identifier); // might be different from bnd.getName() in the case of anonymous class
-			fmx.setIsStub(Boolean.FALSE);
 		}
 	
 		return fmx;
@@ -280,6 +277,7 @@
 		fr.inria.verveine.core.gen.famix.Class parentClass = null;
 		fr.inria.verveine.core.gen.famix.Class rettyp = null;
 		String sig = null;
+		boolean wasBound = false;
 		
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Method");
@@ -316,13 +314,18 @@
 		// ... trying to recover from binding
 		fmx = (Method) getEntityByBinding(bnd);
 		
-		if (fmx == null) {
+		if (fmx != null) {
+			wasBound = true;
+		}
+		else {
+			wasBound = false;
 			// trying to recover from name and other informations
 			for (Method candidate : getEntityByName(Method.class, bnd.getName()) ) {
-				if ( (! candidate.getIsStub()) &&
-					 (candidate.getParentType() == parentClass) &&
+				if ( (candidate.getParentType() == parentClass) &&
 					 (candidate.getDeclaredType() == rettyp) &&
 					 (candidate.getSignature().equals(sig)) ) {
+					// we could also test that this candidate is not bound yet (to another bnd)
+					// but it requires significant modifications and might not be that useful?
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
 					break;
@@ -332,17 +335,16 @@
 		
 		if (fmx == null) {
 			// could not recover it, creating a new entity
-			fmx = (Method) ensureFamixStub(Method.class, bnd, bnd.getName());
+			fmx = (Method) ensureFamixEntity(Method.class, bnd, bnd.getName());
 		}
 		
-		if ((fmx!=null) && fmx.getIsStub()) {
+		if ((fmx!=null) && (! wasBound) ) {
 			// apparently we just created it or it already existed as a stub, so add information to it
 			fmx.setParentType(parentClass);
 			fmx.setDeclaredType(rettyp);	
 			fmx.setName(bnd.getName());
 			fmx.setSignature(sig);
 			setNamedEntityModifiers(fmx, bnd.getModifiers());
-			fmx.setIsStub(Boolean.FALSE);
 		}
 
 		return fmx;
@@ -358,6 +360,7 @@
 	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
 		fr.inria.verveine.core.gen.famix.Class parentClass = null;
 		fr.inria.verveine.core.gen.famix.Class typ = null;
+		boolean wasBound = false;
 
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Attribute");
@@ -372,7 +375,11 @@
 		// ... trying to recover from binding
 		fmx = (Attribute) getEntityByBinding(bnd);
 		
-		if (fmx == null) {
+		if (fmx != null) {
+			wasBound = true;
+		}
+		else {
+			wasBound = false;
 			// trying to recover from name and other informationsparentBehaviouralEntity
 			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
 				if ( (! candidate.getIsStub()) &&
@@ -387,16 +394,15 @@
 		
 		if (fmx == null) {
 			// could not recover it, creating a new entity
-			fmx = ensureFamixStub(Attribute.class, bnd, bnd.getName());
+			fmx = ensureFamixEntity(Attribute.class, bnd, bnd.getName());
 		}
 		
-		if ((fmx!=null) && fmx.getIsStub()) {
+		if ((fmx!=null) && (! wasBound) ) {
 			// apparently we just created it, so add information to it
 			setNamedEntityModifiers(fmx, bnd.getModifiers());
 			fmx.setParentType(parentClass);
 			fmx.setDeclaredType(typ);	
 			fmx.setName(bnd.getName());
-			fmx.setIsStub(Boolean.FALSE);
 		}
 
 		return fmx;
@@ -423,20 +429,30 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Parameter ensureFamixParameter(IVariableBinding bnd) {
+		boolean wasBound = false;
+		
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Parameter");
 			return null;
 		}
 
-		Parameter fmx = (Parameter) ensureFamixStub(Parameter.class, bnd, bnd.getName());
-		if ( (fmx!=null) && fmx.getIsStub() ) {
+		// actually it seems to be very little chances that the aprameter alreasy exist.
+		// but who knows? Does not hurt to try
+		Parameter fmx = (Parameter) getEntityByBinding(bnd);
+		
+		if (fmx != null) {
+			wasBound = true;
+		}
+		else {
+			wasBound = false;
+			fmx = (Parameter) ensureFamixEntity(Parameter.class, bnd, bnd.getName());
+		}
+		
+		if ( (fmx!=null) && (! wasBound) ) {
 			// declaring method
 			fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
-
 			// type of the attribute
 			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
-
-			fmx.setIsStub(Boolean.FALSE);
 		}
 		
 		return fmx;
@@ -452,6 +468,7 @@
 	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
 		Method parentMeth = null;
 		fr.inria.verveine.core.gen.famix.Class typ = null;
+		boolean wasBound = false;
 
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix LocalVariable");
@@ -466,11 +483,14 @@
 		// ... trying to recover from binding
 		fmx = (LocalVariable) getEntityByBinding(bnd);
 
-		if (fmx == null) {
+		if (fmx != null) {
+			wasBound = true;
+		}
+		else {
+			wasBound = false;
 			// trying to recover from name and other informationsparentBehaviouralEntity
 			for (LocalVariable candidate : getEntityByName(LocalVariable.class, bnd.getName()) ) {
-				if ( (! candidate.getIsStub()) &&
-					 (candidate.getParentBehaviouralEntity() == parentMeth) &&
+				if ( (candidate.getParentBehaviouralEntity() == parentMeth) &&
 					 (candidate.getDeclaredType() == typ) ) {
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
@@ -481,14 +501,13 @@
 		
 		if (fmx == null) {
 			// could not recover it, creating a new entity
-			fmx = ensureFamixStub(LocalVariable.class, bnd, bnd.getName());
+			fmx = ensureFamixEntity(LocalVariable.class, bnd, bnd.getName());
 		}
 
-		if ( (fmx!=null) && fmx.getIsStub() ) {
+		if ( (fmx!=null) && (! wasBound) ) {
 			// apparently we just created it, so add information to it
 			fmx.setParentBehaviouralEntity(parentMeth);
 			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
-			fmx.setIsStub(Boolean.FALSE);
 		}
 		
 		return fmx;
@@ -503,10 +522,9 @@
 	 */
 	public UnknownVariable createFamixUnknownVariable(fr.inria.verveine.core.gen.famix.Class ofType, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
-		UnknownVariable fmx = (UnknownVariable) createFamixStub(UnknownVariable.class, name);
+		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(ofType);
-			fmx.setIsStub(Boolean.FALSE);
 		}
 		return fmx;
 	}
@@ -569,8 +587,6 @@
 	 */
 	public Namespace ensureFamixNamespaceJavaLang(IPackageBinding bnd) {
 		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, OBJECT_PACKAGE_NAME);
-		
-		fmx.setIsStub(false);
 
 		return fmx;
 	}
@@ -582,22 +598,20 @@
 	 */
 	public Namespace ensureFamixNamespacePrimitives() {
 		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, PRIMITIVE_PCKG_NAME);
-		fmx.setIsStub(false);
 
 		return fmx;
 	}
 
 	/**
-	 * Creates or recovers a Famix Class for the Java "Object".
-	 * @param bnd -- a potential binding for the java "object" class
-	 * @return a Famix class for Java "Object"
+	 * Creates or recovers the Famix Class for "Object".
+	 * @param bnd -- a potential binding for the java "Object" class
+	 * @return a Famix class for "Object"
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
 		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
 		
 		fmx.setContainer( ensureFamixNamespaceJavaLang(null));
 		// Note: "Object" has no superclass
-		fmx.setIsStub(false);
 
 		return fmx;
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 64)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 65)
@@ -7,7 +7,6 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
@@ -16,13 +15,13 @@
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.Modifier;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.TypeParameter;
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
@@ -137,11 +136,16 @@
 		}
 	}
 	
-	public List<Type> ensureFamixTypes(List types) {
-		List<Type> fmxTypes = new ArrayList<Type>();
+	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
 		Type fmxType = null;
-		for (Object type : types) {
-			fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+		for (org.eclipse.jdt.core.dom.Type type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
 			fmxTypes.add(fmxType);
 		}
 		return fmxTypes;
@@ -155,6 +159,21 @@
 		return fmx;
 	}
 	
+	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
+		Type fmxType = null;
+		for (TypeParameter type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
+			fmxTypes.add(fmxType);
+		}
+		return fmxTypes;
+	}
+	
 	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
 
 		if (bnd == null) {
@@ -366,7 +385,7 @@
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Method");
+			System.err.println("Warning: Unexpected null binding to Famix Method");
 			return null;
 		}
 
@@ -378,7 +397,7 @@
 			// TODO what to put in metamodel?
 		}
 		else {
-			rettyp = this.ensureFamixType(bnd.getReturnType());	
+			rettyp = this.ensureFamixType(bnd.getReturnType());
 		}
 
 		// method signature
@@ -497,7 +516,7 @@
 		boolean wasBound = false;
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Attribute");
+			System.err.println("Warning: Unexpected null binding to Famix Attribute");
 			return null;
 		}
 
@@ -570,7 +589,7 @@
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Parameter");
+			System.err.println("Warning: Unexpected null binding to Famix Parameter");
 			return null;
 		}
 
@@ -611,17 +630,20 @@
 	 * @param bnd -- the JDT Binding 
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, Method fmxMethod) {
 		Method owner = null;
 		Type typ = null;
 		boolean wasBound = false;
 
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix LocalVariable");
+			System.err.println("Warning: Unexpected null binding to Famix LocalVariable");
 			return null;
 		}
 
 		owner = this.ensureFamixMethod(bnd.getDeclaringMethod());
+		if (owner == null) {
+			owner = fmxMethod;
+		}
 		typ = this.ensureFamixType(bnd.getType());
 
 		// finally trying to recover the entity or creating it
@@ -658,7 +680,11 @@
 		
 		return fmx;
 	}
-
+	
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
+		return ensureFamixLocalVariable(bnd, null);
+	}
+	
 	/**
 	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 39)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 40)
@@ -368,7 +368,7 @@
 		return ensureFamixInheritance(sup, sub, null);
 	}
 	
-	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Inheritance prev) {
+	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Association prev) {
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
 				return i;
@@ -402,7 +402,6 @@
 		return ref;
 	}
 
-
 	/**
 	 * Returns a Famix Invocation between two Famix Entities creating it if needed
 	 * @param sender of the invocation
@@ -414,7 +413,7 @@
 		return ensureFamixInvocation(sender, invoked, receiver, null);
 	}
 
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Invocation prev) {
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 1)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 2)
@@ -423,7 +423,7 @@
 			}
 			
 			if (bnd != null) {
-				// may happen for when the entity was first created without binding
+				// may happen for example if the entity was first created without binding
 				// and we find a binding for it later
 				mapBind.put(bnd, fmx);
 			}
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/GenerateFamix.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 94)
@@ -0,0 +1,22 @@
+package fr.inria.verveine.core;
+
+import ch.akuhn.fame.Tower;
+import ch.akuhn.fame.codegen.CodeGeneration;
+import ch.akuhn.fame.parser.InputSource;
+
+
+public class GenerateFamix {
+	
+	public static void main(String[] args) {
+		generateCode();
+	}
+	
+	public static void generateCode() {
+		InputSource input = InputSource.fromFilename("mse/famix30_complete.mse");
+        Tower t = new Tower();
+        t.getMetamodel().importMSE(input);
+		CodeGeneration gen = new CodeGeneration("fr.inria.verveine.core.gen", "src", "");
+		gen.accept(t.getMetamodel());
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 94)
@@ -0,0 +1,95 @@
+package fr.inria.verveine.core;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Vector;
+
+import org.eclipse.jdt.core.compiler.CompilationProgress;
+import org.eclipse.jdt.internal.compiler.batch.Main;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.FAMIXModel;
+import fr.inria.verveine.core.gen.famix.SourceLanguage;
+
+public class VerveineParser extends Main {
+
+	public final static String OUTPUT_FILE = "output.mse";
+	
+	private Repository famixRepo;
+
+	SourceLanguage myLgge = null;
+
+	public VerveineParser() {
+		this(new PrintWriter(System.out),
+				new PrintWriter(System.err),
+				false/*systemExitWhenFinished*/,
+				null/*customDefaultOptions*/,
+				null/*compilationProgress*/);
+		
+	}
+
+	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
+		super(outWriter,
+				errWriter,
+				systemExitWhenFinished,
+				customDefaultOptions,
+				compilationProgress);
+		
+		Repository repo = new Repository(FAMIXModel.metamodel());
+		setFamixRepo(repo);
+		if (myLgge != null) {
+			repo.add( myLgge);
+		}
+	}
+
+	public boolean linkToExisting() {
+		File existingMSE = new File(OUTPUT_FILE);
+		if (existingMSE.exists()) {
+			this.getFamixRepo().importMSEFile(OUTPUT_FILE);
+			return true;
+		}
+		else {
+			return false;
+		}
+	}
+	
+	/**
+	 * Outputting repository to a file
+	 */
+	public void outputMSE() {
+		// * --- Outputting to a file -----------------------------------------------
+		try {
+			famixRepo.exportMSE(new FileWriter(OUTPUT_FILE));
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 * Returns a Collection of all FAMIXEntities in the repository of the given fmxClass
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends Entity> Collection<T> listAll(Class<T> fmxClass) {
+		Collection<T> selection = new Vector<T>();
+		for (Object obj : getFamixRepo().getElements()) {
+			if (fmxClass.isInstance(obj)) {
+				selection.add((T) obj);
+			}
+		}
+		return selection;
+	}
+
+	public Repository getFamixRepo() {
+		return famixRepo;
+	}
+
+	public void setFamixRepo(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+	}
+
+}
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 94)
@@ -0,0 +1,448 @@
+package fr.inria.verveine.core;
+
+import java.util.Stack;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Reference;
+
+/** A stack of FAMIX Entities so that we know in what container each new Entity is declared
+ * @author anquetil
+ */
+public class EntityStack {
+	public static final int EMPTY_CYCLO = 0;
+	public static final int EMPTY_NOS = 0;
+	
+	private Namespace fmxPckg;
+	private Stack<ClassStack> fmxType;
+
+	/**
+	 * A structure to hold a Famix class and its current method
+	 */
+	public class ClassStack {
+		private NamedEntity fmxType;  // can be a FamixClass or a FamixAnnotationType
+		private NamedEntity fmxMember; // can be a FamixMethod or a FamixAnnotationAttribute
+		private int metric_cyclo = EMPTY_CYCLO;  // Cyclomatic Complexity
+		private int metric_nos = EMPTY_NOS;      // Number Of Statements
+		
+		
+ 		public ClassStack(NamedEntity e) {
+			fmxType = e;
+			clearFmxMember();
+		}
+
+		public fr.inria.verveine.core.gen.famix.Class getFmxClass() {
+			if (fmxType instanceof fr.inria.verveine.core.gen.famix.Class) {
+				return (fr.inria.verveine.core.gen.famix.Class) fmxType;
+			}
+			else {
+				return null;
+			}
+		}
+
+		public AnnotationType getFmxAnnotationType() {
+			if (fmxType instanceof AnnotationType) {
+				return (AnnotationType) fmxType;
+			}
+			else {
+				return null;
+			}
+		}
+
+		/**
+		 * Returns the Famix  Method on top of the context stack
+		 */
+		public Method getFmxMethod() {
+			if (fmxMember instanceof Method) {
+				return (Method) fmxMember;
+			}
+			else {
+				return null;
+			}
+		}
+
+		public AnnotationTypeAttribute getFmxAnnotationAttribute() {
+			if (fmxMember instanceof AnnotationTypeAttribute) {
+				return (AnnotationTypeAttribute) fmxMember;
+			}
+			else {
+				return null;
+			}
+		}
+
+		/**
+		 * Returns the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public int getFmxMethodCyclo() {
+			return metric_cyclo;
+		}
+
+		/**
+		 * Returns the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public int getFmxMethodNOS() {
+			return metric_nos;
+		}
+		
+		/**
+		 * Reset the Famix Method on top of the context stack
+		 */
+		public void setFmxMethod(Method fmxMethod) {
+			clearFmxMember();
+			this.fmxMember = fmxMethod;
+		}
+
+		public void setFmxAnnotationAttribute(AnnotationTypeAttribute fmxAtt) {
+			clearFmxMember();
+			this.fmxMember = fmxAtt;
+		}
+
+		/**
+		 * Sets the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public void setFmxMethodCyclo(int c) {
+			metric_cyclo = c;
+		}
+
+		/**
+		 * Sets to the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public void setFmxMethodNOS(int n) {
+			metric_nos = n;
+		}
+		
+		/**
+		 * Adds to the Cyclomatic complexity of the Famix Method on top of the context stack
+		 */
+		public void addFmxMethodCyclo(int c) {
+			metric_cyclo += c;
+		}
+
+		/**
+		 * Adds to the Number of Statements of the Famix Method on top of the context stack
+		 */
+		public void addFmxMethodNOS(int n) {
+			metric_nos += n;
+		}
+		
+		/**
+		 * Empties the context stack of Famix classes
+		 */
+		public void clearFmxType() {
+			fmxType = null;
+			clearFmxMember();
+		}
+		
+		/**
+		 * Empties the Famix Method on top of the context stack
+		 */
+		public void clearFmxMember() {
+			fmxMember = null;
+			metric_cyclo = EMPTY_CYCLO;
+			metric_nos = EMPTY_NOS;
+			setLastInvocation(null);
+			setLastAccess(null);
+		}
+
+	}
+	
+	/**
+	 * last Invocation registered to set the previous/next
+	 */
+	Invocation lastInvocation = null;
+	
+	/**
+	 * last Access registered to set the previous/next
+	 */
+	Access lastAccess = null;
+	
+	/**
+	 * last Reference registered to set the previous/next
+	 */
+	Reference lastReference = null;
+	
+	public Access getLastAccess() {
+		return lastAccess;
+	}
+
+	public void setLastAccess(Access lastAccess) {
+		this.lastAccess = lastAccess;
+	}
+
+	public Reference getLastReference() {
+		return lastReference;
+	}
+
+	public void setLastReference(Reference lastReference) {
+		this.lastReference = lastReference;
+	}
+
+	public Invocation getLastInvocation() {
+		return lastInvocation;
+	}
+
+	public void setLastInvocation(Invocation lastInvocation) {
+		this.lastInvocation = lastInvocation;
+	}
+
+	public EntityStack() {
+		clearPckg();  // initializes (to empty) Pckgs, classes and methods
+	}
+
+	private ClassStack getTopType() {
+		if (fmxType.isEmpty()) {
+			return null;
+		}
+		else {
+			return fmxType.peek();
+		}
+	}
+
+	// WRITE ON THE STACK
+	
+	/**
+	 * Pushes an entity on top of the "context stack"
+	 * @param e -- the entity
+	 */
+	public void push(NamedEntity e) {
+		if (e instanceof Method) {
+			pushMethod((Method) e);
+		}
+		else if (e instanceof fr.inria.verveine.core.gen.famix.Class) {
+			pushClass((fr.inria.verveine.core.gen.famix.Class) e);
+		}
+		else if (e instanceof AnnotationTypeAttribute) {
+			pushAnnotationMember((AnnotationTypeAttribute) e);
+		}
+		else if (e instanceof AnnotationType) {
+			pushAnnotationType((AnnotationType) e);
+		}
+		else if (e instanceof Namespace) {
+			pushPckg((Namespace) e);
+		}
+	}
+
+	/**
+	 * Sets the Famix namespace on top of the "context stack"
+	 * Not really a push, but keep the same convention as the others
+	 * @param e -- the Famix method
+	 */
+	public void pushPckg(Namespace e) {
+		clearTypes();
+		fmxPckg = e;
+	}
+
+	/**
+	 * Pushes a Famix class on top of the "context class stack"
+	 * @param e -- the Famix class
+	 */
+	public void pushClass(fr.inria.verveine.core.gen.famix.Class e) {
+		fmxType.push(new ClassStack(e));
+	}
+
+	public void pushAnnotationType(AnnotationType e) {
+		fmxType.push(new ClassStack(e));
+	}
+
+	/**
+	 * Pushes a Famix method on top of the "context stack" for the current Famix class
+	 * @param e -- the Famix method
+	 */
+	public void pushMethod(Method e) {
+		getTopType().setFmxMethod(e);
+	}
+
+	public void pushAnnotationMember(AnnotationTypeAttribute fmx) {
+		getTopType().setFmxAnnotationAttribute(fmx);	
+	}
+	
+	/**
+	 * Empties the context stack of package and associated classes
+	 */
+	public void clearPckg() {
+		clearTypes();
+		fmxPckg = null;
+	}
+
+	/**
+	 * Empties the context stack of Famix classes
+	 */
+	public void clearTypes() {
+		fmxType = new Stack<ClassStack>();
+	}
+	
+	// READ FROM THE STACK
+
+	/**
+	 * Removes and returns the Famix package from the "context stack"
+	 * Also empties the class stack (which was presumably associated to this package)
+	 * Note: does not check that there is such a namespace
+	 * @return the Famix method
+	 */
+	public Namespace popPckg() {
+		Namespace ret = fmxPckg;
+		clearPckg();
+		return ret;
+	}
+
+	/**
+	 * Pops the top Famix class from the "context stack"
+	 * Note: does not check that there is such a class, so could possibly throw an EmptyStackException
+	 * @return the Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class popClass() {
+		ClassStack tmp = fmxType.pop();
+		return tmp.getFmxClass();
+	}
+	
+	public AnnotationType popAnnotationType() {
+		ClassStack tmp = fmxType.pop();
+		return tmp.getFmxAnnotationType();
+	}
+
+	/**
+	 * Pops the top Famix method of the current class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an Exception
+	 * @return the Famix method
+	 */
+	public Method popMethod() {
+		ClassStack tmp = getTopType();
+		Method ret = tmp.getFmxMethod();
+		tmp.clearFmxMember();
+		return ret;
+	}
+	
+	public AnnotationTypeAttribute popAnnotationMember() {
+		ClassStack tmp = getTopType();
+		AnnotationTypeAttribute ret = tmp.getFmxAnnotationAttribute();
+		tmp.clearFmxMember();
+		return ret;
+	}
+
+	/**
+	 * Returns the Famix entity on top of the "context stack"
+	 * Note: does not check that there is such an entity
+	 * @return the Famix entity
+	 */
+	public ContainerEntity top() {
+		ContainerEntity ret = null;
+		ClassStack topc = getTopType();
+		if (topc != null) {
+			ret = topc.getFmxMethod();
+			if (ret == null) {
+				ret = topc.getFmxClass();
+			}
+		}
+		else {
+			ret = topPckg();
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns the Famix package on top of the "context stack"
+	 * Note: does not check that there is such a package
+	 * @return the Famix namespace
+	 */
+	public Namespace topPckg() {
+		return fmxPckg;
+	}
+
+	/**
+	 * Returns the Famix class on top of the "context stack"
+	 * Note: does not check that there is such a class, so could possibly throw an EmptyStackException
+	 * @return the Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class topClass() {
+		return getTopType().getFmxClass();
+	}
+
+	public AnnotationType topAnnotationType() {
+		return getTopType().getFmxAnnotationType();
+	}
+	
+	/**
+	 * Returns the Famix method  of the Famix class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an EmptyStackException
+	 * @return the Famix method
+	 */
+	public Method topMethod() {
+		return getTopType().getFmxMethod();
+	}
+
+	public AnnotationTypeAttribute topAnnotationMember() {
+		return getTopType().getFmxAnnotationAttribute();
+	}
+
+	// PROPERTIES OF THE TOP METHOD
+
+	/**
+	 * Returns the Cyclomatic complexity of the Famix Method on top of the context stack
+	 */
+	public int getTopMethodCyclo() {
+		if (getTopType() != null) {
+			return getTopType().getFmxMethodCyclo();
+		}
+		else {
+			return EMPTY_CYCLO;
+		}
+	}
+
+	/**
+	 * Returns the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public int getTopMethodNOS() {
+		if (getTopType() != null) {
+			return getTopType().getFmxMethodNOS();
+		}
+		else {
+			return EMPTY_NOS;
+		}
+	}
+
+	/**
+	 * Sets the Cyclomatic complexity of the Famix Method on top of the context stack
+	 */
+	public void setTopMethodCyclo(int c) {
+		if (getTopType() != null) {
+			getTopType().setFmxMethodCyclo(c);
+		}
+	}
+
+	/**
+	 * Sets to the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public void setTopMethodNOS(int n) {
+		if (getTopType() != null) {
+			getTopType().setFmxMethodNOS(n);
+		}
+	}
+	
+	/**
+	 * Adds to the Cyclomatic complexity of the Famix Method on top of the context stack
+	 */
+	public void addTopMethodCyclo(int c) {
+		if (getTopType() != null) {
+			getTopType().addFmxMethodCyclo(c);
+		}
+	}
+
+	/**
+	 * Adds to the Number of Statements of the Famix Method on top of the context stack
+	 */
+	public void addTopMethodNOS(int n) {
+		if (getTopType() != null) {
+			getTopType().addFmxMethodNOS(n);
+		}
+	}
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/File.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/File.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/File.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("File")
+public class File extends AbstractFile {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java	(revision 94)
@@ -0,0 +1,30 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("AbstractFile")
+public class AbstractFile extends Entity {
+
+
+
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FILE")
+@FameDescription("FolderGroup")
+public class FolderGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("Folder")
+public class Folder extends AbstractFile {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FILE")
+@FameDescription("FileGroup")
+public class FileGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoFileHistory")
+public class HismoFileHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceVersion")
+public class HismoNamespaceVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodHistory")
+public class HismoMethodHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHierarchy")
+public class HismoClassHierarchy extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHistoryGroup")
+public class HismoClassHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangePattern")
+public class HismoCoChangePattern extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAbstractVersion")
+public class HismoAbstractVersion extends Entity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassVersion")
+public class HismoClassVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoPackageHistory")
+public class HismoPackageHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangeVersion")
+public class HismoCoChangeVersion extends HismoAbstractVersion {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceHistory")
+public class HismoNamespaceHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoHistoryGroup")
+public class HismoHistoryGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodHistoryGroup")
+public class HismoMethodHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoModelHistory")
+public class HismoModelHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoEntityVersion")
+public class HismoEntityVersion extends HismoAbstractVersion {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAccessHistory")
+public class HismoAccessHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoInheritanceDefinitionHistory")
+public class HismoInheritanceDefinitionHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAttributeHistory")
+public class HismoAttributeHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAbstractHistory")
+public class HismoAbstractHistory extends Entity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodVersion")
+public class HismoMethodVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHistory")
+public class HismoClassHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangeHistory")
+public class HismoCoChangeHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoInvocationHistory")
+public class HismoInvocationHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceHistoryGroup")
+public class HismoNamespaceHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoFolderHistory")
+public class HismoFolderHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("CodeLine")
+public class CodeLine extends Entity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("Dude")
+@FameDescription("DuplicationGroup")
+public class DuplicationGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("Dude")
+@FameDescription("MultiplicationGroup")
+public class MultiplicationGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 94)
@@ -0,0 +1,36 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("Duplication")
+public class Duplication extends Entity {
+
+
+
+    private Multiplication multiplicationInvolved;
+    
+    @FameProperty(name = "multiplicationInvolved", opposite = "duplications")
+    public Multiplication getMultiplicationInvolved() {
+        return multiplicationInvolved;
+    }
+
+    public void setMultiplicationInvolved(Multiplication multiplicationInvolved) {
+        if (this.multiplicationInvolved != null) {
+            if (this.multiplicationInvolved.equals(multiplicationInvolved)) return;
+            this.multiplicationInvolved.getDuplications().remove(this);
+        }
+        this.multiplicationInvolved = multiplicationInvolved;
+        if (multiplicationInvolved == null) return;
+        multiplicationInvolved.getDuplications().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 94)
@@ -0,0 +1,75 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("Multiplication")
+public class Multiplication extends Entity {
+
+
+
+    private Collection<Duplication> duplications; 
+
+    @FameProperty(name = "duplications", opposite = "multiplicationInvolved", derived = true)
+    public Collection<Duplication> getDuplications() {
+        if (duplications == null) {
+            duplications = new MultivalueSet<Duplication>() {
+                @Override
+                protected void clearOpposite(Duplication e) {
+                    e.setMultiplicationInvolved(null);
+                }
+                @Override
+                protected void setOpposite(Duplication e) {
+                    e.setMultiplicationInvolved(Multiplication.this);
+                }
+            };
+        }
+        return duplications;
+    }
+    
+    public void setDuplications(Collection<? extends Duplication> duplications) {
+        this.getDuplications().clear();
+        this.getDuplications().addAll(duplications);
+    }                    
+    
+        
+    public void addDuplications(Duplication one) {
+        this.getDuplications().add(one);
+    }   
+    
+    public void addDuplications(Duplication one, Duplication... many) {
+        this.getDuplications().add(one);
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }   
+    
+    public void addDuplications(Iterable<? extends Duplication> many) {
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }   
+                
+    public void addDuplications(Duplication[] many) {
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }
+    
+    public int numberOfDuplications() {
+        return getDuplications().size();
+    }
+
+    public boolean hasDuplications() {
+        return !getDuplications().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java	(revision 94)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("CodeFragment")
+public class CodeFragment extends Entity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java	(revision 94)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Model")
+public class Model extends AbsractGroup {
+
+
+
+    private String sourceLanguage;
+    
+    @FameProperty(name = "sourceLanguage")
+    public String getSourceLanguage() {
+        return sourceLanguage;
+    }
+
+    public void setSourceLanguage(String sourceLanguage) {
+        this.sourceLanguage = sourceLanguage;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("AbsractGroup")
+public class AbsractGroup extends Entity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Entity")
+public class Entity  {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java	(revision 94)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Group")
+public class Group extends AbsractGroup {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java	(revision 94)
@@ -0,0 +1,21 @@
+package fr.inria.verveine.core;
+
+import java.io.OutputStream;
+import java.io.PrintStream;
+
+/**
+ * A non-closeable output stream
+ * Exists solely to redefine an empty close()
+ */
+public class NonCloseablePrintStream extends PrintStream {
+
+	
+	public NonCloseablePrintStream(OutputStream underlying) {
+		super(underlying);
+	}
+
+	public void close() {
+		// Aah aaaah! NOT closing :-)
+	}
+	
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 62)
@@ -0,0 +1,245 @@
+/**
+ * Copyright (c) 2010 Nicolas Anquetil
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.Iterator;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.Type;
+import fr.inria.verveine.extractor.java.JavaDictionary;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Andre Hora
+ * @since January 17, 2011
+ *
+ */
+public class VerveineJTest_Dictionary {
+
+	private Repository repo;
+
+	public VerveineJTest_Dictionary() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/Dictionary"});
+		repo = parser.getFamixRepo();
+	}
+
+	@After
+	public void tearDown() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+
+	@Test
+	public void testClassParameterTypes() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Dictionary");
+		assertNotNull(nodeClass);
+		assertEquals("Dictionary", nodeClass.getName());
+		assertFalse(nodeClass.getIsInterface());
+		assertEquals(1, nodeClass.getParameterTypes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), nodeClass.getParameterTypes().iterator().next());
+	}
+
+	@Test
+	public void testFieldArgumentTypes() {
+		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "DEFAULT_PCKG_NAME");
+		assertNotNull(famixAtt);
+		assertEquals("DEFAULT_PCKG_NAME", famixAtt.getName());
+		assertNull(famixAtt.getDeclaredArgumentTypes());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "STUB_METHOD_CONTAINER_NAME");
+		assertNotNull(famixAtt);
+		assertEquals("STUB_METHOD_CONTAINER_NAME", famixAtt.getName());
+		assertNull(famixAtt.getDeclaredArgumentTypes());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "SELF_NAME");
+		assertNotNull(famixAtt);
+		assertEquals("SELF_NAME", famixAtt.getName());
+		assertNull(famixAtt.getDeclaredArgumentTypes());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "SUPER_NAME");
+		assertNotNull(famixAtt);
+		assertEquals("SUPER_NAME", famixAtt.getName());
+		assertNull(famixAtt.getDeclaredArgumentTypes());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "famixRepo");
+		assertNotNull(famixAtt);
+		assertEquals("famixRepo", famixAtt.getName());
+		assertNull(famixAtt.getDeclaredArgumentTypes());
+
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
+		assertNotNull(famixAtt);
+		assertEquals("mapBind", famixAtt.getName());
+		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapName");
+		assertNotNull(famixAtt);
+		assertEquals("mapName", famixAtt.getName());
+		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		it = famixAtt.getDeclaredArgumentTypes().iterator();
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "String"), it.next());
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "Collection"), it.next());
+		
+		famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapImpVar");
+		assertNotNull(famixAtt);
+		assertEquals("mapImpVar", famixAtt.getName());
+		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		it = famixAtt.getDeclaredArgumentTypes().iterator();
+		Collection<Type> fmxClasses = TestVerveineUtils.listElements(repo, Type.class, "Class");
+		String javaLangNamespace = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace ns = TestVerveineUtils.detectElement(repo, Namespace.class, javaLangNamespace);
+		//There are two classes with the name Class (java.lang and famix namespaces). Ensure to get the correct one.
+		for (Type fmxClass : fmxClasses) {
+			if (ns != fmxClass.getContainer()) {
+				assertSame(fmxClass, it.next());
+			}
+		}
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "ImplicitVars"), it.next());
+	}
+
+
+	@Test
+	public void testMethodParameterArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+	}
+	
+	@Test
+	public void testMethodLocalVariableArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
+		assertNotNull(fmxMethod);
+		assertEquals(1, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
+			assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+			assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
+			if (fmxLocalVariable.getName().equals("ret")) {
+				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxLocalVariable.getName().equals("l_name")) {
+				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
+			if (fmxLocalVariable.getName().equals("fmx")) {
+				assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
+			}
+			if (fmxLocalVariable.getName().equals("l")) {
+				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+	}
+	
+	@Test
+	public void testMethodReturnArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
+	}
+}
\ No newline at end of file
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 3)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 4)
@@ -80,6 +80,15 @@
 		assertEquals(11, nodeClass.getMethods().size());
 		assertEquals(2, nodeClass.getAttributes().size());
 		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
+		assertFalse(nodeClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(interfce);
+		assertEquals("IPrinter", interfce.getName());
+		assertEquals(1, interfce.getMethods().size());
+		assertEquals(0, interfce.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
+		assertTrue(interfce.getIsInterface());
 		
 		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
 		assertNotNull(innerClass);
@@ -87,13 +96,15 @@
 		assertEquals(2, innerClass.getMethods().size());
 		assertEquals(1, innerClass.getAttributes().size());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
-		
+		assertFalse(innerClass.getIsInterface());
+
 		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
 		assertNotNull(anonClass);
 		assertEquals("anonymous(IPrinter)", anonClass.getName());
 		assertEquals(1, anonClass.getMethods().size());
 		assertEquals(0, anonClass.getAttributes().size());
 		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
+		assertFalse(anonClass.getIsInterface());
 	}
 
 	@Test
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 3)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 4)
@@ -1,5 +1,8 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.Collection;
+import java.util.LinkedList;
+
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.IBinding;
@@ -123,7 +126,7 @@
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd) {
 		ContainerEntity owner = null;
-		fr.inria.verveine.core.gen.famix.Class sup = null;
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
 		String identifier = null;
 		
 		if (bnd == null) {
@@ -181,18 +184,24 @@
 			identifier = bnd.getName();
 		}
 
-		// superclass
-		if (bnd.isInterface()) {
-			// TODO interface don't have superclass
-		}
-		else if ( (! bnd.isPrimitive()) && (! bnd.getName().equals(OBJECT_NAME)) ) {
+		// superclass and/or implemented interfaces
+		if ( (! bnd.isPrimitive()) && (! bnd.getName().equals(OBJECT_NAME)) ) {
 			// "Object" and primitive types don't have a superclass
-			ITypeBinding supbnd = bnd.getSuperclass();
-			if (supbnd == null) {
-				sup = ensureFamixClassObject(null);
+			
+			// superclass
+			if (! bnd.isInterface()) {
+				ITypeBinding supbnd = bnd.getSuperclass();
+				if (supbnd == null) {
+					sups.add( ensureFamixClassObject(null));
+				}
+				else {
+					sups.add( ensureFamixClass(supbnd));
+				}
 			}
 			else {
-				sup = ensureFamixClass(supbnd);
+				for (ITypeBinding supbnd : bnd.getInterfaces()) {
+					sups.add( ensureFamixClass(supbnd));
+				}
 			}
 		}
 
@@ -237,11 +246,14 @@
 		}
 		
 		if ((fmx!=null) && fmx.getIsStub()) {
-			// apparently we just created it, so add information to it
+			// apparently we just created it or it already existed as a stub), so add information to it
+			fmx.setIsInterface(bnd.isInterface());
 			fmx.setContainer(owner);
-			if (sup != null) {
+			if (sups.size() > 0) {
 				// some types don't have superclass
-				ensureFamixInheritance(sup, fmx);
+				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+					ensureFamixInheritance(sup, fmx);
+				}
 			}
 			fmx.setName(identifier); // might be different from bnd.getName() in the case of anonymous class
 			fmx.setIsStub(Boolean.FALSE);
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SmalltalkMonticelloSourceLanguage")
+public class SmalltalkMonticelloSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 95)
@@ -0,0 +1,107 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationTypeAttribute")
+public class AnnotationTypeAttribute extends NamedEntity {
+
+
+
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private AnnotationType parentAnnotationType;
+    
+    @FameProperty(name = "parentAnnotationType", opposite = "attributes")
+    public AnnotationType getParentAnnotationType() {
+        return parentAnnotationType;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return null;
+	}
+
+    public void setParentAnnotationType(AnnotationType parentAnnotationType) {
+        if (this.parentAnnotationType != null) {
+            if (this.parentAnnotationType.equals(parentAnnotationType)) return;
+            this.parentAnnotationType.getAttributes().remove(this);
+        }
+        this.parentAnnotationType = parentAnnotationType;
+        if (parentAnnotationType == null) return;
+        parentAnnotationType.getAttributes().add(this);
+    }
+    
+    private Collection<AnnotationInstanceAttribute> annotationAttributeInstances; 
+
+    @FameProperty(name = "annotationAttributeInstances", opposite = "annotationTypeAttribute", derived = true)
+    public Collection<AnnotationInstanceAttribute> getAnnotationAttributeInstances() {
+        if (annotationAttributeInstances == null) {
+            annotationAttributeInstances = new MultivalueSet<AnnotationInstanceAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationInstanceAttribute e) {
+                    e.setAnnotationTypeAttribute(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstanceAttribute e) {
+                    e.setAnnotationTypeAttribute(AnnotationTypeAttribute.this);
+                }
+            };
+        }
+        return annotationAttributeInstances;
+    }
+    
+    public void setAnnotationAttributeInstances(Collection<? extends AnnotationInstanceAttribute> annotationAttributeInstances) {
+        this.getAnnotationAttributeInstances().clear();
+        this.getAnnotationAttributeInstances().addAll(annotationAttributeInstances);
+    }                    
+    
+        
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute one) {
+        this.getAnnotationAttributeInstances().add(one);
+    }   
+    
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute one, AnnotationInstanceAttribute... many) {
+        this.getAnnotationAttributeInstances().add(one);
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }   
+    
+    public void addAnnotationAttributeInstances(Iterable<? extends AnnotationInstanceAttribute> many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }   
+                
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute[] many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }
+    
+    public int numberOfAnnotationAttributeInstances() {
+        return getAnnotationAttributeInstances().size();
+    }
+
+    public boolean hasAnnotationAttributeInstances() {
+        return !getAnnotationAttributeInstances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java	(revision 95)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ThrownException")
+public class ThrownException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "thrownExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getThrownExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getThrownExceptions().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 95)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("EnumValue")
+public class EnumValue extends NamedEntity {
+
+
+
+    private Enum parentEnum;
+    
+    @FameProperty(name = "parentEnum", opposite = "values")
+    public Enum getParentEnum() {
+        return parentEnum;
+    }
+
+    public void setParentEnum(Enum parentEnum) {
+        if (this.parentEnum != null) {
+            if (this.parentEnum.equals(parentEnum)) return;
+            this.parentEnum.getValues().remove(this);
+        }
+        this.parentEnum = parentEnum;
+        if (parentEnum == null) return;
+        parentEnum.getValues().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 95)
@@ -0,0 +1,77 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Access")
+public class Access extends Association {
+
+
+
+    private Boolean isWrite;
+    
+    @FameProperty(name = "isWrite")
+    public Boolean getIsWrite() {
+        return isWrite;
+    }
+
+    public void setIsWrite(Boolean isWrite) {
+        this.isWrite = isWrite;
+    }
+    
+    private BehaviouralEntity accessor;
+    
+    @FameProperty(name = "accessor", opposite = "accesses")
+    public BehaviouralEntity getAccessor() {
+        return accessor;
+    }
+
+    public void setAccessor(BehaviouralEntity accessor) {
+        if (this.accessor != null) {
+            if (this.accessor.equals(accessor)) return;
+            this.accessor.getAccesses().remove(this);
+        }
+        this.accessor = accessor;
+        if (accessor == null) return;
+        accessor.getAccesses().add(this);
+    }
+    
+    private StructuralEntity variable;
+    
+    @FameProperty(name = "variable", opposite = "incomingAccesses")
+    public StructuralEntity getVariable() {
+        return variable;
+    }
+
+    public void setVariable(StructuralEntity variable) {
+        if (this.variable != null) {
+            if (this.variable.equals(variable)) return;
+            this.variable.getIncomingAccesses().remove(this);
+        }
+        this.variable = variable;
+        if (variable == null) return;
+        variable.getIncomingAccesses().add(this);
+    }
+    
+    @FameProperty(name = "isRead", derived = true)
+    public Boolean getIsRead() {
+        // TODO: this is a derived property, implement this method manually.
+    	return ! getIsWrite(); 
+    }
+
+	@Override
+	public NamedEntity getTo() {
+		return this.getVariable();
+	}
+
+	@Override
+	public NamedEntity getFrom() {
+		return this.getAccessor();
+	}
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 95)
@@ -0,0 +1,107 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourcedEntity")
+public class SourcedEntity extends Entity {
+
+
+
+    private SourceAnchor sourceAnchor;
+    
+    @FameProperty(name = "sourceAnchor", opposite = "element")
+    public SourceAnchor getSourceAnchor() {
+        return sourceAnchor;
+    }
+
+    public void setSourceAnchor(SourceAnchor sourceAnchor) {
+        if (this.sourceAnchor == null ? sourceAnchor != null : !this.sourceAnchor.equals(sourceAnchor)) {
+            SourceAnchor old_sourceAnchor = this.sourceAnchor;
+            this.sourceAnchor = sourceAnchor;
+            if (old_sourceAnchor != null) old_sourceAnchor.setElement(null);
+            if (sourceAnchor != null) sourceAnchor.setElement(this);
+        }
+    }
+    
+    private SourceLanguage declaredSourceLanguage;
+    
+    @FameProperty(name = "declaredSourceLanguage", opposite = "sourcedEntities")
+    public SourceLanguage getDeclaredSourceLanguage() {
+        return declaredSourceLanguage;
+    }
+
+    public void setDeclaredSourceLanguage(SourceLanguage declaredSourceLanguage) {
+        if (this.declaredSourceLanguage != null) {
+            if (this.declaredSourceLanguage.equals(declaredSourceLanguage)) return;
+            this.declaredSourceLanguage.getSourcedEntities().remove(this);
+        }
+        this.declaredSourceLanguage = declaredSourceLanguage;
+        if (declaredSourceLanguage == null) return;
+        declaredSourceLanguage.getSourcedEntities().add(this);
+    }
+    
+    private Collection<Comment> comments; 
+
+    @FameProperty(name = "comments", opposite = "container", derived = true)
+    public Collection<Comment> getComments() {
+        if (comments == null) {
+            comments = new MultivalueSet<Comment>() {
+                @Override
+                protected void clearOpposite(Comment e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(Comment e) {
+                    e.setContainer(SourcedEntity.this);
+                }
+            };
+        }
+        return comments;
+    }
+    
+    public void setComments(Collection<? extends Comment> comments) {
+        this.getComments().clear();
+        this.getComments().addAll(comments);
+    }                    
+    
+        
+    public void addComments(Comment one) {
+        this.getComments().add(one);
+    }   
+    
+    public void addComments(Comment one, Comment... many) {
+        this.getComments().add(one);
+        for (Comment each : many)
+            this.getComments().add(each);
+    }   
+    
+    public void addComments(Iterable<? extends Comment> many) {
+        for (Comment each : many)
+            this.getComments().add(each);
+    }   
+                
+    public void addComments(Comment[] many) {
+        for (Comment each : many)
+            this.getComments().add(each);
+    }
+    
+    public int numberOfComments() {
+        return getComments().size();
+    }
+
+    public boolean hasComments() {
+        return !getComments().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java	(revision 95)
@@ -0,0 +1,46 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Comment")
+public class Comment extends SourcedEntity {
+
+
+
+    private String content;
+    
+    @FameProperty(name = "content")
+    public String getContent() {
+        return content;
+    }
+
+    public void setContent(String content) {
+        this.content = content;
+    }
+    
+    private SourcedEntity container;
+    
+    @FameProperty(name = "container", opposite = "comments")
+    public SourcedEntity getContainer() {
+        return container;
+    }
+
+    public void setContainer(SourcedEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getComments().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getComments().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 95)
@@ -0,0 +1,51 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Attribute")
+public class Attribute extends StructuralEntity {
+
+
+
+    private Boolean hasClassScope;
+    
+    @FameProperty(name = "hasClassScope")
+    public Boolean getHasClassScope() {
+        return hasClassScope;
+    }
+
+    public void setHasClassScope(Boolean hasClassScope) {
+        this.hasClassScope = hasClassScope;
+    }
+    
+    private Type parentType;
+    
+    @FameProperty(name = "parentType", opposite = "attributes")
+    public Type getParentType() {
+        return parentType;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentType();
+	}
+
+    public void setParentType(Type parentType) {
+        if (this.parentType != null) {
+            if (this.parentType.equals(parentType)) return;
+            this.parentType.getAttributes().remove(this);
+        }
+        this.parentType = parentType;
+        if (parentType == null) return;
+        parentType.getAttributes().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 95)
@@ -0,0 +1,74 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Enum")
+public class Enum extends Type {
+
+
+
+    private Collection<EnumValue> values; 
+
+    @FameProperty(name = "values", opposite = "parentEnum", derived = true)
+    public Collection<EnumValue> getValues() {
+        if (values == null) {
+            values = new MultivalueSet<EnumValue>() {
+                @Override
+                protected void clearOpposite(EnumValue e) {
+                    e.setParentEnum(null);
+                }
+                @Override
+                protected void setOpposite(EnumValue e) {
+                    e.setParentEnum(Enum.this);
+                }
+            };
+        }
+        return values;
+    }
+    
+    public void setValues(Collection<? extends EnumValue> values) {
+        this.getValues().clear();
+        this.getValues().addAll(values);
+    }                    
+    
+        
+    public void addValues(EnumValue one) {
+        this.getValues().add(one);
+    }   
+    
+    public void addValues(EnumValue one, EnumValue... many) {
+        this.getValues().add(one);
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }   
+    
+    public void addValues(Iterable<? extends EnumValue> many) {
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }   
+                
+    public void addValues(EnumValue[] many) {
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }
+    
+    public int numberOfValues() {
+        return getValues().size();
+    }
+
+    public boolean hasValues() {
+        return !getValues().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CSourceLanguage")
+public class CSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java	(revision 95)
@@ -0,0 +1,137 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Invocation")
+public class Invocation extends Association {
+
+
+
+    private BehaviouralEntity sender;
+    
+    @FameProperty(name = "sender", opposite = "outgoingInvocations")
+    public BehaviouralEntity getSender() {
+        return sender;
+    }
+
+    public void setSender(BehaviouralEntity sender) {
+        if (this.sender != null) {
+            if (this.sender.equals(sender)) return;
+            this.sender.getOutgoingInvocations().remove(this);
+        }
+        this.sender = sender;
+        if (sender == null) return;
+        sender.getOutgoingInvocations().add(this);
+    }
+    
+    private NamedEntity receiver;
+    
+    @FameProperty(name = "receiver", opposite = "receivingInvocations")
+    public NamedEntity getReceiver() {
+        return receiver;
+    }
+
+    public void setReceiver(NamedEntity receiver) {
+        if (this.receiver != null) {
+            if (this.receiver.equals(receiver)) return;
+            this.receiver.getReceivingInvocations().remove(this);
+        }
+        this.receiver = receiver;
+        if (receiver == null) return;
+        receiver.getReceivingInvocations().add(this);
+    }
+    
+    private String receiverSourceCode;
+    
+    @FameProperty(name = "receiverSourceCode")
+    public String getReceiverSourceCode() {
+        return receiverSourceCode;
+    }
+
+    public void setReceiverSourceCode(String receiverSourceCode) {
+        this.receiverSourceCode = receiverSourceCode;
+    }
+    
+    private String signature;
+    
+    @FameProperty(name = "signature")
+    public String getSignature() {
+        return signature;
+    }
+
+    public void setSignature(String signature) {
+        this.signature = signature;
+    }
+    
+    private Collection<BehaviouralEntity> candidates; 
+
+    @FameProperty(name = "candidates", opposite = "incomingInvocations")
+    public Collection<BehaviouralEntity> getCandidates() {
+        if (candidates == null) {
+            candidates = new MultivalueSet<BehaviouralEntity>() {
+                @Override
+                protected void clearOpposite(BehaviouralEntity e) {
+                    e.getIncomingInvocations().remove(Invocation.this);
+                }
+                @Override
+                protected void setOpposite(BehaviouralEntity e) {
+                    e.getIncomingInvocations().add(Invocation.this);
+                }
+            };
+        }
+        return candidates;
+    }
+    
+    public void setCandidates(Collection<? extends BehaviouralEntity> candidates) {
+        this.getCandidates().clear();
+        this.getCandidates().addAll(candidates);
+    }
+    
+    public void addCandidates(BehaviouralEntity one) {
+        this.getCandidates().add(one);
+    }   
+    
+    public void addCandidates(BehaviouralEntity one, BehaviouralEntity... many) {
+        this.getCandidates().add(one);
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }   
+    
+    public void addCandidates(Iterable<? extends BehaviouralEntity> many) {
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }   
+                
+    public void addCandidates(BehaviouralEntity[] many) {
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }
+    
+    public int numberOfCandidates() {
+        return getCandidates().size();
+    }
+
+    public boolean hasCandidates() {
+        return !getCandidates().isEmpty();
+    }
+
+	public NamedEntity getFrom() {
+		return this.getSender();
+	}
+
+	public NamedEntity getTo() {
+		return this.getReceiver();
+	}
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("NamespaceGroup")
+public class NamespaceGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SmalltalkSourceLanguage")
+public class SmalltalkSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java	(revision 95)
@@ -0,0 +1,74 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Entity")
+public class Entity  {
+
+
+
+    private Collection<AnnotationInstance> annotationInstances; 
+
+    @FameProperty(name = "annotationInstances", opposite = "annotatedEntity", derived = true)
+    public Collection<AnnotationInstance> getAnnotationInstances() {
+        if (annotationInstances == null) {
+            annotationInstances = new MultivalueSet<AnnotationInstance>() {
+                @Override
+                protected void clearOpposite(AnnotationInstance e) {
+                    e.setAnnotatedEntity(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstance e) {
+                    e.setAnnotatedEntity(Entity.this);
+                }
+            };
+        }
+        return annotationInstances;
+    }
+    
+    public void setAnnotationInstances(Collection<? extends AnnotationInstance> annotationInstances) {
+        this.getAnnotationInstances().clear();
+        this.getAnnotationInstances().addAll(annotationInstances);
+    }                    
+    
+        
+    public void addAnnotationInstances(AnnotationInstance one) {
+        this.getAnnotationInstances().add(one);
+    }   
+    
+    public void addAnnotationInstances(AnnotationInstance one, AnnotationInstance... many) {
+        this.getAnnotationInstances().add(one);
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }   
+    
+    public void addAnnotationInstances(Iterable<? extends AnnotationInstance> many) {
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }   
+                
+    public void addAnnotationInstances(AnnotationInstance[] many) {
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }
+    
+    public int numberOfAnnotationInstances() {
+        return getAnnotationInstances().size();
+    }
+
+    public boolean hasAnnotationInstances() {
+        return !getAnnotationInstances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 95)
@@ -0,0 +1,40 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Parameter")
+public class Parameter extends StructuralEntity {
+
+
+
+    private BehaviouralEntity parentBehaviouralEntity;
+    
+    @FameProperty(name = "parentBehaviouralEntity", opposite = "parameters")
+    public BehaviouralEntity getParentBehaviouralEntity() {
+        return parentBehaviouralEntity;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentBehaviouralEntity();
+	}
+
+    public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
+        if (this.parentBehaviouralEntity != null) {
+            if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
+            this.parentBehaviouralEntity.getParameters().remove(this);
+        }
+        this.parentBehaviouralEntity = parentBehaviouralEntity;
+        if (parentBehaviouralEntity == null) return;
+        parentBehaviouralEntity.getParameters().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 95)
@@ -0,0 +1,34 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ImplicitVariable")
+public class ImplicitVariable extends StructuralEntity {
+
+
+
+    private Type container;
+    
+    @FameProperty(name = "container")
+    public Type getContainer() {
+        return container;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
+    public void setContainer(Type container) {
+        this.container = container;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 95)
@@ -0,0 +1,226 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Method")
+public class Method extends BehaviouralEntity {
+
+
+
+    private Collection<CaughtException> caughtExceptions; 
+
+    @FameProperty(name = "caughtExceptions", opposite = "definingMethod", derived = true)
+    public Collection<CaughtException> getCaughtExceptions() {
+        if (caughtExceptions == null) {
+            caughtExceptions = new MultivalueSet<CaughtException>() {
+                @Override
+                protected void clearOpposite(CaughtException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(CaughtException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return caughtExceptions;
+    }
+    
+    public void setCaughtExceptions(Collection<? extends CaughtException> caughtExceptions) {
+        this.getCaughtExceptions().clear();
+        this.getCaughtExceptions().addAll(caughtExceptions);
+    }                    
+    
+        
+    public void addCaughtExceptions(CaughtException one) {
+        this.getCaughtExceptions().add(one);
+    }   
+    
+    public void addCaughtExceptions(CaughtException one, CaughtException... many) {
+        this.getCaughtExceptions().add(one);
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }   
+    
+    public void addCaughtExceptions(Iterable<? extends CaughtException> many) {
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }   
+                
+    public void addCaughtExceptions(CaughtException[] many) {
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }
+    
+    public int numberOfCaughtExceptions() {
+        return getCaughtExceptions().size();
+    }
+
+    public boolean hasCaughtExceptions() {
+        return !getCaughtExceptions().isEmpty();
+    }
+    
+                
+    private Collection<DeclaredException> declaredExceptions; 
+
+    @FameProperty(name = "declaredExceptions", opposite = "definingMethod", derived = true)
+    public Collection<DeclaredException> getDeclaredExceptions() {
+        if (declaredExceptions == null) {
+            declaredExceptions = new MultivalueSet<DeclaredException>() {
+                @Override
+                protected void clearOpposite(DeclaredException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(DeclaredException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return declaredExceptions;
+    }
+    
+    public void setDeclaredExceptions(Collection<? extends DeclaredException> declaredExceptions) {
+        this.getDeclaredExceptions().clear();
+        this.getDeclaredExceptions().addAll(declaredExceptions);
+    }                    
+    
+        
+    public void addDeclaredExceptions(DeclaredException one) {
+        this.getDeclaredExceptions().add(one);
+    }   
+    
+    public void addDeclaredExceptions(DeclaredException one, DeclaredException... many) {
+        this.getDeclaredExceptions().add(one);
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }   
+    
+    public void addDeclaredExceptions(Iterable<? extends DeclaredException> many) {
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }   
+                
+    public void addDeclaredExceptions(DeclaredException[] many) {
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }
+    
+    public int numberOfDeclaredExceptions() {
+        return getDeclaredExceptions().size();
+    }
+
+    public boolean hasDeclaredExceptions() {
+        return !getDeclaredExceptions().isEmpty();
+    }
+    
+                
+    private Boolean hasClassScope;
+    
+    @FameProperty(name = "hasClassScope")
+    public Boolean getHasClassScope() {
+        return hasClassScope;
+    }
+
+    public void setHasClassScope(Boolean hasClassScope) {
+        this.hasClassScope = hasClassScope;
+    }
+    
+    private Collection<ThrownException> thrownExceptions; 
+
+    @FameProperty(name = "thrownExceptions", opposite = "definingMethod", derived = true)
+    public Collection<ThrownException> getThrownExceptions() {
+        if (thrownExceptions == null) {
+            thrownExceptions = new MultivalueSet<ThrownException>() {
+                @Override
+                protected void clearOpposite(ThrownException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(ThrownException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return thrownExceptions;
+    }
+    
+    public void setThrownExceptions(Collection<? extends ThrownException> thrownExceptions) {
+        this.getThrownExceptions().clear();
+        this.getThrownExceptions().addAll(thrownExceptions);
+    }                    
+    
+        
+    public void addThrownExceptions(ThrownException one) {
+        this.getThrownExceptions().add(one);
+    }   
+    
+    public void addThrownExceptions(ThrownException one, ThrownException... many) {
+        this.getThrownExceptions().add(one);
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }   
+    
+    public void addThrownExceptions(Iterable<? extends ThrownException> many) {
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }   
+                
+    public void addThrownExceptions(ThrownException[] many) {
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }
+    
+    public int numberOfThrownExceptions() {
+        return getThrownExceptions().size();
+    }
+
+    public boolean hasThrownExceptions() {
+        return !getThrownExceptions().isEmpty();
+    }
+    
+                
+    private Type parentType;
+    
+    @FameProperty(name = "parentType", opposite = "methods")
+    public Type getParentType() {
+        return parentType;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentType();
+	}
+
+	public void setParentType(Type parentType) {
+        if (this.parentType != null) {
+            if (this.parentType.equals(parentType)) return;
+            this.parentType.getMethods().remove(this);
+        }
+        this.parentType = parentType;
+        if (parentType == null) return;
+        parentType.getMethods().add(this);
+    }
+    
+    private String kind;
+    
+    @FameProperty(name = "kind")
+    public String getKind() {
+        return kind;
+    }
+
+    public void setKind(String kind) {
+        this.kind = kind;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 95)
@@ -0,0 +1,242 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("NamedEntity")
+public class NamedEntity extends SourcedEntity {
+
+
+
+    public NamedEntity() {
+		super();
+		this.setIsFinal(Boolean.FALSE);
+		this.setIsPrivate(Boolean.FALSE);
+		this.setIsProtected(Boolean.FALSE);
+		this.setIsPublic(Boolean.FALSE);
+		this.setIsAbstract(Boolean.FALSE);
+	}
+
+	private Boolean isAbstract;
+    
+    @FameProperty(name = "isAbstract")
+    public Boolean getIsAbstract() {
+        return isAbstract;
+    }
+
+    public void setIsAbstract(Boolean isAbstract) {
+        this.isAbstract = isAbstract;
+    }
+    
+    private Boolean isPrivate;
+    
+    @FameProperty(name = "isPrivate")
+    public Boolean getIsPrivate() {
+        return isPrivate;
+    }
+
+    public void setIsPrivate(Boolean isPrivate) {
+        this.isPrivate = isPrivate;
+    }
+    
+    private Boolean isPackage;
+    
+    @FameProperty(name = "isPackage")
+    public Boolean getIsPackage() {
+        return isPackage;
+    }
+
+    public void setIsPackage(Boolean isPackage) {
+        this.isPackage = isPackage;
+    }
+    
+    private Package parentPackage;
+    
+    @FameProperty(name = "parentPackage", opposite = "childNamedEntities")
+    public Package getParentPackage() {
+        return parentPackage;
+    }
+
+    public void setParentPackage(Package parentPackage) {
+        if (this.parentPackage != null) {
+            if (this.parentPackage.equals(parentPackage)) return;
+            this.parentPackage.getChildNamedEntities().remove(this);
+        }
+        this.parentPackage = parentPackage;
+        if (parentPackage == null) return;
+        parentPackage.getChildNamedEntities().add(this);
+    }
+    
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+    private Boolean isStub;
+    
+    @FameProperty(name = "isStub")
+    public Boolean getIsStub() {
+        return isStub;
+    }
+
+    public void setIsStub(Boolean isStub) {
+        this.isStub = isStub;
+    }
+    
+    private Boolean isPublic;
+    
+    @FameProperty(name = "isPublic")
+    public Boolean getIsPublic() {
+        return isPublic;
+    }
+
+    public void setIsPublic(Boolean isPublic) {
+        this.isPublic = isPublic;
+    }
+    
+    private Collection<Invocation> receivingInvocations; 
+
+    @FameProperty(name = "receivingInvocations", opposite = "receiver", derived = true)
+    public Collection<Invocation> getReceivingInvocations() {
+        if (receivingInvocations == null) {
+            receivingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.setReceiver(null);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.setReceiver(NamedEntity.this);
+                }
+            };
+        }
+        return receivingInvocations;
+    }
+    
+    public void setReceivingInvocations(Collection<? extends Invocation> receivingInvocations) {
+        this.getReceivingInvocations().clear();
+        this.getReceivingInvocations().addAll(receivingInvocations);
+    }                    
+    
+        
+    public void addReceivingInvocations(Invocation one) {
+        this.getReceivingInvocations().add(one);
+    }   
+    
+    public void addReceivingInvocations(Invocation one, Invocation... many) {
+        this.getReceivingInvocations().add(one);
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }   
+    
+    public void addReceivingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }   
+                
+    public void addReceivingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }
+    
+    public int numberOfReceivingInvocations() {
+        return getReceivingInvocations().size();
+    }
+
+    public boolean hasReceivingInvocations() {
+        return !getReceivingInvocations().isEmpty();
+    }
+    
+                
+    private Boolean isProtected;
+    
+    @FameProperty(name = "isProtected")
+    public Boolean getIsProtected() {
+        return isProtected;
+    }
+
+    public void setIsProtected(Boolean isProtected) {
+        this.isProtected = isProtected;
+    }
+    
+    private Collection<String> modifiers; 
+
+    @FameProperty(name = "modifiers")
+    public Collection<String> getModifiers() {
+        if (modifiers == null) modifiers = new HashSet<String>();
+        return modifiers;
+    }
+    
+    public void setModifiers(Collection<? extends String> modifiers) {
+        this.getModifiers().clear();
+        this.getModifiers().addAll(modifiers);
+    }                    
+
+    public void addModifiers(String one) {
+        this.getModifiers().add(one);
+    }   
+    
+    public void addModifiers(String one, String... many) {
+        this.getModifiers().add(one);
+        for (String each : many)
+            this.getModifiers().add(each);
+    }   
+    
+    public void addModifiers(Iterable<? extends String> many) {
+        for (String each : many)
+            this.getModifiers().add(each);
+    }   
+                
+    public void addModifiers(String[] many) {
+        for (String each : many)
+            this.getModifiers().add(each);
+    }
+    
+    public int numberOfModifiers() {
+        return getModifiers().size();
+    }
+
+    public boolean hasModifiers() {
+        return !getModifiers().isEmpty();
+    }
+    
+                
+    @FameProperty(name = "belongsTo", derived = true)
+    public ContainerEntity getBelongsTo() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("NamedEntity.getBelongsTo() Not implemented in this class, use the proper subclass ("+this.getClass().getName()+")"); 
+    }
+    
+    private Boolean isFinal;
+    
+    @FameProperty(name = "isFinal")
+    public Boolean getIsFinal() {
+        return isFinal;
+    }
+
+    public void setIsFinal(Boolean isFinal) {
+        this.isFinal = isFinal;
+    }
+    
+
+	@Override
+	public String toString() {
+	// mainly for debugging purposes (in Eclipse debugger)
+		return "a " + this.getClass().getCanonicalName() + " named: " + this.getName();
+	}
+    
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java	(revision 95)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("DeclaredException")
+public class DeclaredException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "declaredExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getDeclaredExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getDeclaredExceptions().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 95)
@@ -0,0 +1,63 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationInstanceAttribute")
+public class AnnotationInstanceAttribute extends Entity {
+
+
+
+    private AnnotationInstance parentAnnotationInstance;
+    
+    @FameProperty(name = "parentAnnotationInstance", opposite = "attributes")
+    public AnnotationInstance getParentAnnotationInstance() {
+        return parentAnnotationInstance;
+    }
+
+    public void setParentAnnotationInstance(AnnotationInstance parentAnnotationInstance) {
+        if (this.parentAnnotationInstance != null) {
+            if (this.parentAnnotationInstance.equals(parentAnnotationInstance)) return;
+            this.parentAnnotationInstance.getAttributes().remove(this);
+        }
+        this.parentAnnotationInstance = parentAnnotationInstance;
+        if (parentAnnotationInstance == null) return;
+        parentAnnotationInstance.getAttributes().add(this);
+    }
+    
+    private String value;
+    
+    @FameProperty(name = "value")
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+    }
+    
+    private AnnotationTypeAttribute annotationTypeAttribute;
+    
+    @FameProperty(name = "annotationTypeAttribute", opposite = "annotationAttributeInstances")
+    public AnnotationTypeAttribute getAnnotationTypeAttribute() {
+        return annotationTypeAttribute;
+    }
+
+    public void setAnnotationTypeAttribute(AnnotationTypeAttribute annotationTypeAttribute) {
+        if (this.annotationTypeAttribute != null) {
+            if (this.annotationTypeAttribute.equals(annotationTypeAttribute)) return;
+            this.annotationTypeAttribute.getAnnotationAttributeInstances().remove(this);
+        }
+        this.annotationTypeAttribute = annotationTypeAttribute;
+        if (annotationTypeAttribute == null) return;
+        annotationTypeAttribute.getAnnotationAttributeInstances().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("GlobalVariableGroup")
+public class GlobalVariableGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Module")
+public class Module extends ScopingEntity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 95)
@@ -0,0 +1,76 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class FAMIXModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.famix.CSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Access.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.EnumValue.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Reference.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Invocation.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Exception.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Enum.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkMonticelloSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Attribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ImplicitVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ScopingEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Module.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Package.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CustomSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ContainerEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LeafEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CaughtException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.DeclaredException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Method.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ThrownException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizedType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Parameter.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PackageGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.JavaSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PrimitiveType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Type.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizableClass.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
+
+    }
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationTypeGroup")
+public class AnnotationTypeGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java	(revision 95)
@@ -0,0 +1,34 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceAnchor")
+public class SourceAnchor extends Entity {
+
+
+
+    private SourcedEntity element;
+    
+    @FameProperty(name = "element", opposite = "sourceAnchor")
+    public SourcedEntity getElement() {
+        return element;
+    }
+
+    public void setElement(SourcedEntity element) {
+        if (this.element == null ? element != null : !this.element.equals(element)) {
+            SourcedEntity old_element = this.element;
+            this.element = element;
+            if (old_element != null) old_element.setSourceAnchor(null);
+            if (element != null) element.setSourceAnchor(this);
+        }
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java	(revision 95)
@@ -0,0 +1,74 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Package")
+public class Package extends ScopingEntity {
+
+
+
+    private Collection<NamedEntity> childNamedEntities; 
+
+    @FameProperty(name = "childNamedEntities", opposite = "parentPackage", derived = true)
+    public Collection<NamedEntity> getChildNamedEntities() {
+        if (childNamedEntities == null) {
+            childNamedEntities = new MultivalueSet<NamedEntity>() {
+                @Override
+                protected void clearOpposite(NamedEntity e) {
+                    e.setParentPackage(null);
+                }
+                @Override
+                protected void setOpposite(NamedEntity e) {
+                    e.setParentPackage(Package.this);
+                }
+            };
+        }
+        return childNamedEntities;
+    }
+    
+    public void setChildNamedEntities(Collection<? extends NamedEntity> childNamedEntities) {
+        this.getChildNamedEntities().clear();
+        this.getChildNamedEntities().addAll(childNamedEntities);
+    }                    
+    
+        
+    public void addChildNamedEntities(NamedEntity one) {
+        this.getChildNamedEntities().add(one);
+    }   
+    
+    public void addChildNamedEntities(NamedEntity one, NamedEntity... many) {
+        this.getChildNamedEntities().add(one);
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }   
+    
+    public void addChildNamedEntities(Iterable<? extends NamedEntity> many) {
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }   
+                
+    public void addChildNamedEntities(NamedEntity[] many) {
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }
+    
+    public int numberOfChildNamedEntities() {
+        return getChildNamedEntities().size();
+    }
+
+    public boolean hasChildNamedEntities() {
+        return !getChildNamedEntities().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Namespace")
+public class Namespace extends ScopingEntity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java	(revision 95)
@@ -0,0 +1,72 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterizedType")
+public class ParameterizedType extends Type {
+
+
+
+    private Collection<Type> arguments; 
+
+    @FameProperty(name = "arguments")
+    public Collection<Type> getArguments() {
+        if (arguments == null) arguments = new HashSet<Type>();
+        return arguments;
+    }
+    
+    public void setArguments(Collection<? extends Type> arguments) {
+        this.getArguments().clear();
+        this.getArguments().addAll(arguments);
+    }                    
+
+    public void addArguments(Type one) {
+        this.getArguments().add(one);
+    }   
+    
+    public void addArguments(Type one, Type... many) {
+        this.getArguments().add(one);
+        for (Type each : many)
+            this.getArguments().add(each);
+    }   
+    
+    public void addArguments(Iterable<? extends Type> many) {
+        for (Type each : many)
+            this.getArguments().add(each);
+    }   
+                
+    public void addArguments(Type[] many) {
+        for (Type each : many)
+            this.getArguments().add(each);
+    }
+    
+    public int numberOfArguments() {
+        return getArguments().size();
+    }
+
+    public boolean hasArguments() {
+        return !getArguments().isEmpty();
+    }
+    
+                
+    private ParameterizableClass parameterizableClass;
+    
+    @FameProperty(name = "parameterizableClass")
+    public ParameterizableClass getParameterizableClass() {
+        return parameterizableClass;
+    }
+
+    public void setParameterizableClass(ParameterizableClass parameterizableClass) {
+        this.parameterizableClass = parameterizableClass;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 95)
@@ -0,0 +1,332 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("BehaviouralEntity")
+public class BehaviouralEntity extends ContainerEntity {
+
+
+	private int cyclo = 0;  // metric: Cyclomatic complexity
+	private int nos = 0;    // metric Number Of Statement
+
+
+    private Collection<Access> accesses; 
+
+    @FameProperty(name = "accesses", opposite = "accessor", derived = true)
+    public Collection<Access> getAccesses() {
+        if (accesses == null) {
+            accesses = new MultivalueSet<Access>() {
+                @Override
+                protected void clearOpposite(Access e) {
+                    e.setAccessor(null);
+                }
+                @Override
+                protected void setOpposite(Access e) {
+                    e.setAccessor(BehaviouralEntity.this);
+                }
+            };
+        }
+        return accesses;
+    }
+    
+    public void setAccesses(Collection<? extends Access> accesses) {
+        this.getAccesses().clear();
+        this.getAccesses().addAll(accesses);
+    }                    
+    
+        
+    public void addAccesses(Access one) {
+        this.getAccesses().add(one);
+    }   
+    
+    public void addAccesses(Access one, Access... many) {
+        this.getAccesses().add(one);
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }   
+    
+    public void addAccesses(Iterable<? extends Access> many) {
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }   
+                
+    public void addAccesses(Access[] many) {
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }
+    
+    public int numberOfAccesses() {
+        return getAccesses().size();
+    }
+
+    public boolean hasAccesses() {
+        return !getAccesses().isEmpty();
+    }
+    
+                
+    private Collection<Invocation> outgoingInvocations; 
+
+    @FameProperty(name = "outgoingInvocations", opposite = "sender", derived = true)
+    public Collection<Invocation> getOutgoingInvocations() {
+        if (outgoingInvocations == null) {
+            outgoingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.setSender(null);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.setSender(BehaviouralEntity.this);
+                }
+            };
+        }
+        return outgoingInvocations;
+    }
+    
+    public void setOutgoingInvocations(Collection<? extends Invocation> outgoingInvocations) {
+        this.getOutgoingInvocations().clear();
+        this.getOutgoingInvocations().addAll(outgoingInvocations);
+    }                    
+    
+        
+    public void addOutgoingInvocations(Invocation one) {
+        this.getOutgoingInvocations().add(one);
+    }   
+    
+    public void addOutgoingInvocations(Invocation one, Invocation... many) {
+        this.getOutgoingInvocations().add(one);
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }   
+    
+    public void addOutgoingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }   
+                
+    public void addOutgoingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }
+    
+    public int numberOfOutgoingInvocations() {
+        return getOutgoingInvocations().size();
+    }
+
+    public boolean hasOutgoingInvocations() {
+        return !getOutgoingInvocations().isEmpty();
+    }
+    
+                
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private Collection<Invocation> incomingInvocations; 
+
+    @FameProperty(name = "incomingInvocations", opposite = "candidates", derived = true)
+    public Collection<Invocation> getIncomingInvocations() {
+        if (incomingInvocations == null) {
+            incomingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.getCandidates().remove(BehaviouralEntity.this);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.getCandidates().add(BehaviouralEntity.this);
+                }
+            };
+        }
+        return incomingInvocations;
+    }
+    
+    public void setIncomingInvocations(Collection<? extends Invocation> incomingInvocations) {
+        this.getIncomingInvocations().clear();
+        this.getIncomingInvocations().addAll(incomingInvocations);
+    }
+    
+    public void addIncomingInvocations(Invocation one) {
+        this.getIncomingInvocations().add(one);
+    }   
+    
+    public void addIncomingInvocations(Invocation one, Invocation... many) {
+        this.getIncomingInvocations().add(one);
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }   
+    
+    public void addIncomingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }   
+                
+    public void addIncomingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }
+    
+    public int numberOfIncomingInvocations() {
+        return getIncomingInvocations().size();
+    }
+
+    public boolean hasIncomingInvocations() {
+        return !getIncomingInvocations().isEmpty();
+    }
+    
+                
+    private Collection<LocalVariable> localVariables; 
+
+    @FameProperty(name = "localVariables", opposite = "parentBehaviouralEntity", derived = true)
+    public Collection<LocalVariable> getLocalVariables() {
+        if (localVariables == null) {
+            localVariables = new MultivalueSet<LocalVariable>() {
+                @Override
+                protected void clearOpposite(LocalVariable e) {
+                    e.setParentBehaviouralEntity(null);
+                }
+                @Override
+                protected void setOpposite(LocalVariable e) {
+                    e.setParentBehaviouralEntity(BehaviouralEntity.this);
+                }
+            };
+        }
+        return localVariables;
+    }
+    
+    public void setLocalVariables(Collection<? extends LocalVariable> localVariables) {
+        this.getLocalVariables().clear();
+        this.getLocalVariables().addAll(localVariables);
+    }                    
+    
+        
+    public void addLocalVariables(LocalVariable one) {
+        this.getLocalVariables().add(one);
+    }   
+    
+    public void addLocalVariables(LocalVariable one, LocalVariable... many) {
+        this.getLocalVariables().add(one);
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }   
+    
+    public void addLocalVariables(Iterable<? extends LocalVariable> many) {
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }   
+                
+    public void addLocalVariables(LocalVariable[] many) {
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }
+    
+    public int numberOfLocalVariables() {
+        return getLocalVariables().size();
+    }
+
+    public boolean hasLocalVariables() {
+        return !getLocalVariables().isEmpty();
+    }
+    
+                
+    private Collection<Parameter> parameters; 
+
+    @FameProperty(name = "parameters", opposite = "parentBehaviouralEntity", derived = true)
+    public Collection<Parameter> getParameters() {
+        if (parameters == null) {
+            parameters = new MultivalueSet<Parameter>() {
+                @Override
+                protected void clearOpposite(Parameter e) {
+                    e.setParentBehaviouralEntity(null);
+                }
+                @Override
+                protected void setOpposite(Parameter e) {
+                    e.setParentBehaviouralEntity(BehaviouralEntity.this);
+                }
+            };
+        }
+        return parameters;
+    }
+    
+    public void setParameters(Collection<? extends Parameter> parameters) {
+        this.getParameters().clear();
+        this.getParameters().addAll(parameters);
+    }                    
+    
+        
+    public void addParameters(Parameter one) {
+        this.getParameters().add(one);
+    }   
+    
+    public void addParameters(Parameter one, Parameter... many) {
+        this.getParameters().add(one);
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }   
+    
+    public void addParameters(Iterable<? extends Parameter> many) {
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }   
+                
+    public void addParameters(Parameter[] many) {
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }
+    
+    public int numberOfParameters() {
+        return getParameters().size();
+    }
+
+    public boolean hasParameters() {
+        return !getParameters().isEmpty();
+    }
+    
+                
+    private String signature;
+    
+    @FameProperty(name = "signature")
+    public String getSignature() {
+        return signature;
+    }
+
+    public void setSignature(String signature) {
+        this.signature = signature;
+    }
+
+    public void setCyclo(int cyclo) {
+		this.cyclo = cyclo;
+	}
+
+	@FameProperty(name = "CYCLO")
+	public int getCyclo() {
+		return cyclo;
+	}
+
+    @FameProperty(name = "NOS")
+	public int getNOS() {
+		return nos;
+	}
+
+	public void setNOS(int nos) {
+		this.nos = nos;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java	(revision 95)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Exception")
+public class Exception extends Entity {
+
+
+
+    private Class exceptionClass;
+    
+    @FameProperty(name = "exceptionClass")
+    public Class getExceptionClass() {
+        return exceptionClass;
+    }
+
+    public void setExceptionClass(Class exceptionClass) {
+        this.exceptionClass = exceptionClass;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java	(revision 95)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CustomSourceLanguage")
+public class CustomSourceLanguage extends SourceLanguage {
+
+
+
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 95)
@@ -0,0 +1,108 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationInstance")
+public class AnnotationInstance extends Entity {
+
+
+
+    private Entity annotatedEntity;
+    
+    @FameProperty(name = "annotatedEntity", opposite = "annotationInstances")
+    public Entity getAnnotatedEntity() {
+        return annotatedEntity;
+    }
+
+    public void setAnnotatedEntity(Entity annotatedEntity) {
+        if (this.annotatedEntity != null) {
+            if (this.annotatedEntity.equals(annotatedEntity)) return;
+            this.annotatedEntity.getAnnotationInstances().remove(this);
+        }
+        this.annotatedEntity = annotatedEntity;
+        if (annotatedEntity == null) return;
+        annotatedEntity.getAnnotationInstances().add(this);
+    }
+    
+    private AnnotationType annotationType;
+    
+    @FameProperty(name = "annotationType", opposite = "instances")
+    public AnnotationType getAnnotationType() {
+        return annotationType;
+    }
+
+    public void setAnnotationType(AnnotationType annotationType) {
+        if (this.annotationType != null) {
+            if (this.annotationType.equals(annotationType)) return;
+            this.annotationType.getInstances().remove(this);
+        }
+        this.annotationType = annotationType;
+        if (annotationType == null) return;
+        annotationType.getInstances().add(this);
+    }
+    
+    private Collection<AnnotationInstanceAttribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentAnnotationInstance", derived = true)
+    public Collection<AnnotationInstanceAttribute> getAttributes() {
+        if (attributes == null) {
+            attributes = new MultivalueSet<AnnotationInstanceAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationInstanceAttribute e) {
+                    e.setParentAnnotationInstance(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstanceAttribute e) {
+                    e.setParentAnnotationInstance(AnnotationInstance.this);
+                }
+            };
+        }
+        return attributes;
+    }
+    
+    public void setAttributes(Collection<? extends AnnotationInstanceAttribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
+        
+    public void addAttributes(AnnotationInstanceAttribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(AnnotationInstanceAttribute one, AnnotationInstanceAttribute... many) {
+        this.getAttributes().add(one);
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends AnnotationInstanceAttribute> many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(AnnotationInstanceAttribute[] many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
+
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 95)
@@ -0,0 +1,204 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ScopingEntity")
+public class ScopingEntity extends ContainerEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope", opposite = "childScopes")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentScope();
+	}
+
+    public void setParentScope(ScopingEntity parentScope) {
+        if (this.parentScope != null) {
+            if (this.parentScope.equals(parentScope)) return;
+            this.parentScope.getChildScopes().remove(this);
+        }
+        this.parentScope = parentScope;
+        if (parentScope == null) return;
+        parentScope.getChildScopes().add(this);
+    }
+    
+    private Collection<Function> functions; 
+
+    @FameProperty(name = "functions", opposite = "parentScope", derived = true)
+    public Collection<Function> getFunctions() {
+        if (functions == null) {
+            functions = new MultivalueSet<Function>() {
+                @Override
+                protected void clearOpposite(Function e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(Function e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return functions;
+    }
+    
+    public void setFunctions(Collection<? extends Function> functions) {
+        this.getFunctions().clear();
+        this.getFunctions().addAll(functions);
+    }                    
+    
+        
+    public void addFunctions(Function one) {
+        this.getFunctions().add(one);
+    }   
+    
+    public void addFunctions(Function one, Function... many) {
+        this.getFunctions().add(one);
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }   
+    
+    public void addFunctions(Iterable<? extends Function> many) {
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }   
+                
+    public void addFunctions(Function[] many) {
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }
+    
+    public int numberOfFunctions() {
+        return getFunctions().size();
+    }
+
+    public boolean hasFunctions() {
+        return !getFunctions().isEmpty();
+    }
+    
+                
+    private Collection<ScopingEntity> childScopes; 
+
+    @FameProperty(name = "childScopes", opposite = "parentScope", derived = true)
+    public Collection<ScopingEntity> getChildScopes() {
+        if (childScopes == null) {
+            childScopes = new MultivalueSet<ScopingEntity>() {
+                @Override
+                protected void clearOpposite(ScopingEntity e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(ScopingEntity e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return childScopes;
+    }
+    
+    public void setChildScopes(Collection<? extends ScopingEntity> childScopes) {
+        this.getChildScopes().clear();
+        this.getChildScopes().addAll(childScopes);
+    }                    
+    
+        
+    public void addChildScopes(ScopingEntity one) {
+        this.getChildScopes().add(one);
+    }   
+    
+    public void addChildScopes(ScopingEntity one, ScopingEntity... many) {
+        this.getChildScopes().add(one);
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }   
+    
+    public void addChildScopes(Iterable<? extends ScopingEntity> many) {
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }   
+                
+    public void addChildScopes(ScopingEntity[] many) {
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }
+    
+    public int numberOfChildScopes() {
+        return getChildScopes().size();
+    }
+
+    public boolean hasChildScopes() {
+        return !getChildScopes().isEmpty();
+    }
+    
+                
+    private Collection<GlobalVariable> globalVariables; 
+
+    @FameProperty(name = "globalVariables", opposite = "parentScope", derived = true)
+    public Collection<GlobalVariable> getGlobalVariables() {
+        if (globalVariables == null) {
+            globalVariables = new MultivalueSet<GlobalVariable>() {
+                @Override
+                protected void clearOpposite(GlobalVariable e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(GlobalVariable e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return globalVariables;
+    }
+    
+    public void setGlobalVariables(Collection<? extends GlobalVariable> globalVariables) {
+        this.getGlobalVariables().clear();
+        this.getGlobalVariables().addAll(globalVariables);
+    }                    
+    
+        
+    public void addGlobalVariables(GlobalVariable one) {
+        this.getGlobalVariables().add(one);
+    }   
+    
+    public void addGlobalVariables(GlobalVariable one, GlobalVariable... many) {
+        this.getGlobalVariables().add(one);
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }   
+    
+    public void addGlobalVariables(Iterable<? extends GlobalVariable> many) {
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }   
+                
+    public void addGlobalVariables(GlobalVariable[] many) {
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }
+    
+    public int numberOfGlobalVariables() {
+        return getGlobalVariables().size();
+    }
+
+    public boolean hasGlobalVariables() {
+        return !getGlobalVariables().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 95)
@@ -0,0 +1,40 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("LocalVariable")
+public class LocalVariable extends StructuralEntity {
+
+
+
+    private BehaviouralEntity parentBehaviouralEntity;
+    
+    @FameProperty(name = "parentBehaviouralEntity", opposite = "localVariables")
+    public BehaviouralEntity getParentBehaviouralEntity() {
+        return parentBehaviouralEntity;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getParentBehaviouralEntity();
+	}
+
+    public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
+        if (this.parentBehaviouralEntity != null) {
+            if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
+            this.parentBehaviouralEntity.getLocalVariables().remove(this);
+        }
+        this.parentBehaviouralEntity = parentBehaviouralEntity;
+        if (parentBehaviouralEntity == null) return;
+        parentBehaviouralEntity.getLocalVariables().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceTextAnchor")
+public class SourceTextAnchor extends SourceAnchor {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("LeafEntity")
+public class LeafEntity extends NamedEntity {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 95)
@@ -0,0 +1,82 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceLanguage")
+public class SourceLanguage extends Entity {
+
+
+
+    private Collection<SourcedEntity> sourcedEntities; 
+
+    @FameProperty(name = "sourcedEntities", opposite = "declaredSourceLanguage", derived = true)
+    public Collection<SourcedEntity> getSourcedEntities() {
+        if (sourcedEntities == null) {
+            sourcedEntities = new MultivalueSet<SourcedEntity>() {
+                @Override
+                protected void clearOpposite(SourcedEntity e) {
+                    e.setDeclaredSourceLanguage(null);
+                }
+                @Override
+                protected void setOpposite(SourcedEntity e) {
+                    e.setDeclaredSourceLanguage(SourceLanguage.this);
+                }
+            };
+        }
+        return sourcedEntities;
+    }
+    
+    public void setSourcedEntities(Collection<? extends SourcedEntity> sourcedEntities) {
+        this.getSourcedEntities().clear();
+        this.getSourcedEntities().addAll(sourcedEntities);
+    }                    
+    
+        
+    public void addSourcedEntities(SourcedEntity one) {
+        this.getSourcedEntities().add(one);
+    }   
+    
+    public void addSourcedEntities(SourcedEntity one, SourcedEntity... many) {
+        this.getSourcedEntities().add(one);
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }   
+    
+    public void addSourcedEntities(Iterable<? extends SourcedEntity> many) {
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }   
+                
+    public void addSourcedEntities(SourcedEntity[] many) {
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }
+    
+    public int numberOfSourcedEntities() {
+        return getSourcedEntities().size();
+    }
+
+    public boolean hasSourcedEntities() {
+        return !getSourcedEntities().isEmpty();
+    }
+    
+                
+    @FameProperty(name = "name", derived = true)
+    public String getName() {
+        // TODO: this is a derived property, implement this method manually.
+        //throw new UnsupportedOperationException("Not yet implemented!");
+    	String fullname = this.getClass().getName();
+    	return fullname.substring(0, fullname.indexOf("SourceLanguage"));
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 95)
@@ -0,0 +1,39 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Class")
+public class Class extends Type {
+
+    public Class() {
+		super();
+		this.setIsInterface(Boolean.FALSE);  // by default assume a real class
+	}
+
+
+    @FameProperty(name = "isAbstract", derived = true)
+    public Boolean getIsAbstract() {
+        // TODO: this is a derived property, implement this method manually.
+        return this.getModifiers().contains("abstract");
+    }
+    
+    private Boolean isInterface;
+    
+    @FameProperty(name = "isInterface")
+    public Boolean getIsInterface() {
+        return isInterface;
+    }
+
+    public void setIsInterface(Boolean isInterface) {
+        this.isInterface = isInterface;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 95)
@@ -0,0 +1,85 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("StructuralEntity")
+public class StructuralEntity extends LeafEntity {
+
+
+
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private Collection<Access> incomingAccesses; 
+
+    @FameProperty(name = "incomingAccesses", opposite = "variable", derived = true)
+    public Collection<Access> getIncomingAccesses() {
+        if (incomingAccesses == null) {
+            incomingAccesses = new MultivalueSet<Access>() {
+                @Override
+                protected void clearOpposite(Access e) {
+                    e.setVariable(null);
+                }
+                @Override
+                protected void setOpposite(Access e) {
+                    e.setVariable(StructuralEntity.this);
+                }
+            };
+        }
+        return incomingAccesses;
+    }
+    
+    public void setIncomingAccesses(Collection<? extends Access> incomingAccesses) {
+        this.getIncomingAccesses().clear();
+        this.getIncomingAccesses().addAll(incomingAccesses);
+    }                    
+    
+        
+    public void addIncomingAccesses(Access one) {
+        this.getIncomingAccesses().add(one);
+    }   
+    
+    public void addIncomingAccesses(Access one, Access... many) {
+        this.getIncomingAccesses().add(one);
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }   
+    
+    public void addIncomingAccesses(Iterable<? extends Access> many) {
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }   
+                
+    public void addIncomingAccesses(Access[] many) {
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }
+    
+    public int numberOfIncomingAccesses() {
+        return getIncomingAccesses().size();
+    }
+
+    public boolean hasIncomingAccesses() {
+        return !getIncomingAccesses().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 95)
@@ -0,0 +1,22 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("UnknownVariable")
+public class UnknownVariable extends StructuralEntity {
+
+
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return null;
+	}
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("JavaSourceLanguage")
+public class JavaSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 95)
@@ -0,0 +1,46 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("GlobalVariable")
+public class GlobalVariable extends StructuralEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    public void setParentScope(ScopingEntity parentScope) {
+        this.parentScope = parentScope;
+    }
+    
+    private Module parentModule;
+    
+    @FameProperty(name = "parentModule", opposite = "globalVariables")
+    public Module getParentModule() {
+        return parentModule;
+    }
+
+    public void setParentModule(Module parentModule) {
+        if (this.parentModule != null) {
+            if (this.parentModule.equals(parentModule)) return;
+            this.parentModule.getGlobalVariables().remove(this);
+        }
+        this.parentModule = parentModule;
+        if (parentModule == null) return;
+        parentModule.getGlobalVariables().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("PackageGroup")
+public class PackageGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java	(revision 95)
@@ -0,0 +1,51 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("FileAnchor")
+public class FileAnchor extends SourceAnchor {
+
+
+
+    private Number startLine;
+    
+    @FameProperty(name = "startLine")
+    public Number getStartLine() {
+        return startLine;
+    }
+
+    public void setStartLine(Number startLine) {
+        this.startLine = startLine;
+    }
+    
+    private Number endLine;
+    
+    @FameProperty(name = "endLine")
+    public Number getEndLine() {
+        return endLine;
+    }
+
+    public void setEndLine(Number endLine) {
+        this.endLine = endLine;
+    }
+    
+    private String fileName;
+    
+    @FameProperty(name = "fileName")
+    public String getFileName() {
+        return fileName;
+    }
+
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("PrimitiveType")
+public class PrimitiveType extends Type {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 95)
@@ -0,0 +1,150 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationType")
+public class AnnotationType extends NamedEntity {
+
+
+
+    private ContainerEntity container;
+    
+    @FameProperty(name = "container", opposite = "definedAnnotationTypes")
+    public ContainerEntity getContainer() {
+        return container;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
+    public void setContainer(ContainerEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getDefinedAnnotationTypes().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getDefinedAnnotationTypes().add(this);
+    }
+    
+    private Collection<AnnotationTypeAttribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentAnnotationType", derived = true)
+    public Collection<AnnotationTypeAttribute> getAttributes() {
+        if (attributes == null) {
+            attributes = new MultivalueSet<AnnotationTypeAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationTypeAttribute e) {
+                    e.setParentAnnotationType(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationTypeAttribute e) {
+                    e.setParentAnnotationType(AnnotationType.this);
+                }
+            };
+        }
+        return attributes;
+    }
+    
+    public void setAttributes(Collection<? extends AnnotationTypeAttribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
+        
+    public void addAttributes(AnnotationTypeAttribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(AnnotationTypeAttribute one, AnnotationTypeAttribute... many) {
+        this.getAttributes().add(one);
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends AnnotationTypeAttribute> many) {
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(AnnotationTypeAttribute[] many) {
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
+
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
+    private Collection<AnnotationInstance> instances; 
+
+    @FameProperty(name = "instances", opposite = "annotationType", derived = true)
+    public Collection<AnnotationInstance> getInstances() {
+        if (instances == null) {
+            instances = new MultivalueSet<AnnotationInstance>() {
+                @Override
+                protected void clearOpposite(AnnotationInstance e) {
+                    e.setAnnotationType(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstance e) {
+                    e.setAnnotationType(AnnotationType.this);
+                }
+            };
+        }
+        return instances;
+    }
+    
+    public void setInstances(Collection<? extends AnnotationInstance> instances) {
+        this.getInstances().clear();
+        this.getInstances().addAll(instances);
+    }                    
+    
+        
+    public void addInstances(AnnotationInstance one) {
+        this.getInstances().add(one);
+    }   
+    
+    public void addInstances(AnnotationInstance one, AnnotationInstance... many) {
+        this.getInstances().add(one);
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }   
+    
+    public void addInstances(Iterable<? extends AnnotationInstance> many) {
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }   
+                
+    public void addInstances(AnnotationInstance[] many) {
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }
+    
+    public int numberOfInstances() {
+        return getInstances().size();
+    }
+
+    public boolean hasInstances() {
+        return !getInstances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java	(revision 95)
@@ -0,0 +1,62 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Association")
+public class Association extends SourcedEntity {
+
+
+
+    @FameProperty(name = "to", derived = true)
+    public NamedEntity getTo() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Association.getTo() Not yet implemented!");  
+    }
+    
+    private Association previous;
+    
+    @FameProperty(name = "previous", opposite = "next")
+    public Association getPrevious() {
+        return previous;
+    }
+
+    public void setPrevious(Association previous) {
+        if (this.previous == null ? previous != null : !this.previous.equals(previous)) {
+            Association old_previous = this.previous;
+            this.previous = previous;
+            if (old_previous != null) old_previous.setNext(null);
+            if (previous != null) previous.setNext(this);
+        }
+    }
+    
+    private Association next;
+    
+    @FameProperty(name = "next", opposite = "previous", derived = true)
+    public Association getNext() {
+        return next;
+    }
+
+    public void setNext(Association next) {
+        if (this.next == null ? next != null : !this.next.equals(next)) {
+            Association old_next = this.next;
+            this.next = next;
+            if (old_next != null) old_next.setPrevious(null);
+            if (next != null) next.setPrevious(this);
+        }
+    }
+    
+    @FameProperty(name = "from", derived = true)
+    public NamedEntity getFrom() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Association.getFrom() Not yet implemented!");  
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java	(revision 95)
@@ -0,0 +1,236 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ContainerEntity")
+public class ContainerEntity extends NamedEntity {
+
+
+
+    private Collection<AnnotationType> definedAnnotationTypes; 
+
+    @FameProperty(name = "definedAnnotationTypes", opposite = "container", derived = true)
+    public Collection<AnnotationType> getDefinedAnnotationTypes() {
+        if (definedAnnotationTypes == null) {
+            definedAnnotationTypes = new MultivalueSet<AnnotationType>() {
+                @Override
+                protected void clearOpposite(AnnotationType e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationType e) {
+                    e.setContainer(ContainerEntity.this);
+                }
+            };
+        }
+        return definedAnnotationTypes;
+    }
+    
+    public void setDefinedAnnotationTypes(Collection<? extends AnnotationType> definedAnnotationTypes) {
+        this.getDefinedAnnotationTypes().clear();
+        this.getDefinedAnnotationTypes().addAll(definedAnnotationTypes);
+    }                    
+    
+        
+    public void addDefinedAnnotationTypes(AnnotationType one) {
+        this.getDefinedAnnotationTypes().add(one);
+    }   
+    
+    public void addDefinedAnnotationTypes(AnnotationType one, AnnotationType... many) {
+        this.getDefinedAnnotationTypes().add(one);
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }   
+    
+    public void addDefinedAnnotationTypes(Iterable<? extends AnnotationType> many) {
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }   
+                
+    public void addDefinedAnnotationTypes(AnnotationType[] many) {
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }
+    
+    public int numberOfDefinedAnnotationTypes() {
+        return getDefinedAnnotationTypes().size();
+    }
+
+    public boolean hasDefinedAnnotationTypes() {
+        return !getDefinedAnnotationTypes().isEmpty();
+    }
+    
+                
+    private Collection<Reference> outgoingReferences; 
+
+    @FameProperty(name = "outgoingReferences", opposite = "source", derived = true)
+    public Collection<Reference> getOutgoingReferences() {
+        if (outgoingReferences == null) {
+            outgoingReferences = new MultivalueSet<Reference>() {
+                @Override
+                protected void clearOpposite(Reference e) {
+                    e.setSource(null);
+                }
+                @Override
+                protected void setOpposite(Reference e) {
+                    e.setSource(ContainerEntity.this);
+                }
+            };
+        }
+        return outgoingReferences;
+    }
+    
+    public void setOutgoingReferences(Collection<? extends Reference> outgoingReferences) {
+        this.getOutgoingReferences().clear();
+        this.getOutgoingReferences().addAll(outgoingReferences);
+    }                    
+    
+        
+    public void addOutgoingReferences(Reference one) {
+        this.getOutgoingReferences().add(one);
+    }   
+    
+    public void addOutgoingReferences(Reference one, Reference... many) {
+        this.getOutgoingReferences().add(one);
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }   
+    
+    public void addOutgoingReferences(Iterable<? extends Reference> many) {
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }   
+                
+    public void addOutgoingReferences(Reference[] many) {
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }
+    
+    public int numberOfOutgoingReferences() {
+        return getOutgoingReferences().size();
+    }
+
+    public boolean hasOutgoingReferences() {
+        return !getOutgoingReferences().isEmpty();
+    }
+    
+                
+    private Collection<Type> types; 
+
+    @FameProperty(name = "types", opposite = "container", derived = true)
+    public Collection<Type> getTypes() {
+        if (types == null) {
+            types = new MultivalueSet<Type>() {
+                @Override
+                protected void clearOpposite(Type e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(Type e) {
+                    e.setContainer(ContainerEntity.this);
+                }
+            };
+        }
+        return types;
+    }
+    
+    public void setTypes(Collection<? extends Type> types) {
+        this.getTypes().clear();
+        this.getTypes().addAll(types);
+    }                    
+    
+        
+    public void addTypes(Type one) {
+        this.getTypes().add(one);
+    }   
+    
+    public void addTypes(Type one, Type... many) {
+        this.getTypes().add(one);
+        for (Type each : many)
+            this.getTypes().add(each);
+    }   
+    
+    public void addTypes(Iterable<? extends Type> many) {
+        for (Type each : many)
+            this.getTypes().add(each);
+    }   
+                
+    public void addTypes(Type[] many) {
+        for (Type each : many)
+            this.getTypes().add(each);
+    }
+    
+    public int numberOfTypes() {
+        return getTypes().size();
+    }
+
+    public boolean hasTypes() {
+        return !getTypes().isEmpty();
+    }
+    
+                
+    private Collection<Reference> incomingReferences; 
+
+    @FameProperty(name = "incomingReferences", opposite = "target", derived = true)
+    public Collection<Reference> getIncomingReferences() {
+        if (incomingReferences == null) {
+            incomingReferences = new MultivalueSet<Reference>() {
+                @Override
+                protected void clearOpposite(Reference e) {
+                    e.setTarget(null);
+                }
+                @Override
+                protected void setOpposite(Reference e) {
+                    e.setTarget(ContainerEntity.this);
+                }
+            };
+        }
+        return incomingReferences;
+    }
+    
+    public void setIncomingReferences(Collection<? extends Reference> incomingReferences) {
+        this.getIncomingReferences().clear();
+        this.getIncomingReferences().addAll(incomingReferences);
+    }                    
+    
+        
+    public void addIncomingReferences(Reference one) {
+        this.getIncomingReferences().add(one);
+    }   
+    
+    public void addIncomingReferences(Reference one, Reference... many) {
+        this.getIncomingReferences().add(one);
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }   
+    
+    public void addIncomingReferences(Iterable<? extends Reference> many) {
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }   
+                
+    public void addIncomingReferences(Reference[] many) {
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }
+    
+    public int numberOfIncomingReferences() {
+        return getIncomingReferences().size();
+    }
+
+    public boolean hasIncomingReferences() {
+        return !getIncomingReferences().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 95)
@@ -0,0 +1,258 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Type")
+public class Type extends ContainerEntity {
+
+
+
+    private Collection<Method> methods; 
+
+    @FameProperty(name = "methods", opposite = "parentType", derived = true)
+    public Collection<Method> getMethods() {
+        if (methods == null) {
+            methods = new MultivalueSet<Method>() {
+                @Override
+                protected void clearOpposite(Method e) {
+                    e.setParentType(null);
+                }
+                @Override
+                protected void setOpposite(Method e) {
+                    e.setParentType(Type.this);
+                }
+            };
+        }
+        return methods;
+    }
+    
+    public void setMethods(Collection<? extends Method> methods) {
+        this.getMethods().clear();
+        this.getMethods().addAll(methods);
+    }                    
+    
+        
+    public void addMethods(Method one) {
+        this.getMethods().add(one);
+    }   
+    
+    public void addMethods(Method one, Method... many) {
+        this.getMethods().add(one);
+        for (Method each : many)
+            this.getMethods().add(each);
+    }   
+    
+    public void addMethods(Iterable<? extends Method> many) {
+        for (Method each : many)
+            this.getMethods().add(each);
+    }   
+                
+    public void addMethods(Method[] many) {
+        for (Method each : many)
+            this.getMethods().add(each);
+    }
+    
+    public int numberOfMethods() {
+        return getMethods().size();
+    }
+
+    public boolean hasMethods() {
+        return !getMethods().isEmpty();
+    }
+    
+                
+    private Collection<Inheritance> superInheritances; 
+
+    @FameProperty(name = "superInheritances", opposite = "subclass", derived = true)
+    public Collection<Inheritance> getSuperInheritances() {
+        if (superInheritances == null) {
+            superInheritances = new MultivalueSet<Inheritance>() {
+                @Override
+                protected void clearOpposite(Inheritance e) {
+                    e.setSubclass(null);
+                }
+                @Override
+                protected void setOpposite(Inheritance e) {
+                    e.setSubclass(Type.this);
+                }
+            };
+        }
+        return superInheritances;
+    }
+    
+    public void setSuperInheritances(Collection<? extends Inheritance> superInheritances) {
+        this.getSuperInheritances().clear();
+        this.getSuperInheritances().addAll(superInheritances);
+    }                    
+    
+        
+    public void addSuperInheritances(Inheritance one) {
+        this.getSuperInheritances().add(one);
+    }   
+    
+    public void addSuperInheritances(Inheritance one, Inheritance... many) {
+        this.getSuperInheritances().add(one);
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }   
+    
+    public void addSuperInheritances(Iterable<? extends Inheritance> many) {
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }   
+                
+    public void addSuperInheritances(Inheritance[] many) {
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }
+    
+    public int numberOfSuperInheritances() {
+        return getSuperInheritances().size();
+    }
+
+    public boolean hasSuperInheritances() {
+        return !getSuperInheritances().isEmpty();
+    }
+    
+                
+    private ContainerEntity container;
+    
+    @FameProperty(name = "container", opposite = "types")
+    public ContainerEntity getContainer() {
+        return container;
+    }
+
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return getContainer();
+	}
+
+    public void setContainer(ContainerEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getTypes().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getTypes().add(this);
+    }
+    
+    private Collection<Attribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentType", derived = true)
+    public Collection<Attribute> getAttributes() {
+        if (attributes == null) {
+            attributes = new MultivalueSet<Attribute>() {
+                @Override
+                protected void clearOpposite(Attribute e) {
+                    e.setParentType(null);
+                }
+                @Override
+                protected void setOpposite(Attribute e) {
+                    e.setParentType(Type.this);
+                }
+            };
+        }
+        return attributes;
+    }
+    
+    public void setAttributes(Collection<? extends Attribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
+        
+    public void addAttributes(Attribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(Attribute one, Attribute... many) {
+        this.getAttributes().add(one);
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends Attribute> many) {
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(Attribute[] many) {
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
+
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
+    private Collection<Inheritance> subInheritances; 
+
+    @FameProperty(name = "subInheritances", opposite = "superclass", derived = true)
+    public Collection<Inheritance> getSubInheritances() {
+        if (subInheritances == null) {
+            subInheritances = new MultivalueSet<Inheritance>() {
+                @Override
+                protected void clearOpposite(Inheritance e) {
+                    e.setSuperclass(null);
+                }
+                @Override
+                protected void setOpposite(Inheritance e) {
+                    e.setSuperclass(Type.this);
+                }
+            };
+        }
+        return subInheritances;
+    }
+    
+    public void setSubInheritances(Collection<? extends Inheritance> subInheritances) {
+        this.getSubInheritances().clear();
+        this.getSubInheritances().addAll(subInheritances);
+    }                    
+    
+        
+    public void addSubInheritances(Inheritance one) {
+        this.getSubInheritances().add(one);
+    }   
+    
+    public void addSubInheritances(Inheritance one, Inheritance... many) {
+        this.getSubInheritances().add(one);
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }   
+    
+    public void addSubInheritances(Iterable<? extends Inheritance> many) {
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }   
+                
+    public void addSubInheritances(Inheritance[] many) {
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }
+    
+    public int numberOfSubInheritances() {
+        return getSubInheritances().size();
+    }
+
+    public boolean hasSubInheritances() {
+        return !getSubInheritances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ClassGroup")
+public class ClassGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterType")
+public class ParameterType extends Type {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java	(revision 95)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("UnknownSourceLanguage")
+public class UnknownSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 95)
@@ -0,0 +1,46 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Function")
+public class Function extends BehaviouralEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    public void setParentScope(ScopingEntity parentScope) {
+        this.parentScope = parentScope;
+    }
+    
+    private Module parentModule;
+    
+    @FameProperty(name = "parentModule", opposite = "functions")
+    public Module getParentModule() {
+        return parentModule;
+    }
+
+    public void setParentModule(Module parentModule) {
+        if (this.parentModule != null) {
+            if (this.parentModule.equals(parentModule)) return;
+            this.parentModule.getFunctions().remove(this);
+        }
+        this.parentModule = parentModule;
+        if (parentModule == null) return;
+        parentModule.getFunctions().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java	(revision 95)
@@ -0,0 +1,64 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Inheritance")
+public class Inheritance extends Association {
+
+
+
+    private Type superclass;
+    
+    @FameProperty(name = "superclass", opposite = "subInheritances")
+    public Type getSuperclass() {
+        return superclass;
+    }
+
+    public void setSuperclass(Type superclass) {
+        if (this.superclass != null) {
+            if (this.superclass.equals(superclass)) return;
+            this.superclass.getSubInheritances().remove(this);
+        }
+        this.superclass = superclass;
+        if (superclass == null) return;
+        superclass.getSubInheritances().add(this);
+    }
+    
+    private Type subclass;
+    
+    @FameProperty(name = "subclass", opposite = "superInheritances")
+    public Type getSubclass() {
+        return subclass;
+    }
+
+    public void setSubclass(Type subclass) {
+        if (this.subclass != null) {
+            if (this.subclass.equals(subclass)) return;
+            this.subclass.getSuperInheritances().remove(this);
+        }
+        this.subclass = subclass;
+        if (subclass == null) return;
+        subclass.getSuperInheritances().add(this);
+    }
+
+	@Override
+	public NamedEntity getFrom() {
+		return getSubclass();
+	}
+
+	@Override
+	public NamedEntity getTo() {
+		return getSuperclass();
+	}
+    
+    
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java	(revision 95)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CaughtException")
+public class CaughtException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "caughtExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getCaughtExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getCaughtExceptions().add(this);
+    }
+    
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 95)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("MethodGroup")
+public class MethodGroup extends Group {
+
+
+
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 95)
@@ -0,0 +1,33 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterizableClass")
+public class ParameterizableClass extends Class {
+
+
+
+    @FameProperty(name = "parameters", derived = true)
+    public Collection<ParameterType> getParameters() {
+        // this is a derived property, implement this method manually.
+    	Collection<ParameterType> ret = new LinkedList<ParameterType>();
+    	
+        for (Type inner : getTypes()) {
+        	if (inner instanceof ParameterType) {
+        		ret.add((ParameterType) inner);
+        	}
+        }
+        
+        return ret;
+    }
+        
+
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java	(revision 95)
@@ -0,0 +1,62 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Reference")
+public class Reference extends Association {
+
+
+
+    private ContainerEntity source;
+    
+    @FameProperty(name = "source", opposite = "outgoingReferences")
+    public ContainerEntity getSource() {
+        return source;
+    }
+
+    public void setSource(ContainerEntity source) {
+        if (this.source != null) {
+            if (this.source.equals(source)) return;
+            this.source.getOutgoingReferences().remove(this);
+        }
+        this.source = source;
+        if (source == null) return;
+        source.getOutgoingReferences().add(this);
+    }
+    
+    private ContainerEntity target;
+    
+    @FameProperty(name = "target", opposite = "incomingReferences")
+    public ContainerEntity getTarget() {
+        return target;
+    }
+
+    public void setTarget(ContainerEntity target) {
+        if (this.target != null) {
+            if (this.target.equals(target)) return;
+            this.target.getIncomingReferences().remove(this);
+        }
+        this.target = target;
+        if (target == null) return;
+        target.getIncomingReferences().add(this);
+    }
+
+	@Override
+	public NamedEntity getFrom() {
+		return getSource();
+	}
+
+	@Override
+	public NamedEntity getTo() {
+		return getTarget();
+	}
+    
+
+
+}
+
Index: verveine.extractor.java/test_src/Dictionary/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 0)
+++ verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 59)
@@ -0,0 +1,675 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+
+/**
+ * A dictionnary of Famix entities to help create them and find them back
+ * @author anquetil
+ *
+ * @param <B> The super class of all bindings. Different for JDT, PDT, ... bindings
+ */
+public class Dictionary<B> {
+
+	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
+	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
+	public static final String SELF_NAME = "self";
+	public static final String SUPER_NAME = "super";
+
+	/**
+	 * The FAMIX repository where all FAMIX entities are created and stored
+	 */
+	protected Repository famixRepo;
+
+	/**
+	 * A dictionary to map an IBinding to FAMIX Entity
+	 */
+	protected Map<B,NamedEntity> mapBind;
+
+	/**
+	 * Another dictionary to map a name to FAMIX Entities with this name
+	 */
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	/**
+	 * Yet another dictionary for implicit variables
+	 * 'self' and 'super' have the same binding than their associated class so they can't be kept easily in bindFmxDico
+	 */
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	/**
+	 * Used to keep the two possible ImplicitVariable for a given Class binding
+	 * @author anquetil
+	 */
+	protected class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+	
+	/** Constructor taking a FAMIX repository
+	 * @param famixRepo
+	 */
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
+	}
+
+	protected void recoverExistingRepository() {
+		for (Object obj : famixRepo.getElements()) {
+			if (obj instanceof NamedEntity) {
+				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
+			}
+		}
+		
+		for (Access acc : famixRepo.all(Access.class)) {
+			try {
+				if (acc.getIsWrite()) { }
+			}
+			catch (NullPointerException e) {
+				acc.setIsWrite(Boolean.FALSE);
+			}
+		}
+
+		for (fr.inria.verveine.core.gen.famix.Class clazz : famixRepo.all(fr.inria.verveine.core.gen.famix.Class.class)) {
+			try { if (clazz.getIsAbstract()) { } }
+			catch (NullPointerException e) { clazz.setIsAbstract(Boolean.FALSE); }
+			try { if (clazz.getIsStub()) { } }
+			catch (NullPointerException e) { clazz.setIsStub(Boolean.FALSE); }
+			try { if (clazz.getIsPublic()) { } }
+			catch (NullPointerException e) { clazz.setIsPublic(Boolean.FALSE); }
+			try { if (clazz.getIsPrivate()) { } }
+			catch (NullPointerException e) { clazz.setIsPrivate(Boolean.FALSE); }
+			try { if (clazz.getIsProtected()) { } }
+			catch (NullPointerException e) { clazz.setIsProtected(Boolean.FALSE); }
+			try { if (clazz.getIsFinal()) { } }
+			catch (NullPointerException e) { clazz.setIsFinal(Boolean.FALSE); }
+		}
+
+		for (Method meth : famixRepo.all(Method.class)) {
+			try { if (meth.getIsAbstract()) { } }
+			catch (NullPointerException e) { meth.setIsAbstract(Boolean.FALSE); }
+			try { if (meth.getIsStub()) { } }
+			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
+			try { if (meth.getIsPublic()) { } }
+			catch (NullPointerException e) { meth.setIsPublic(Boolean.FALSE); }
+			try { if (meth.getIsPrivate()) { } }
+			catch (NullPointerException e) { meth.setIsPrivate(Boolean.FALSE); }
+			try { if (meth.getIsProtected()) { } }
+			catch (NullPointerException e) { meth.setIsProtected(Boolean.FALSE); }
+			try { if (meth.getIsFinal()) { } }
+			catch (NullPointerException e) { meth.setIsFinal(Boolean.FALSE); }
+		}
+
+		for (Attribute att : famixRepo.all(Attribute.class)) {
+			try { if (att.getIsAbstract()) { } }
+			catch (NullPointerException e) { att.setIsAbstract(Boolean.FALSE); }
+			try { if (att.getIsStub()) { } }
+			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
+			try { if (att.getIsPublic()) { } }
+			catch (NullPointerException e) { att.setIsPublic(Boolean.FALSE); }
+			try { if (att.getIsPrivate()) { } }
+			catch (NullPointerException e) { att.setIsPrivate(Boolean.FALSE); }
+			try { if (att.getIsProtected()) { } }
+			catch (NullPointerException e) { att.setIsProtected(Boolean.FALSE); }
+			try { if (att.getIsFinal()) { } }
+			catch (NullPointerException e) { att.setIsFinal(Boolean.FALSE); }
+		}
+
+	}
+	
+	protected void mapEntityToName(String name, NamedEntity ent) {
+		Collection<NamedEntity> l_ent = mapName.get(name);
+		if (l_ent == null) {
+			l_ent = new LinkedList<NamedEntity>();
+		}
+		l_ent.add(ent);
+		mapName.put(name, l_ent);
+	}
+	
+	/**
+	 * Returns all the Famix Entity with the given name and class 
+	 * @param fmxClass -- the subtype of Famix Entity we are looking for
+	 * @param name -- the name of the entity
+	 * @return the Collection of Famix Entities with the given name and class (possibly empty)
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns the Famix Entity associated to the given binding.
+	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
+	 * In such a case, this method will always retrieve the Class associated to the binding.
+	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public NamedEntity getEntityByBinding(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapBind.get(bnd);
+		}
+	}
+
+	/**
+	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
+	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param name -- the name of the new instance
+	 * @return the FAMIX Entity or null in case of a FAMIX error
+	 */
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+		T fmx = null;
+
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			mapEntityToName(name, fmx);
+			
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a FAMIX Entity of the type <b>fmxClass</b> and maps it to its binding <b>bnd</b> (if not null).
+	 * The Entity is created if it did not exist.
+	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use ensureFamixImplicitVariable instead.
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param bnd -- the binding to map to the new instance
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
+	 * 
+	 * TODO Make public and remove ensureFamixClass(name), ensureFamixAttribute(name), ... ????
+	 */
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		else {
+			// Unfortunately different entities with the same name and same type may exist
+			// e.g. 2 parameters of 2 different methods but having the same name
+			// so we must recreate a new entity each time
+
+			//fmxEnt = getEntityByName(fmxClass, name);
+		}
+
+		if (fmx != null) {
+			return fmx;
+		}
+
+		fmx = createFamixEntity(fmxClass, name);
+		// put new entity in mappers
+		if (bnd != null) {
+			mapBind.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Adds an already created Entity to the FAMIX repository
+	 * Used mainly for non-NamedEntity, for example relationships
+	 * @param e -- the FAMIX entity to add to the repository
+	 */
+	public void famixRepoAdd(Entity e) {
+		this.famixRepo.add(e);
+	}
+
+	///// ensure Famix Entities /////
+	
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+		if (fmx != null) {
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.FALSE);
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Method
+	 * @return the FAMIX Method or null in case of a FAMIX error
+	 */
+	public Method ensureFamixMethod(String name) {
+		return (Method) ensureFamixEntity(Method.class, null, name);
+	}
+
+	/**
+	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Attribute
+	 * @return the FAMIX Attribute or null in case of a FAMIX error
+	 */
+	public Attribute ensureFamixAttribute(String name) {
+		return (Attribute) ensureFamixEntity(Attribute.class, null, name);
+	}
+
+	/**
+	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX LocalVariable
+	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
+	 */
+	public LocalVariable ensureFamixLocalVariable(String name) {
+		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
+	}
+
+	/**
+	 * Creates and returns a FAMIX Comment
+	 * @param cmt -- the content (String) of the comment 
+	 * @return the FAMIX Comment
+	 */
+	public Comment createFamixComment(String cmt) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+
+	/**
+	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
+	 * @param cmt -- the content (String) of the comment 
+	 * @param owner -- the entity concerned by this comment
+	 * @return the FAMIX Comment
+	 */
+	public Comment createFamixComment(String cmt, SourcedEntity owner) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		fmx.setContainer(owner);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+	
+	/**
+	 * Creates and returns a FAMIX Parameter and associates it with an BehaviouralEntity
+	 * @param identifier -- the name of the parameter
+	 * @param owner -- the entity concerned by this parameter
+	 * @param type -- the type of the parameter
+	 * @return the FAMIX parameter
+	 */
+	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, String type) {
+		Parameter fmx = new Parameter();
+		fmx.setName(identifier);
+		fmx.setParentBehaviouralEntity(owner);
+		fmx.setDeclaredType(ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type));
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+	
+	///// ensure Famix Relationships /////
+
+	/**
+	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
+	 * @param sup -- the super class
+	 * @param sub -- the sub class
+	 * @return the Inheritance relationship
+	 */
+	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
+		return ensureFamixInheritance(sup, sub, null);
+	}
+	
+	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub, Association prev) {
+		for (Inheritance i : sup.getSubInheritances()) {
+			if (i.getSubclass() == sub) {
+				return i;
+			}
+		}
+		Inheritance inh = new Inheritance();
+		inh.setSuperclass(sup);
+		inh.setSubclass(sub);
+		chainPrevNext(prev,inh);
+		famixRepoAdd(inh);
+		return inh;
+	}
+
+	/**
+	 * Returns a Famix Reference between two Famix Entities creating it if needed
+	 * @param src -- source of the reference
+	 * @param tgt -- target of the reference
+	 * @return the Reference
+	 */
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
+		return ensureFamixReference(src, tgt, null);
+	}
+	
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+		Reference ref = new Reference();
+		ref.setTarget(tgt);
+		ref.setSource(src);
+		chainPrevNext(prev,ref);
+		famixRepoAdd(ref);
+		
+		return ref;
+	}
+
+	/**
+	 * Returns a Famix Invocation between two Famix Entities creating it if needed
+	 * @param sender of the invocation
+	 * @param invoked -- method invoked
+	 * @param receiver of the invocation
+	 * @return the Invocation
+	 */
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
+		return ensureFamixInvocation(sender, invoked, receiver, null);
+	}
+
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+		Invocation invok = new Invocation();
+		invok.setReceiver(receiver);
+		invok.setSender(sender);
+		invok.setSignature(invoked.getSignature());
+		invok.addCandidates(invoked);
+		chainPrevNext(prev,invok);
+		famixRepoAdd(invok);
+		
+		return invok;
+	}
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
+		/* We keep multiple accesses from one method to a field */
+		Access acc = new Access();
+		acc.setAccessor(accessor);
+		acc.setVariable(var);
+		acc.setIsWrite(new Boolean(isWrite));
+		chainPrevNext(prev, acc);
+		famixRepoAdd(acc);
+		
+		return acc;
+	}
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
+		return ensureFamixAccess(accessor, var, isWrite, null);
+	}
+	
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
+		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
+	}
+
+	private void chainPrevNext(Association prev, Association next) {
+		if (prev != null) {
+			next.setPrevious(prev);  // not yet implemented in importer
+		}
+	}
+	
+	/**
+	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception declared to be thrown
+	 * @return the DeclaredException
+	 */
+	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		DeclaredException decl = new DeclaredException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix CaughtException between a method and an Exception that is caught
+	 * @param meth -- the method catching the exception
+	 * @param excep -- the exception caught
+	 * @return the CaughtException
+	 */
+	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		CaughtException decl = new CaughtException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
+	 * Note: DeclaredException indicates that the method declares it can throw the exception,
+	 * here we state that the exception is actually thrown
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception thrown
+	 * @return the ThrownException
+	 */
+	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		ThrownException decl = new ThrownException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	///// Special Case: ImplicitVariables /////
+
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given binding and name (self or super).
+	 * See also {@link Dictionary#getEntityByBinding(Object)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
+		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByBinding(bnd), iv_name);
+	}
+	
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given Famix Class.
+	 * @param clazz -- the FamixClass
+	 * @param name -- name of the ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the Famix ImplicitVariable associated to the Class or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByClass(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVars iv = mapImpVar.get(clazz);
+		ImplicitVariable ret = null;
+		
+		if (iv == null) {
+			iv = new ImplicitVars();
+		}
+		
+		if (name.equals(SELF_NAME)) {
+			ret = iv.self_iv;
+		}
+		else if (name.equals(SUPER_NAME)) {
+			ret = iv.super_iv;
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
+	 * If this ImplicitVariable does not exist yet, it is created
+	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
+	 */
+	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
+		
+		if (fmx == null) {
+			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
+			if (fmx!=null) {
+				fmx.setContainer(clazz);
+				fmx.setIsStub(Boolean.FALSE);
+
+				ImplicitVars iv = mapImpVar.get(clazz);				
+				if (iv == null) {
+					iv = new ImplicitVars();
+				}
+
+				if (name.equals(SELF_NAME)) {
+					iv.self_iv = fmx;
+				}
+				else if (name.equals(SUPER_NAME)) {
+					iv.super_iv = fmx;
+				}
+				
+				mapImpVar.put(clazz, iv);
+			}
+		}
+
+		return fmx;
+	}
+
+	///// Special Case: "Uniq" Entities /////
+
+	/**
+	 * Creates or recovers a Famix Named Entity uniq for the given name.
+	 * For some specific entities we don't allow two of them with the same name.
+	 * This is the case e.g. for the default package, or the Java class "Object" and its package "java.lang".
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param bnd -- a potential binding for the entity
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the uniq Famix Entity for this binding and/or name
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		
+		if (fmx == null) {
+			Collection<T> l = getEntityByName( fmxClass, name);
+			if (l.size() > 0) {
+				fmx = l.iterator().next();
+			}
+			else {
+				fmx = createFamixEntity(fmxClass, name);
+			}
+			
+			if (bnd != null) {
+				// may happen for example if the entity was first created without binding
+				// and we find a binding for it later
+				mapBind.put(bnd, fmx);
+			}
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Namespace with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that Namespaces must be uniq for a given name
+	 * @param name -- the name of the FAMIX Namespace
+	 * @return the FAMIX Namespace or null in case of a FAMIX error
+	 */
+	public Namespace ensureFamixNamespace(String name) {
+		return  ensureFamixUniqEntity(Namespace.class, null, name);
+	}
+
+	/**
+	 * Creates or recovers a default Famix Namespace.
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix Namespace
+	 */
+	public Namespace ensureFamixNamespaceDefault() {
+		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, DEFAULT_PCKG_NAME);
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that PrimitiveType must be uniq for a given name
+	 * @param name -- the name of the FAMIX PrimitiveType
+	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
+	 */
+	public PrimitiveType ensureFamixPrimitiveType(String name) {
+		return  ensureFamixUniqEntity(PrimitiveType.class, null, name);
+	}
+	
+	/**
+	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
+		if (fmx != null) {
+			fmx.setContainer( ensureFamixNamespaceDefault());
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.FALSE);
+		}
+
+		return fmx;
+	}
+	
+}
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 46)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 47)
@@ -22,6 +22,8 @@
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Comment;
@@ -112,6 +114,8 @@
 		assertEquals(6+24, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
 		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
 		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+		assertEquals(1, TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
+		assertEquals(2, TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
 	}
 
 	@Test
@@ -549,7 +553,7 @@
 	}
 	
 	@Test
-	public void testMetric() {	
+	public void testMetric() {
 		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
 			assertNotNull(m);
 			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
@@ -568,5 +572,43 @@
 			}
 		}		
 	}
-
-}
+	
+	@Test
+	public void testAnnotation() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<AnnotationInstance> annInstances;
+		
+		AnnotationType annType = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
+		assertNotNull(annType);
+		assertEquals("Override", annType.getName());
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("output")) {
+				assertEquals(1, annInstances.size());
+				AnnotationInstance annInstance = annInstances.iterator().next();
+				assertEquals("Override", annInstance.getAnnotationType().getName());
+				assertSame(annType, annInstance.getAnnotationType());
+				assertSame(method, annInstance.getAnnotatedEntity());
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("isDestinationFor")) {
+				assertEquals(1, annInstances.size());
+				AnnotationInstance annInstance = annInstances.iterator().next();
+				assertEquals("Override", annInstance.getAnnotationType().getName());
+				assertSame(annType, annInstance.getAnnotationType());
+				assertSame(method, annInstance.getAnnotatedEntity());
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}	
+	}
+}
\ No newline at end of file
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 6)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 7)
@@ -117,12 +117,12 @@
 
 	/**
 	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
-	 * The Entity is always created (see {@link Dictionary#ensureFamixStub(Class, Object, String)}).
+	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
 	 * @param fmxClass -- the FAMIX class of the instance to create
 	 * @param name -- the name of the new instance
 	 * @return the FAMIX Entity or null in case of a FAMIX error
 	 */
-	protected <T extends NamedEntity> T createFamixStub(Class<T> fmxClass, String name) {
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
 
 		try {
@@ -163,7 +163,7 @@
 	 * TODO Make public and remove ensureFamixClass(name), ensureFamixAttribute(name), ... ????
 	 */
 	@SuppressWarnings("unchecked")
-	protected <T extends NamedEntity> T ensureFamixStub(Class<T> fmxClass, B bnd, String name) {
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
 		
 		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
@@ -185,7 +185,7 @@
 			return fmx;
 		}
 
-		fmx = createFamixStub(fmxClass, name);
+		fmx = createFamixEntity(fmxClass, name);
 		// put new entity in mappers
 		if (bnd != null) {
 			mapBind.put(bnd, fmx);
@@ -211,7 +211,7 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
-		return (fr.inria.verveine.core.gen.famix.Class) ensureFamixStub(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+		return (fr.inria.verveine.core.gen.famix.Class) ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, null, name);
 	}
 
 	/**
@@ -220,7 +220,7 @@
 	 * @return the FAMIX Method or null in case of a FAMIX error
 	 */
 	public Method ensureFamixMethod(String name) {
-		return (Method) ensureFamixStub(Method.class, null, name);
+		return (Method) ensureFamixEntity(Method.class, null, name);
 	}
 
 	/**
@@ -229,7 +229,7 @@
 	 * @return the FAMIX Attribute or null in case of a FAMIX error
 	 */
 	public Attribute ensureFamixAttribute(String name) {
-		return (Attribute) ensureFamixStub(Attribute.class, null, name);
+		return (Attribute) ensureFamixEntity(Attribute.class, null, name);
 	}
 
 	/**
@@ -238,7 +238,7 @@
 	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
 	 */
 	public LocalVariable ensureFamixLocalVariable(String name) {
-		return (LocalVariable) ensureFamixStub(LocalVariable.class, null, name);
+		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
 	}
 
 	///// ensure Famix Relationships /////
@@ -371,7 +371,7 @@
 		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
 		
 		if (fmx == null) {
-			fmx = (ImplicitVariable) createFamixStub(ImplicitVariable.class, name);
+			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
 			if (fmx!=null) {
 				fmx.setContainer(clazz);
 				fmx.setIsStub(Boolean.FALSE);
@@ -419,7 +419,7 @@
 				fmx = l.iterator().next();
 			}
 			else {
-				fmx = createFamixStub(fmxClass, name);
+				fmx = createFamixEntity(fmxClass, name);
 			}
 			
 			if (bnd != null) {
Index: branches/postMoose4_3Refactoring/verveine.core/.project
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/.project	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/.project	(revision 93)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>verveine.core</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 93)
@@ -0,0 +1,751 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import org.eclipse.jdt.core.dom.ITypeBinding;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.Enum;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.core.gen.famix.Type;
+
+/**
+ * A dictionnary of Famix entities to help create them and find them back
+ * @author anquetil
+ *
+ *Entities are mapped to keys. Typically the key will be a binding provided by the parser used
+ * @param <B> The class of the keys, typically a JDT binding or a CDT binding, ...
+ */
+public class Dictionary<B> {
+
+	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
+	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
+	public static final String SELF_NAME = "self";
+	public static final String SUPER_NAME = "super";
+
+	/**
+	 * The FAMIX repository where all FAMIX entities are created and stored
+	 */
+	protected Repository famixRepo;
+
+	/**
+	 * A dictionary to map a key (provided by the user) to FAMIX Entity
+	 */
+	protected Map<B,NamedEntity> mapToKey;
+
+	/**
+	 * Another dictionary to map a name to FAMIX Entities with this name
+	 */
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	/**
+	 * Yet another dictionary for implicit variables ('self' and 'super')
+	 * Because they are implicit, they may not have a binding provided by the parser,
+	 * or may have the same binding than their associated class so they can't be kept easily in {@link Dictionary#mapToKey}
+	 */
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	/**
+	 * Used to keep the two possible ImplicitVariable for a given Class binding
+	 * @author anquetil
+	 */
+	private class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+	
+	/** Constructor taking a FAMIX repository
+	 * @param famixRepo
+	 */
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapToKey = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
+	}
+
+	protected void recoverExistingRepository() {
+		for (Object obj : famixRepo.getElements()) {
+			if (obj instanceof NamedEntity) {
+				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
+			}
+		}
+		
+		for (Access acc : famixRepo.all(Access.class)) {
+			try {
+				if (acc.getIsWrite()) { }
+			}
+			catch (NullPointerException e) {
+				acc.setIsWrite(Boolean.FALSE);
+			}
+		}
+
+		for (Method meth : famixRepo.all(Method.class)) {
+			try { if (meth.getIsStub()) { } }
+			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
+		}
+
+		for (Attribute att : famixRepo.all(Attribute.class)) {
+			try { if (att.getIsStub()) { } }
+			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
+		}
+
+	}
+	
+	protected void mapEntityToName(String name, NamedEntity ent) {
+		Collection<NamedEntity> l_ent = mapName.get(name);
+		if (l_ent == null) {
+			l_ent = new LinkedList<NamedEntity>();
+		}
+		l_ent.add(ent);
+		mapName.put(name, l_ent);
+	}
+	
+	/**
+	 * Returns all the Famix Entity with the given name and class 
+	 * @param fmxClass -- the subtype of Famix Entity we are looking for
+	 * @param name -- the name of the entity
+	 * @return the Collection of Famix Entities with the given name and class (possibly empty)
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns the Famix Entity associated to the given binding.
+	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
+	 * In such a case, this method will always retrieve the Class associated to the binding.
+	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public NamedEntity getEntityByKey(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapToKey.get(bnd);
+		}
+	}
+
+	/**
+	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
+	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param name -- the name of the new instance must not be null (and this is not tested)
+	 * @return the FAMIX Entity or null in case of a FAMIX error
+	 */
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+		T fmx = null;
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			mapEntityToName(name, fmx);
+			
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a FAMIX Entity of the type <b>fmxClass</b> and maps it to its binding <b>bnd</b> (if not null).
+	 * The Entity is created if it did not exist.
+	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use {@link Dictionary#ensureFamixImplicitVariable} instead.
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param bnd -- the binding to map to the new instance
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
+	 */
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByKey(bnd);
+			if (fmx != null) {
+				return fmx;
+			}
+		}
+		// else
+		// Unfortunately different entities with the same name and same type may exist
+		// e.g. 2 parameters of 2 different methods but having the same name
+		// so we cannot recover just from the name
+
+		fmx = createFamixEntity(fmxClass, name);
+		if (bnd != null) {
+			mapToKey.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Adds an already created Entity to the FAMIX repository
+	 * Used mainly for non-NamedEntity, for example relationships
+	 * @param e -- the FAMIX entity to add to the repository
+	 */
+	public void famixRepoAdd(Entity e) {
+		this.famixRepo.add(e);
+	}
+
+	///// ensure Famix Entities /////
+
+	/**
+	 * Returns a FAMIX Type with the given <b>name</b>, creating it if it does not exist yet.
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public Type ensureFamixType(B key, String name, ContainerEntity owner) {
+		Type fmx = ensureFamixEntity(Type.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet.
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Method (MUST NOT be null, but this is not checked)
+	 * @param owner -- type defining the method (should not be null, but it will work if it is) 
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(B key, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public, not Interface
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public ParameterizableClass ensureFamixParameterizableClass(B key, String name, ContainerEntity owner) {
+		ParameterizableClass fmx = ensureFamixEntity(ParameterizableClass.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public ParameterizedType ensureFamixParameterizedType(B key, String name, ParameterizableClass generic, ContainerEntity owner) {
+		ParameterizedType fmx = ensureFamixEntity(ParameterizedType.class, key, name);
+		fmx.setContainer(owner);
+		fmx.setParameterizableClass(generic);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX ParameterType (created by a FAMIX ParameterizableClass) with the given <b>name</b>, creating it if it does not exist yet
+	 * In the second case, sets some default properties: not Abstract, not Final, not Private, not Protected, not Public
+	 * @param name -- the name of the FAMIX ParameterType
+	 * @return the FAMIX ParameterType or null in case of a FAMIX error
+	 */
+	public ParameterType ensureFamixParameterType(B key, String name, ContainerEntity owner) {
+		ParameterType fmx = ensureFamixEntity(ParameterType.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public Enum ensureFamixEnum(B key, String name,	ContainerEntity owner) {
+		Enum fmx = ensureFamixEntity(Enum.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public EnumValue ensureFamixEnumValue(B key, String name, Enum owner) {
+		EnumValue fmx = ensureFamixEntity(EnumValue.class, key, name);
+		fmx.setParentEnum(owner);
+		return fmx;
+	}
+
+	public AnnotationType ensureFamixAnnotationType(B key, String name,	ContainerEntity owner) {
+		AnnotationType fmx = ensureFamixEntity(AnnotationType.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(B key, String name, AnnotationType owner) {
+		AnnotationTypeAttribute fmx = ensureFamixEntity(AnnotationTypeAttribute.class, key, name);
+		fmx.setParentAnnotationType(owner);
+		return fmx;
+	}
+
+	public AnnotationInstanceAttribute createFamixAnnotationInstanceAttribute(AnnotationTypeAttribute att, String value) {
+		AnnotationInstanceAttribute fmx = new AnnotationInstanceAttribute();
+		fmx.setAnnotationTypeAttribute(att);
+		fmx.setValue(value);
+		return fmx;
+	}
+
+	public AnnotationInstance addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
+		AnnotationInstance inst = new AnnotationInstance();
+		inst.setAnnotatedEntity(annType);
+		inst.setAnnotatedEntity(fmx);
+		inst.addAttributes(annAtts);
+		return inst;
+	}
+
+	/**
+	 * Returns a FAMIX PrimitiveType with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that PrimitiveType must be uniq for a given name
+	 * @param name -- the name of the FAMIX PrimitiveType
+	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
+	 */
+	public PrimitiveType ensureFamixPrimitiveType(B key, String name) {
+		return  ensureFamixUniqEntity(PrimitiveType.class, key, name);
+	}
+	
+	/**
+	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Method (MUST NOT be null, but this is not checked)
+	 * @param sig -- method's signature, including type of parameters and return type (should not be null, but it will work if it is)
+	 * @param ret -- Famix Type returned by the method (ideally should only be null in case of a constructor, but will accept it in any case)
+	 * @param owner -- type defining the method (should not be null, but it will work if it is)
+	 * @return the FAMIX Method or null in case of a FAMIX error
+	 */
+	public Method ensureFamixMethod(B key, String name, String sig, Type ret, Type owner) {
+		Method fmx = (Method) ensureFamixEntity(Method.class, key, name);
+		fmx.setSignature(sig);
+		fmx.setDeclaredType(ret);
+		fmx.setParentType(owner);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the FAMIX Attribute (MUST NOT be null, but this is not checked)
+	 * @param type -- Famix Type of the Attribute (should not be null, but it will work if it is)
+	 * @param owner -- type defining the Attribute (should not be null, but it will work if it is)
+	 * @return the FAMIX Attribute or null in case of a FAMIX error
+	 */
+	public Attribute ensureFamixAttribute(B key, String name, Type type, Type owner) {
+		Attribute fmx = ensureFamixEntity(Attribute.class, key, name);
+		fmx.setParentType(owner);
+		fmx.setDeclaredType(type);
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX LocalVariable
+	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
+	 */
+	public LocalVariable ensureFamixLocalVariable(B key, String name, Type type, BehaviouralEntity owner) {
+		LocalVariable fmx = ensureFamixEntity(LocalVariable.class, key, name);
+		fmx.setParentBehaviouralEntity(owner);
+		fmx.setDeclaredType(type);
+		return fmx;
+	}
+
+	/**
+	 * Creates and returns a FAMIX Comment
+	 * @param cmt -- the content (String) of the comment 
+	 * @return the FAMIX Comment
+	 */
+	public Comment createFamixComment(String cmt) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+
+	/**
+	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
+	 * @param cmt -- the content (String) of the comment 
+	 * @param owner -- the entity concerned by this comment
+	 * @return the FAMIX Comment
+	 */
+	public Comment createFamixComment(String cmt, SourcedEntity owner) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		fmx.setContainer(owner);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+	
+	/**
+	 * Creates and returns a FAMIX Parameter and associates it with a BehaviouralEntity
+	 * @param name -- the name of the parameter
+	 * @param owner -- the entity concerned by this parameter
+	 * @param type -- the type of the parameter
+	 * @return the FAMIX parameter
+	 */
+	public Parameter createFamixParameter(B key, String name, Type type, BehaviouralEntity owner) {
+		Parameter fmx = ensureFamixEntity(Parameter.class, key, name);
+		fmx.setParentBehaviouralEntity(owner);
+		fmx.setDeclaredType(type);
+		
+		return fmx;
+	}
+	
+	///// ensure Famix Relationships /////
+
+	/**
+	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
+	 * @param sup -- the super class
+	 * @param sub -- the sub class
+	 * @return the Inheritance relationship
+	 */
+	public Inheritance ensureFamixInheritance(Type sup, Type sub) {
+		return ensureFamixInheritance(sup, sub, null);
+	}
+	
+	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
+		for (Inheritance i : sup.getSubInheritances()) {
+			if (i.getSubclass() == sub) {
+				return i;
+			}
+		}
+		Inheritance inh = new Inheritance();
+		inh.setSuperclass(sup);
+		inh.setSubclass(sub);
+		chainPrevNext(prev,inh);
+		famixRepoAdd(inh);
+		return inh;
+	}
+
+	/**
+	 * Returns a Famix Reference between two Famix Entities creating it if needed
+	 * @param src -- source of the reference
+	 * @param tgt -- target of the reference
+	 * @return the Reference
+	 */
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
+		return ensureFamixReference(src, tgt, null);
+	}
+	
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+		Reference ref = new Reference();
+		ref.setTarget(tgt);
+		ref.setSource(src);
+		chainPrevNext(prev,ref);
+		famixRepoAdd(ref);
+		
+		return ref;
+	}
+
+	/**
+	 * Returns a Famix Invocation between two Famix Entities creating it if needed
+	 * @param sender of the invocation
+	 * @param invoked -- method invoked
+	 * @param receiver of the invocation
+	 * @return the Invocation
+	 */
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
+		return ensureFamixInvocation(sender, invoked, receiver, null);
+	}
+
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+		Invocation invok = new Invocation();
+		invok.setReceiver(receiver);
+		invok.setSender(sender);
+		invok.setSignature(invoked.getSignature());
+		invok.addCandidates(invoked);
+		chainPrevNext(prev,invok);
+		famixRepoAdd(invok);
+		
+		return invok;
+	}
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
+		/* We keep multiple accesses from one method to a field */
+		Access acc = new Access();
+		acc.setAccessor(accessor);
+		acc.setVariable(var);
+		acc.setIsWrite(new Boolean(isWrite));
+		chainPrevNext(prev, acc);
+		famixRepoAdd(acc);
+		
+		return acc;
+	}
+
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
+		return ensureFamixAccess(accessor, var, isWrite, null);
+	}
+	
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
+		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
+	}
+
+	private void chainPrevNext(Association prev, Association next) {
+		if (prev != null) {
+			next.setPrevious(prev);  // not yet implemented in importer
+		}
+	}
+	
+	/**
+	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception declared to be thrown
+	 * @return the DeclaredException
+	 */
+	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		DeclaredException decl = new DeclaredException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix CaughtException between a method and an Exception that is caught
+	 * @param meth -- the method catching the exception
+	 * @param excep -- the exception caught
+	 * @return the CaughtException
+	 */
+	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		CaughtException decl = new CaughtException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	/**
+	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
+	 * Note: DeclaredException indicates that the method declares it can throw the exception,
+	 * here we state that the exception is actually thrown
+	 * @param meth -- the method throwing the exception
+	 * @param excep -- the exception thrown
+	 * @return the ThrownException
+	 */
+	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		ThrownException decl = new ThrownException();
+		decl.setExceptionClass(excep);
+		decl.setDefiningMethod(meth);
+		famixRepoAdd(decl);
+		return decl;
+	}
+
+	///// Special Case: ImplicitVariables /////
+
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given binding and name (self or super).
+	 * See also {@link Dictionary#getEntityByKey(Object)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
+		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd), iv_name);
+	}
+	
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given Famix Class.
+	 * @param clazz -- the FamixClass
+	 * @param name -- name of the ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the Famix ImplicitVariable associated to the Class or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByClass(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVars iv = mapImpVar.get(clazz);
+		ImplicitVariable ret = null;
+		
+		if (iv == null) {
+			iv = new ImplicitVars();
+		}
+		
+		if (name.equals(SELF_NAME)) {
+			ret = iv.self_iv;
+		}
+		else if (name.equals(SUPER_NAME)) {
+			ret = iv.super_iv;
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
+	 * If this ImplicitVariable does not exist yet, it is created
+	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
+	 */
+	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
+		
+		if (fmx == null) {
+			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
+			if (fmx!=null) {
+				fmx.setContainer(clazz);
+				fmx.setIsStub(Boolean.FALSE);
+
+				ImplicitVars iv = mapImpVar.get(clazz);				
+				if (iv == null) {
+					iv = new ImplicitVars();
+				}
+
+				if (name.equals(SELF_NAME)) {
+					iv.self_iv = fmx;
+				}
+				else if (name.equals(SUPER_NAME)) {
+					iv.super_iv = fmx;
+				}
+				
+				mapImpVar.put(clazz, iv);
+			}
+		}
+
+		return fmx;
+	}
+
+	///// Special Case: "Uniq" Entities /////
+
+	/**
+	 * Creates or recovers a Famix Named Entity uniq for the given name.
+	 * For some specific entities we don't allow two of them with the same name.
+	 * This is the case e.g. for the default package, or the Java class "Object" and its package "java.lang".
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param key -- a potential binding for the entity
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the uniq Famix Entity for this binding and/or name
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B key, String name) {
+		T fmx = null;
+		if (key != null) {
+			fmx = (T) getEntityByKey(key);
+		}
+		
+		if (fmx == null) {
+			Collection<T> l = getEntityByName( fmxClass, name);
+			if (l.size() > 0) {
+				fmx = l.iterator().next();
+			}
+			else {
+				fmx = createFamixEntity(fmxClass, name);
+			}
+			
+			if (key != null) {
+				// may happen for example if the entity was first created without binding
+				// and we find a binding for it later
+				mapToKey.put(key, fmx);
+			}
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Namespace with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that Namespaces must be uniq for a given name
+	 * @param name -- the name of the FAMIX Namespace
+	 * @return the FAMIX Namespace or null in case of a FAMIX error
+	 */
+	public Namespace ensureFamixNamespace(B key, String name) {
+		return  ensureFamixUniqEntity(Namespace.class, key, name);
+	}
+
+	/**
+	 * Creates or recovers a default Famix Namespace.
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix Namespace
+	 */
+	public Namespace ensureFamixNamespaceDefault() {
+		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, DEFAULT_PCKG_NAME);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
+		if (fmx != null) {
+			fmx.setContainer( ensureFamixNamespaceDefault());
+		}
+
+		return fmx;
+	}
+
+
+
+
+
+
+
+
+	public Type searchTypeInContext(String name, ContainerEntity ctxt) {
+		if (ctxt == null) {
+			return null;
+		}
+		
+		for (Type candidate : ctxt.getTypes()) {
+			if (candidate.getName().equals(name) ) {
+				return candidate;
+			}
+		}
+		
+		return searchTypeInContext(name, ctxt.getBelongsTo());
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 93)
@@ -0,0 +1,24 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class FILEModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
+
+    }
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 93)
@@ -0,0 +1,44 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class HismoModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
+
+    }
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 93)
@@ -0,0 +1,25 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class DudeModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.Multiplication.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.CodeLine.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
+
+    }
+
+}
+
Index: branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 93)
@@ -0,0 +1,23 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class MooseModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Group.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Model.class);
+
+    }
+
+}
+
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 52)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 53)
@@ -1,7 +1,9 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedList;
+import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.CompilationUnit;
@@ -11,13 +13,16 @@
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
 import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.Modifier;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
@@ -132,6 +137,24 @@
 		}
 	}
 	
+	public List<Type> ensureFamixTypes(List types) {
+		List<Type> fmxTypes = new ArrayList<Type>();
+		Type fmxType = null;
+		for (Object type : types) {
+			fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			fmxTypes.add(fmxType);
+		}
+		return fmxTypes;
+	}
+	
+	public Type ensureFamixType(ITypeBinding bnd, String type) {
+		Type fmx = ensureFamixType(bnd);
+		if (fmx == null) {
+			return ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type);
+		}
+		return fmx;
+	}
+	
 	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
 
 		if (bnd == null) {
@@ -412,7 +435,55 @@
 
 		return fmx;
 	}
-
+	
+	@SuppressWarnings("unchecked")
+	public String stubMethodSignature(MethodDeclaration node) {
+		String sig = node.getName().getIdentifier() + "(";
+		boolean first = true;
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+			if (! first) {
+				sig += "," + param.getType().toString();
+			}
+			else {
+				sig += param.getType().toString();
+				first = false;
+			}
+		}
+		sig += ")";
+		return sig;
+	}
+	
+	public Method ensureFamixMethod(String identifier, NamedEntity owner, int numberOfParameters) {
+		Method fmx = null;
+		if (owner != null) {
+			for (Method candidate : getEntityByName(Method.class, identifier) ) {
+				if ((candidate.getParentType() == owner) && (candidate.getParameters().size() == numberOfParameters)) {
+					fmx = candidate;
+					break;
+				}
+			}
+		} else {
+			for (Method candidate : getEntityByName(Method.class, identifier) ) {
+				if (candidate.getParameters().size() == numberOfParameters) {
+					fmx = candidate;
+					break;
+				}
+			}
+		}
+		return fmx;
+	}
+	
+	public Method ensureFamixMethod(MethodDeclaration node, fr.inria.verveine.core.gen.famix.Class owner) {
+		Method fmx = null;
+		for (Method candidate : getEntityByName(Method.class, node.getName().getIdentifier()) ) {
+			if ((candidate.getParentType() == owner) && (candidate.getSignature().equals(stubMethodSignature(node))) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		return fmx;
+	}
+		
 	/**
 	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
@@ -495,7 +566,7 @@
 	 * @param bnd -- the JDT Binding 
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Parameter ensureFamixParameter(IVariableBinding bnd) {
+	public Parameter ensureFamixParameter(IVariableBinding bnd, Method owner) {
 		boolean wasBound = false;
 		
 		if (bnd == null) {
@@ -517,13 +588,21 @@
 		
 		if ( (fmx!=null) && (! wasBound) ) {
 			// declaring method
-			fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
+			if (bnd.getDeclaringMethod() != null) {
+				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
+			} else {
+				fmx.setParentBehaviouralEntity(owner);
+			}
 			// type of the attribute
 			fmx.setDeclaredType(this.ensureFamixType(bnd.getType()));
 		}
 		
 		return fmx;
 	}
+	
+	public Parameter ensureFamixParameter(IVariableBinding bnd) {
+		return ensureFamixParameter(bnd, null);
+	}
 
 	/**
 	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 14)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 15)
@@ -15,7 +15,6 @@
 	
 	private Namespace fmxPckg;
 	private Stack<ClassStack> fmxClass;
-	private String lastComment = null;
 	
 	// for debugging
 	private boolean tracing = false;;
@@ -126,18 +125,6 @@
 		this.tracing = tracing;
 	}
 
-	public void setLastComment(String lastComment) {
-		this.lastComment = lastComment;
-	}
-
-	public void clearLastComment() {
-		this.lastComment = null;
-	}
-
-	public String getLastComment() {
-		return lastComment;
-	}
-
 	private ClassStack getTopClass() {
 		if (fmxClass.isEmpty()) {
 			return null;
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 14)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 15)
@@ -244,6 +244,25 @@
 		return (LocalVariable) ensureFamixEntity(LocalVariable.class, null, name);
 	}
 
+	/**
+	 * Creates and returns a FAMIX Comment
+	 * @param cmt -- the content (String) of the comment 
+	 * @return the FAMIX Comment
+	 */
+	public Comment createFamixComment(String cmt) {
+		Comment fmx = new Comment();
+		fmx.setContent(cmt);
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+
+	/**
+	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
+	 * @param cmt -- the content (String) of the comment 
+	 * @param owner -- the entity concerned by this comment
+	 * @return the FAMIX Comment
+	 */
 	public Comment createFamixComment(String cmt, SourcedEntity owner) {
 		Comment fmx = new Comment();
 		fmx.setContent(cmt);
Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 77)
+++ verveine.core/.classpath	(revision 78)
@@ -2,7 +2,8 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar"/>
+	<classpathentry kind="lib" path="lib/akuhn-util-r28011.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.core/mse/famix30_complete.mse
===================================================================
--- verveine.core/mse/famix30_complete.mse	(revision 77)
+++ verveine.core/mse/famix30_complete.mse	(revision 78)
@@ -1,831 +1,987 @@
-(+ ( 	(FM3.Package (id: 1)-		(name 'FAMIX')+		(name 'FILE') 		(classes 			(FM3.Class (id: 2)-				(name 'LocalVariable')+				(name 'FileGroup') 				(package (ref: 1))-				(superclass (ref: 3))-				(attributes-					(FM3.Property (id: 4)-						(name 'parentBehaviouralEntity')-						(class (ref: 2))-						(opposite (ref: 5))-						(type (ref: 6)))))+				(superclass (ref: 3)))+			(FM3.Class (id: 4)+				(name 'Folder')+				(package (ref: 1))+				(superclass (ref: 5)))+			(FM3.Class (id: 6)+				(name 'File')+				(package (ref: 1))+				(superclass (ref: 5))) 			(FM3.Class (id: 7)-				(name 'GlobalVariableGroup')+				(name 'FolderGroup') 				(package (ref: 1))-				(superclass (ref: 8)))-			(FM3.Class (id: 9)-				(name 'SourceAnchor')+				(superclass (ref: 3)))+			(FM3.Class (id: 5)+				(name 'AbstractFile') 				(package (ref: 1))-				(superclass (ref: 10))+				(superclass (ref: 8)) 				(attributes-					(FM3.Property (id: 11)-						(name 'element')-						(class (ref: 9))-						(opposite (ref: 12))-						(type (ref: 13)))))-			(FM3.Class (id: 14)-				(name 'PrimitiveType')-				(package (ref: 1))-				(superclass (ref: 15)))-			(FM3.Class (id: 16)+					(FM3.Property (id: 9)+						(name 'name')+						(class (ref: 5))+						(type (ref: String)))))))+	(FM3.Package (id: 10)+		(name 'FAMIX')+		(classes+			(FM3.Class (id: 11)+				(name 'ClassGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 12) 				(name 'Parameter')-				(package (ref: 1))-				(superclass (ref: 3))+				(package (ref: 10))+				(superclass (ref: 13)) 				(attributes-					(FM3.Property (id: 17)+					(FM3.Property (id: 14) 						(name 'parentBehaviouralEntity')-						(class (ref: 16))-						(opposite (ref: 18))-						(type (ref: 6)))))-			(FM3.Class (id: 10)-				(name 'Entity')-				(package (ref: 1))-				(superclass (ref: Object))+						(class (ref: 12))+						(opposite (ref: 15))+						(type (ref: 16)))))+			(FM3.Class (id: 16)+				(name 'BehaviouralEntity')+				(package (ref: 10))+				(superclass (ref: 17)) 				(attributes-					(FM3.Property (id: 19)-						(name 'annotationInstances')-						(class (ref: 10))+					(FM3.Property (id: 18)+						(name 'declaredType')+						(class (ref: 16))+						(type (ref: 19)))+					(FM3.Property (id: 20)+						(name 'outgoingInvocations')+						(class (ref: 16)) 						(derived true) 						(multivalued true)-						(opposite (ref: 20))-						(type (ref: 21)))))-			(FM3.Class (id: 22)-				(name 'ImplicitVariable')-				(package (ref: 1))-				(superclass (ref: 3))-				(attributes+						(opposite (ref: 21))+						(type (ref: 22))) 					(FM3.Property (id: 23)-						(name 'container')-						(class (ref: 22))-						(type (ref: 15)))))-			(FM3.Class (id: 24)-				(name 'MethodGroup')-				(package (ref: 1))-				(superclass (ref: 8)))-			(FM3.Class (id: 25)-				(name 'Inheritance')-				(package (ref: 1))-				(superclass (ref: 26))-				(attributes+						(name 'signature')+						(class (ref: 16))+						(type (ref: String)))+					(FM3.Property (id: 24)+						(name 'localVariables')+						(class (ref: 16))+						(derived true)+						(multivalued true)+						(opposite (ref: 25))+						(type (ref: 26))) 					(FM3.Property (id: 27)-						(name 'superclass')-						(class (ref: 25))+						(name 'accesses')+						(class (ref: 16))+						(derived true)+						(multivalued true) 						(opposite (ref: 28))-						(type (ref: 15)))-					(FM3.Property (id: 29)-						(name 'subclass')-						(class (ref: 25))-						(opposite (ref: 30))-						(type (ref: 15)))))-			(FM3.Class (id: 3)-				(name 'StructuralEntity')-				(package (ref: 1))-				(superclass (ref: 31))+						(type (ref: 29)))+					(FM3.Property (id: 30)+						(name 'incomingInvocations')+						(class (ref: 16))+						(derived true)+						(multivalued true)+						(opposite (ref: 31))+						(type (ref: 22)))+					(FM3.Property (id: 15)+						(name 'parameters')+						(class (ref: 16))+						(derived true)+						(multivalued true)+						(opposite (ref: 14))+						(type (ref: 12)))))+			(FM3.Class (id: 32)+				(name 'ParameterizableClass')+				(package (ref: 10))+				(superclass (ref: 33)) 				(attributes-					(FM3.Property (id: 32)-						(name 'incomingAccesses')-						(class (ref: 3))+					(FM3.Property (id: 34)+						(name 'parameters')+						(class (ref: 32)) 						(derived true) 						(multivalued true)-						(opposite (ref: 33))-						(type (ref: 34)))-					(FM3.Property (id: 35)-						(name 'declaredType')-						(class (ref: 3))-						(type (ref: 15)))))+						(type (ref: 35))))) 			(FM3.Class (id: 36)-				(name 'Attribute')-				(package (ref: 1))-				(superclass (ref: 3))+				(name 'PrimitiveType')+				(package (ref: 10))+				(superclass (ref: 19)))+			(FM3.Class (id: 8)+				(name 'Entity')+				(package (ref: 10))+				(superclass (ref: Object)) 				(attributes 					(FM3.Property (id: 37)-						(name 'parentType')-						(class (ref: 36))+						(name 'annotationInstances')+						(class (ref: 8))+						(derived true)+						(multivalued true) 						(opposite (ref: 38))-						(type (ref: 15)))-					(FM3.Property (id: 39)-						(name 'hasClassScope')-						(class (ref: 36))-						(type (ref: Boolean)))))+						(type (ref: 39))))) 			(FM3.Class (id: 40)-				(name 'Invocation')-				(package (ref: 1))-				(superclass (ref: 26))+				(name 'Comment')+				(package (ref: 10))+				(superclass (ref: 41)) 				(attributes-					(FM3.Property (id: 41)-						(name 'signature')-						(class (ref: 40))-						(type (ref: String))) 					(FM3.Property (id: 42)-						(name 'receiverSourceCode')+						(name 'content') 						(class (ref: 40)) 						(type (ref: String))) 					(FM3.Property (id: 43)-						(name 'candidates')+						(name 'container') 						(class (ref: 40))-						(multivalued true) 						(opposite (ref: 44))-						(type (ref: 6)))-					(FM3.Property (id: 45)-						(name 'sender')-						(class (ref: 40))-						(opposite (ref: 46))-						(type (ref: 6)))+						(type (ref: 41)))))+			(FM3.Class (id: 35)+				(name 'ParameterType')+				(package (ref: 10))+				(superclass (ref: 19)))+			(FM3.Class (id: 45)+				(name 'NamespaceGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 46)+				(name 'ParameterizedType')+				(package (ref: 10))+				(superclass (ref: 19))+				(attributes 					(FM3.Property (id: 47)-						(name 'receiver')-						(class (ref: 40))-						(opposite (ref: 48))-						(type (ref: 49)))))-			(FM3.Class (id: 50)-				(name 'Reference')-				(package (ref: 1))-				(superclass (ref: 26))+						(name 'arguments')+						(class (ref: 46))+						(multivalued true)+						(type (ref: 19)))+					(FM3.Property (id: 48)+						(name 'parameterizableClass')+						(class (ref: 46))+						(type (ref: 32)))))+			(FM3.Class (id: 49)+				(name 'AnnotationType')+				(package (ref: 10))+				(superclass (ref: 50)) 				(attributes 					(FM3.Property (id: 51)-						(name 'target')-						(class (ref: 50))+						(name 'container')+						(class (ref: 49)) 						(opposite (ref: 52))-						(type (ref: 53)))-					(FM3.Property (id: 54)-						(name 'source')-						(class (ref: 50))-						(opposite (ref: 55))-						(type (ref: 53)))))-			(FM3.Class (id: 56)-				(name 'DeclaredException')-				(package (ref: 1))-				(superclass (ref: 57))-				(attributes-					(FM3.Property (id: 58)-						(name 'definingMethod')-						(class (ref: 56))-						(opposite (ref: 59))-						(type (ref: 60)))))-			(FM3.Class (id: 61)-				(name 'ScopingEntity')-				(package (ref: 1))-				(superclass (ref: 53))-				(attributes-					(FM3.Property (id: 62)-						(name 'functions')-						(class (ref: 61))+						(type (ref: 17)))+					(FM3.Property (id: 53)+						(name 'instances')+						(class (ref: 49)) 						(derived true) 						(multivalued true)-						(opposite (ref: 63))-						(type (ref: 64)))-					(FM3.Property (id: 65)-						(name 'childScopes')-						(class (ref: 61))+						(opposite (ref: 54))+						(type (ref: 39)))+					(FM3.Property (id: 55)+						(name 'attributes')+						(class (ref: 49)) 						(derived true) 						(multivalued true)-						(opposite (ref: 66))-						(type (ref: 61)))-					(FM3.Property (id: 66)-						(name 'parentScope')-						(class (ref: 61))+						(opposite (ref: 56))+						(type (ref: 57)))))+			(FM3.Class (id: 58)+				(name 'Attribute')+				(package (ref: 10))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 59)+						(name 'hasClassScope')+						(class (ref: 58))+						(type (ref: Boolean)))+					(FM3.Property (id: 60)+						(name 'parentType')+						(class (ref: 58))+						(opposite (ref: 61))+						(type (ref: 19)))))+			(FM3.Class (id: 62)+				(name 'DeclaredException')+				(package (ref: 10))+				(superclass (ref: 63))+				(attributes+					(FM3.Property (id: 64)+						(name 'definingMethod')+						(class (ref: 62)) 						(opposite (ref: 65))-						(type (ref: 61)))-					(FM3.Property (id: 67)-						(name 'globalVariables')-						(class (ref: 61))-						(derived true)-						(multivalued true)-						(opposite (ref: 68))-						(type (ref: 69)))))-			(FM3.Class (id: 53)-				(name 'ContainerEntity')-				(package (ref: 1))-				(superclass (ref: 49))+						(type (ref: 66)))))+			(FM3.Class (id: 67)+				(name 'UnknownVariable')+				(package (ref: 10))+				(superclass (ref: 13)))+			(FM3.Class (id: 68)+				(name 'Inheritance')+				(package (ref: 10))+				(superclass (ref: 69)) 				(attributes-					(FM3.Property (id: 52)-						(name 'incomingReferences')-						(class (ref: 53))+					(FM3.Property (id: 70)+						(name 'superclass')+						(class (ref: 68))+						(opposite (ref: 71))+						(type (ref: 19)))+					(FM3.Property (id: 72)+						(name 'subclass')+						(class (ref: 68))+						(opposite (ref: 73))+						(type (ref: 19)))))+			(FM3.Class (id: 69)+				(name 'Association')+				(package (ref: 10))+				(superclass (ref: 41))+				(attributes+					(FM3.Property (id: 74)+						(name 'from')+						(class (ref: 69)) 						(derived true)-						(multivalued true)-						(opposite (ref: 51)) 						(type (ref: 50)))-					(FM3.Property (id: 70)-						(name 'definedAnnotationTypes')-						(class (ref: 53))+					(FM3.Property (id: 75)+						(name 'next')+						(class (ref: 69)) 						(derived true)-						(multivalued true)-						(opposite (ref: 71))-						(type (ref: 72)))-					(FM3.Property (id: 73)-						(name 'types')-						(class (ref: 53))+						(opposite (ref: 76))+						(type (ref: 69)))+					(FM3.Property (id: 77)+						(name 'to')+						(class (ref: 69)) 						(derived true)-						(multivalued true)-						(opposite (ref: 74))-						(type (ref: 15)))-					(FM3.Property (id: 55)-						(name 'outgoingReferences')-						(class (ref: 53))+						(type (ref: 50)))+					(FM3.Property (id: 76)+						(name 'previous')+						(class (ref: 69))+						(opposite (ref: 75))+						(type (ref: 69)))))+			(FM3.Class (id: 13)+				(name 'StructuralEntity')+				(package (ref: 10))+				(superclass (ref: 78))+				(attributes+					(FM3.Property (id: 79)+						(name 'declaredType')+						(class (ref: 13))+						(type (ref: 19)))+					(FM3.Property (id: 80)+						(name 'incomingAccesses')+						(class (ref: 13)) 						(derived true) 						(multivalued true)-						(opposite (ref: 54))-						(type (ref: 50)))))-			(FM3.Class (id: 75)-				(name 'Package')-				(package (ref: 1))-				(superclass (ref: 61))+						(opposite (ref: 81))+						(type (ref: 29)))))+			(FM3.Class (id: 82)+				(name 'SmalltalkSourceLanguage')+				(package (ref: 10))+				(superclass (ref: 83)))+			(FM3.Class (id: 39)+				(name 'AnnotationInstance')+				(package (ref: 10))+				(superclass (ref: 8)) 				(attributes-					(FM3.Property (id: 76)-						(name 'childNamedEntities')-						(class (ref: 75))+					(FM3.Property (id: 84)+						(name 'attributes')+						(class (ref: 39)) 						(derived true) 						(multivalued true)-						(opposite (ref: 77))+						(type (ref: 85)))+					(FM3.Property (id: 38)+						(name 'annotatedEntity')+						(class (ref: 39))+						(opposite (ref: 37))+						(type (ref: 8)))+					(FM3.Property (id: 54)+						(name 'annotationType')+						(class (ref: 39))+						(opposite (ref: 53)) 						(type (ref: 49)))))-			(FM3.Class (id: 78)+			(FM3.Class (id: 86)+				(name 'GlobalVariable')+				(package (ref: 10))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 87)+						(name 'parentScope')+						(class (ref: 86))+						(opposite (ref: 88))+						(type (ref: 89)))+					(FM3.Property (id: 90)+						(name 'parentModule')+						(class (ref: 86))+						(type (ref: 91)))))+			(FM3.Class (id: 63)+				(name 'Exception')+				(package (ref: 10))+				(superclass (ref: 8))+				(attributes+					(FM3.Property (id: 92)+						(name 'exceptionClass')+						(class (ref: 63))+						(type (ref: 33)))))+			(FM3.Class (id: 93)+				(name 'EnumValue')+				(package (ref: 10))+				(superclass (ref: 50))+				(attributes+					(FM3.Property (id: 94)+						(name 'parentEnum')+						(class (ref: 93))+						(type (ref: 95)))))+			(FM3.Class (id: 96) 				(name 'FileAnchor')-				(package (ref: 1))-				(superclass (ref: 9))+				(package (ref: 10))+				(superclass (ref: 97)) 				(attributes-					(FM3.Property (id: 79)-						(name 'endLine')-						(class (ref: 78))-						(type (ref: Number)))-					(FM3.Property (id: 80)+					(FM3.Property (id: 98) 						(name 'fileName')-						(class (ref: 78))+						(class (ref: 96)) 						(type (ref: String)))-					(FM3.Property (id: 81)+					(FM3.Property (id: 99) 						(name 'startLine')-						(class (ref: 78))+						(class (ref: 96))+						(type (ref: Number)))+					(FM3.Property (id: 100)+						(name 'endLine')+						(class (ref: 96)) 						(type (ref: Number)))))-			(FM3.Class (id: 6)-				(name 'BehaviouralEntity')-				(package (ref: 1))-				(superclass (ref: 53))+			(FM3.Class (id: 101)+				(name 'SourceTextAnchor')+				(package (ref: 10))+				(superclass (ref: 97)))+			(FM3.Class (id: 97)+				(name 'SourceAnchor')+				(package (ref: 10))+				(superclass (ref: 8))+				(attributes+					(FM3.Property (id: 102)+						(name 'element')+						(class (ref: 97))+						(opposite (ref: 103))+						(type (ref: 41)))))+			(FM3.Class (id: 57)+				(name 'AnnotationTypeAttribute')+				(package (ref: 10))+				(superclass (ref: 50)) 				(attributes-					(FM3.Property (id: 82)-						(name 'accesses')-						(class (ref: 6))-						(derived true)-						(multivalued true)-						(opposite (ref: 83))-						(type (ref: 34)))-					(FM3.Property (id: 84)-						(name 'declaredType')-						(class (ref: 6))-						(type (ref: 15)))-					(FM3.Property (id: 5)-						(name 'localVariables')-						(class (ref: 6))-						(derived true)-						(multivalued true)-						(opposite (ref: 4))-						(type (ref: 2)))-					(FM3.Property (id: 44)-						(name 'incomingInvocations')-						(class (ref: 6))-						(derived true)-						(multivalued true)-						(opposite (ref: 43))-						(type (ref: 40)))-					(FM3.Property (id: 18)-						(name 'parameters')-						(class (ref: 6))+					(FM3.Property (id: 104)+						(name 'declaredType')+						(class (ref: 57))+						(type (ref: 19)))+					(FM3.Property (id: 56)+						(name 'parentAnnotationType')+						(class (ref: 57))+						(opposite (ref: 55))+						(type (ref: 49)))+					(FM3.Property (id: 105)+						(name 'annotationAttributeInstances')+						(class (ref: 57)) 						(derived true) 						(multivalued true)-						(opposite (ref: 17))+						(type (ref: 85)))))+			(FM3.Class (id: 22)+				(name 'Invocation')+				(package (ref: 10))+				(superclass (ref: 69))+				(attributes+					(FM3.Property (id: 21)+						(name 'sender')+						(class (ref: 22))+						(opposite (ref: 20)) 						(type (ref: 16)))-					(FM3.Property (id: 85)+					(FM3.Property (id: 106) 						(name 'signature')-						(class (ref: 6))+						(class (ref: 22)) 						(type (ref: String)))-					(FM3.Property (id: 46)-						(name 'outgoingInvocations')-						(class (ref: 6))-						(derived true)+					(FM3.Property (id: 107)+						(name 'receiver')+						(class (ref: 22))+						(opposite (ref: 108))+						(type (ref: 50)))+					(FM3.Property (id: 31)+						(name 'candidates')+						(class (ref: 22)) 						(multivalued true)-						(opposite (ref: 45))-						(type (ref: 40)))))-			(FM3.Class (id: 57)-				(name 'Exception')-				(package (ref: 1))-				(superclass (ref: 10))+						(opposite (ref: 30))+						(type (ref: 16)))+					(FM3.Property (id: 109)+						(name 'receiverSourceCode')+						(class (ref: 22))+						(type (ref: String)))))+			(FM3.Class (id: 110)+				(name 'MethodGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 111)+				(name 'Function')+				(package (ref: 10))+				(superclass (ref: 16)) 				(attributes-					(FM3.Property (id: 86)-						(name 'exceptionClass')-						(class (ref: 57))-						(type (ref: 87)))))-			(FM3.Class (id: 15)-				(name 'Type')-				(package (ref: 1))-				(superclass (ref: 53))+					(FM3.Property (id: 112)+						(name 'parentModule')+						(class (ref: 111))+						(type (ref: 91)))+					(FM3.Property (id: 113)+						(name 'parentScope')+						(class (ref: 111))+						(opposite (ref: 114))+						(type (ref: 89)))))+			(FM3.Class (id: 115)+				(name 'JavaSourceLanguage')+				(package (ref: 10))+				(superclass (ref: 83)))+			(FM3.Class (id: 116)+				(name 'CustomSourceLanguage')+				(package (ref: 10))+				(superclass (ref: 83)) 				(attributes-					(FM3.Property (id: 28)-						(name 'subInheritances')-						(class (ref: 15))+					(FM3.Property (id: 117)+						(name 'name')+						(class (ref: 116))+						(type (ref: String)))))+			(FM3.Class (id: 78)+				(name 'LeafEntity')+				(package (ref: 10))+				(superclass (ref: 50)))+			(FM3.Class (id: 91)+				(name 'Module')+				(package (ref: 10))+				(superclass (ref: 89)))+			(FM3.Class (id: 118)+				(name 'Namespace')+				(package (ref: 10))+				(superclass (ref: 89)))+			(FM3.Class (id: 119)+				(name 'PackageGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 50)+				(name 'NamedEntity')+				(package (ref: 10))+				(superclass (ref: 41))+				(attributes+					(FM3.Property (id: 120)+						(name 'isFinal')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 108)+						(name 'receivingInvocations')+						(class (ref: 50)) 						(derived true) 						(multivalued true)-						(opposite (ref: 27))-						(type (ref: 25)))-					(FM3.Property (id: 30)-						(name 'superInheritances')-						(class (ref: 15))-						(derived true)+						(opposite (ref: 107))+						(type (ref: 22)))+					(FM3.Property (id: 121)+						(name 'name')+						(class (ref: 50))+						(type (ref: String)))+					(FM3.Property (id: 122)+						(name 'isPublic')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 123)+						(name 'isProtected')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 124)+						(name 'parentPackage')+						(class (ref: 50))+						(opposite (ref: 125))+						(type (ref: 126)))+					(FM3.Property (id: 127)+						(name 'isStub')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 128)+						(name 'isPrivate')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 129)+						(name 'modifiers')+						(class (ref: 50)) 						(multivalued true)-						(opposite (ref: 29))-						(type (ref: 25)))-					(FM3.Property (id: 38)-						(name 'attributes')-						(class (ref: 15))+						(type (ref: String)))+					(FM3.Property (id: 130)+						(name 'isPackage')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 131)+						(name 'isAbstract')+						(class (ref: 50))+						(type (ref: Boolean)))+					(FM3.Property (id: 132)+						(name 'belongsTo')+						(class (ref: 50)) 						(derived true)-						(multivalued true)-						(opposite (ref: 37))-						(type (ref: 36)))-					(FM3.Property (id: 88)-						(name 'methods')-						(class (ref: 15))+						(type (ref: 17)))))+			(FM3.Class (id: 126)+				(name 'Package')+				(package (ref: 10))+				(superclass (ref: 89))+				(attributes+					(FM3.Property (id: 125)+						(name 'childNamedEntities')+						(class (ref: 126)) 						(derived true) 						(multivalued true)-						(opposite (ref: 89))-						(type (ref: 60)))-					(FM3.Property (id: 74)+						(opposite (ref: 124))+						(type (ref: 50)))))+			(FM3.Class (id: 133)+				(name 'ImplicitVariable')+				(package (ref: 10))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 134) 						(name 'container')-						(class (ref: 15))-						(opposite (ref: 73))-						(type (ref: 53)))))-			(FM3.Class (id: 90)-				(name 'ClassGroup')-				(package (ref: 1))-				(superclass (ref: 8)))-			(FM3.Class (id: 91)-				(name 'Namespace')-				(package (ref: 1))-				(superclass (ref: 61)))-			(FM3.Class (id: 60)+						(class (ref: 133))+						(type (ref: 19)))))+			(FM3.Class (id: 66) 				(name 'Method')-				(package (ref: 1))-				(superclass (ref: 6))+				(package (ref: 10))+				(superclass (ref: 16)) 				(attributes-					(FM3.Property (id: 92)-						(name 'caughtExceptions')-						(class (ref: 60))+					(FM3.Property (id: 135)+						(name 'thrownExceptions')+						(class (ref: 66)) 						(derived true) 						(multivalued true)-						(opposite (ref: 93))-						(type (ref: 94)))-					(FM3.Property (id: 89)-						(name 'parentType')-						(class (ref: 60))-						(opposite (ref: 88))-						(type (ref: 15)))-					(FM3.Property (id: 95)-						(name 'hasClassScope')-						(class (ref: 60))-						(type (ref: Boolean)))-					(FM3.Property (id: 96)+						(opposite (ref: 136))+						(type (ref: 137)))+					(FM3.Property (id: 138) 						(name 'kind')-						(class (ref: 60))+						(class (ref: 66)) 						(type (ref: String)))-					(FM3.Property (id: 59)+					(FM3.Property (id: 139)+						(name 'hasClassScope')+						(class (ref: 66))+						(type (ref: Boolean)))+					(FM3.Property (id: 65) 						(name 'declaredExceptions')-						(class (ref: 60))+						(class (ref: 66)) 						(derived true) 						(multivalued true)-						(opposite (ref: 58))-						(type (ref: 56)))-					(FM3.Property (id: 97)-						(name 'thrownExceptions')-						(class (ref: 60))+						(opposite (ref: 64))+						(type (ref: 62)))+					(FM3.Property (id: 140)+						(name 'caughtExceptions')+						(class (ref: 66)) 						(derived true) 						(multivalued true)-						(opposite (ref: 98))-						(type (ref: 99)))))-			(FM3.Class (id: 100)-				(name 'Comment')-				(package (ref: 1))-				(superclass (ref: 13))-				(attributes-					(FM3.Property (id: 101)-						(name 'container')-						(class (ref: 100))-						(opposite (ref: 102))-						(type (ref: 13)))-					(FM3.Property (id: 103)-						(name 'content')-						(class (ref: 100))-						(type (ref: String)))))-			(FM3.Class (id: 49)-				(name 'NamedEntity')-				(package (ref: 1))-				(superclass (ref: 13))+						(opposite (ref: 141))+						(type (ref: 142)))+					(FM3.Property (id: 143)+						(name 'parentType')+						(class (ref: 66))+						(opposite (ref: 144))+						(type (ref: 19)))))+			(FM3.Class (id: 83)+				(name 'SourceLanguage')+				(package (ref: 10))+				(superclass (ref: 8)) 				(attributes-					(FM3.Property (id: 104)-						(name 'modifiers')-						(class (ref: 49))-						(multivalued true)-						(type (ref: String)))-					(FM3.Property (id: 105)-						(name 'isAbstract')-						(class (ref: 49))-						(type (ref: Boolean)))-					(FM3.Property (id: 106)-						(name 'isPublic')-						(class (ref: 49))-						(type (ref: Boolean)))-					(FM3.Property (id: 107)-						(name 'belongsTo')-						(class (ref: 49))+					(FM3.Property (id: 145)+						(name 'sourcedEntities')+						(class (ref: 83)) 						(derived true)-						(type (ref: 53)))-					(FM3.Property (id: 108)-						(name 'isPrivate')-						(class (ref: 49))-						(type (ref: Boolean)))-					(FM3.Property (id: 109)-						(name 'isPackage')-						(class (ref: 49))-						(type (ref: Boolean)))-					(FM3.Property (id: 110)+						(multivalued true)+						(opposite (ref: 146))+						(type (ref: 41)))+					(FM3.Property (id: 147) 						(name 'name')-						(class (ref: 49))-						(type (ref: String)))-					(FM3.Property (id: 77)-						(name 'parentPackage')-						(class (ref: 49))-						(opposite (ref: 76))-						(type (ref: 75)))-					(FM3.Property (id: 48)-						(name 'receivingInvocations')-						(class (ref: 49))+						(class (ref: 83)) 						(derived true)-						(multivalued true)-						(opposite (ref: 47))-						(type (ref: 40)))-					(FM3.Property (id: 111)-						(name 'isProtected')-						(class (ref: 49))-						(type (ref: Boolean)))-					(FM3.Property (id: 112)-						(name 'isStub')-						(class (ref: 49))+						(type (ref: String)))))+			(FM3.Class (id: 29)+				(name 'Access')+				(package (ref: 10))+				(superclass (ref: 69))+				(attributes+					(FM3.Property (id: 28)+						(name 'accessor')+						(class (ref: 29))+						(opposite (ref: 27))+						(type (ref: 16)))+					(FM3.Property (id: 148)+						(name 'isWrite')+						(class (ref: 29)) 						(type (ref: Boolean)))-					(FM3.Property (id: 113)-						(name 'isFinal')-						(class (ref: 49))+					(FM3.Property (id: 81)+						(name 'variable')+						(class (ref: 29))+						(opposite (ref: 80))+						(type (ref: 13)))+					(FM3.Property (id: 149)+						(name 'isRead')+						(class (ref: 29))+						(derived true) 						(type (ref: Boolean)))))-			(FM3.Class (id: 21)-				(name 'AnnotationInstance')-				(package (ref: 1))-				(superclass (ref: 10))+			(FM3.Class (id: 150)+				(name 'AnnotationTypeGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 89)+				(name 'ScopingEntity')+				(package (ref: 10))+				(superclass (ref: 17)) 				(attributes 					(FM3.Property (id: 114)-						(name 'annotationType')-						(class (ref: 21))-						(opposite (ref: 115))-						(type (ref: 72)))-					(FM3.Property (id: 20)-						(name 'annotatedEntity')-						(class (ref: 21))-						(opposite (ref: 19))-						(type (ref: 10)))))-			(FM3.Class (id: 116)-				(name 'PackageGroup')-				(package (ref: 1))-				(superclass (ref: 8)))-			(FM3.Class (id: 117)-				(name 'NamespaceGroup')-				(package (ref: 1))-				(superclass (ref: 8)))-			(FM3.Class (id: 64)-				(name 'Function')-				(package (ref: 1))-				(superclass (ref: 6))-				(attributes-					(FM3.Property (id: 63)+						(name 'functions')+						(class (ref: 89))+						(derived true)+						(multivalued true)+						(opposite (ref: 113))+						(type (ref: 111)))+					(FM3.Property (id: 151) 						(name 'parentScope')-						(class (ref: 64))-						(opposite (ref: 62))-						(type (ref: 61)))))-			(FM3.Class (id: 13)+						(class (ref: 89))+						(opposite (ref: 152))+						(type (ref: 89)))+					(FM3.Property (id: 88)+						(name 'globalVariables')+						(class (ref: 89))+						(derived true)+						(multivalued true)+						(opposite (ref: 87))+						(type (ref: 86)))+					(FM3.Property (id: 152)+						(name 'childScopes')+						(class (ref: 89))+						(derived true)+						(multivalued true)+						(opposite (ref: 151))+						(type (ref: 89)))))+			(FM3.Class (id: 142)+				(name 'CaughtException')+				(package (ref: 10))+				(superclass (ref: 63))+				(attributes+					(FM3.Property (id: 141)+						(name 'definingMethod')+						(class (ref: 142))+						(opposite (ref: 140))+						(type (ref: 66)))))+			(FM3.Class (id: 41) 				(name 'SourcedEntity')-				(package (ref: 1))-				(superclass (ref: 10))+				(package (ref: 10))+				(superclass (ref: 8)) 				(attributes-					(FM3.Property (id: 12)-						(name 'sourceAnchor')-						(class (ref: 13))-						(opposite (ref: 11))-						(type (ref: 9)))-					(FM3.Property (id: 102)+					(FM3.Property (id: 44) 						(name 'comments')-						(class (ref: 13))+						(class (ref: 41)) 						(derived true) 						(multivalued true)-						(opposite (ref: 101))-						(type (ref: 100)))))-			(FM3.Class (id: 118)-				(name 'UnknownVariable')-				(package (ref: 1))-				(superclass (ref: 3)))-			(FM3.Class (id: 69)-				(name 'GlobalVariable')-				(package (ref: 1))-				(superclass (ref: 3))+						(opposite (ref: 43))+						(type (ref: 40)))+					(FM3.Property (id: 103)+						(name 'sourceAnchor')+						(class (ref: 41))+						(opposite (ref: 102))+						(type (ref: 97)))+					(FM3.Property (id: 146)+						(name 'declaredSourceLanguage')+						(class (ref: 41))+						(opposite (ref: 145))+						(type (ref: 83)))))+			(FM3.Class (id: 137)+				(name 'ThrownException')+				(package (ref: 10))+				(superclass (ref: 63)) 				(attributes-					(FM3.Property (id: 68)-						(name 'parentScope')-						(class (ref: 69))-						(opposite (ref: 67))-						(type (ref: 61)))))-			(FM3.Class (id: 87)-				(name 'Class')-				(package (ref: 1))-				(superclass (ref: 15))+					(FM3.Property (id: 136)+						(name 'definingMethod')+						(class (ref: 137))+						(opposite (ref: 135))+						(type (ref: 66)))))+			(FM3.Class (id: 17)+				(name 'ContainerEntity')+				(package (ref: 10))+				(superclass (ref: 50)) 				(attributes-					(FM3.Property (id: 119)-						(name 'isAbstract')-						(class (ref: 87))+					(FM3.Property (id: 153)+						(name 'types')+						(class (ref: 17)) 						(derived true)-						(type (ref: Boolean)))-					(FM3.Property (id: 120)-						(name 'isInterface')-						(class (ref: 87))-						(type (ref: Boolean)))))-			(FM3.Class (id: 72)-				(name 'AnnotationType')-				(package (ref: 1))-				(superclass (ref: 49))+						(multivalued true)+						(opposite (ref: 154))+						(type (ref: 19)))+					(FM3.Property (id: 155)+						(name 'incomingReferences')+						(class (ref: 17))+						(derived true)+						(multivalued true)+						(opposite (ref: 156))+						(type (ref: 157)))+					(FM3.Property (id: 158)+						(name 'outgoingReferences')+						(class (ref: 17))+						(derived true)+						(multivalued true)+						(opposite (ref: 159))+						(type (ref: 157)))+					(FM3.Property (id: 52)+						(name 'definedAnnotationTypes')+						(class (ref: 17))+						(derived true)+						(multivalued true)+						(opposite (ref: 51))+						(type (ref: 49)))))+			(FM3.Class (id: 95)+				(name 'Enum')+				(package (ref: 10))+				(superclass (ref: 19)))+			(FM3.Class (id: 160)+				(name 'GlobalVariableGroup')+				(package (ref: 10))+				(superclass (ref: 3)))+			(FM3.Class (id: 85)+				(name 'AnnotationInstanceAttribute')+				(package (ref: 10))+				(superclass (ref: 8)))+			(FM3.Class (id: 19)+				(name 'Type')+				(package (ref: 10))+				(superclass (ref: 17)) 				(attributes-					(FM3.Property (id: 71)+					(FM3.Property (id: 61)+						(name 'attributes')+						(class (ref: 19))+						(derived true)+						(multivalued true)+						(opposite (ref: 60))+						(type (ref: 58)))+					(FM3.Property (id: 144)+						(name 'methods')+						(class (ref: 19))+						(derived true)+						(multivalued true)+						(opposite (ref: 143))+						(type (ref: 66)))+					(FM3.Property (id: 154) 						(name 'container')-						(class (ref: 72))-						(opposite (ref: 70))-						(type (ref: 53)))-					(FM3.Property (id: 115)-						(name 'instances')-						(class (ref: 72))+						(class (ref: 19))+						(opposite (ref: 153))+						(type (ref: 17)))+					(FM3.Property (id: 73)+						(name 'superInheritances')+						(class (ref: 19)) 						(derived true) 						(multivalued true)-						(opposite (ref: 114))-						(type (ref: 21)))))-			(FM3.Class (id: 31)-				(name 'LeafEntity')-				(package (ref: 1))-				(superclass (ref: 49)))-			(FM3.Class (id: 94)-				(name 'CaughtException')-				(package (ref: 1))-				(superclass (ref: 57))-				(attributes-					(FM3.Property (id: 93)-						(name 'definingMethod')-						(class (ref: 94))-						(opposite (ref: 92))-						(type (ref: 60)))))-			(FM3.Class (id: 99)-				(name 'ThrownException')-				(package (ref: 1))-				(superclass (ref: 57))-				(attributes-					(FM3.Property (id: 98)-						(name 'definingMethod')-						(class (ref: 99))-						(opposite (ref: 97))-						(type (ref: 60)))))-			(FM3.Class (id: 34)-				(name 'Access')-				(package (ref: 1))-				(superclass (ref: 26))+						(opposite (ref: 72))+						(type (ref: 68)))+					(FM3.Property (id: 71)+						(name 'subInheritances')+						(class (ref: 19))+						(derived true)+						(multivalued true)+						(opposite (ref: 70))+						(type (ref: 68)))))+			(FM3.Class (id: 33)+				(name 'Class')+				(package (ref: 10))+				(superclass (ref: 19)) 				(attributes-					(FM3.Property (id: 121)-						(name 'isRead')-						(class (ref: 34))+					(FM3.Property (id: 161)+						(name 'isAbstract')+						(class (ref: 33)) 						(derived true) 						(type (ref: Boolean)))-					(FM3.Property (id: 122)-						(name 'isWrite')-						(class (ref: 34))-						(type (ref: Boolean)))-					(FM3.Property (id: 83)-						(name 'accessor')-						(class (ref: 34))-						(opposite (ref: 82))-						(type (ref: 6)))-					(FM3.Property (id: 33)-						(name 'variable')-						(class (ref: 34))-						(opposite (ref: 32))-						(type (ref: 3)))))-			(FM3.Class (id: 123)-				(name 'SourceTextAnchor')-				(package (ref: 1))-				(superclass (ref: 9)))+					(FM3.Property (id: 162)+						(name 'isInterface')+						(class (ref: 33))+						(type (ref: Boolean))))) 			(FM3.Class (id: 26)-				(name 'Association')-				(package (ref: 1))+				(name 'LocalVariable')+				(package (ref: 10)) 				(superclass (ref: 13)) 				(attributes-					(FM3.Property (id: 124)-						(name 'previous')-						(class (ref: 26))-						(opposite (ref: 125))-						(type (ref: 26)))-					(FM3.Property (id: 126)-						(name 'to')-						(class (ref: 26))-						(derived true)-						(type (ref: 49)))-					(FM3.Property (id: 127)-						(name 'from')-						(class (ref: 26))-						(derived true)-						(type (ref: 49)))-					(FM3.Property (id: 125)-						(name 'next')+					(FM3.Property (id: 25)+						(name 'parentBehaviouralEntity') 						(class (ref: 26))-						(derived true)-						(opposite (ref: 124))-						(type (ref: 26)))))))-	(FM3.Package (id: 128)-		(name 'FILE')-		(classes-			(FM3.Class (id: 129)-				(name 'FileGroup')-				(package (ref: 128))-				(superclass (ref: 8)))-			(FM3.Class (id: 130)-				(name 'File')-				(package (ref: 128))-				(superclass (ref: 131)))-			(FM3.Class (id: 132)-				(name 'Folder')-				(package (ref: 128))-				(superclass (ref: 131)))-			(FM3.Class (id: 131)-				(name 'AbstractFile')-				(package (ref: 128))-				(superclass (ref: 10))+						(opposite (ref: 24))+						(type (ref: 16)))))+			(FM3.Class (id: 163)+				(name 'UnknownSourceLanguage')+				(package (ref: 10))+				(superclass (ref: 83)))+			(FM3.Class (id: 164)+				(name 'SmalltalkMonticelloSourceLanguage')+				(package (ref: 10))+				(superclass (ref: 83)))+			(FM3.Class (id: 157)+				(name 'Reference')+				(package (ref: 10))+				(superclass (ref: 69)) 				(attributes-					(FM3.Property (id: 133)-						(name 'name')-						(class (ref: 131))-						(type (ref: String)))))-			(FM3.Class (id: 134)-				(name 'FolderGroup')-				(package (ref: 128))-				(superclass (ref: 8)))))-	(FM3.Package (id: 135)+					(FM3.Property (id: 156)+						(name 'target')+						(class (ref: 157))+						(opposite (ref: 155))+						(type (ref: 17)))+					(FM3.Property (id: 159)+						(name 'source')+						(class (ref: 157))+						(opposite (ref: 158))+						(type (ref: 17)))))))+	(FM3.Package (id: 165) 		(name 'Dude') 		(classes-			(FM3.Class (id: 136)-				(name 'CodeFragment')-				(package (ref: 135))-				(superclass (ref: 10)))-			(FM3.Class (id: 137)-				(name 'CodeLine')-				(package (ref: 135))-				(superclass (ref: 10)))-			(FM3.Class (id: 138)-				(name 'Multiplication')-				(package (ref: 135))-				(superclass (ref: 10)))-			(FM3.Class (id: 139)+			(FM3.Class (id: 166) 				(name 'MultiplicationGroup')-				(package (ref: 135))-				(superclass (ref: 8)))-			(FM3.Class (id: 140)+				(package (ref: 165))+				(superclass (ref: 3)))+			(FM3.Class (id: 167) 				(name 'DuplicationGroup')-				(package (ref: 135))+				(package (ref: 165))+				(superclass (ref: 3)))+			(FM3.Class (id: 168)+				(name 'CodeLine')+				(package (ref: 165))+				(superclass (ref: 8)))+			(FM3.Class (id: 169)+				(name 'CodeFragment')+				(package (ref: 165)) 				(superclass (ref: 8)))-			(FM3.Class (id: 141)+			(FM3.Class (id: 170) 				(name 'Duplication')-				(package (ref: 135))-				(superclass (ref: 10)))))-	(FM3.Package (id: 142)+				(package (ref: 165))+				(superclass (ref: 8))+				(attributes+					(FM3.Property (id: 171)+						(name 'multiplicationInvolved')+						(class (ref: 170))+						(opposite (ref: 172))+						(type (ref: 173)))))+			(FM3.Class (id: 173)+				(name 'Multiplication')+				(package (ref: 165))+				(superclass (ref: 8))+				(attributes+					(FM3.Property (id: 172)+						(name 'duplications')+						(class (ref: 173))+						(derived true)+						(multivalued true)+						(opposite (ref: 171))+						(type (ref: 170)))))))+	(FM3.Package (id: 174) 		(name 'Hismo') 		(classes-			(FM3.Class (id: 143)-				(name 'HismoAbstractHistory')-				(package (ref: 142))-				(superclass (ref: 10)))-			(FM3.Class (id: 144)-				(name 'HismoNamespaceVersion')-				(package (ref: 142))-				(superclass (ref: 145)))-			(FM3.Class (id: 146)-				(name 'HismoAttributeHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 147)-				(name 'HismoFileHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 148)-				(name 'HismoCoChangeHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 149)-				(name 'HismoClassHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 150)-				(name 'HismoMethodVersion')-				(package (ref: 142))-				(superclass (ref: 145)))-			(FM3.Class (id: 145)-				(name 'HismoEntityVersion')-				(package (ref: 142))-				(superclass (ref: 151)))-			(FM3.Class (id: 152)-				(name 'HismoNamespaceHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 153)-				(name 'HismoNamespaceHistoryGroup')-				(package (ref: 142))-				(superclass (ref: 154)))-			(FM3.Class (id: 155)-				(name 'HismoInvocationHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 156)-				(name 'HismoClassHierarchy')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 157)-				(name 'HismoCoChangePattern')-				(package (ref: 142))-				(superclass (ref: 8)))-			(FM3.Class (id: 158)-				(name 'HismoFolderHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 159)-				(name 'HismoMethodHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 160)+			(FM3.Class (id: 175) 				(name 'HismoClassVersion')-				(package (ref: 142))-				(superclass (ref: 145)))-			(FM3.Class (id: 161)+				(package (ref: 174))+				(superclass (ref: 176)))+			(FM3.Class (id: 177) 				(name 'HismoMethodHistoryGroup')-				(package (ref: 142))-				(superclass (ref: 154)))-			(FM3.Class (id: 162)+				(package (ref: 174))+				(superclass (ref: 178)))+			(FM3.Class (id: 179) 				(name 'HismoPackageHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 163)-				(name 'HismoClassHistoryGroup')-				(package (ref: 142))-				(superclass (ref: 154)))-			(FM3.Class (id: 164)+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 181)+				(name 'HismoClassHierarchy')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 182) 				(name 'HismoCoChangeVersion')-				(package (ref: 142))-				(superclass (ref: 151)))-			(FM3.Class (id: 151)-				(name 'HismoAbstractVersion')-				(package (ref: 142))-				(superclass (ref: 10)))-			(FM3.Class (id: 165)-				(name 'HismoInheritanceDefinitionHistory')-				(package (ref: 142))-				(superclass (ref: 143)))-			(FM3.Class (id: 154)+				(package (ref: 174))+				(superclass (ref: 183)))+			(FM3.Class (id: 176)+				(name 'HismoEntityVersion')+				(package (ref: 174))+				(superclass (ref: 183)))+			(FM3.Class (id: 184)+				(name 'HismoClassHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 185)+				(name 'HismoNamespaceHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 178) 				(name 'HismoHistoryGroup')-				(package (ref: 142))-				(superclass (ref: 8)))-			(FM3.Class (id: 166)+				(package (ref: 174))+				(superclass (ref: 3)))+			(FM3.Class (id: 186)+				(name 'HismoAccessHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 187)+				(name 'HismoCoChangePattern')+				(package (ref: 174))+				(superclass (ref: 3)))+			(FM3.Class (id: 188)+				(name 'HismoInheritanceDefinitionHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 189) 				(name 'HismoModelHistory')-				(package (ref: 142))-				(superclass (ref: 143)))))-	(FM3.Package (id: 167)+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 190)+				(name 'HismoNamespaceVersion')+				(package (ref: 174))+				(superclass (ref: 176)))+			(FM3.Class (id: 180)+				(name 'HismoAbstractHistory')+				(package (ref: 174))+				(superclass (ref: 8)))+			(FM3.Class (id: 191)+				(name 'HismoInvocationHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 192)+				(name 'HismoNamespaceHistoryGroup')+				(package (ref: 174))+				(superclass (ref: 178)))+			(FM3.Class (id: 193)+				(name 'HismoClassHistoryGroup')+				(package (ref: 174))+				(superclass (ref: 178)))+			(FM3.Class (id: 194)+				(name 'HismoMethodHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 195)+				(name 'HismoAttributeHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 196)+				(name 'HismoCoChangeHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 197)+				(name 'HismoMethodVersion')+				(package (ref: 174))+				(superclass (ref: 176)))+			(FM3.Class (id: 198)+				(name 'HismoFileHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 199)+				(name 'HismoFolderHistory')+				(package (ref: 174))+				(superclass (ref: 180)))+			(FM3.Class (id: 183)+				(name 'HismoAbstractVersion')+				(package (ref: 174))+				(superclass (ref: 8)))))+	(FM3.Package (id: 200) 		(name 'Moose') 		(classes-			(FM3.Class (id: 8)-				(name 'MooseGroup')-				(package (ref: 167))-				(superclass (ref: 168)))-			(FM3.Class (id: 168)-				(name 'MooseAbsractGroup')+			(FM3.Class (id: 201)+				(name 'Entity') 				(abstract true)-				(package (ref: 167))-				(superclass (ref: 169)))-			(FM3.Class (id: 170)-				(name 'HismoAccessHistory')-				(package (ref: 167))-				(superclass (ref: 143)))-			(FM3.Class (id: 171)-				(name 'MooseModel')-				(package (ref: 167))-				(superclass (ref: 168))+				(package (ref: 200))+				(superclass (ref: Object)))+			(FM3.Class (id: 3)+				(name 'Group')+				(package (ref: 200))+				(superclass (ref: 202)))+			(FM3.Class (id: 203)+				(name 'Model')+				(package (ref: 200))+				(superclass (ref: 202)) 				(attributes-					(FM3.Property (id: 172)+					(FM3.Property (id: 204) 						(name 'sourceLanguage')-						(class (ref: 171))+						(class (ref: 203)) 						(type (ref: String)))))-			(FM3.Class (id: 169)-				(name 'MooseEntity')+			(FM3.Class (id: 202)+				(name 'AbsractGroup') 				(abstract true)-				(package (ref: 167))-				(superclass (ref: Object))))))
\ No newline at end of file
+				(package (ref: 200))+				(superclass (ref: 201))))))Index: verveine.core/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/src/fr/inria/verveine/core/GenerateFamix.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 78)
@@ -12,7 +12,7 @@
 	}
 	
 	public static void generateCode() {
-		InputSource input = InputSource.fromFilename("mse/famix30_famix.mse");
+		InputSource input = InputSource.fromFilename("mse/famix30_complete.mse");
         Tower t = new Tower();
         t.getMetamodel().importMSE(input);
 		CodeGeneration gen = new CodeGeneration("fr.inria.verveine.core.gen", "src", "");
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 78)
@@ -13,10 +13,10 @@
     
     public static void importInto(MetaRepository metamodel) {
 		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
 		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.file;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FILE")
 @FameDescription("FolderGroup")
-public class FolderGroup extends MooseGroup {
+public class FolderGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.file;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FILE")
 @FameDescription("FileGroup")
-public class FileGroup extends MooseGroup {
+public class FileGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 78)
@@ -12,30 +12,31 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.hismo;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("Hismo")
 @FameDescription("HismoCoChangePattern")
-public class HismoCoChangePattern extends MooseGroup {
+public class HismoCoChangePattern extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.hismo;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("Hismo")
 @FameDescription("HismoHistoryGroup")
-public class HismoHistoryGroup extends MooseGroup {
+public class HismoHistoryGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAccessHistory.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAccessHistory")
+public class HismoAccessHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 78)
@@ -12,11 +12,11 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
-		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.Multiplication.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.CodeLine.class);
 
     }
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.dude;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("Dude")
 @FameDescription("DuplicationGroup")
-public class DuplicationGroup extends MooseGroup {
+public class DuplicationGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 78)
@@ -1,14 +1,14 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.dude;
 
-import fr.inria.verveine.core.gen.moose.MooseGroup;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("Dude")
 @FameDescription("MultiplicationGroup")
-public class MultiplicationGroup extends MooseGroup {
+public class MultiplicationGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 78)
@@ -1,6 +1,7 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.dude;
 
+import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import fr.inria.verveine.core.gen.famix.Entity;
 import ch.akuhn.fame.FamePackage;
@@ -12,7 +13,24 @@
 
 
 
+    private Multiplication multiplicationInvolved;
+    
+    @FameProperty(name = "multiplicationInvolved", opposite = "duplications")
+    public Multiplication getMultiplicationInvolved() {
+        return multiplicationInvolved;
+    }
 
+    public void setMultiplicationInvolved(Multiplication multiplicationInvolved) {
+        if (this.multiplicationInvolved != null) {
+            if (this.multiplicationInvolved.equals(multiplicationInvolved)) return;
+            this.multiplicationInvolved.getDuplications().remove(this);
+        }
+        this.multiplicationInvolved = multiplicationInvolved;
+        if (multiplicationInvolved == null) return;
+        multiplicationInvolved.getDuplications().add(this);
+    }
+    
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 78)
@@ -1,6 +1,9 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.dude;
 
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import fr.inria.verveine.core.gen.famix.Entity;
 import ch.akuhn.fame.FamePackage;
@@ -12,7 +15,61 @@
 
 
 
+    private Collection<Duplication> duplications; 
+
+    @FameProperty(name = "duplications", opposite = "multiplicationInvolved", derived = true)
+    public Collection<Duplication> getDuplications() {
+        if (duplications == null) {
+            duplications = new MultivalueSet<Duplication>() {
+                @Override
+                protected void clearOpposite(Duplication e) {
+                    e.setMultiplicationInvolved(null);
+                }
+                @Override
+                protected void setOpposite(Duplication e) {
+                    e.setMultiplicationInvolved(Multiplication.this);
+                }
+            };
+        }
+        return duplications;
+    }
+    
+    public void setDuplications(Collection<? extends Duplication> duplications) {
+        this.getDuplications().clear();
+        this.getDuplications().addAll(duplications);
+    }                    
+    
+        
+    public void addDuplications(Duplication one) {
+        this.getDuplications().add(one);
+    }   
+    
+    public void addDuplications(Duplication one, Duplication... many) {
+        this.getDuplications().add(one);
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }   
+    
+    public void addDuplications(Iterable<? extends Duplication> many) {
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }   
+                
+    public void addDuplications(Duplication[] many) {
+        for (Duplication each : many)
+            this.getDuplications().add(each);
+    }
+    
+    public int numberOfDuplications() {
+        return getDuplications().size();
+    }
 
+    public boolean hasDuplications() {
+        return !getDuplications().isEmpty();
+    }
+    
+                
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java	(revision 78)
@@ -1,17 +0,0 @@
-// Automagically generated code, please do not change
-package fr.inria.verveine.core.gen.moose;
-
-import ch.akuhn.fame.FameDescription;
-import ch.akuhn.fame.FamePackage;
-
-
-@FamePackage("Moose")
-@FameDescription("MooseAbsractGroup")
-public class MooseAbsractGroup extends MooseEntity {
-
-
-
-
-
-}
-
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java	(revision 78)
@@ -1,17 +0,0 @@
-// Automagically generated code, please do not change
-package fr.inria.verveine.core.gen.moose;
-
-import ch.akuhn.fame.FameDescription;
-import ch.akuhn.fame.FamePackage;
-
-
-@FamePackage("Moose")
-@FameDescription("MooseEntity")
-public class MooseEntity  {
-
-
-
-
-
-}
-
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java	(revision 78)
@@ -1,17 +0,0 @@
-// Automagically generated code, please do not change
-package fr.inria.verveine.core.gen.moose;
-
-import ch.akuhn.fame.FameDescription;
-import ch.akuhn.fame.FamePackage;
-
-
-@FamePackage("Moose")
-@FameDescription("MooseGroup")
-public class MooseGroup extends MooseAbsractGroup {
-
-
-
-
-
-}
-
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java	(revision 78)
@@ -1,18 +0,0 @@
-// Automagically generated code, please do not change
-package fr.inria.verveine.core.gen.moose;
-
-import fr.inria.verveine.core.gen.hismo.HismoAbstractHistory;
-import ch.akuhn.fame.FameDescription;
-import ch.akuhn.fame.FamePackage;
-
-
-@FamePackage("Moose")
-@FameDescription("HismoAccessHistory")
-public class HismoAccessHistory extends HismoAbstractHistory {
-
-
-
-
-
-}
-
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/Model.java	(revision 78)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Model")
+public class Model extends AbsractGroup {
+
+
+
+    private String sourceLanguage;
+    
+    @FameProperty(name = "sourceLanguage")
+    public String getSourceLanguage() {
+        return sourceLanguage;
+    }
+
+    public void setSourceLanguage(String sourceLanguage) {
+        this.sourceLanguage = sourceLanguage;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 78)
@@ -12,11 +12,10 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.moose.MooseGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.HismoAccessHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.MooseModel.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.MooseAbsractGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.MooseEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Model.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Group.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/AbsractGroup.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("AbsractGroup")
+public class AbsractGroup extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/Entity.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Entity")
+public class Entity  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/Group.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("Group")
+public class Group extends AbsractGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkMonticelloSourceLanguage.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SmalltalkMonticelloSourceLanguage")
+public class SmalltalkMonticelloSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 78)
@@ -0,0 +1,53 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationTypeAttribute")
+public class AnnotationTypeAttribute extends NamedEntity {
+
+
+
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private AnnotationType parentAnnotationType;
+    
+    @FameProperty(name = "parentAnnotationType", opposite = "attributes")
+    public AnnotationType getParentAnnotationType() {
+        return parentAnnotationType;
+    }
+
+    public void setParentAnnotationType(AnnotationType parentAnnotationType) {
+        if (this.parentAnnotationType != null) {
+            if (this.parentAnnotationType.equals(parentAnnotationType)) return;
+            this.parentAnnotationType.getAttributes().remove(this);
+        }
+        this.parentAnnotationType = parentAnnotationType;
+        if (parentAnnotationType == null) return;
+        parentAnnotationType.getAttributes().add(this);
+    }
+    
+    @FameProperty(name = "annotationAttributeInstances", derived = true)
+    public Collection<AnnotationInstanceAttribute> getAnnotationAttributeInstances() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Not yet implemented!");  
+    }
+        
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 78)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("EnumValue")
+public class EnumValue extends NamedEntity {
+
+
+
+    private Enum parentEnum;
+    
+    @FameProperty(name = "parentEnum")
+    public Enum getParentEnum() {
+        return parentEnum;
+    }
+
+    public void setParentEnum(Enum parentEnum) {
+        this.parentEnum = parentEnum;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 78)
@@ -72,8 +72,6 @@
 	public NamedEntity getFrom() {
 		return this.getAccessor();
 	}
-    
-
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 78)
@@ -14,6 +14,23 @@
 
 
 
+    private SourceLanguage declaredSourceLanguage;
+    
+    @FameProperty(name = "declaredSourceLanguage", opposite = "sourcedEntities")
+    public SourceLanguage getDeclaredSourceLanguage() {
+        return declaredSourceLanguage;
+    }
+
+    public void setDeclaredSourceLanguage(SourceLanguage declaredSourceLanguage) {
+        if (this.declaredSourceLanguage != null) {
+            if (this.declaredSourceLanguage.equals(declaredSourceLanguage)) return;
+            this.declaredSourceLanguage.getSourcedEntities().remove(this);
+        }
+        this.declaredSourceLanguage = declaredSourceLanguage;
+        if (declaredSourceLanguage == null) return;
+        declaredSourceLanguage.getSourcedEntities().add(this);
+    }
+    
     private SourceAnchor sourceAnchor;
     
     @FameProperty(name = "sourceAnchor", opposite = "element")
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Enum")
+public class Enum extends Type {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 78)
@@ -3,11 +3,12 @@
 
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FAMIX")
 @FameDescription("NamespaceGroup")
-public class NamespaceGroup  {
+public class NamespaceGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SmalltalkSourceLanguage.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SmalltalkSourceLanguage")
+public class SmalltalkSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 78)
@@ -3,7 +3,6 @@
 
 import ch.akuhn.fame.internal.MultivalueSet;
 import java.util.*;
-
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
@@ -188,17 +187,6 @@
     }
     
                 
-    private String kind;
-    
-    @FameProperty(name = "kind")
-    public String getKind() {
-        return kind;
-    }
-
-    public void setKind(String kind) {
-        this.kind = kind;
-    }
-    
     private Type parentType;
     
     @FameProperty(name = "parentType", opposite = "methods")
@@ -216,6 +204,17 @@
         parentType.getMethods().add(this);
     }
     
+    private String kind;
+    
+    @FameProperty(name = "kind")
+    public String getKind() {
+        return kind;
+    }
+
+    public void setKind(String kind) {
+        this.kind = kind;
+    }
+   
     private Collection<Type> declaredArgumentTypes;
     
     @FameProperty(name = "declaredArgumentTypes")
@@ -226,4 +225,8 @@
     public void setDeclaredArgumentTypes(Collection<Type> declaredArgumentTypes) {
         this.declaredArgumentTypes = declaredArgumentTypes;
     }
-}
\ No newline at end of file
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationInstanceAttribute")
+public class AnnotationInstanceAttribute extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 78)
@@ -3,11 +3,12 @@
 
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FAMIX")
 @FameDescription("GlobalVariableGroup")
-public class GlobalVariableGroup  {
+public class GlobalVariableGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Module.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Module")
+public class Module extends ScopingEntity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 78)
@@ -12,47 +12,62 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Invocation.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.EnumValue.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.CaughtException.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.DeclaredException.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.SourceAnchor.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.LeafEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.PackageGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ScopingEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Attribute.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Access.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Method.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Type.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.PrimitiveType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.JavaSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Access.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Exception.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Parameter.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Reference.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizedType.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.ThrownException.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Invocation.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownSourceLanguage.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.ContainerEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkMonticelloSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Attribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ScopingEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizableClass.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Package.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Reference.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.DeclaredException.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.ImplicitVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Method.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Module.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CustomSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Parameter.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Enum.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PackageGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeGroup.java	(revision 78)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationTypeGroup")
+public class AnnotationTypeGroup extends Group {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizedType.java	(revision 78)
@@ -0,0 +1,72 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterizedType")
+public class ParameterizedType extends Type {
+
+
+
+    private Collection<Type> arguments; 
+
+    @FameProperty(name = "arguments")
+    public Collection<Type> getArguments() {
+        if (arguments == null) arguments = new HashSet<Type>();
+        return arguments;
+    }
+    
+    public void setArguments(Collection<? extends Type> arguments) {
+        this.getArguments().clear();
+        this.getArguments().addAll(arguments);
+    }                    
+
+    public void addArguments(Type one) {
+        this.getArguments().add(one);
+    }   
+    
+    public void addArguments(Type one, Type... many) {
+        this.getArguments().add(one);
+        for (Type each : many)
+            this.getArguments().add(each);
+    }   
+    
+    public void addArguments(Iterable<? extends Type> many) {
+        for (Type each : many)
+            this.getArguments().add(each);
+    }   
+                
+    public void addArguments(Type[] many) {
+        for (Type each : many)
+            this.getArguments().add(each);
+    }
+    
+    public int numberOfArguments() {
+        return getArguments().size();
+    }
+
+    public boolean hasArguments() {
+        return !getArguments().isEmpty();
+    }
+    
+                
+    private ParameterizableClass parameterizableClass;
+    
+    @FameProperty(name = "parameterizableClass")
+    public ParameterizableClass getParameterizableClass() {
+        return parameterizableClass;
+    }
+
+    public void setParameterizableClass(ParameterizableClass parameterizableClass) {
+        this.parameterizableClass = parameterizableClass;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 78)
@@ -324,7 +324,7 @@
 
 	public void setNOS(int nos) {
 		this.nos = nos;
-	}
+    }
     
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/CustomSourceLanguage.java	(revision 78)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CustomSourceLanguage")
+public class CustomSourceLanguage extends SourceLanguage {
+
+
+
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 78)
@@ -1,6 +1,7 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import java.util.*;
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
@@ -46,6 +47,12 @@
         annotationType.getInstances().add(this);
     }
     
+    @FameProperty(name = "attributes", derived = true)
+    public Collection<AnnotationInstanceAttribute> getAttributes() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Not yet implemented!");  
+    }
+        
 
 
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 78)
@@ -0,0 +1,80 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceLanguage")
+public class SourceLanguage extends Entity {
+
+
+
+    @FameProperty(name = "name", derived = true)
+    public String getName() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Not yet implemented!");  
+    }
+    
+    private Collection<SourcedEntity> sourcedEntities; 
+
+    @FameProperty(name = "sourcedEntities", opposite = "declaredSourceLanguage", derived = true)
+    public Collection<SourcedEntity> getSourcedEntities() {
+        if (sourcedEntities == null) {
+            sourcedEntities = new MultivalueSet<SourcedEntity>() {
+                @Override
+                protected void clearOpposite(SourcedEntity e) {
+                    e.setDeclaredSourceLanguage(null);
+                }
+                @Override
+                protected void setOpposite(SourcedEntity e) {
+                    e.setDeclaredSourceLanguage(SourceLanguage.this);
+                }
+            };
+        }
+        return sourcedEntities;
+    }
+    
+    public void setSourcedEntities(Collection<? extends SourcedEntity> sourcedEntities) {
+        this.getSourcedEntities().clear();
+        this.getSourcedEntities().addAll(sourcedEntities);
+    }                    
+    
+        
+    public void addSourcedEntities(SourcedEntity one) {
+        this.getSourcedEntities().add(one);
+    }   
+    
+    public void addSourcedEntities(SourcedEntity one, SourcedEntity... many) {
+        this.getSourcedEntities().add(one);
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }   
+    
+    public void addSourcedEntities(Iterable<? extends SourcedEntity> many) {
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }   
+                
+    public void addSourcedEntities(SourcedEntity[] many) {
+        for (SourcedEntity each : many)
+            this.getSourcedEntities().add(each);
+    }
+    
+    public int numberOfSourcedEntities() {
+        return getSourcedEntities().size();
+    }
+
+    public boolean hasSourcedEntities() {
+        return !getSourcedEntities().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 78)
@@ -1,8 +1,6 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
-import java.util.Collection;
-
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
@@ -13,7 +11,7 @@
 public class Class extends Type {
 
 
-	// Apparently, we should not use getIsAbstract() (from NamedEntity) here ?!?!?
+
     @FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
@@ -31,14 +29,7 @@
         this.isInterface = isInterface;
     }
     
-    private Collection<Type> parameterTypes;
-    
-    @FameProperty(name = "parameterTypes")
-    public Collection<Type> getParameterTypes() {
-    	return parameterTypes;
-    }
-    
-    public void setParameterTypes(Collection<Type> parameterTypes) {
-    	this.parameterTypes = parameterTypes;
-    }
-}
\ No newline at end of file
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 78)
@@ -25,17 +25,6 @@
         this.declaredType = declaredType;
     }
     
-    private Collection<Type> declaredArgumentTypes;
-    
-    @FameProperty(name = "declaredArgumentTypes")
-    public Collection<Type> getDeclaredArgumentTypes() {
-        return declaredArgumentTypes;
-    }
-
-    public void setDeclaredArgumentTypes(Collection<Type> declaredArgumentTypes) {
-        this.declaredArgumentTypes = declaredArgumentTypes;
-    }
-    
     private Collection<Access> incomingAccesses; 
 
     @FameProperty(name = "incomingAccesses", opposite = "variable", derived = true)
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/JavaSourceLanguage.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("JavaSourceLanguage")
+public class JavaSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 78)
@@ -29,7 +29,18 @@
         parentScope.getGlobalVariables().add(this);
     }
     
+    private Module parentModule;
+    
+    @FameProperty(name = "parentModule")
+    public Module getParentModule() {
+        return parentModule;
+    }
 
+    public void setParentModule(Module parentModule) {
+        this.parentModule = parentModule;
+    }
+    
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 78)
@@ -3,11 +3,12 @@
 
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FAMIX")
 @FameDescription("PackageGroup")
-public class PackageGroup  {
+public class PackageGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 78)
@@ -31,6 +31,60 @@
         container.getDefinedAnnotationTypes().add(this);
     }
     
+    private Collection<AnnotationTypeAttribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentAnnotationType", derived = true)
+    public Collection<AnnotationTypeAttribute> getAttributes() {
+        if (attributes == null) {
+            attributes = new MultivalueSet<AnnotationTypeAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationTypeAttribute e) {
+                    e.setParentAnnotationType(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationTypeAttribute e) {
+                    e.setParentAnnotationType(AnnotationType.this);
+                }
+            };
+        }
+        return attributes;
+    }
+    
+    public void setAttributes(Collection<? extends AnnotationTypeAttribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
+        
+    public void addAttributes(AnnotationTypeAttribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(AnnotationTypeAttribute one, AnnotationTypeAttribute... many) {
+        this.getAttributes().add(one);
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends AnnotationTypeAttribute> many) {
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(AnnotationTypeAttribute[] many) {
+        for (AnnotationTypeAttribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
+
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
     private Collection<AnnotationInstance> instances; 
 
     @FameProperty(name = "instances", opposite = "annotationType", derived = true)
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 78)
@@ -3,11 +3,12 @@
 
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FAMIX")
 @FameDescription("ClassGroup")
-public class ClassGroup  {
+public class ClassGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterType.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterType")
+public class ParameterType extends Type {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownSourceLanguage.java	(revision 78)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("UnknownSourceLanguage")
+public class UnknownSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 78)
@@ -29,7 +29,18 @@
         parentScope.getFunctions().add(this);
     }
     
+    private Module parentModule;
+    
+    @FameProperty(name = "parentModule")
+    public Module getParentModule() {
+        return parentModule;
+    }
 
+    public void setParentModule(Module parentModule) {
+        this.parentModule = parentModule;
+    }
+    
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 77)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 78)
@@ -3,11 +3,12 @@
 
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
+import fr.inria.verveine.core.gen.moose.Group;
 
 
 @FamePackage("FAMIX")
 @FameDescription("MethodGroup")
-public class MethodGroup  {
+public class MethodGroup extends Group {
 
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 78)
@@ -0,0 +1,25 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ParameterizableClass")
+public class ParameterizableClass extends Class {
+
+
+
+    @FameProperty(name = "parameters", derived = true)
+    public Collection<ParameterType> getParameters() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Not yet implemented!");  
+    }
+        
+
+
+}
+
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 82)
+++ verveine.extractor.java/.classpath	(revision 83)
@@ -2,7 +2,11 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core">
+		<attributes>
+			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
Index: verveine.extractor.java/test_src/Dictionary/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 82)
+++ verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 83)
@@ -1,143 +0,0 @@
-package fr.inria.verveine.core;
-
-import java.util.Collection;
-import java.util.Hashtable;
-import java.util.LinkedList;
-import java.util.Map;
-
-import ch.akuhn.fame.Repository;
-
-import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Association;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.CaughtException;
-import fr.inria.verveine.core.gen.famix.Comment;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.DeclaredException;
-import fr.inria.verveine.core.gen.famix.Entity;
-import fr.inria.verveine.core.gen.famix.ImplicitVariable;
-import fr.inria.verveine.core.gen.famix.Inheritance;
-import fr.inria.verveine.core.gen.famix.Invocation;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.PrimitiveType;
-import fr.inria.verveine.core.gen.famix.Reference;
-import fr.inria.verveine.core.gen.famix.SourcedEntity;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-import fr.inria.verveine.core.gen.famix.ThrownException;
-
-public class Dictionary<B> {
-
-	protected Map<B,NamedEntity> mapBind;
-
-	protected Map<String,Collection<NamedEntity>> mapName;
-
-	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
-
-	protected class ImplicitVars {
-		public ImplicitVariable self_iv;
-		public ImplicitVariable super_iv;
-	}
-
-	/* method added to test a specific bug with constructor declaration having a null binding */
-	public Dictionary(T arg) {
-		System.out.println(arg + " is not used");
-	}
-	
-	public Dictionary(Repository famixRepo) {
-		this.famixRepo = famixRepo;
-		
-		this.mapBind = new Hashtable<B,NamedEntity>();
-		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
-		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
-		
-		if (! this.famixRepo.isEmpty()) {
-			recoverExistingRepository();
-		}
-	}
-	
-	@SuppressWarnings("unchecked")
-	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
-		Collection<T> ret = new LinkedList<T>();
-		Collection<NamedEntity> l_name = mapName.get(name);
-		
-		if (l_name != null ) {
-			for (NamedEntity obj : l_name) {
-				if (fmxClass.isInstance(obj)) {
-					ret.add((T) obj);
-				}
-			}
-		}
-
-		return ret;
-	}
-
-	public NamedEntity getEntityByBinding(B bnd) {
-		if (bnd == null) {
-			return null;
-		}
-		else {
-			return mapBind.get(bnd);
-		}
-	}
-
-	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
-		T fmx = null;
-
-		try {
-			fmx = fmxClass.newInstance();
-		} catch (Exception e) {
-			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
-			e.printStackTrace();
-		}
-		
-		if (fmx != null) {
-			fmx.setName(name);
-			fmx.setIsStub(Boolean.TRUE);
-
-			mapEntityToName(name, fmx);
-			
-			// put new entity in Famix repository
-			this.famixRepo.add(fmx);
-		}
-
-		return fmx;
-	}
-	
-	@SuppressWarnings("unchecked")
-	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
-		T fmx = null;
-		
-		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
-			return null;
-		}
-		
-		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
-		}
-		else {
-			// Unfortunately different entities with the same name and same type may exist
-			// e.g. 2 parameters of 2 different methods but having the same name
-			// so we must recreate a new entity each time
-
-			//fmxEnt = getEntityByName(fmxClass, name);
-		}
-
-		if (fmx != null) {
-			return fmx;
-		}
-
-		fmx = createFamixEntity(fmxClass, name);
-		// put new entity in mappers
-		if (bnd != null) {
-			mapBind.put(bnd, fmx);
-		}
-		
-		return fmx;
-	}
-	
-}
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 83)
@@ -0,0 +1,143 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+
+public class Dictionary<B> {
+
+	protected Map<B,NamedEntity> mapBind;
+
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	protected class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+
+	/* method added to test a specific bug with constructor declaration having a null binding */
+	public Dictionary(T arg) {
+		System.out.println(arg + " is not used");
+	}
+	
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	public NamedEntity getEntityByBinding(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapBind.get(bnd);
+		}
+	}
+
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+		T fmx = null;
+
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			mapEntityToName(name, fmx);
+			
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		else {
+			// Unfortunately different entities with the same name and same type may exist
+			// e.g. 2 parameters of 2 different methods but having the same name
+			// so we must recreate a new entity each time
+
+			//fmxEnt = getEntityByName(fmxClass, name);
+		}
+
+		if (fmx != null) {
+			return fmx;
+		}
+
+		fmx = createFamixEntity(fmxClass, name);
+		// put new entity in mappers
+		if (bnd != null) {
+			mapBind.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+	
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 82)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 83)
@@ -54,7 +54,7 @@
 	@Before
 	public void setUp() throws Exception {
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/Dictionary"});
+		parser.compile(new String[] {"test_src/ad_hoc/Dictionary.java"});
 		repo = parser.getFamixRepo();
 	}
 
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 82)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 83)
@@ -36,7 +36,6 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -72,10 +71,14 @@
 				"server/PrintServer.java"
 		};
 
-		// separate parsing of each source file
-		for (String f : files) {
+		// separate parsing of each source file --------
+		/*for (String f : files) {
 			parseFile(f);
-		}
+		}*/
+		// or parsing the entire project in one pass ---
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
+		repo = parser.getFamixRepo();
 	}
 
 	/**
@@ -86,7 +89,7 @@
 	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
-				"test_src/LANModel/",
+				"test_src/LANModel//moose/lan/",
 				"test_src/LANModel/moose/lan/"+file
 				};
 		
@@ -105,21 +108,18 @@
 	
 	@Test
 	public void testEntitiesNumber() {
-		for (Type t : TestVerveineUtils.selectElementsOfType(repo, Type.class) ) {
-			System.out.println("TEST TYPES "+t.getName()+"   --> "+t.getClass().getCanonicalName());
-		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
-		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(6+24, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
-		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-		assertEquals(1, TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
-		assertEquals(2, TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
+		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
+		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
+		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
 	}
 
 	@Test
@@ -161,7 +161,7 @@
 	public void testNamedEntities() {
 		JavaDictionary dico = new JavaDictionary(repo);
 		
-		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
+		assertNotSame(dico.ensureFamixClass(null, A_CLASS_NAME, null),dico.ensureFamixClass(null, A_CLASS_NAME, null));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
 		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 83)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTVisitor;
@@ -28,7 +30,9 @@
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleName;
 import org.eclipse.jdt.core.dom.SimpleType;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
@@ -74,7 +78,7 @@
 			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
 		}
 		else {
-			this.context.pushPckg( (Namespace)dico.getEntityByBinding(pckg.resolveBinding()) );
+			this.context.pushPckg( (Namespace)dico.getEntityByKey(pckg.resolveBinding()) );
 		}
 		return super.visit(node);
 
@@ -94,23 +98,29 @@
 		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
 
 		IBinding importBnd = node.resolveBinding();
+		String importName = node.getName().getFullyQualifiedName();
 		if (importBnd instanceof IMethodBinding)  {
 			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
 		}
 		else if (importBnd instanceof IVariableBinding)  {
 			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
 		}
 		else if (importBnd instanceof ITypeBinding)  {
 			importBnd = ((ITypeBinding)importBnd).getPackage();
+			importName = dico.removeLastName(importName);
 		}
-
-		context.setLastReference( dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd), context.getLastReference()) );
+		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
+		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(node.resolveBinding()));
+		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(node.resolveBinding()));
 
 		return super.visit(node);
 	}
@@ -123,7 +133,7 @@
 	public boolean visit(ClassInstanceCreation node) {
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(decl.resolveBinding()));
+			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(decl.resolveBinding()));
 		}
 		return super.visit(node);
 	}
@@ -135,16 +145,31 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		Method meth = dico.ensureFamixMethod(node.resolveBinding());
-		if (meth == null) {
-			meth = dico.ensureFamixMethod(node, context.topClass());
+		IMethodBinding bnd = node.resolveBinding();
+		Type retTyp = node.getReturnType2();
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+		Method meth = null;
+		if (retTyp != null) {
+			meth = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+					context.topClass());
+		}
+		else {
+			meth = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					null,   // probably a constructor
+					context.topClass());
 		}
+
 		this.context.pushMethod(meth);
 		for (Name excepName : (List<Name>)node.thrownExceptions()) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding());
-			if (excepFmx == null) {
-				excepFmx = this.dico.ensureFamixClass(excepName.getFullyQualifiedName());
-			}
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
 			if (excepFmx != null) {
 				dico.ensureFamixDeclaredException(meth, excepFmx);
 			}
@@ -158,16 +183,41 @@
 	}
 
 	public boolean visit(MethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()), node.arguments().size());
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
 		return super.visit(node);
 	}
 
-	@SuppressWarnings("static-access")
+	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME), node.arguments().size());
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
 		return super.visit(node);
 	}
 
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param calledBnd -- a binding for the method
+	 * @param calledName of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
+	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
+		BehaviouralEntity sender = this.context.topMethod();
+		if (sender != null) {
+			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			/* TODO old code, may not be valid anymore ...
+			   if (invoked == null) {
+				if (receiver != null && receiver.getName().equals("self")) {
+					receiver = this.context.topClass();
+				}
+				invoked = this.dico.ensureFamixMethod(calledName, receiver, list);
+				//invoked = this.dico.ensureFamixStubMethod(name);
+			}
+			if (invoked == null) {
+				invoked = this.dico.ensureFamixStubMethod(calledName);
+			}*/
+			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+		}
+	}
+
 	public boolean visit(FieldAccess node) {
 		fieldAccess(node.resolveFieldBinding());
 		
@@ -190,14 +240,12 @@
 		Method meth = this.context.topMethod();
 		Type excepClass = node.getException().getType();
 		if (meth != null) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding());
-			if (excepFmx == null) {
-				if (excepClass instanceof SimpleType) {
-					excepFmx = this.dico.ensureFamixClass(((SimpleType) excepClass).getName().getFullyQualifiedName());
-				}
-				else if (excepClass instanceof QualifiedType) {
-					excepFmx = this.dico.ensureFamixClass(((QualifiedType) excepClass).getName().getIdentifier());
-				}
+			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
+			if (excepClass instanceof SimpleType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+			}
+			else if (excepClass instanceof QualifiedType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
 				dico.ensureFamixCaughtException(meth, excepFmx);
@@ -210,7 +258,7 @@
 	@Override
 	public boolean visit(ThrowStatement node) {
 		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding());
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
 			dico.ensureFamixThrownException(meth, excepFmx);
 		}
@@ -273,12 +321,7 @@
 		else if (expr instanceof FieldAccess) {
 			Attribute ret = null;
 			IVariableBinding bnd = ((FieldAccess) expr).resolveFieldBinding();
-			if (bnd == null) {
-				ret = dico.ensureFamixAttribute(((FieldAccess)expr).getName().getIdentifier());
-			}
-			else {
-				ret = this.dico.ensureFamixAttribute(bnd);
-			}
+			ret = dico.ensureFamixAttribute(bnd, ((FieldAccess) expr).getName().getIdentifier(), null, null);
 
 			return ret;
 		}
@@ -298,24 +341,27 @@
 
 		// name.msg()
 		else if (expr instanceof Name) {
-			NamedEntity ret = null;
 			// can be a class or a variable name
 			IBinding bnd = ((Name) expr).resolveBinding();
-			if (bnd != null) {
-				if (bnd instanceof ITypeBinding) {
-					// msg() is a static method of Name
-					ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, this.context.top()), bnd.getName());
+			if (bnd == null) {
+				return null;
+			}
+			NamedEntity ret = null;
+			if (bnd instanceof ITypeBinding) {
+				// msg() is a static method of Name
+				//TODO why returning a variable here? Should not it be the class itself?
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null), bnd.getName());
+			}
+			else if (bnd instanceof IVariableBinding) {
+				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
+				if ( ((IVariableBinding)bnd).isField() ) {
+					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
 				}
-				else if (bnd instanceof IVariableBinding) {
-					if ( ((IVariableBinding)bnd).isField() ) {
-						ret = dico.ensureFamixAttribute( (IVariableBinding)bnd);
-					}
-					else if ( ((IVariableBinding)bnd).isParameter() ) {
-						ret = dico.ensureFamixParameter( (IVariableBinding)bnd);
-					}
-					else { // suppose it's a local variable
-						ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, context.topMethod());
-					}
+				else if ( ((IVariableBinding)bnd).isParameter() ) {
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, context.topMethod());
+				}
+				else { // suppose it's a local variable
+					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
 				}
 			}
 			
@@ -337,12 +383,7 @@
 		else if (expr instanceof SuperFieldAccess) {
 			Attribute ret = null;
 			IVariableBinding bnd = ((SuperFieldAccess) expr).resolveFieldBinding();
-			if (bnd == null) {
-				ret = dico.ensureFamixAttribute(((SuperFieldAccess)expr).getName().getIdentifier());
-			}
-			else {
-				ret = this.dico.ensureFamixAttribute(bnd);
-			}
+			ret = dico.ensureFamixAttribute(bnd, ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
 
 			return ret;
 		}
@@ -362,7 +403,7 @@
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
 			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding(), this.context.top());
+			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null);
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
@@ -380,7 +421,7 @@
 	private void fieldAccess(IVariableBinding bnd) {
 		BehaviouralEntity accessor = this.context.topMethod();
 		if (accessor != null) {
-			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
+			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
 				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
@@ -390,29 +431,4 @@
 		}
 	}
 
-	/**
-	 * Handles an invocation of a method by creating the corresponding Famix Entity
-	 * @param bnd -- a binding for the method
-	 * @param name of the method invoked
-	 * @param receiver of the call, i.e. the object to which the message is sent
-	 */
-	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver, int numberOfArguments) {
-		BehaviouralEntity sender = this.context.topMethod();
-		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(bnd);
-			if (invoked == null) {
-				if (receiver != null && receiver.getName().equals("self")) {
-					receiver = this.context.topClass();
-				}
-				invoked = this.dico.ensureFamixMethod(name, receiver, numberOfArguments);
-				//invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			if (invoked == null) {
-				invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
-		}
-	}
-
-
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 83)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
@@ -24,7 +26,6 @@
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -36,7 +37,6 @@
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeParameter;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -50,7 +50,6 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -83,15 +82,8 @@
 			fmx = dico.ensureFamixNamespaceDefault();
 		}
 		else {
-			fmx = dico.ensureFamixNamespace(pckg.resolveBinding());
-			if (fmx != null) {
-				fmx.setIsStub(false);
-			}
-			else {
-				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ", fallbacks to creating a stub");
-				// try again without binding
-				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
-			}
+			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
+			fmx.setIsStub(false);
 		}
 		this.context.pushPckg(fmx);
 		return super.visit(node);
@@ -104,43 +96,14 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-//		System.out.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
-
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
-
-		// Dealing with Parameterized classes
-		List<TypeParameter> nodeParameters = node.typeParameters();
-
-//System.out.println("                                        size="+nodeParameters.size());
-		if (nodeParameters.size() > 0) {
-			fmx = dico.ensureFamixParameterizableClass(bnd);
-		}
-		else {
-			fmx = dico.ensureFamixClass(bnd);
-		}
-		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
-		else {
-			System.err.println("         Class="+node.getName().getIdentifier() + ",  fallback to creating a stub");
-			if (nodeParameters.size() > 0) {
-				fmx = dico.ensureFamixParameterizableClass(node.getName().getIdentifier());
-			}
-			else {
-				fmx = dico.ensureFamixClass(node.getName().getIdentifier());
-			}
-			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
-			fmx.setContainer( context.top());
-		}
 
-		// Dealing with Parameterized classes: adding the parameters
-		if (nodeParameters.size() > 0) {
-			for (TypeParameter param : nodeParameters) {
-				dico.ensureFamixParameterType(param.getName().getIdentifier(), (ParameterizableClass)fmx);
-			}
-		}
+		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
 		
 		dico.addSourceAnchor(fmx, node);
 		Javadoc jdoc = node.getJavadoc();
@@ -148,7 +111,6 @@
 			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 			dico.addSourceAnchor(cmt, jdoc);
 		}
-		
 		//Annotation
 		if (bnd != null) {
 			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
@@ -156,7 +118,6 @@
 				dico.createFamixAnnotationInstance(fmx, annType);
 			}
 		}
-		
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -170,16 +131,11 @@
 //		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding());
+			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
-			else {
-				System.err.println("         Class="+"anonymous(??),  fallback to creating a stub");
-				fmx = dico.ensureFamixClass("anonymous(??)");
-				dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
-				fmx.setContainer( context.top());
-			}
+
 			dico.addSourceAnchor(fmx, node);
 			this.context.pushClass(fmx);
 		}
@@ -194,24 +150,34 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
-		Method fmx = dico.ensureFamixMethod(bnd);
-		if (fmx != null) {
-			fmx.setIsStub(false);
+		Type retTyp = node.getReturnType2();
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+		Method fmx = null;
+		if (retTyp != null) {
+			fmx = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+					context.topClass());
 		}
 		else {
-			System.err.println("         Method="+node.getName().getIdentifier());
-			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
-			fmx.setParentType(context.topClass());
-			fmx.setSignature(dico.stubMethodSignature(node));
-			if (! node.isConstructor()) {
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
-			}
+			fmx = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					null,   // probably a constructor
+					context.topClass());
 		}
 		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
-			fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
 		}
+		
 		if (fmx != null) {
+			fmx.setIsStub(false);
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
@@ -220,7 +186,7 @@
 				} else {
 					// Has no binding? It might be a Generic parameter
 					System.err.println("         Parameter="+param.getName().getIdentifier());
-					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), param.getType().toString(), this.context.topClass()));
+					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null));
 				}
 				if (param.getType().isParameterizedType()) {
 					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
@@ -262,26 +228,16 @@
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-//			System.err.println("            Field: "+vd.getName().getIdentifier());
 			IVariableBinding bnd = vd.resolveBinding();
-			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
-			
-			//((ParameterizedType)node.getType()).typeArguments();
+			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
+
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
-			else {
-				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
-				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
-				fmx.setParentType(context.topClass());
-				// should try to find type name from 'node.getType()' ?
-				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-				// Has no binding? It might be a Generic type
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
-			}
 			if (node.getType().isParameterizedType()) {
 				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
 			}
+
 			dico.addSourceAnchor(fmx, node);
 			Javadoc jdoc = node.getJavadoc();
 			if (jdoc != null) {
@@ -302,35 +258,28 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
-	private void visitVariableDeclaration(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+	private void visitVariablesDeclarations(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming here that the user is not interested in them 
 		if (nodeTyp.isPrimitiveType()) {
 			return;
 		}
 
 		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), context.topMethod());
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), dico.ensureFamixType(null, nodeTyp.toString(), null), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
-			}
-			else {
-				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
-				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
-				fmx.setParentBehaviouralEntity(context.topMethod());
-				// should try to find type name from 'node.getType()' ?
-				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-				// Has no binding? It might be a Generic type
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
 			if (nodeTyp.isParameterizedType()) {
@@ -339,7 +288,6 @@
 		}
 	}
 
-
 	// METRICS: CYCLO, NOS
 	
 	public boolean visit(AssertStatement node) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 83)
@@ -6,15 +6,16 @@
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ArrayType;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
 import org.eclipse.jdt.core.dom.IVariableBinding;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.Modifier;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleType;
 import org.eclipse.jdt.core.dom.TypeParameter;
 
 import ch.akuhn.fame.Repository;
@@ -30,11 +31,10 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterType;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.core.gen.famix.UnknownVariable;
 
@@ -61,56 +61,29 @@
 	}
 
 	/**
-	 * Returns a Famix Namespace associated with the IPackageBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public Namespace ensureFamixNamespace(IPackageBinding bnd) {
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Namespace");
-			return null;
-		}
-
-		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, null);
-
-		return fmx;
-	}
-
-	@Override
-	public Namespace ensureFamixNamespace(String name) {
-		Namespace fmx = ensureFamixNamespaceWithParentScope(null, name);
-
-		return fmx;
-	}
-
-	/**
-	 * Creates or recovers a namespace. Also creates or recovers recusively it's parent namespaces.
-	 * At least one of <b>bnd</b> and <b>name</b> must be passed.
-	 * <p>Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
-	 * (for example when creating parent packages of a package we have a binding for).
-	 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
-	 * all is said and done.</p>
-	 * @param bnd - the (optional) binding for the namespace
-	 * @param name - the (optional) full name for the namespace
-	 * @return the namespace created or null
+	 * Returns a Famix Namespace associated with its IPackageBinding and/or name.
+	 * The Entity is created if it does not exist (see also {@link Dictionary#ensureFamixNamespace(Object, String)}).
+	 * Also creates or recovers recusively it's parent namespaces.<br>
+	 * At least one of <b>bnd</b> and <b>name</b> must be non null.
+	 * @param bnd -- the JDT Binding that may be used as a uniq key to recover this namespace
+	 * @param name -- fully qualified name of the namespace (e.g. 'java.lang')
+	 * @return the Famix Namespace found or created. May return null in case of a Famix error
 	 */
-	private Namespace ensureFamixNamespaceWithParentScope(IPackageBinding bnd, String name) {
+	public Namespace ensureFamixNamespace(IPackageBinding bnd, String name) {
 		Namespace fmx = null;
 		Namespace parent = null;
-		
-		if (bnd != null) {
+
+		if ( (name == null) && (bnd != null) ) {
 			name = bnd.getName();
 		}
 		
-		if ( (name!=null) && (name.length() > 0) ) {
-			fmx = ensureFamixUniqEntity(Namespace.class, bnd, name);
-			// compute parent's name and creates parent
-			int last = name.lastIndexOf('.');
-			if (last > 0) {
-				parent = ensureFamixNamespaceWithParentScope(null, name.substring(0, last));
-			}
+		if (name.length() > 0) {
+			/* Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
+			 * (for example when creating parent packages of a package we have a binding for).
+			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
+			 * all is said and done. */
+			fmx = super.ensureFamixNamespace( bnd, name);
+			parent = this.ensureFamixNamespace(null, removeLastName(name));
 			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
 				parent.addChildScopes(fmx);
@@ -120,108 +93,51 @@
 		return fmx;
 	}
 
-	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
-	 * Checks for: primitive type, interface, class, parameterizable class
-	 * @param bnd -- JDT binding for the type
-	 * @return the type recovered or created, or null in case of an error
-	 */
-	public Type ensureFamixType(ITypeBinding bnd, ContainerEntity ctxt) {
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
-			return null;
+	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
+		
+		Type fmxType = null;
+		for (org.eclipse.jdt.core.dom.Type type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd, findTypeName(type), null);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
+			fmxTypes.add(fmxType);
 		}
-		return ensureFamixType(bnd, bnd.getName(), ctxt);
+		return fmxTypes;
 	}
 
-	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
-	 * Checks for: primitive type, interface, class, parameterizable class
-	 * Types are more difficult entities, they can be recovered from their binding or from their name in their context
-	 * @param bnd -- JDT binding for the type
-	 * @param name -- name of the type
-	 * @return the type recovered or created, or null in case of an error
+	/**
+	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
 	 */
-	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity ctxt) {
-		Type fmx = null;
-	
-		if (bnd != null) {
-			bnd = findNonArrayType(bnd);
-			
-			fmx = (Type) getEntityByBinding(bnd);
-			
-			if (fmx != null) {
-				return fmx;
-			}
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
 
-			fmx = findTypeInContext(name, ctxt);
-			if (fmx != null) {
-				mapBind.put(bnd, fmx);
-				return fmx;
-			}
-		}
-		
-		if ( (fmx == null) && (bnd != null) ) {		
-			// not found, will have to create it
-			// from the binding
-			if (bnd.isPrimitive()) {
-				fmx = ensureFamixPrimitiveType(bnd);
-			}
-			else if (bnd.isClass())  {
-				fmx = ensureFamixClass(bnd);
-			}
-			else if (bnd.isGenericType())  {
-				fmx = ensureFamixParameterizableClass(bnd);
-			}
-			else if (bnd.isParameterizedType())  {
-				fmx = super.ensureFamixType(bnd.getName());
-				mapBind.put(bnd, fmx);
-			}
-			else {
-				fmx = super.ensureFamixType(bnd.getName());
-				mapBind.put(bnd, fmx);
-			}
+		if (bnd == null) {
+			return super.ensureFamixType(bnd, name, owner);
 		}
 
-		if (fmx == null) {
-			// not found and not created by binding (probably null), will have to create it
-			// from its name
-			fmx = this.ensureFamixType(name);
-		}
-		return fmx;
-	}
-	
-	/** Searches for a type with the given name in the context (a Famix Method or Famix Type)
-	 * If the context is a method, zsearches in its owner. Otherwise returns null.
-	 * See {@link getEntityByName} to search an entity by its name outside any special context
-	 * @param name of the type to look for
-	 * @param ctxt -- context of the search
-	 * @return the Famix Type found or null
-	 */
-	private Type findTypeInContext(String name, ContainerEntity ctxt) {
-		if (ctxt == null) {
-//System.out.println("lookfor type"+ name+"  in NULL context  :-(");
-			return null;
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
 		}
-//System.out.println("lookfor type"+ name+"  in context:" +ctxt.getName());
-		for (Type typ : ctxt.getTypes()) {
-			if (typ.getName().equals(name)) {
-				return typ;
-			}
+		
+		if (bnd.isPrimitive()) {
+			return ensureFamixPrimitiveType(bnd, name);
 		}
-		if (ctxt instanceof Method) {
-			return findTypeInContext(name, ctxt.getBelongsTo());
+		else {
+			return this.ensureFamixClass(bnd, null, null);
 		}
-		
-		return null;
 	}
-
-	//TODO remove this method
-	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+	
+	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
 		Collection<Type> fmxTypes = new ArrayList<Type>();
 		Type fmxType = null;
-		for (org.eclipse.jdt.core.dom.Type type : types) {
+		
+		for (TypeParameter type : types) {
 			ITypeBinding bnd = type.resolveBinding();
 			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, null);
+				fmxType = ensureFamixType(bnd, null, null);
 			} else {
 				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
 			}
@@ -230,144 +146,149 @@
 		return fmxTypes;
 	}
 	
-	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
-
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Primitive Type");
-			return null;
+	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
+		if (name == null) {
+			if (bnd == null) {
+				return null;
+			}
+			else {
+				name = bnd.getName();
+			}
 		}
-		
-		PrimitiveType fmx = super.ensureFamixPrimitiveType(bnd.getName());
-		mapBind.put(bnd, fmx);
-		return fmx;
+		return super.ensureFamixPrimitiveType(bnd, name);
 	}
 	
 	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
 
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
 			return null;
 		}
 		
 		AnnotationType fmx = ensureFamixUniqEntity(AnnotationType.class, null, bnd.getName());
 		fmx.setIsStub(true);
-		fmx.setContainer(ensureFamixNamespace(bnd.getPackage()));
-		mapBind.put(bnd, fmx);
+		fmx.setContainer(ensureFamixNamespace(bnd.getPackage(), null));
+		mapToKey.put(bnd, fmx);
 		return fmx;
 	}
 
 	/**
-	 * Returns a Famix ParameterType (in a ParameterizableClass) with the given name
-	 * We cannot use bindings here since they are usually null (TODO check the javadoc)
-	 * @param paramName -- the name of the ParameterType
-	 * @param owner -- the ParameterizableClass that defines this ParameterType
-	 * @return the Famix Entity created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public ParameterType ensureFamixParameterType(String paramName, ParameterizableClass owner) {
-		//System.err.println("TRACE: ensureFamixParameterType( "+paramName+" , "+owner.getName()+" )");
-		ParameterType fmx = null;
-System.out.println("creating CLASS: "+paramName+"   type: ParameterType");
-		fmx = ensureFamixParameterType(paramName);
-
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
-		fmx.setContainer( owner);
-
-		return fmx;
-	}
-	
-	/**
-	 * Returns a Famix Parameterizable Class associated with the ITypeBinding similarly to ensureFamixClass for normal classes
-	 * @param bnd -- the JDT Binding 
+	 * Returns a Famix Class associated with the ITypeBinding.
+	 * The Entity is created if it does not exist.
+	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public ParameterizableClass ensureFamixParameterizableClass(ITypeBinding bnd) {
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixNamespaceDefault();
+			}
+			return super.ensureFamixClass(null, name, owner);
 		}
 
-		bnd = findNonArrayType(bnd);
-
-		return ensureFamixClassOrSub(ParameterizableClass.class, bnd, findClassOwner(bnd));
-	}
-
-	/**
-	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd) {
+		// --------------- some special cases
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
+		}
 
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
+		if (bnd.isPrimitive()) {
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
 			return null;
 		}
 
-		if (bnd.getName().equals(OBJECT_NAME)) {
-			return ensureFamixClassObject(bnd);
+		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
 		}
 
-		bnd = findNonArrayType(bnd);
-
-		return ensureFamixClassOrSub(fr.inria.verveine.core.gen.famix.Class.class, bnd, findClassOwner(bnd));
-	}
+		// --------------- name
+		if (name == null) {
+			if (! bnd.isAnonymous()) {
+				name = bnd.getName();
+			}
+			else { // anonymous class
+				if (bnd.getSuperclass() != null) {
+					name = bnd.getSuperclass().getName();
+				}
+				if ( (name == null) || name.equals(OBJECT_NAME)) {
+					ITypeBinding[] intfcs = bnd.getInterfaces();
+					if ( (intfcs != null) && (intfcs.length > 0) ) {
+						name = bnd.getInterfaces()[0].getName();
+					}
+					else {
+						name = "???";
+					}
+				}
+				name = "anonymous(" + name + ")";
+			}
+		}
 		
-	/**
-	 * Create a FamixClass or one of its subclass
-	 * @param bnd -- the JDT Binding. If null the methods silently returns null
-	 */
-	@SuppressWarnings("unchecked")
-	private <T extends fr.inria.verveine.core.gen.famix.Class>
-			T ensureFamixClassOrSub( Class<T> fmxClass, ITypeBinding bnd, ContainerEntity owner) {
-
-		String identifier = findClassName(bnd);
-//System.out.println("ensure CLASS: "+identifier+"   type: "+fmxClass.getCanonicalName());
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = findClassSupers(bnd);
+		if (name.equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
+		}
 
-		// finally trying to recover the entity or creating it
-		T fmx = null;
-		// ... trying to recover from binding
-		fmx = (T) getEntityByBinding(bnd);
+		// --------------- owner
+		if ( (owner == null) && (bnd != null) ) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
 
-		boolean wasBound = false;
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- superclasses (including interfaces)
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		if (! bnd.isInterface()) {
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd != null) {
+				sups.add(this.ensureFamixClass(supbnd, null, null));
+			}
+			else {
+				sups.add( ensureFamixClassObject(null));
+			}
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informations
-			for (T candidate : getEntityByName(fmxClass, identifier) ) {
-				if (candidate.getContainer() == owner) {
-					// could test superclass also...
-					fmx = candidate;
-					break;
-				}
+		for (ITypeBinding intbnd : bnd.getInterfaces()) {
+			sups.add( ensureFamixClass(intbnd, null, null));
+		}
+
+		// --------------- recover from name ?
+		for (fr.inria.verveine.core.gen.famix.Class candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
+			if ( recoverAndMapClass(bnd, candidate) ) {
+				fmx = candidate;
+				break;
 			}
 		}
-		
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			// note: name might be different from bnd.getName() in the case of anonymous class
-			fmx = (T) ensureFamixEntity(fmxClass, bnd, identifier);
+			fmx = super.ensureFamixClass(bnd, name, owner);
 		}
 		
-		if ((fmx!=null) && (! wasBound)) {
-			// apparently we just created it or it already existed but was not bound, so add information to it
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setIsInterface(bnd.isInterface());
-			fmx.setContainer(owner);
-			if (sups.size() > 0) {
-				// some types don't have superclass
-				Inheritance lastInheritance = null;
-				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-					lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
-				}
+			Inheritance lastInheritance = null;
+			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
-			if (! wasBound) {
-				mapBind.put(bnd, fmx);
-			}
-			// modifiers
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
 			if (fmx.getIsAbstract()) {
 				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
@@ -378,189 +299,136 @@
 		return fmx;
 	}
 
-	/** Find the "basic" type of something that may be an array
-	 * @param bnd -- non null binding for the class definition
-	 * @return the "basic" (non array) type binding
-	 */
-	private ITypeBinding findNonArrayType(ITypeBinding bnd) {
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
+	private boolean recoverAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+
+		if (bnd.getName().equals(candidate.getName())) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
-		return bnd;
+		return false;
 	}
 
-	/** 
-	 * Finds and returns the superclass and/or implemented interfaces of a class declaration
-	 * @param bnd -- non null binding for the class definition
-	 * @return the list of super types
-	 */
-	private Collection<fr.inria.verveine.core.gen.famix.Class> findClassSupers(ITypeBinding bnd) {
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
-		if (! bnd.getName().equals(OBJECT_NAME)) {
-			// "Object" doesn't have a superclass
-			
-			// superclass
-			if (! bnd.isInterface()) {
-				ITypeBinding supbnd = bnd.getSuperclass();
-				ITypeBinding[] intsbnd = bnd.getInterfaces();
-				if (supbnd == null && intsbnd.length == 0) {
-					sups.add( ensureFamixClassObject(null));
-				}
-				else {
-					if (supbnd != null) {
-						//TODO ensureFamixType ??
-						sups.add(ensureFamixClass(supbnd));
-					}
-					for (ITypeBinding intbnd : intsbnd) {
-						//TODO ensureFamixType ??
-						sups.add( ensureFamixClass(intbnd));
-					}
-				}
+	private boolean recoverAndMapType(ITypeBinding bnd, Type candidate) {
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+		
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+		
+		if ( (bnd.isClass() || bnd.isInterface()) &&
+			 (candidate instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			return recoverAndMapClass(bnd, (fr.inria.verveine.core.gen.famix.Class) candidate);
+		}
+		else if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
+			if ( (bnd.isPrimitive()) && (bnd.toString().equals(candidate.getName())) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
 			}
 			else {
-				for (ITypeBinding supbnd : bnd.getInterfaces()) {
-					//TODO ensureFamixType ??
-					sups.add( ensureFamixClass(supbnd));
-				}
+				return false;
 			}
 		}
-		return sups;
-	}
-
-	/** Finds and returns the name of a class declaration, especially for anonymous class
-	 * @param bnd -- non null binding for the class definition
-	 * @return the name
-	 */
-	private String findClassName(ITypeBinding bnd) {
-		String identifier = null;
-		if (! bnd.isAnonymous()) {
-			identifier = bnd.getName();
-		}
 		else {
-			if (bnd.getSuperclass() != null) {
-				identifier = bnd.getSuperclass().getName();
-			}
-			if ( (identifier == null) || identifier.equals(OBJECT_NAME)) {
-				ITypeBinding[] intfcs = bnd.getInterfaces();
-				if ( (intfcs != null) && (intfcs.length > 0) ) {
-					identifier = bnd.getInterfaces()[0].getName();
+			IMethodBinding methBnd = bnd.getDeclaringMethod();
+			if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+				if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+					mapToKey.put(bnd, candidate);
+					return true;
 				}
 				else {
-					identifier = "???";
+					return false;
 				}
 			}
-			identifier = "anonymous(" + identifier + ")";
-		}
-		return identifier;
-	}
 
-	/** Finds and returns the owner of a class declaration
-	 * It can be a method (anonymous class), a class (inner class, or ParameterType), or a package (normal class)
-	 * @param bnd -- non null binding for the class definition
-	 * @return the owner found
-	 */
-	private ContainerEntity findClassOwner(ITypeBinding bnd) {
-		ContainerEntity owner = null;
-		IMethodBinding parentMtd = bnd.getDeclaringMethod();
-		if (parentMtd != null) {
-			owner = this.ensureFamixMethod(parentMtd);
-		}
-		else {
-			ITypeBinding parentClass = bnd.getDeclaringClass();
-			if (parentClass != null) {
-				owner = this.ensureFamixClass(parentClass);
-			}
-			else {
-				IPackageBinding parentPckg = bnd.getPackage();
-				if (parentPckg != null) {
-					owner = this.ensureFamixNamespace(parentPckg);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+				if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+					mapToKey.put(bnd, candidate);
+					return true;
 				}
 				else {
-					owner = this.ensureFamixNamespaceDefault();
+					return false;
 				}
 			}
+			
+			IPackageBinding pckgBnd = bnd.getPackage();
+			if ( (candidate.getBelongsTo() instanceof Namespace) &&
+				 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
 		}
-		return owner;
 	}
 
-	/**
-	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public Method ensureFamixMethod(IMethodBinding bnd) {
-		Type owner = null;
-		Type rettyp = null;
-		String sig = null;
-		boolean wasBound = false;
-		
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Method");
-			return null;
+	private boolean recoverAndMapClass(ITypeBinding bnd, fr.inria.verveine.core.gen.famix.Class candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
 		}
-
-		// owner
-		owner = this.ensureFamixType(bnd.getDeclaringClass(), null);
+		else if (bound != null) {
+			return false;
+		}
 
-		// return type
-		if (! bnd.isConstructor()) {
-			rettyp = this.ensureFamixType(bnd.getReturnType(), /*context*/owner); // the context is the declaring class
+		IMethodBinding methBnd = bnd.getDeclaringMethod();
+		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
 		}
-		// TODO   else what?
 
-		sig = computeSignature(bnd);
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
 
-		// finally trying to recover the entity or creating it
-		Method fmx = null;
-		// ... trying to recover from binding
-		fmx = (Method) getEntityByBinding(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		IPackageBinding pckgBnd = bnd.getPackage();
+		if ( (candidate.getBelongsTo() instanceof Namespace) &&
+			 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
 		else {
-			wasBound = false;
-			// trying to recover from name and other informations
-			for (Method candidate : getEntityByName(Method.class, bnd.getName()) ) {
-				if ( (candidate.getParentType() == owner) &&
-					 (candidate.getDeclaredType() == rettyp) &&
-					 (candidate.getSignature().equals(sig)) ) {
-					// we could also test that this candidate is not bound yet (to another bnd)
-					// but it would require significant modifications and might not be that useful?
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
-			}
+			return false;
 		}
-		
-		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = (Method) ensureFamixEntity(Method.class, bnd, bnd.getName());
+	}
+
+	private boolean recoverAndMapMethod(IMethodBinding bnd, Method candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
 		}
-		
-		if ((fmx!=null) && (! wasBound) ) {
-			// apparently we just created it or it already existed as a stub, so add information to it
-			fmx.setParentType(owner);
-			fmx.setDeclaredType(rettyp);	
-			fmx.setName(bnd.getName());
-			fmx.setSignature(sig);
-			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		else if (bound != null) {
+			return false;
 		}
 
-		return fmx;
-	}
-
-	/** Computes the signature of a method from its binding
-	 * @param bnd -- bJDT binding of the method
-	 * @return the signature of the method in a String
-	 */
-	private String computeSignature(IMethodBinding bnd) {
-		String sig;
-		// method signature
-		sig = bnd.getName() + "(";
+		// for methods, the name is not enough, we must test the signature also 
+		String sig = bnd.getName() + "(";
 		boolean first = true;
 		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
 			if (! first) {
@@ -570,112 +438,230 @@
 				sig += parBnd.getName();
 				first = false;
 			}
+			sig += ")";
 		}
-		sig += ")";
-		return sig;
+		if (! candidate.getSignature().equals(sig)) {
+			return false;
+		}
+
+		ITypeBinding ownerBnd = bnd.getDeclaringClass();
+		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
+			 (recoverAndMapClass(ownerBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+				mapToKey.put(bnd, candidate);
+				// everything seems OK, but we still need to test return type which is not in the Moose signature
+				return recoverAndMapType(bnd.getReturnType(), candidate.getDeclaredType());
+		}
+		else {
+			return false;
+		}
 	}
-	
-	@SuppressWarnings("unchecked")
-	public String stubMethodSignature(MethodDeclaration node) {
-		String sig = node.getName().getIdentifier() + "(";
-		boolean first = true;
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-			if (! first) {
-				sig += "," + param.getType().toString();
+
+	private boolean recoverAndMapVariable(IVariableBinding bnd, StructuralEntity candidate) {
+		NamedEntity bound = (StructuralEntity)getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+
+		IMethodBinding methBnd = bnd.getDeclaringMethod();
+		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
 			}
 			else {
-				sig += param.getType().toString();
-				first = false;
+				return false;
 			}
 		}
-		sig += ")";
-		return sig;
+
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
+			 (recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		else {
+			return false;
+		}
 	}
-	
-	public Method ensureFamixMethod(String identifier, NamedEntity owner, int numberOfParameters) {
+
+	/**
+	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
 		Method fmx = null;
-		if (owner != null) {
-			for (Method candidate : getEntityByName(Method.class, identifier) ) {
-				if ((candidate.getParentType() == owner) && (candidate.getParameters().size() == numberOfParameters)) {
-					fmx = candidate;
-					break;
+		String sig;
+		boolean first;
+
+		// signature is dealt in two places
+		// here we try to use the parameter of ensureFamixMethod to compute the list of parameter types of the FamixMethod
+		// if it does not work and binding is not null, we will have another chance to compute this list later
+		sig = "(";
+		first = true;
+		if (paramTypes != null) {
+			for (org.eclipse.jdt.core.dom.Type t : paramTypes) {
+				if (! first) {
+					sig += "," + findTypeName(t);
+				}
+				else {
+					sig += findTypeName(t);
+					first = false;
 				}
 			}
-		} else {
-			for (Method candidate : getEntityByName(Method.class, identifier) ) {
-				if (candidate.getParameters().size() == numberOfParameters) {
-					fmx = candidate;
-					break;
+			
+		}
+		sig += ")";
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (paramTypes == null) {
+				sig = name + "(???)";
+			}
+			else {
+				sig = name + sig;
+			}
+			if (owner == null) {
+				owner= ensureFamixClassStubOwner();
+			}
+			return super.ensureFamixMethod(null, name, sig, ret, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- signature
+		if (paramTypes == null) {
+			sig = "(";
+			first = true;
+			paramTypes = new ArrayList<org.eclipse.jdt.core.dom.Type>();
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
 				}
 			}
+			sig += ")";
 		}
-		return fmx;
-	}
-	
-	public Method ensureFamixMethod(MethodDeclaration node, fr.inria.verveine.core.gen.famix.Class owner) {
-		Method fmx = null;
-		for (Method candidate : getEntityByName(Method.class, node.getName().getIdentifier()) ) {
-			if ((candidate.getParentType() == owner) && (candidate.getSignature().equals(stubMethodSignature(node))) ) {
+		sig = name + sig;
+
+		// --------------- return type
+		if ( (ret == null) && (! bnd.isConstructor()) ) {
+			ret = this.ensureFamixType(bnd.getReturnType(), null, null);
+		}
+		// else leave it to null ...
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (Method candidate : this.getEntityByName(Method.class, name)) {
+			if ( recoverAndMapMethod(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
 		}
+		if (fmx == null) {
+			fmx = ensureFamixMethod(bnd, name, sig, ret, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setDeclaredType(ret);
+			fmx.setSignature(sig);
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
 		return fmx;
 	}
-		
+	
+	public String findTypeName(org.eclipse.jdt.core.dom.Type t) {
+		if (t.isPrimitiveType()) {
+			return t.toString();
+		}
+		else if (t.isSimpleType()) {
+			return ((SimpleType)t).getName().getFullyQualifiedName();
+		}
+		else if (t.isQualifiedType()) {
+			return ((QualifiedType)t).getName().getIdentifier();
+		}
+		else if (t.isArrayType()) {
+			return findTypeName( ((ArrayType)t).getElementType() );
+		}
+		else if (t.isParameterizedType()) {
+			return "?";  // TODO
+		}
+		else { // it is a WildCardType
+			return "?"; // TODO
+		}
+	}
+
 	/**
-	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)} 
+	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
-	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
-		Type owner = null;
-		Type typ = null;
-		boolean wasBound = false;
+	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
+		Attribute fmx = null;
 
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Attribute");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of an attribute for which we ignore the declaring class? 
+			}
+			return super.ensureFamixAttribute(null, name, type, owner);
 		}
 
-		owner = this.ensureFamixType(bnd.getDeclaringClass(), /*context*/null); // the context is the declaring class=owner
-		typ = this.ensureFamixType(bnd.getType(), owner);
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
 
-		// finally trying to recover the entity or creating it
-		Attribute fmx = null;
-		// ... trying to recover from binding
-		fmx = (Attribute) getEntityByBinding(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- return type
+		if (type == null) {
+			type = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informationsparentBehaviouralEntity
-			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
-				if ( //(! candidate.getIsStub()) &&
-					 (candidate.getParentType() == owner) &&
-					 (candidate.getDeclaredType() == typ) ) {
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
-			}
+		// else leave it to null ...
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
 		}
 		
+		// --------------- recover from name ?
+		for (Attribute candidate : getEntityByName(Attribute.class, name) ) {
+			if ( recoverAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = ensureFamixEntity(Attribute.class, bnd, bnd.getName());
+			fmx = super.ensureFamixAttribute(bnd, name, type, owner);
 		}
 		
-		if ((fmx!=null) && (! wasBound) ) {
-			// apparently we just created it, so add information to it
-			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setParentType(owner);
-			fmx.setDeclaredType(typ);	
-			fmx.setName(bnd.getName());
+			fmx.setDeclaredType(type);	
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
 		}
 
 		return fmx;
@@ -709,13 +695,17 @@
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Parameter");
+			System.err.println("Warning: Unexpected null binding to Famix Parameter");
 			return null;
 		}
 
-		// actually it seems to be very little chances that the parameter alreasy exist.
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+		}
+		
+		// actually it seems to be very little chances that the parameter already exist.
 		// but who knows? Does not hurt to try
-		Parameter fmx = (Parameter) getEntityByBinding(bnd);
+		Parameter fmx = (Parameter) getEntityByKey(bnd);
 		
 		if (fmx != null) {
 			wasBound = true;
@@ -728,90 +718,73 @@
 		if ( (fmx!=null) && (! wasBound) ) {
 			// declaring method
 			if (bnd.getDeclaringMethod() != null) {
-				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
+				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null));  // cast needed to desambiguate the call
 			} else {
 				fmx.setParentBehaviouralEntity(owner);
 			}
 			// type of the attribute
-//System.out.println("looking for parameter type:"+bnd.getName()+"  context="+owner.getName());
-			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), /*context*/owner));
+			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), null, null));
 		}
 		
 		return fmx;
 	}
 	
-	public Parameter ensureFamixParameter(IVariableBinding bnd) {
-		return ensureFamixParameter(bnd, null);
-	}
-
 	/**
 	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
+	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
-	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, Method fmxMethod) {
-		Method owner = null;
-		Type typ = null;
-		boolean wasBound = false;
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, String name, Type typ, Method owner) {
+		LocalVariable fmx = null;
 
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix LocalVariable");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of a local variable for which we ignore the declaring method?
+			}
+			return super.ensureFamixLocalVariable(null, name, typ, owner);
 		}
 
-		owner = this.ensureFamixMethod(bnd.getDeclaringMethod());
-		if (owner == null) {
-			owner = fmxMethod;
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
 		}
-		typ = this.ensureFamixType(bnd.getType(), /*context*/fmxMethod);
 
-		// finally trying to recover the entity or creating it
-		LocalVariable fmx = null;
-		// ... trying to recover from binding
-		fmx = (LocalVariable) getEntityByBinding(bnd);
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+		// else leave it to null ...
 
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informationsparentBehaviouralEntity
-			for (LocalVariable candidate : getEntityByName(LocalVariable.class, bnd.getName()) ) {
-				if ( (candidate.getParentBehaviouralEntity() == owner) &&
-					 (candidate.getDeclaredType() == typ) ) {
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
+		
+		// --------------- recover from name ?
+		for (LocalVariable candidate : getEntityByName(LocalVariable.class, name) ) {
+			if ( recoverAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
 			}
 		}
-		
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = ensureFamixEntity(LocalVariable.class, bnd, bnd.getName());
+			fmx = super.ensureFamixLocalVariable(bnd, name, typ, owner);
 		}
-
-		if ( (fmx!=null) && (! wasBound) ) {
-			// apparently we just created it, so add information to it
+		
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setParentBehaviouralEntity(owner);
-			fmx.setDeclaredType(typ);
+			fmx.setDeclaredType(typ);	
 		}
-		
+
 		return fmx;
 	}
 	
-	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
-		return ensureFamixLocalVariable(bnd, null);
-	}
-	
 	/**
 	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
@@ -856,7 +829,7 @@
 			while ( ! (ast instanceof CompilationUnit) ) {
 				ASTNode tmp = ast.getParent();
 				if ( (ast == null) || (tmp == ast) ) {
-					// we reached the top node without finding a CompilationUnit. This would be strange, but what can one do ... ?
+					// if we are here, then we reached the top node without finding a CompilationUnit. This should not happen
 					return null;
 				}
 				else {
@@ -881,12 +854,7 @@
 	 * @return the Famix Method
 	 */
 	public Method ensureFamixStubMethod(String name) {
-		Method fmx = ensureFamixMethod(name);
-		fmx.setSignature(name + " (<unknown-stub>)");
-		fmx.setParentType( ensureFamixClassStubOwner());
-		fmx.setDeclaredType(ensureFamixClassObject(null));
-		
-		return fmx;
+		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, ensureFamixClassStubOwner());  // cast needed to desambiguate the call
 	}
 
 	/**
@@ -896,7 +864,7 @@
 	 * @return a Famix Namespace for "java.lang"
 	 */
 	public Namespace ensureFamixNamespaceJavaLang(IPackageBinding bnd) {
-		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, OBJECT_PACKAGE_NAME);
+		Namespace fmx = this.ensureFamixNamespace(bnd, OBJECT_PACKAGE_NAME);
 
 		return fmx;
 	}
@@ -958,4 +926,19 @@
 		return fmx;
 	}
 
+
+	public String removeLastName(String qualifiedName) {
+		String ret = null;
+		int last = qualifiedName.lastIndexOf('.');
+		if (last > 0) {
+			// recursively creating the parent
+			ret = qualifiedName.substring(0, last);
+		}
+		else {
+			ret = "";
+		}
+
+		return ret;
+	}
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 83)
@@ -40,9 +40,9 @@
 	@Override
 	public boolean compile(String[] argv) {
 		boolean ret;
-		if (this.linkToExisting()) {
+		/*if (this.linkToExisting()) {
 			this.expandNamespacesNames();
-		}
+		}*/
 
 		setInitialArgs(argv);
 		ret = super.compile(argv);
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 5)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 6)
@@ -15,7 +15,7 @@
     @FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
-        return this.getModifiers().contains("abstract");
+        return super.getIsAbstract() || this.getModifiers().contains("abstract");
     }
     
     private Boolean isInterface;
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 91)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/">
 		<attributes>
 			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
 		</attributes>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 91)
@@ -32,6 +32,11 @@
 
 public class Dictionary<B> {
 
+	/**
+	 * The FAMIX repository where all FAMIX entities are created and stored
+	 */
+	protected Repository famixRepo;
+
 	protected Map<B,NamedEntity> mapBind;
 
 	protected Map<String,Collection<NamedEntity>> mapName;
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 91)
@@ -75,6 +75,7 @@
 		for (String f : files) {
 			parseFile(f);
 		}*/
+		
 		// or parsing the entire project in one pass ---
 		VerveineJParser parser = new VerveineJParser();
 		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
@@ -86,10 +87,10 @@
 	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
 	 * @param file -- name of the file to parse
 	 */
-/*	private void parseFile(String file) {
+	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
-				"test_src/LANModel//moose/lan/",
+				"test_src/LANModel/",
 				"test_src/LANModel/moose/lan/"+file
 				};
 		
@@ -100,7 +101,7 @@
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
 	}
-*/
+
 	@After
 	public void tearDown() {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
@@ -108,6 +109,9 @@
 	
 	@Test
 	public void testEntitiesNumber() {
+		for (fr.inria.verveine.core.gen.famix.Class c : TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class)) {
+			//System.out.println("class -- "+c.getName());
+		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
 		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
@@ -161,7 +165,7 @@
 	public void testNamedEntities() {
 		JavaDictionary dico = new JavaDictionary(repo);
 		
-		assertNotSame(dico.ensureFamixClass(null, A_CLASS_NAME, null),dico.ensureFamixClass(null, A_CLASS_NAME, null));
+		assertNotSame(dico.createFamixClass(null, A_CLASS_NAME, null),dico.createFamixClass(null, A_CLASS_NAME, null));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
 		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
@@ -173,9 +177,9 @@
 		assertEquals(0, obj.getSuperInheritances().size());
 		assertSame(javaLang, obj.getContainer());
 		
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.createFamixClassStubOwner();
 		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
-		assertSame(fmx, dico.ensureFamixClassStubOwner());
+		assertSame(fmx, dico.createFamixClassStubOwner());
 	}
 
 	@Test
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 91)
@@ -5,14 +5,15 @@
 
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 import java.io.File;
+import java.io.FileWriter;
 import java.util.Collection;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -46,32 +47,23 @@
 
 	private Repository repo;
 
-	public VerveineJTest_AdHoc() {
-		// make sure we don't have any pre-existing mse lying in the way
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
-
 	/**
 	 * @throws java.lang.Exception
 	 */
 	@Before
 	public void setUp() throws Exception {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
 		VerveineJParser parser = new VerveineJParser();
 		parser.compile(new String[] {"test_src/ad_hoc"});
 		repo = parser.getFamixRepo();
+		repo.exportMSE(new FileWriter(VerveineJParser.OUTPUT_FILE));
 	}
 
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
 	@Test
 	public void testExceptions() {
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
 		assertNotNull(meth);
-		
+
 		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
 		assertNotNull(excepClass);
 
@@ -79,7 +71,7 @@
 		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
 		assertSame(meth, exD.getDefiningMethod());
 		assertSame(excepClass, exD.getExceptionClass());
-		
+
 		assertEquals(1, meth.getThrownExceptions().size());
 		ThrownException exT = meth.getThrownExceptions().iterator().next();
 		assertSame(meth, exT.getDefiningMethod());
@@ -169,19 +161,24 @@
 	}
 
 	@Test
-	public void testClassParameterTypes() {
-		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
-		assertNotNull(dicoClass);
-		assertEquals("Dictionary", dicoClass.getName());
-		assertEquals(2, dicoClass.getTypes().size());
-		assertEquals(1, dicoClass.getParameters().size());
+	public void testParameterizableClass() {
+		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dico);
+		assertEquals("Dictionary", dico.getName());
+		assertEquals(2, dico.getTypes().size());
+		assertEquals(1, dico.getParameters().size());
 		
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
 		assertNotNull(dicoParam);
 		assertEquals("B", dicoParam.getName());
 		
-		assertSame(dicoClass, dicoParam.getContainer());
-		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
+		assertSame(dico, dicoParam.getContainer());
+		assertSame(dicoParam, dico.getParameters().iterator().next());
+
+		/* Collection<Object> is not seen as parameterizable by JDT 		 */
+		 ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
+		 assertNotNull(collec);
+
 	}
 
 	@Test
@@ -206,17 +203,6 @@
 	}
 	
 	@Test
-	public void testFieldArgumentTypes() {
-		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
-		assertNotNull(famixAtt);
-		assertEquals("mapBind", famixAtt.getName());
-		//assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		//Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
-		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
-		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
-	}
-	
-	@Test
 	public void testMethodParameterArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
 		assertNotNull(fmxMethod);
@@ -321,8 +307,7 @@
 			}
 		}
 	}
-	
-	
+
 	@Test
 	public void testMethodReturnArgumentTypes() {
 		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 91)
@@ -73,15 +73,24 @@
 	// VISITOR METHODS
 
 	public boolean visit(CompilationUnit node) {
+		System.err.println("TRACE, RefVisiting CompilationUnit");
+
 		PackageDeclaration pckg = node.getPackage();
+		Namespace fmx = null;
 		if (pckg==null) {
-			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
+			 fmx = dico.createFamixNamespaceDefault();
 		}
 		else {
-			this.context.pushPckg( (Namespace)dico.getEntityByKey(pckg.resolveBinding()) );
+			fmx = (Namespace)dico.getEntityByKey(pckg.resolveBinding());
 		}
-		return super.visit(node);
-
+		if (pckg != null) {
+			this.context.pushPckg(fmx);
+			return super.visit(node);
+		}
+		else {
+			this.context.pushPckg(null);
+			return false;
+		}
 	}
 
 	public void endVisit(CompilationUnit node) {
@@ -120,13 +129,20 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
+		System.err.println("TRACE, RefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
-		this.context.pushClass(fmx );
+		if (fmx != null) {
+			this.context.pushClass(fmx );
 
-		dico.addFamixAnnotationInstances(bnd, fmx);
+			dico.addFamixAnnotationInstances(bnd, fmx);
 
-		return super.visit(node);
+			return super.visit(node);
+		}
+		else {
+			this.context.pushClass(null);
+			return false;
+		}
 	}
 
 	public void endVisit(TypeDeclaration node) {
@@ -135,15 +151,24 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
+		System.err.println("TRACE, RefVisiting ClassInstanceCreation");
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
 			ITypeBinding bnd = decl.resolveBinding();
 			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
-			this.context.pushClass(fmx);
-
-			dico.addFamixAnnotationInstances(bnd, fmx);
+			if (fmx != null) {
+				this.context.pushClass(fmx);
+				dico.addFamixAnnotationInstances(bnd, fmx);
+				return super.visit(node);
+			}
+			else {
+				this.context.pushClass(null );
+				return false;
+			}
 		}
-		return super.visit(node);
+		else {
+			return super.visit(node);
+		}
 	}
 
 	public void endVisit(AnonymousClassDeclaration node) {
@@ -153,6 +178,8 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
+		System.err.println("TRACE, RefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+
 		IMethodBinding bnd = node.resolveBinding();
 		Method meth = (Method) dico.getEntityByKey(bnd);
 
@@ -163,14 +190,18 @@
 
 			// Exceptions
 			for (Name excepName : (List<Name>)node.thrownExceptions()) {
-				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.createFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
 				if (excepFmx != null) {
 					dico.createFamixDeclaredException(meth, excepFmx);
 				}
 			}
+			return super.visit(node);
+		}
+		else {
+			this.context.pushMethod(null);
+			return false;
 		}
 
-		return super.visit(node);
 	}
 
 	public void endVisit(MethodDeclaration node) {
@@ -180,7 +211,7 @@
 
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
-//		System.err.println("TRACE, RefVisiting FieldDeclaration");
+		System.err.println("TRACE, RefVisiting FieldDeclaration: ");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
 			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
@@ -199,7 +230,7 @@
 
 	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
 		return super.visit(node);
 	}
 
@@ -252,10 +283,10 @@
 		if (meth != null) {
 			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
 			if (excepClass instanceof SimpleType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+				excepFmx = this.dico.createFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
 			}
 			else if (excepClass instanceof QualifiedType) {
-				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
+				excepFmx = this.dico.createFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
 				dico.createFamixCaughtException(meth, excepFmx);
@@ -268,7 +299,7 @@
 	@Override
 	public boolean visit(ThrowStatement node) {
 		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.createFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
 			dico.createFamixThrownException(meth, excepFmx);
 		}
@@ -285,7 +316,7 @@
 	private NamedEntity getReceiver(Expression expr) {
 		// msg(), same as ThisExpression
 		if (expr == null) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
 		}
 
 		// array[i].msg()
@@ -359,12 +390,12 @@
 			if (bnd instanceof ITypeBinding) {
 				// msg() is a static method of Name
 				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null), bnd.getName());
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
 			}
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
-					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
+					ret = dico.createFamixAttribute(bnd, varName, null, null);
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
 					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -406,13 +437,13 @@
 		
 		// this.msg()
 		else if (expr instanceof ThisExpression) {
-			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+			return this.dico.createFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
 		}
 
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
 			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null);
+			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null,  context.top());
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 91)
@@ -38,6 +38,8 @@
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeParameter;
+import org.eclipse.jdt.core.dom.VariableDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -47,11 +49,16 @@
 import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -81,15 +88,20 @@
 		Namespace fmx = null;
 		PackageDeclaration pckg = node.getPackage();
 		if (pckg==null) {
-			fmx = dico.ensureFamixNamespaceDefault();
+			fmx = dico.createFamixNamespaceDefault();
 		}
 		else {
 			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
 			fmx.setIsStub(false);
 		}
-		this.context.pushPckg(fmx);
-		return super.visit(node);
 
+		if (pckg != null) {
+			return super.visit(node);
+		}
+		else {
+			this.context.pushPckg(null);
+			return false;
+		}
 	}
 
 	public void endVisit(CompilationUnit node) {
@@ -98,9 +110,13 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
+		// Can only be a class or interface declaration
+
 		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
+		@SuppressWarnings("unchecked")
+		List<TypeParameter> tparams = node.typeParameters();
+		fr.inria.verveine.core.gen.famix.Class fmx = (Class) dico.ensureFamixType(bnd, /*name*/node.getName().getIdentifier(), /*owner*/context.top(), /*ctxt*/context.top());  // isGeneric = (tparams.size()>0)
 		if (fmx != null) {
 			fmx.setIsStub(false);
 
@@ -108,11 +124,20 @@
 
 			dico.addSourceAnchor(fmx, node);
 			dico.createFamixComment(node.getJavadoc(), fmx);
+			
+			for (TypeParameter tp : tparams) {
+				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
+				ParameterType fmxParam = dico.createFamixParameterType( tp.resolveBinding(), tp.getName().getIdentifier(), (ParameterizableClass)fmx); // note owner of the ParameterType is the ParameterizableClass
+				if (fmxParam != null) {
+					fmxParam.setIsStub(false);
+				}
+			}
+			return super.visit(node);
 		}
-
-		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
-		
-		return super.visit(node);
+		else {
+			this.context.pushClass(null);
+			return false;
+		}
 	}
 
 	public void endVisit(TypeDeclaration node) {
@@ -125,19 +150,26 @@
 		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
+			fmx = (Class) this.dico.ensureFamixType(decl.resolveBinding(), /*name*/"anonymous("+dico.findTypeName(node.getType())+")", /*owner*/context.top(), /*ctxt*/context.top());  //  isGeneric = false
 			if (fmx != null) {
 				fmx.setIsStub(false);
-			}
 
-			dico.addSourceAnchor(fmx, node);
+				dico.addSourceAnchor(fmx, node);
+				this.context.pushClass(fmx);
+				return super.visit(node);
+			}
+			else {
+				this.context.pushClass(null);
+				return false;
+			}
 		}
-		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
 	public void endVisit(ClassInstanceCreation node) {
-		this.context.popClass();
+		if (node.getAnonymousClassDeclaration() != null) {
+			this.context.popClass();
+		}
 		super.endVisit(node);
 	}
 
@@ -149,12 +181,14 @@
 			fmx.setIsStub(Boolean.FALSE);
 			
 			context.pushAnnotationType(fmx);
+			return super.visit(node);
 		}
-
-		return super.visit(node);
+		else {
+			context.pushAnnotationType(null);
+			return false;
+		}
 	}
 
-
 	public void endVisit(AnnotationTypeDeclaration node) {
 		this.context.popAnnotationType();
 		super.endVisit(node);
@@ -168,9 +202,12 @@
 			fmx.setIsStub(false);
 			
 			context.pushAnnotationMember(fmx);
+			return super.visit(node);
 		}
-
-		return super.visit(node);
+		else {
+			context.pushAnnotationMember(null);
+			return false;
+		}
 	}
 
 	public void endVisit(AnnotationTypeMemberDeclaration node) {
@@ -181,7 +218,7 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(EnumDeclaration node) {
 //		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.createFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(Boolean.FALSE);
 			
@@ -189,8 +226,11 @@
 				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
 				ev.setIsStub(Boolean.FALSE);
 			}
+			return super.visit(node);
 		}
-		return super.visit(node);
+		else {
+			return false;
+		}
 	}
 
 	@SuppressWarnings("unchecked")
@@ -204,13 +244,24 @@
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				paramTypes.add(param.getType());
 		}
+
+		fr.inria.verveine.core.gen.famix.Type fmxTyp;
+		if (retTyp == null) {
+			fmxTyp = null;
+		}
+		else if (retTyp.isParameterizedType()) {
+			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
+			fmxTyp = dico.ensureFamixParameterizedType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
+		}
+		else {
+			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
+		}
+
 		// creating/recovering it
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes,
-											(retTyp == null) ? null : dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-											context.topClass());
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, fmxTyp, context.topClass());
 		
-		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
-			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+		if (retTyp != null && retTyp.isParameterizedType()) {
+			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)retTyp).typeArguments()));
 		}
 		
 		if (fmx != null) {
@@ -225,44 +276,43 @@
 			dico.createFamixComment(node.getJavadoc(), fmx);
 
 			// creating the method's parameters
+			List<VariableDeclaration> paramAsVarList;
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				fr.inria.verveine.core.gen.famix.Type paramTyp = dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null);
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), param.getName().getIdentifier(), paramTyp, fmx);
-				if (fmxParam != null) {
-					fmxParam.setIsStub(false);
-				}
-				if (param.getType().isParameterizedType()) {
-					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
-				}
+				// Note: method and ParamTyp bindings are null for ParameterType :-(
+				paramAsVarList = new ArrayList<VariableDeclaration>(1);
+				paramAsVarList.add(param);
+				visitVariablesDeclarations(node, param.getType(), paramAsVarList, context.topMethod());
 			}
+			return super.visit(node);
+		}
+		else {
+			this.context.pushMethod(null);
+			return false;
 		}
-		return super.visit(node);	
 	}
 
 	public void endVisit(MethodDeclaration node) {
-		int cyclo = context.getTopMethodCyclo();
-		int nos = context.getTopMethodNOS();
+		int cyclo = 0;
+		int nos = 0;
+		if (context.topMethod() != null) {
+			cyclo = context.getTopMethodCyclo();
+			nos = context.getTopMethodNOS();
+		}
 		Method fmx = this.context.popMethod();
-		fmx.setNOS(nos);
-		fmx.setCyclo(cyclo);
+		if (fmx != null) {
+			fmx.setNOS(nos);
+			fmx.setCyclo(cyclo);
+		}
 		super.endVisit(node);
 	}
 	
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
-		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
-
-			if (fmx != null) {
-				fmx.setIsStub(false);
-			}
-			if (node.getType().isParameterizedType()) {
-				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
-			}
 
-			dico.addSourceAnchor(fmx, node);
-			dico.createFamixComment(node.getJavadoc(), fmx);
+		for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
+			dico.addSourceAnchor(att, node);
+			dico.createFamixComment(node.getJavadoc(), att);
 		}
 		return super.visit(node);
 	}
@@ -270,34 +320,74 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming that the user is not interested in them 
+		if (! node.getType().isPrimitiveType()) {
+			for (StructuralEntity att : visitVariablesDeclarations(node, node.getType(), (List<VariableDeclaration>)node.fragments(), context.topMethod())) {
+				dico.addSourceAnchor(att, node);
+			}
+		}
+
 		return super.visit(node);
 	}
 
-	private void visitVariablesDeclarations(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
-		// we don't declare (local) variables that have a primitive type
-		// because we are assuming here that the user is not interested in them 
-		if (nodeTyp.isPrimitiveType()) {
-			return;
+	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
+		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
+
+		fr.inria.verveine.core.gen.famix.Type fmxTyp;
+		if (varTyp.isParameterizedType()) {
+			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
+			fmxTyp = dico.ensureFamixParameterizedType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
+			// TODO treat ParameterTypes
 		}
+		else {
+			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
+		}
+		for (VariableDeclaration vd : fragments) {
+			StructuralEntity fmx;
+			if (node instanceof MethodDeclaration) {
+				// creating the parameters of a method. In this case, 'fragment' is aList<SingleVariableDeclarationFragment> and 'varType' is null
+				fmx = dico.ensureFamixParameter(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method)ctxt);
+			}
+			else if (node instanceof FieldDeclaration) {
+				// creating a class' field
+				fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (fr.inria.verveine.core.gen.famix.Class) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+			}
+			else if (node instanceof VariableDeclarationExpression) {
+				// creating a method's local variable
+				fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), fmxTyp, (Method) ctxt);
+			}
+			else {
+				fmx = null;
+			}
 
-		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), dico.ensureFamixType(null, nodeTyp.toString(), null), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
-				dico.addSourceAnchor(fmx, node);
-			}
-			if (nodeTyp.isParameterizedType()) {
-				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+				ret.add(fmx);
 			}
 		}
+
+		return ret;
 	}
 
 	// METRICS: CYCLO, NOS
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 91)
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedList;
-import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ArrayType;
@@ -18,7 +17,6 @@
 import org.eclipse.jdt.core.dom.Modifier;
 import org.eclipse.jdt.core.dom.QualifiedType;
 import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.TypeParameter;
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
@@ -38,6 +36,9 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ParameterizedType;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
@@ -69,7 +70,7 @@
 
 	/**
 	 * Returns a Famix Namespace associated with its IPackageBinding and/or name.
-	 * The Entity is created if it does not exist (see also {@link Dictionary#ensureFamixNamespace(Object, String)}).
+	 * The Entity is created if it does not exist (see also {@link Dictionary#createFamixNamespace(Object, String)}).
 	 * Also creates or recovers recusively it's parent namespaces.<br>
 	 * At least one of <b>bnd</b> and <b>name</b> must be non null.
 	 * @param bnd -- the JDT Binding that may be used as a uniq key to recover this namespace
@@ -89,8 +90,8 @@
 			 * (for example when creating parent packages of a package we have a binding for).
 			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
 			 * all is said and done. */
-			fmx = super.ensureFamixNamespace( bnd, name);
-			parent = this.ensureFamixNamespace(null, removeLastName(name));
+			fmx = createFamixNamespace( bnd, name);
+			parent = ensureFamixNamespace(null, removeLastName(name));
 			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
 				parent.addChildScopes(fmx);
@@ -100,67 +101,262 @@
 		return fmx;
 	}
 
-	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
-		Collection<Type> fmxTypes = new ArrayList<Type>();
-		
-		Type fmxType = null;
-		for (org.eclipse.jdt.core.dom.Type type : types) {
-			ITypeBinding bnd = type.resolveBinding();
-			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, findTypeName(type), null);
-			} else {
-				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+	/**
+	 * Recovers or creates a Famix Type (see also {@link Dictionary#createFamixType(Object, String, ContainerEntity)}
+	 */
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner, ContainerEntity ctxt) {
+		Type fmx = null;
+
+		if (bnd == null) {
+			if (name == null) {
+				return null;
 			}
-			fmxTypes.add(fmxType);
+			fmx = searchTypeInContext(name, ctxt);
+			if (fmx != null) {
+				return fmx;
+			}
+
+			if ( (owner != null) && (owner instanceof ParameterizableClass) ) {
+				return createFamixParameterType(null, name, (ParameterizableClass) owner);
+			}
+			else {
+				return super.createFamixType(null, name, owner);
+			}
 		}
-		return fmxTypes;
+
+		// bnd != null
+
+		fmx = (Type) getEntityByKey(bnd);
+		if (fmx != null) {
+			return fmx;
+		}
+
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+
+		if (bnd.isPrimitive()) {
+			return createFamixPrimitiveType(bnd, name);
+		}
+
+		if (bnd.isEnum()) {
+			return createFamixEnum(bnd, name, owner);
+		}
+		
+		if (bnd.isTypeVariable() ) {
+			return createFamixParameterType(bnd, name, (ParameterizableClass) owner);
+		}
+
+		if (bnd.isRawType() || bnd.isGenericType()) {
+			return ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+		}
+
+		if (bnd.isParameterizedType()) {
+			return ensureFamixParameterizedType(bnd, name, (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true), owner);
+		}
+
+		// it seems wise to test isClass after isGenericType, isParameterizedType, ... ? 
+		if (bnd.isClass() || bnd.isInterface()) {
+			return ensureFamixClass(bnd, name, owner, /*isGeneric*/false);
+		}
+
+
+		return super.createFamixType(bnd, name, owner);
 	}
 
 	/**
-	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
+	 * Returns a Famix Class associated with the ITypeBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#createFamixClass(Object, String, ContainerEntity)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner, boolean isGeneric) {
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
 
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-			return super.ensureFamixType(null, name, owner);
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = createFamixNamespaceDefault();
+			}
+			
+			if (isGeneric) {
+				return super.createFamixParameterizableClass(null, name, owner);
+			}
+			else {
+				return super.createFamixClass(null, name, owner);
+			}
 		}
 
+		// --------------- some special cases
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
 
-		if (bnd.isClass() || bnd.isInterface()) {
-			return this.ensureFamixClass(bnd, name, owner);
+		if (bnd.isPrimitive()) {
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
+			return null;
+		}
+
+		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
+		// --------------- name
+		if (name == null) {
+			if (! bnd.isAnonymous()) {
+				name = bnd.getErasure().getName();  // for generics, will give the "core" type name, for naormal type, won't change anything
+			}
+			else { // anonymous class
+				if (bnd.getSuperclass() != null) {
+					name = bnd.getSuperclass().getName();
+				}
+				if ( (name == null) || name.equals(OBJECT_NAME)) {
+					ITypeBinding[] intfcs = bnd.getInterfaces();
+					if ( (intfcs != null) && (intfcs.length > 0) ) {
+						name = bnd.getInterfaces()[0].getName();
+					}
+					else {
+						name = "???";
+					}
+				}
+				name = "anonymous(" + name + ")";
+			}
 		}
 		
-		if (bnd.isPrimitive()) {
-			return ensureFamixPrimitiveType(bnd, name);
+		if (name.equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
 		}
 
-		if (bnd.isEnum()) {
-			return ensureFamixEnum(bnd, name, owner);
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.createFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- superclasses (including interfaces)
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		if (! bnd.isInterface()) {
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd != null) {
+				sups.add((Class)ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
+			}
+			else {
+				sups.add( ensureFamixClassObject(null));
+			}
+		}
+		for (ITypeBinding intbnd : bnd.getInterfaces()) {
+			sups.add( (Class)ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); // intbnd.isGenericType()));
+		}
+
+		// --------------- recover from name ?
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			if (isGeneric) {
+				fmx = super.createFamixParameterizableClass(bnd, name, owner);
+			}
+			else {
+				fmx = super.createFamixClass(bnd, name, owner);
+			}
 		}
 		
-		return super.ensureFamixType(bnd, name, owner);
-	}
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setIsInterface(bnd.isInterface());
+			Inheritance lastInheritance = null;
+			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+				lastInheritance = createFamixInheritance(sup, fmx, lastInheritance);
+			}
+			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
+			if (fmx.getIsAbstract()) {
+				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
+				fmx.addModifiers("abstract");
+			}
+		}
 	
-	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
-		Collection<Type> fmxTypes = new ArrayList<Type>();
-		Type fmxType = null;
-		
-		for (TypeParameter type : types) {
-			ITypeBinding bnd = type.resolveBinding();
-			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, null, null);
-			} else {
-				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+		return fmx;
+	}
+
+	public ParameterizedType ensureFamixParameterizedType(ITypeBinding bnd, String name, ParameterizableClass generic, ContainerEntity owner) {
+		ParameterizedType fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.createFamixParameterizedType(null, name, generic, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null); //parentClass.isGenericType());
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.createFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- recover from name ?
+		for (ParameterizedType candidate : getEntityByName(ParameterizedType.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
 			}
-			fmxTypes.add(fmxType);
+		}
+
+		if (fmx == null) {
+			fmx = super.createFamixParameterizedType(bnd, name, generic, owner);
 		}
-		return fmxTypes;
+
+		return fmx;
 	}
-	
-	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
+
+	public PrimitiveType createFamixPrimitiveType(ITypeBinding bnd, String name) {
 		if (name == null) {
 			if (bnd == null) {
 				return null;
@@ -169,10 +365,10 @@
 				name = bnd.getName();
 			}
 		}
-		return super.ensureFamixPrimitiveType(bnd, name);
+		return super.createFamixPrimitiveType(bnd, name);
 	}
 
-	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
+	public fr.inria.verveine.core.gen.famix.Enum createFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
 		fr.inria.verveine.core.gen.famix.Enum fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
@@ -180,7 +376,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.ensureFamixEnum(null, name, owner);
+			return super.createFamixEnum(null, name, owner);
 		}
 
 		// --------------- name
@@ -197,7 +393,7 @@
 			else {
 				ITypeBinding parentClass = bnd.getDeclaringClass();
 				if (parentClass != null) {
-					owner = this.ensureFamixClass(parentClass, null, null);
+					owner = this.createFamixClass(parentClass, null, null);
 				}
 				else {
 					IPackageBinding parentPckg = bnd.getPackage();
@@ -205,7 +401,7 @@
 						owner = this.ensureFamixNamespace(parentPckg, null);
 					}
 					else {
-						owner = this.ensureFamixNamespaceDefault();
+						owner = this.createFamixNamespaceDefault();
 					}
 				}
 			}
@@ -220,7 +416,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.ensureFamixEnum(bnd, name, owner);
+			fmx = super.createFamixEnum(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -242,7 +438,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of creating an EnumValue without a declaring Enum type? 
 			}
-			return super.ensureFamixEnumValue(null, name, owner);
+			return super.createFamixEnumValue(null, name, owner);
 		}
 
 		// --------------- name
@@ -252,7 +448,7 @@
 
 		// --------------- owner
 		if (owner == null) {
-			owner = ensureFamixEnum(bnd.getDeclaringClass(), null, null);
+			owner = createFamixEnum(bnd.getDeclaringClass(), null, null);
 		}
 		
 		// --------------- recover from name ?
@@ -263,7 +459,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixEnumValue(bnd, name, owner);
+			fmx = super.createFamixEnumValue(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -282,7 +478,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.ensureFamixAnnotationType(null, name, owner);
+			return super.createFamixAnnotationType(null, name, owner);
 		}
 
 		// --------------- name
@@ -297,7 +493,7 @@
 				owner = this.ensureFamixNamespace(parentPckg, null);
 			}
 			else {
-				owner = this.ensureFamixNamespaceDefault();
+				owner = this.createFamixNamespaceDefault();
 			}
 		}
 
@@ -310,7 +506,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.ensureFamixAnnotationType(bnd, name, owner);
+			fmx = super.createFamixAnnotationType(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -329,7 +525,7 @@
 			if (name == null) {
 				return null;
 			}
-			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
+			return super.createFamixAnnotationTypeAttribute(null, name, owner);
 		}
 
 		// --------------- name
@@ -354,7 +550,7 @@
 		}
 
 		if (fmx == null) {
-			fmx = super.ensureFamixAnnotationTypeAttribute(bnd, name, owner);
+			fmx = super.createFamixAnnotationTypeAttribute(bnd, name, owner);
 		}
 		
 		if (fmx!=null) {
@@ -378,14 +574,8 @@
 		}
 	}
 
-	/**
-	 * Returns a Famix Class associated with the ITypeBinding.
-	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner) {
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
+	public ParameterType createFamixParameterType(ITypeBinding bnd,	String name, ParameterizableClass owner) {
+		ParameterType fmx = null;
 
 		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
@@ -393,115 +583,41 @@
 				return null;
 			}
 			if (owner == null) {
-				owner = ensureFamixNamespaceDefault();
+				return super.createFamixParameterType(null, name, null);
 			}
-			return super.ensureFamixClass(null, name, owner);
-		}
-
-		// --------------- some special cases
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
-		}
-
-		if (bnd.isPrimitive()) {
-			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
-			return null;
+			
+			return super.createFamixParameterType(null, name, owner);
 		}
 
-		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		fmx = (ParameterType)getEntityByKey(bnd);	// to avoid useless computations if we can
 		if (fmx != null) {
 			return fmx;
 		}
 
 		// --------------- name
 		if (name == null) {
-			if (! bnd.isAnonymous()) {
-				name = bnd.getName();
-			}
-			else { // anonymous class
-				if (bnd.getSuperclass() != null) {
-					name = bnd.getSuperclass().getName();
-				}
-				if ( (name == null) || name.equals(OBJECT_NAME)) {
-					ITypeBinding[] intfcs = bnd.getInterfaces();
-					if ( (intfcs != null) && (intfcs.length > 0) ) {
-						name = bnd.getInterfaces()[0].getName();
-					}
-					else {
-						name = "???";
-					}
-				}
-				name = "anonymous(" + name + ")";
-			}
-		}
-		
-		if (name.equals(OBJECT_NAME)) {
-			return ensureFamixClassObject(bnd);
+			name = bnd.getName();
 		}
 
 		// --------------- owner
 		if (owner == null) {
-			IMethodBinding parentMtd = bnd.getDeclaringMethod();
-			if (parentMtd != null) {
-				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
-			}
-			else {
-				ITypeBinding parentClass = bnd.getDeclaringClass();
-				if (parentClass != null) {
-					owner = this.ensureFamixClass(parentClass, null, null);
-				}
-				else {
-					IPackageBinding parentPckg = bnd.getPackage();
-					if (parentPckg != null) {
-						owner = this.ensureFamixNamespace(parentPckg, null);
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
-				}
-			}
-		}
-
-		// --------------- superclasses (including interfaces)
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
-		if (! bnd.isInterface()) {
-			ITypeBinding supbnd = bnd.getSuperclass();
-			if (supbnd != null) {
-				sups.add(this.ensureFamixClass(supbnd, null, null));
-			}
-			else {
-				sups.add( ensureFamixClassObject(null));
+			ITypeBinding parentClass = bnd.getDeclaringClass();
+			if (parentClass != null) {
+				owner = (ParameterizableClass) this.ensureFamixType(parentClass, /*name*/null, /*owner*/null, /*ctxt*/null);  // isGeneric=true
 			}
 		}
-		for (ITypeBinding intbnd : bnd.getInterfaces()) {
-			sups.add( ensureFamixClass(intbnd, null, null));
-		}
 
 		// --------------- recover from name ?
 		for (Type candidate : this.getEntityByName(Type.class, name)) {
-			if ( checkAndMapClass(bnd, candidate) ) {
-				fmx = (Class) candidate;
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = (ParameterType) candidate;
 				break;
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixClass(bnd, name, owner);
+			fmx = super.createFamixParameterType(bnd, name, owner);
 		}
-		
-		if (fmx!=null) {
-			// we just created it or it was not bound, so we make sure it has the right information in it
-			fmx.setIsInterface(bnd.isInterface());
-			Inheritance lastInheritance = null;
-			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
-			}
-			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
-			if (fmx.getIsAbstract()) {
-				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
-				fmx.addModifiers("abstract");
-			}
-		}
-	
+
 		return fmx;
 	}
 
@@ -696,8 +812,18 @@
 			}
 
 			// ... and the signature should include the return type
-			if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
-				return false;
+			if (bnd.isConstructor()) {
+				if ( ((Method) candidate).getDeclaredType() != null) {
+					return false;
+				}
+			}
+			else {
+				if ( ((Method) candidate).getDeclaredType() == null) {
+					return false;
+				}
+				if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
+					return false;
+				}
 			}
 		}
 
@@ -766,7 +892,7 @@
 	/**
 	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
 	 * The Entity is created if it does not exist.
-	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
+	 * Params: see {@link Dictionary#createFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
@@ -805,9 +931,9 @@
 				sig = name + sig;
 			}
 			if (owner == null) {
-				owner= ensureFamixClassStubOwner();
+				owner= createFamixClassStubOwner();
 			}
-			return super.ensureFamixMethod(null, name, sig, ret, owner);
+			return super.createFamixMethod(null, name, sig, ret, owner);
 		}
 
 		// --------------- name
@@ -835,13 +961,16 @@
 
 		// --------------- return type
 		if ( (ret == null) && (! bnd.isConstructor()) ) {
-			ret = this.ensureFamixType(bnd.getReturnType(), null, null);
+			ret = this.ensureFamixType(bnd.getReturnType(), null, null, owner);
 		}
 		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
-			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if (classBnd != null) {
+				owner = (Class) ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);  // classBnd.isGenericType());
+			}
 		}
 		
 		// --------------- recover from name ?
@@ -852,7 +981,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = ensureFamixMethod(bnd, name, sig, ret, owner);
+			fmx = createFamixMethod(bnd, name, sig, ret, owner);
 		}
 		
 		if (fmx!=null) {
@@ -866,6 +995,10 @@
 	}
 	
 	public String findTypeName(org.eclipse.jdt.core.dom.Type t) {
+		if (t == null) {
+			return null;
+		}
+		
 		if (t.isPrimitiveType()) {
 			return t.toString();
 		}
@@ -879,17 +1012,22 @@
 			return findTypeName( ((ArrayType)t).getElementType() );
 		}
 		else if (t.isParameterizedType()) {
-			return "?";  // TODO
+			return findTypeName(((org.eclipse.jdt.core.dom.ParameterizedType)t).getType());
 		}
 		else { // it is a WildCardType
-			return "?"; // TODO
+			if ( ((org.eclipse.jdt.core.dom.WildcardType)t).isUpperBound() ) {
+				return findTypeName( ((org.eclipse.jdt.core.dom.WildcardType)t).getBound() );
+			}
+			else {
+				return OBJECT_NAME;
+			}
 		}
 	}
 
 	/**
 	 * Returns a Famix Attribute associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)}.
+	 * Params: see {@link Dictionary#createFamixAttribute(Object, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
@@ -903,7 +1041,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of creating an attribute for which we ignore the declaring class? 
 			}
-			return super.ensureFamixAttribute(null, name, type, owner);
+			return super.createFamixAttribute(null, name, type, owner);
 		}
 
 		// --------------- name
@@ -913,12 +1051,15 @@
 
 		// --------------- return type
 		if (type == null) {
-			type = this.ensureFamixType(bnd.getType(), null, null);
+			type = this.ensureFamixType(bnd.getType(), null, null, owner);
 		}
 
 		// --------------- owner
 		if (owner == null) {
-			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if (classBnd != null) {
+				owner = ensureFamixType(classBnd, /*name*/null, /*owner*/null, /*ctxt*/null);   // classBnd.isGenericType());
+			}
 		}
 		
 		// --------------- recover from name ?
@@ -929,7 +1070,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixAttribute(bnd, name, type, owner);
+			fmx = super.createFamixAttribute(bnd, name, type, owner);
 		}
 		
 		if (fmx!=null) {
@@ -962,7 +1103,7 @@
 	/**
 	 * Returns a Famix Parameter associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
+	 * Params: see {@link Dictionary#createFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Parameter ensureFamixParameter(IVariableBinding bnd, String name, Type typ, Method owner) {
@@ -975,7 +1116,7 @@
 			if (owner == null) {
 				owner = ensureFamixStubMethod("<"+name+"_owner>");
 			}
-			return super.ensureFamixParameter(null, name, typ, owner);
+			return super.createFamixParameter(null, name, typ, owner);
 		}
 
 		// --------------- name
@@ -985,7 +1126,7 @@
 
 		// --------------- return type
 		if (typ == null) {
-			typ = this.ensureFamixType(bnd.getType(), null, null);
+			typ = this.ensureFamixType(bnd.getType(), null, null, owner.getParentType());  // context of the parameter def = the class definition
 		}
 
 		// --------------- owner
@@ -1001,7 +1142,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixParameter(bnd, name, typ, owner);
+			fmx = super.createFamixParameter(bnd, name, typ, owner);
 		}
 		
 		if (fmx != null) {
@@ -1016,7 +1157,7 @@
 	/**
 	 * Returns a Famix LocalVariable associated with the IVariableBinding.
 	 * The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
+	 * Params: see {@link Dictionary#createFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
 	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
 	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, String name, Type typ, Method owner) {
@@ -1029,7 +1170,7 @@
 			if (owner == null) {
 				return null;  // what would be the interest of a local variable for which we ignore the declaring method?
 			}
-			return super.ensureFamixLocalVariable(null, name, typ, owner);
+			return super.createFamixLocalVariable(null, name, typ, owner);
 		}
 
 		// --------------- name
@@ -1039,7 +1180,7 @@
 
 		// --------------- return type
 		if (typ == null) {
-			typ = this.ensureFamixType(bnd.getType(), null, null);
+			typ = this.ensureFamixType(bnd.getType(), null, null, owner);
 		}
 
 		// --------------- owner
@@ -1055,7 +1196,7 @@
 			}
 		}
 		if (fmx == null) {
-			fmx = super.ensureFamixLocalVariable(bnd, name, typ, owner);
+			fmx = super.createFamixLocalVariable(bnd, name, typ, owner);
 		}
 		
 		if (fmx != null) {
@@ -1132,7 +1273,7 @@
 	 * @return the Famix Method
 	 */
 	public Method ensureFamixStubMethod(String name) {
-		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, ensureFamixClassStubOwner());  // cast needed to desambiguate the call
+		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, createFamixClassStubOwner());  // cast needed to desambiguate the call
 	}
 
 	/**
@@ -1153,7 +1294,7 @@
 	 * @return a Famix class for "Object"
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
+		fr.inria.verveine.core.gen.famix.Class fmx =  createFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
 		
 		if (fmx != null) {
 			fmx.setContainer( ensureFamixNamespaceJavaLang(null));
@@ -1174,9 +1315,9 @@
 	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
 	 * @return a Famix class
 	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
-		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+	public fr.inria.verveine.core.gen.famix.Class createFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx = super.createFamixClassStubOwner();
+		createFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 
 		return fmx;
 	}
@@ -1188,10 +1329,10 @@
 	 * @return a Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
+		fr.inria.verveine.core.gen.famix.Class fmx = createFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
 		if (fmx != null) {
-			ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
-			fmx.setContainer( ensureFamixNamespaceDefault());
+			createFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+			fmx.setContainer( createFamixNamespaceDefault());
 			
 			fmx.setIsAbstract(Boolean.FALSE);
 			fmx.setIsFinal(Boolean.FALSE);
@@ -1218,6 +1359,4 @@
 		return ret;
 	}
 
-
-
 }
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 90)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 91)
@@ -39,9 +39,9 @@
 	@Override
 	public boolean compile(String[] argv) {
 		boolean ret;
-		/*if (this.linkToExisting()) {
+		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
-		}*/
+		}
 
 		setInitialArgs(argv);
 		ret = super.compile(argv);
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 51)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 52)
@@ -23,6 +23,7 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
@@ -356,6 +357,23 @@
 		return fmx;
 	}
 	
+	/**
+	 * Creates and returns a FAMIX Parameter and associates it with an BehaviouralEntity
+	 * @param identifier -- the name of the parameter
+	 * @param owner -- the entity concerned by this parameter
+	 * @param type -- the type of the parameter
+	 * @return the FAMIX parameter
+	 */
+	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, String type) {
+		Parameter fmx = new Parameter();
+		fmx.setName(identifier);
+		fmx.setParentBehaviouralEntity(owner);
+		fmx.setDeclaredType(ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type));
+		this.famixRepo.add(fmx);
+		
+		return fmx;
+	}
+	
 	///// ensure Famix Relationships /////
 
 	/**
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java
===================================================================
--- verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 23)
+++ verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 24)
@@ -17,25 +17,16 @@
 	 * Returns a Collection of all FAMIXEntities in repository of the given fmxClass.
 	 * Same method as listAll(Class<T extends Entity>) defined in VerveineParser
 	 */
-	@SuppressWarnings("unchecked")
 	public static <T extends Entity> Collection<T> selectElementsOfType(Repository repository, Class<T> fmxClass) {
-		Collection<T> selection = new Vector<T>();
-		for (Object obj : repository.getElements()) {
-			if (fmxClass.isInstance(obj)) {
-				selection.add((T) obj);
-			}
-		}
-		return selection;
+		return( repository.all(fmxClass));
 	}
 
 	/** Returns the first FAMIXEntities in repository of the given fmxClass and with the given name
 	 */
-	@SuppressWarnings("unchecked")
 	public static <T extends NamedEntity> T detectElement(Repository repository, Class<T> fmxClass, String name) {
-		for (Object obj : repository.getElements()) {
-			if (fmxClass.isInstance(obj)
-				&& ((T) obj).getName().equals(name) ) {
-				return (T) obj;
+		for (T ent : selectElementsOfType(repository, fmxClass)) {
+			if (ent.getName().equals(name) ) {
+				return ent;
 			}
 		}
 		return null;
@@ -43,13 +34,11 @@
 
 	/** Returns a Collection of FAMIXEntities in repository of the given fmxClass and with the given name
 	 */
-	@SuppressWarnings("unchecked")
 	public static <T extends NamedEntity> Collection<T> listElements(Repository repository, Class<T> fmxClass, String name) {
 		Collection<T> selection = new Vector<T>();
-		for (Object obj : repository.getElements()) {
-			if (fmxClass.isInstance(obj)
-				&& ((T) obj).getName().equals(name) ) {
-				selection.add((T) obj);
+		for (T ent : selectElementsOfType(repository, fmxClass)) {
+			if ( ent.getName().equals(name) ) {
+				selection.add(ent);
 			}
 		}
 		return selection;
Index: verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 23)
+++ verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 24)
@@ -1,5 +1,6 @@
 package fr.inria.verveine.core;
 
+import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -21,19 +22,35 @@
 	private Repository famixRepo;
 
 	public VerveineParser() {
-		super(new PrintWriter(System.out), new PrintWriter(System.err), false/*systemExitWhenFinished*/, null/*customDefaultOptions*/, null/*compilationProgress*/);
+		this(new PrintWriter(System.out),
+				new PrintWriter(System.err),
+				false/*systemExitWhenFinished*/,
+				null/*customDefaultOptions*/,
+				null/*compilationProgress*/);
+		
 	}
 
-	@Override
-	public boolean compile(String[] argv) {
-
+	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
+		super(outWriter,
+				errWriter,
+				systemExitWhenFinished,
+				customDefaultOptions,
+				compilationProgress);
+		
 		setFamixRepo(new Repository(FAMIXModel.metamodel()));
-
-		boolean ret = super.compile(argv);
-
-		return ret;
 	}
 
+	public boolean linkToExisting() {
+		File existingMSE = new File(OUTPUT_FILE);
+		if (! existingMSE.exists()) {
+			return false;
+		}
+		else {
+			this.getFamixRepo().importMSEFile(OUTPUT_FILE);
+			return true;
+		}
+	}
+	
 	/**
 	 * Outputting repository to a file
 	 */
@@ -46,10 +63,6 @@
 		}
 	}
 
-	public VerveineParser(PrintWriter outWriter, PrintWriter errWriter,	boolean systemExitWhenFinished, @SuppressWarnings("rawtypes")Map customDefaultOptions, CompilationProgress compilationProgress) {
-		super(outWriter, errWriter, systemExitWhenFinished,	customDefaultOptions, compilationProgress);
-	}
-
 	/**
 	 * Returns a Collection of all FAMIXEntities in the repository of the given fmxClass
 	 */
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 23)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 24)
@@ -80,8 +80,84 @@
 		this.mapBind = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
 		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
 	}
 
+	protected void recoverExistingRepository() {
+		for (Object obj : famixRepo.getElements()) {
+			if (obj instanceof NamedEntity) {
+				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
+			}
+		}
+		
+		for (Access acc : famixRepo.all(Access.class)) {
+			try {
+				if (acc.getIsWrite()) { }
+			}
+			catch (NullPointerException e) {
+				acc.setIsWrite(Boolean.FALSE);
+			}
+		}
+
+		for (fr.inria.verveine.core.gen.famix.Class clazz : famixRepo.all(fr.inria.verveine.core.gen.famix.Class.class)) {
+			try { if (clazz.getIsAbstract()) { } }
+			catch (NullPointerException e) { clazz.setIsAbstract(Boolean.FALSE); }
+			try { if (clazz.getIsStub()) { } }
+			catch (NullPointerException e) { clazz.setIsStub(Boolean.FALSE); }
+			try { if (clazz.getIsPublic()) { } }
+			catch (NullPointerException e) { clazz.setIsPublic(Boolean.FALSE); }
+			try { if (clazz.getIsPrivate()) { } }
+			catch (NullPointerException e) { clazz.setIsPrivate(Boolean.FALSE); }
+			try { if (clazz.getIsProtected()) { } }
+			catch (NullPointerException e) { clazz.setIsProtected(Boolean.FALSE); }
+			try { if (clazz.getIsFinal()) { } }
+			catch (NullPointerException e) { clazz.setIsFinal(Boolean.FALSE); }
+		}
+
+		for (Method meth : famixRepo.all(Method.class)) {
+			try { if (meth.getIsAbstract()) { } }
+			catch (NullPointerException e) { meth.setIsAbstract(Boolean.FALSE); }
+			try { if (meth.getIsStub()) { } }
+			catch (NullPointerException e) { meth.setIsStub(Boolean.FALSE); }
+			try { if (meth.getIsPublic()) { } }
+			catch (NullPointerException e) { meth.setIsPublic(Boolean.FALSE); }
+			try { if (meth.getIsPrivate()) { } }
+			catch (NullPointerException e) { meth.setIsPrivate(Boolean.FALSE); }
+			try { if (meth.getIsProtected()) { } }
+			catch (NullPointerException e) { meth.setIsProtected(Boolean.FALSE); }
+			try { if (meth.getIsFinal()) { } }
+			catch (NullPointerException e) { meth.setIsFinal(Boolean.FALSE); }
+		}
+
+		for (Attribute att : famixRepo.all(Attribute.class)) {
+			try { if (att.getIsAbstract()) { } }
+			catch (NullPointerException e) { att.setIsAbstract(Boolean.FALSE); }
+			try { if (att.getIsStub()) { } }
+			catch (NullPointerException e) { att.setIsStub(Boolean.FALSE); }
+			try { if (att.getIsPublic()) { } }
+			catch (NullPointerException e) { att.setIsPublic(Boolean.FALSE); }
+			try { if (att.getIsPrivate()) { } }
+			catch (NullPointerException e) { att.setIsPrivate(Boolean.FALSE); }
+			try { if (att.getIsProtected()) { } }
+			catch (NullPointerException e) { att.setIsProtected(Boolean.FALSE); }
+			try { if (att.getIsFinal()) { } }
+			catch (NullPointerException e) { att.setIsFinal(Boolean.FALSE); }
+		}
+
+	}
+	
+	protected void mapEntityToName(String name, NamedEntity ent) {
+		Collection<NamedEntity> l_ent = mapName.get(name);
+		if (l_ent == null) {
+			l_ent = new LinkedList<NamedEntity>();
+		}
+		l_ent.add(ent);
+		mapName.put(name, l_ent);
+	}
+	
 	/**
 	 * Returns all the Famix Entity with the given name and class 
 	 * @param fmxClass -- the subtype of Famix Entity we are looking for
@@ -142,14 +218,8 @@
 			fmx.setName(name);
 			fmx.setIsStub(Boolean.TRUE);
 
-			// put new entity in mappers
-			Collection<NamedEntity> l_ent = mapName.get(name);
-			if (l_ent == null) {
-				l_ent = new LinkedList<NamedEntity>();
-			}
-			l_ent.add(fmx);
-			mapName.put(name, l_ent);
-
+			mapEntityToName(name, fmx);
+			
 			// put new entity in Famix repository
 			this.famixRepo.add(fmx);
 		}
@@ -357,16 +427,20 @@
 		return invok;
 	}
 	
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
 		/* We keep multiple accesses from one method to a field */
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
-		acc.setIsWrite(false);  // must be some default and this one seems safer than the opposite
+		acc.setIsWrite(new Boolean(isWrite));
 		famixRepoAdd(acc);
 		
 		return acc;
 	}
+	
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
+		return ensureFamixAccess(accessor, var, false);  // must be some default and this one seems safer than the opposite
+	}
 
 	/**
 	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 23)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 24)
@@ -60,7 +60,6 @@
     @FameProperty(name = "isRead", derived = true)
     public Boolean getIsRead() {
         // TODO: this is a derived property, implement this method manually.
-        //throw new UnsupportedOperationException("Access.getIsRead() Not yet implemented!");
     	return ! getIsWrite(); 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 23)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 24)
@@ -11,11 +11,11 @@
 public class Class extends Type {
 
 
-
+	// Apparently, we should not use getIsAbstract() (from NamedEntity) here ?!?!?
     @FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
-        return super.getIsAbstract() || this.getModifiers().contains("abstract");
+        return this.getModifiers().contains("abstract");
     }
     
     private Boolean isInterface;
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 90)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
+		<attributes>
+			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/memusage.txt	(revision 90)
@@ -0,0 +1,54 @@
+
+memory usage for Eclipse 3.1
+$ time ./verveinej3_1.sh 2> toto.log >&2
+$ time ./verveinej-mono-3_1.sh 2> toto.log >&2
+
+120.51user 3.31system 2:25.05elapsed 85%CPU 
+(0avgtext+0avgdata 9.646.080maxresident)k
+292144inputs+221248outputs (2356major+700607minor)pagefaults 0swaps
+8522 toto.log
+
+120.79user 2.95system 1:53.51elapsed 109%CPU 
+(0avgtext+0avgdata 9.175.040maxresident)k
+142416inputs+220976outputs (87major+622960minor)pagefaults 0swaps
+8522 toto.log
+3.340.182 output.mse
+
+112.33user 4.35system 1:40.17elapsed 116%CPU 
+(0avgtext+0avgdata 9.777.152maxresident)k
+68760inputs+221504outputs (190major+682907minor)pagefaults 0swaps
+
+$ for i in `grep FAMIX output.mse | sed -e 's/ (id:.*//' | sed -e 's/^        (//' | sort -u`; do echo -n "$i   "; grep -c $i output.mse ; done
+FAMIX.Access   60984
+FAMIX.Attribute   27473
+FAMIX.CaughtException   3690
+FAMIX.Class   7906
+FAMIX.Comment   37000
+FAMIX.DeclaredException   3848
+FAMIX.FileAnchor   124493
+FAMIX.ImplicitVariable   4996
+FAMIX.Inheritance   7136
+FAMIX.Invocation   169940
+FAMIX.LocalVariable   37753
+FAMIX.Method   53602
+FAMIX.Namespace   377
+FAMIX.Parameter   52480
+FAMIX.PrimitiveType   9
+FAMIX.Reference   30799
+FAMIX.ThrownException   2414
+FAMIX.UnknownVariable   23090
+FAMIX   647990
+
+$ grep -c 'null binding' toto.log 
+8413
+
+
+=======================================
+SEPARATE
+
+2041.59user 115.58system 27:47.42elapsed 129%CPU 
+(0avgtext+0avgdata 7.086.080maxresident)k
+135200inputs+6149832outputs (110major+16978083minor)pagefaults 0swaps
+
+
+FAMIX.Attribute   27520
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.project
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.project	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.project	(revision 90)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>verveine.extractor.java</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/fame.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.runtime_3.6.0.v20100505.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.runtime_3.6.0.v20100505.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.equinox.common_3.6.0.v20100503.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.equinox.common_3.6.0.v20100503.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.extractor.java.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.jobs_3.5.0.v20100515.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.core.jobs_3.5.0.v20100515.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.osgi_3.6.0.v20100517.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.eclipse.osgi_3.6.0.v20100517.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java	(revision 90)
@@ -0,0 +1,55 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class WorkStation extends Node {
+
+	private String type;
+	
+	/*
+	 * 	This is how packets get inserted into the network. This is a likely method to be rwritten to permit  
+	 * 	packets to be entered in various ways. Currently, I assume that someone alse creates the packet,  
+	 * 	and passes it to me as an argument. 
+	 */
+	public void originate(Packet thePacket) {
+		thePacket.originator(this);
+		send(thePacket);
+	}
+	
+	/*
+	 * accept the packet and see if I am the originator. If this is the case, take the packet out 
+	 * because the addressee is unknown. Print this on the Transcript.
+	 * 
+	 * @see moose.lan.Node#accept(moose.lan.Packet)
+	 */
+	public void accept(Packet thePacket) {
+		if( thePacket.originator().equals(this) ) {
+			System.out.println("The receiver of following packet does not exist:");
+			System.out.println(thePacket.toString());
+		} else {
+			send(thePacket);
+		}
+	}
+
+	public boolean canOriginate() {
+		return true;
+	}
+
+	/*
+	 * added for candidate invocations operator test. 
+	 * 
+	 * @see moose.lan.Node#name()
+	 */
+	public String name() {
+		return super.name();
+	}
+
+	
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Node.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Node.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Node.java	(revision 90)
@@ -0,0 +1,70 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class Node {
+
+	private String name;
+	
+	private Node nextNode;
+	
+	
+	public Node() {
+		name("Undefined");
+	}
+	
+	public String name() {
+		return this.name;
+	}
+	
+	public void name(String name) {
+		this.name = name;
+	}
+	
+	public Node nextNode() {
+		return this.nextNode;
+	}
+	
+	public void nextNode(Node node) {
+		this.nextNode = node;
+	}
+	
+	public void methodWithEmptyBody() {
+	}
+
+	public boolean canOutput() {
+		return false;
+	}
+	
+	public boolean canOriginate() {
+		return false;
+	}
+	
+	/*
+	 * Having received the packet, send it on. This is the default behavior. 
+	 * My subclasses will probably override this method to do something special 
+	 */
+	public void accept(Packet thePacket) {
+		send(thePacket);
+	}
+	
+	//	Display debug information in the Transcript, then send the packet to the node which whom I communicate
+	public void send(Packet thePacket) {
+		System.out.println(name() + " sending the packet to " + nextNode().name());
+		nextNode().accept(thePacket);
+	}
+	
+	public void printOn(StringBuffer aStream) {
+		aStream.append(": ").append(name());
+		if( nextNode() != null ) {
+			aStream.append(", pointing to ").append(nextNode().name());
+		}
+	}
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java	(revision 90)
@@ -0,0 +1,55 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Packet;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class PrintServer extends OutputServer {
+	
+	private IPrinter printer;
+	
+	public class XPrinter implements IPrinter {
+
+		private int uselessNumber;
+		
+		/* (non-Javadoc)
+		 * @see moose.lan.server.IPrinter#print(java.lang.String, boolean)
+		 */
+		public void print(String contents, boolean rv) {
+		}
+		
+		public int idNumber() {
+			return this.uselessNumber;
+		}
+		
+	}
+	
+	public PrintServer() {
+		this.printer = new IPrinter() {
+			public void print(String contents, boolean rv) {
+				System.out.println(contents);		
+			}
+		};
+	}
+	
+
+	/* (non-Javadoc)
+	 * @see moose.lan.server.OutputServer#output(moose.lan.Packet)
+	 */
+	@Override
+	public void output(Packet thePacket) {
+		System.out.println();
+		for (int i = 0; i < 80; i++) {
+			System.out.print("-");
+		}
+		System.out.println();
+		this.printer.print("Printer " + name() + " prints " + thePacket.contents(), false);
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java	(revision 90)
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Packet;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class FileServer extends OutputServer {
+
+	/* (non-Javadoc)
+	 * @see moose.lan.server.OutputServer#output(moose.lan.Packet)
+	 */
+	public void output(Packet thePacket) {
+		System.out.println();
+		System.out.println("FileServer " + name() + " saves " + thePacket.contents());
+	}
+	
+	public String name() {
+		return super.name();
+	}
+	
+	public void setServerType() {
+		this.serverType = "FileServer";
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java	(revision 90)
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Node;
+import moose.lan.Packet;
+
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public abstract class OutputServer extends Node {
+
+	protected String serverType = null;
+	
+	/*
+	 * I first see if the packet is for me. If it is, I output it. Otherwise, I pass it on.
+	 */
+	public void accept(Packet thePacket) {
+		if( thePacket.addressee().isDestinationFor(name()) ) {
+			output(thePacket);
+		} else {
+			send(thePacket);
+		}
+	}
+	
+	public boolean canOutput() {
+		return true;
+	}
+	
+	/*
+	 * My subclasses have to use this method to define their outputting behavior.
+	 */
+	public abstract void output(Packet thePacket);
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java	(revision 90)
@@ -0,0 +1,15 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+/**
+ * @author Simon Denier
+ * @since Mar 6, 2009
+ *
+ */
+public interface IPrinter {
+	
+	public void print(String contents, boolean rv);
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java	(revision 90)
@@ -0,0 +1,47 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class Packet {
+
+	private String contents;
+	private SingleDestinationAddress addressee;
+	private Node originator;
+	
+	public String contents() {
+		return this.contents;
+	}
+	
+	public void contents(String contents) {
+		this.contents = contents;
+	}
+	
+	public SingleDestinationAddress addressee() {
+		return this.addressee;
+	}
+	
+	public void addressee(SingleDestinationAddress addressee) {
+		this.addressee = addressee;
+	}
+	
+	public Node originator() {
+		return this.originator;
+	}
+
+	public void originator(Node originator) {
+		this.originator = originator;
+	}
+	
+	public void printOn(StringBuffer aStream) {
+		if( originator()!=null ) {
+			aStream.append(" coming from ").append(originator().name());
+		}
+		aStream.append(" addressed to " + addressee().id() + " with contents: " + contents());
+	}
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java	(revision 90)
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class SingleDestinationAddress extends AbstractDestinationAddress {
+
+	private String id;
+	
+	public String id() {
+		return this.id;
+	}
+	
+	public void id(String id) {
+		this.id = id;
+	}
+	
+	/* (non-Javadoc)
+	 * @see moose.lan.AbstractDestinationAddress#isDestinationFor(moose.lan.AbstractDestinationAddress)
+	 */
+	@Override
+	public boolean isDestinationFor(String id) {
+		return this.equalsSingle(id);
+	}
+
+	/**
+	 * @param singleDestinationAddress
+	 * @return
+	 */
+	public boolean equalsSingle(String id) {
+		return id().equals(id);
+	}
+	
+	public boolean equalsMultiple(AbstractDestinationAddress anAddress) {
+		return false;
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java	(revision 90)
@@ -0,0 +1,15 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public abstract class AbstractDestinationAddress {
+
+	public abstract boolean isDestinationFor(String id);
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 90)
@@ -0,0 +1,143 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+
+public class Dictionary<B> {
+
+	protected Map<B,NamedEntity> mapBind;
+
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	protected class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+
+	/* method added to test a specific bug with constructor declaration having a null binding */
+	public Dictionary(T arg) {
+		System.out.println(arg + " is not used");
+	}
+	
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	public NamedEntity getEntityByBinding(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapBind.get(bnd);
+		}
+	}
+
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+		T fmx = null;
+
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			mapEntityToName(name, fmx);
+			
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		else {
+			// Unfortunately different entities with the same name and same type may exist
+			// e.g. 2 parameters of 2 different methods but having the same name
+			// so we must recreate a new entity each time
+
+			//fmxEnt = getEntityByName(fmxClass, name);
+		}
+
+		if (fmx != null) {
+			return fmx;
+		}
+
+		fmx = createFamixEntity(fmxClass, name);
+		// put new entity in mappers
+		if (bnd != null) {
+			mapBind.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 90)
@@ -0,0 +1,40 @@
+package ad_hoc;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Card {
+
+	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
+
+	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
+        SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
+
+    private final Rank rank;
+    private final Suit suit;
+    private Card(Rank rank, Suit suit) {
+        this.rank = rank;
+        this.suit = suit;
+    }
+
+    public Rank rank() { return rank; }
+    public Suit suit() { return suit; }
+    public String toString() { return rank + " of " + suit; }
+
+    private static final List<Card> protoDeck = new ArrayList<Card>();
+
+    // Initialize prototype deck
+    static {
+        for (Suit s : Suit.values())
+            for (Rank r : Rank.values()) {
+            	if (r == Rank.QUEEN) {
+            		System.out.println("God save the Queen!");
+            		}
+            	protoDeck.add(new Card(r, s));
+            }
+    }
+
+    public static ArrayList<Card> newDeck() {
+        return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
+    }
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Element.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 90)
@@ -0,0 +1,89 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame.fm3;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.Named;
+import ch.akuhn.fame.Nested;
+import ch.akuhn.fame.internal.Warnings;
+
+/**
+ * Abstract superclass of MSE metamodel.
+ * 
+ * This is an abstract class with attributes </p>
+ * <ul>
+ * <li>Element <code>owner</code> (derived)</li>
+ * <li>String <code>fullname</code> (derived)</li>
+ * <li>String <code>name</code></li>
+ * </ul>
+ * <p>
+ * with these constraints
+ * </p>
+ * <ul>
+ * <li> <code>name</code> must be alphanumeric</li>
+ * <li> <code>fullname</code> is derived recursively, concatenating
+ * <code>owner.fullname</code> and <code>name</code></li>
+ * <li> <code>fullname</code> is separated by dots, eg
+ * <code>MSE.Class.attributes</code></li>
+ * </ul>
+ * 
+ * @author Adrian Kuhn
+ * 
+ */
+@FamePackage("FM3")
+@FameDescription("Element")
+public abstract class Element implements Named, Nested {
+
+    private String name;
+
+    public Element() {
+    }
+
+    public Element(String name) {
+        this.name = name;
+    }
+
+    @FameProperty(derived = true)
+    public String getFullname() {
+        Element parent = this.getOwner();
+        return parent == null ? this.getName() : parent.getFullname() + "." + this.getName();
+    }
+
+    @FameProperty
+    public String getName() {
+        return name;
+    }
+
+    @FameProperty(derived = true)
+    public abstract Element getOwner();
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return this.getFullname();
+    }
+    
+    public abstract void checkConstraints(Warnings warnings);
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/ReadException.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 90)
@@ -0,0 +1,4 @@
+package OMGL2;
+public class ReadException extends Exception {
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 90)
@@ -0,0 +1,47 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Attaches FM3-related meta-information to class members (ie fields or
+ * methods).
+ * 
+ * @author akuhn
+ * 
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target( { ElementType.METHOD, ElementType.FIELD })
+public @interface FameProperty {
+
+    boolean container() default false;
+
+    boolean derived() default false;
+
+    String name() default "*";
+
+    String opposite() default "";
+
+    Class<?> type() default Void.class;
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Client.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 90)
@@ -0,0 +1,70 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+@Override
+@Deprecated
+public class Client {
+	
+	@Override
+	@Deprecated
+	private String num;
+	@Deprecated
+	private String nom;
+
+	@Deprecated
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+	
+	@Override
+	@Deprecated
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+	
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	@Override
+	@Deprecated
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh	(revision 90)
@@ -0,0 +1,53 @@
+#!/bin/bash
+
+if [ -z "$1" ]
+then
+	echo "Usage: verveinej.sh [ <jvm-options> -- ] [ <verveine-options> ] <java-source>" >&2
+	echo "  <verveine-options> from Eclipse JDT Batch Compiler:" >&2
+	echo "" >&2
+fi
+
+# Directory for verveine source
+BASELIB=`dirname $0`/lib
+
+
+# JVM options e.g. -Xmx2500m to augment maximum memory size of the vm to 2.5Go.
+JOPT=""
+# Verveine option
+VOPT=""
+
+# Any argument before "--" is for the JVM
+# Any argument after "--" is for verveine
+# Without "--" every argument goes to verveine
+while [ ${1:-"--"} != "--" ]
+do
+	JOPT="$JOPT $1"
+	shift
+done
+
+if [ "$1" == "--" ]
+then
+	shift
+	VOPT=$*
+else
+	# without the special "--" argument, all options are assumed to be for Verveine
+	VOPT=$JOPT
+	JOPT=""
+fi
+
+CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.extractor.java.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/fame.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/akuhn-util-r28011.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/famix.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.core.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.jdt.core_3.6.0.v_A58.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.jobs_3.5.0.v20100515.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.runtime_3.6.0.v20100505.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.equinox.common_3.6.0.v20100503.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.osgi_3.6.0.v20100517.jar"
+
+
+java $JOPT -cp $CLASSPATH fr.inria.verveine.extractor.java.VerveineJParser $VOPT

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/verveinej.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 90)
@@ -0,0 +1,618 @@
+/**
+ * Copyright (c) 2010 Nicolas Anquetil
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.util.Collection;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.extractor.java.JavaDictionary;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Nicolas Anquetil
+ * @since May 28, 2010
+ *
+ */
+public class VerveineJTest_LanModel {
+
+	private static final String A_CLASS_NAME = "--aClassName--";
+
+	private Repository repo;
+
+	public VerveineJTest_LanModel() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		/*String[] files = new String[] {
+				"AbstractDestinationAddress.java",
+				"Node.java",
+				"Packet.java",
+				"SingleDestinationAddress.java",
+				"WorkStation.java",
+				"server/FileServer.java",
+				"server/IPrinter.java",
+				"server/OutputServer.java",
+				"server/PrintServer.java"
+		};
+
+		// separate parsing of each source file --------
+		for (String f : files) {
+			parseFile(f);
+		}*/
+		// or parsing the entire project in one pass ---
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
+		repo = parser.getFamixRepo();
+	}
+
+	/**
+	 * Parses the file received in parameter independently from any other
+	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
+	 * @param file -- name of the file to parse
+	 */
+/*	private void parseFile(String file) {
+		String[] args = new String[] {
+				"-cp",
+				"test_src/LANModel//moose/lan/",
+				"test_src/LANModel/moose/lan/"+file
+				};
+		
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(args);
+		repo = parser.getFamixRepo();
+		
+		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
+		parser.outputMSE();  // to create a new one
+	}
+*/
+	@After
+	public void tearDown() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+	@Test
+	public void testEntitiesNumber() {
+		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
+		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
+		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
+		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
+	}
+
+	@Test
+	public void testClassProperties() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		assertEquals("Node", nodeClass.getName());
+		assertEquals(11, nodeClass.getMethods().size());
+		assertEquals(2, nodeClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
+		assertFalse(nodeClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(interfce);
+		assertEquals("IPrinter", interfce.getName());
+		assertEquals(1, interfce.getMethods().size());
+		assertEquals(0, interfce.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
+		assertTrue(interfce.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(innerClass);
+		assertEquals("XPrinter", innerClass.getName());
+		assertEquals(2, innerClass.getMethods().size());
+		assertEquals(1, innerClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
+		assertFalse(innerClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
+		assertNotNull(anonClass);
+		assertEquals("anonymous(IPrinter)", anonClass.getName());
+		assertEquals(1, anonClass.getMethods().size());
+		assertEquals(0, anonClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
+		assertFalse(anonClass.getIsInterface());
+	}
+
+	@Test
+	public void testNamedEntities() {
+		JavaDictionary dico = new JavaDictionary(repo);
+		
+		assertNotSame(dico.ensureFamixClass(null, A_CLASS_NAME, null),dico.ensureFamixClass(null, A_CLASS_NAME, null));
+		
+		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
+		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
+		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
+
+		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
+		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
+		assertSame(obj, dico.ensureFamixClassObject(null));
+		assertEquals(0, obj.getSuperInheritances().size());
+		assertSame(javaLang, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
+		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
+		assertSame(fmx, dico.ensureFamixClassStubOwner());
+	}
+
+	@Test
+	public void testInheritance() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<Inheritance> superInheritances;
+		Inheritance inh, inh2 = null;
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(2, superInheritances.size()); // superInheritances: Object and IPrinter (in this order)
+		for (Inheritance inheritance : superInheritances) {
+			assertSame(clazz, inheritance.getSubclass());
+			if (inheritance.getSuperclass().getName().equals("IPrinter")) {
+				inh2 = inheritance;
+				assertNull(inheritance.getNext());
+				assertSame(inheritance,inheritance.getPrevious().getNext());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter"), inheritance.getSuperclass());
+			} else {
+				inh = inheritance;
+				assertNull(inheritance.getPrevious());
+				assertSame(inheritance,inheritance.getNext().getPrevious());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inheritance.getSuperclass());
+			}
+		}
+		assertSame(inh.getNext(), inh2);
+		assertSame(inh2.getPrevious(), inh);
+	}
+
+	@Test
+	public void testMethodProperties() {
+		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
+		assertNotNull(mweb);
+		assertEquals("methodWithEmptyBody", mweb.getName());
+		assertEquals("methodWithEmptyBody()", mweb.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
+
+		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
+		assertNotNull(em);
+		assertEquals("equalsMultiple", em.getName());
+		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
+
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
+		assertNotNull(clazz);
+		Method n = null;
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name")) {
+				n = m;
+				break;
+			}
+		}
+		assertNotNull(n);
+		assertEquals("name", n.getName());
+		assertEquals("name()", n.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
+	}
+
+	@Test
+	public void testFieldType() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		Collection<Attribute> l_atts = clazz.getAttributes();
+		assertEquals(2, l_atts.size());
+		for (Attribute a : l_atts) {
+			if (a.getName().equals("nextNode")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(clazz, a.getDeclaredType());
+			}
+			else if (a.getName().equals("name")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testStubs() {
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
+		assertNotNull(ns);
+		assertEquals(8, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Appendable,CharSequence
+		assertTrue(ns.getIsStub());
+			
+		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
+		assertNotNull(obj);
+		assertTrue(obj.getIsStub());
+		assertSame(ns, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
+		assertNotNull(str);
+		assertTrue(str.getIsStub());
+		assertSame(ns, str.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsStub());
+		
+		/* [].length not used in the default test case 
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
+		assertNotNull(att);
+		clazz = (Class) att.getParentType();
+		assertNotNull(clazz);
+		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
+	}
+
+	@Test
+	public void testParameter() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("Node")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOriginate")) ||
+				 (mNode.getName().equals("canOutput")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
+			}
+			else if ( (mNode.getName().equals("name")) ||
+					  (mNode.getName().equals("nextNode")) ) {
+				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
+			}
+			else if ( (mNode.getName().equals("accept")) ||
+					 (mNode.getName().equals("send")) ||
+					 (mNode.getName().equals("printOn")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
+			}
+		}
+		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(iprintClass);
+		Method mPrint = iprintClass.getMethods().iterator().next();
+		assertEquals(2, mPrint.getParameters().size());
+		for (Parameter p : mPrint.getParameters()) {
+			assertSame(mPrint, p.getParentBehaviouralEntity());
+			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
+			if (p.getName().equals("contents")) {
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
+			}
+			if (p.getName().equals("rv")) {
+				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testInvocation() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("name")) ||
+				 (mNode.getName().equals("nextNode")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOutput")) ||
+				 (mNode.getName().equals("canOriginate")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
+			}
+			else if ( (mNode.getName().equals("Node")) ||
+					  (mNode.getName().equals("accept")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("send"))  {
+				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("printOn")) {
+				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
+			}
+		}
+		
+		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(sdaClass);
+		for (Method mSDA : sdaClass.getMethods()) {
+			for (Invocation inv : mSDA.getOutgoingInvocations()) {
+				assertTrue( "Unexpected method signature: "+inv.getSignature(),
+							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
+				if (inv.getSignature().equals("equalsSingle (String)")) {
+					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
+				}
+				else if (inv.getSignature().equals("id ()")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+				else if (inv.getSignature().equals("equals (Object)")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals(null, inv.getReceiver());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+			}
+		}
+		
+		// test that the chain (next/previous) of invocations is correct
+		for (Method mNode : nodeClass.getMethods()) {
+			if (mNode.getName().equals("accept")) {
+				Invocation invok = mNode.getOutgoingInvocations().iterator().next();
+				assertNull(invok.getPrevious());
+				assertNull(invok.getNext());
+			}
+			else if (mNode.getName().equals("send"))  {
+				int nbNull = 0;
+				for (Invocation invok : mNode.getOutgoingInvocations()) {
+					Invocation previous = (Invocation) invok.getPrevious();
+					if (previous == null) {
+						nbNull++;
+					}
+					else {
+						assertSame(mNode, previous.getSender());
+					}					
+				}
+				assertEquals(1, nbNull);
+			}
+		}
+
+	}
+	
+	@Test
+	public void testAccess() {
+		Attribute att;
+		BehaviouralEntity accessor;
+		
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
+		assertNotNull(att);
+		assertSame(2, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("name", accessor.getName());
+		assertEquals("Node", ((Method)accessor).getParentType().getName());
+
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
+		assertNotNull(att);
+		assertSame(1, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("setServerType", accessor.getName());
+		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
+
+		// finds method PrintServer.output()
+		Method output = null;
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
+			if (m.getParentType().getName().equals("PrintServer")) {
+				output = m;
+				break;
+			}
+		}
+		assertNotNull(output);
+		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		for (Access acc : output.getAccesses()) {
+			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
+						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
+			assertEquals(output, acc.getAccessor());
+		}
+	}
+
+	@Test
+	public void testSourceAnchors() {
+		SourceAnchor anc = null;
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/server/PrintServer.java"));
+		assertEquals(17, ((FileAnchor)anc).getStartLine());
+		assertEquals(31, ((FileAnchor)anc).getEndLine());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/Node.java"));
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(70, ((FileAnchor)anc).getEndLine());
+		
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
+		assertNotNull(meth);
+
+		anc = meth.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(meth, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/SingleDestinationAddress.java"));
+		assertEquals(39, ((FileAnchor)anc).getStartLine());
+		assertEquals(41, ((FileAnchor)anc).getEndLine());
+		
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
+		assertNotNull(meth);
+
+		anc = att.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(att, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().equals("test_src/LANModel/moose/lan/Packet.java"));
+		assertEquals(15, ((FileAnchor)anc).getStartLine());
+		assertEquals(15, ((FileAnchor)anc).getEndLine());
+		
+	}
+
+	@Test
+	public void testModifiers() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsInterface());
+		assertTrue(clazz.getIsAbstract());
+		assertTrue(clazz.getModifiers().contains("abstract"));
+		assertTrue(clazz.getIsPublic());
+		assertFalse(clazz.getIsPrivate());
+		assertFalse(clazz.getIsProtected());
+		assertFalse(clazz.getIsFinal());
+		
+		assertEquals(3, clazz.getMethods().size());
+		for (Method m : clazz.getMethods()) {
+			assertTrue(m.getIsPublic());
+			assertFalse(m.getIsPrivate());
+			assertFalse(m.getIsProtected());
+			assertFalse(m.getIsFinal());
+			if (m.getName().equals("output")) {
+				assertTrue(m.getIsAbstract());
+			}
+			else {
+				assertFalse(m.getIsAbstract());
+			}
+		}
+		
+		assertEquals(1, clazz.getAttributes().size());
+		Attribute a = clazz.getAttributes().iterator().next();
+		assertFalse(a.getIsPublic());
+		assertFalse(a.getIsPrivate());
+		assertTrue(a.getIsProtected());
+		assertFalse(a.getIsFinal());
+	}
+
+	@Test
+	public void testComment() {	
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		Collection<Comment> cmts = clazz.getComments();
+		assertEquals(1, cmts.size());
+		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(10, ((FileAnchor)anc).getEndLine());
+
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
+		assertNotNull(meth);
+		cmts = meth.getComments();
+		assertEquals(1, cmts.size());
+		anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(31, ((FileAnchor)anc).getStartLine());
+		assertEquals(34, ((FileAnchor)anc).getEndLine());
+
+	}
+	
+	@Test
+	public void testMetric() {
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
+			assertNotNull(m);
+			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
+			assertNotNull(owner);
+			if (owner.getName().equals("OutputServer")) {
+			assertEquals(2, m.getCyclo());
+				assertEquals(6, m.getNOS());
+			}
+			else if (owner.getName().equals("Node")) {
+				assertEquals(1, m.getCyclo());
+				assertEquals(1, m.getNOS());
+			}
+			else if (owner.getName().equals("WorkStation")) {
+				assertEquals(2, m.getCyclo());
+				assertEquals(7, m.getNOS());
+			}
+		}		
+	}
+	
+	@Test
+	public void testAnnotation() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<AnnotationInstance> annInstances;
+		
+		AnnotationType annType = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
+		assertNotNull(annType);
+		assertEquals("Override", annType.getName());
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("output")) {
+				assertEquals(1, annInstances.size());
+				AnnotationInstance annInstance = annInstances.iterator().next();
+				assertEquals("Override", annInstance.getAnnotationType().getName());
+				assertSame(annType, annInstance.getAnnotationType());
+				assertSame(method, annInstance.getAnnotatedEntity());
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("isDestinationFor")) {
+				assertEquals(1, annInstances.size());
+				AnnotationInstance annInstance = annInstances.iterator().next();
+				assertEquals("Override", annInstance.getAnnotationType().getName());
+				assertSame(annType, annInstance.getAnnotationType());
+				assertSame(method, annInstance.getAnnotatedEntity());
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}	
+	}
+}
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 90)
@@ -0,0 +1,361 @@
+/**
+ * Copyright (c) 2010 Anquetil Nicolas
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.util.Collection;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.core.gen.famix.Type;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Nicolas Anquetil
+ * @since November 25, 2010
+ *
+ */
+public class VerveineJTest_AdHoc {
+
+	private Repository repo;
+
+	public VerveineJTest_AdHoc() {
+		// make sure we don't have any pre-existing mse lying in the way
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/ad_hoc"});
+		repo = parser.getFamixRepo();
+	}
+
+	@After
+	public void tearDown() {
+		new File(VerveineJParser.OUTPUT_FILE).delete();
+	}
+	
+	@Test
+	public void testExceptions() {
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
+		assertNotNull(meth);
+		
+		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
+		assertNotNull(excepClass);
+
+		assertEquals(1, meth.getDeclaredExceptions().size());
+		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
+		assertSame(meth, exD.getDefiningMethod());
+		assertSame(excepClass, exD.getExceptionClass());
+		
+		assertEquals(1, meth.getThrownExceptions().size());
+		ThrownException exT = meth.getThrownExceptions().iterator().next();
+		assertSame(meth, exT.getDefiningMethod());
+		assertSame(excepClass, exT.getExceptionClass());
+
+		excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "IOException");
+		assertNotNull(excepClass);
+
+		assertEquals(1,meth.getCaughtExceptions().size());
+		CaughtException exC = meth.getCaughtExceptions().iterator().next();
+		assertSame(meth, exC.getDefiningMethod());
+		assertSame(excepClass, exC.getExceptionClass());
+	}
+	
+	@Test
+	public void testAnnotation() {
+		Collection<AnnotationType> l_FmProp = TestVerveineUtils.listElements(repo,AnnotationType.class, "FameProperty");
+		assertEquals(1, l_FmProp.size());
+
+		AnnotationType fmProp = l_FmProp.iterator().next();
+		assertNotNull(fmProp);
+		assertEquals("FameProperty", fmProp.getName());
+		//TODO assertFalse(fmProp.getIsStub());
+		
+		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
+		assertNotNull(fmPckg);
+		assertEquals("FamePackage", fmPckg.getName());
+		assertTrue(fmPckg.getIsStub());
+		
+		AnnotationType fmDesc = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FameDescription");
+		assertNotNull(fmDesc);
+		assertEquals("FameDescription", fmDesc.getName());
+		assertTrue(fmDesc.getIsStub());
+
+		// class annotations 
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Element");
+		assertNotNull(clazz);
+		Collection<AnnotationInstance> annInstances = clazz.getAnnotationInstances();
+		assertEquals(2, annInstances.size());
+		for (AnnotationInstance annotationInstance : annInstances) {
+			assertSame(clazz, annotationInstance.getAnnotatedEntity());
+			if (annotationInstance.getAnnotationType().getName().equals("FamePackage")) {
+				assertSame(fmPckg, annotationInstance.getAnnotationType());
+			} else {
+				assertEquals("FameDescription", annotationInstance.getAnnotationType().getName());
+				assertSame(fmDesc, annotationInstance.getAnnotationType());
+			}
+		}
+
+		AnnotationTypeAttribute decl = null;
+		for (AnnotationTypeAttribute a : TestVerveineUtils.listElements(repo, AnnotationTypeAttribute.class, "derived")) {
+			if (a.getParentAnnotationType() == fmProp) {
+				decl = a;
+				break;
+			}
+		}
+		assertNotNull(decl);
+		
+		// Method annotations
+		for (Method meth : clazz.getMethods()) {
+			annInstances = meth.getAnnotationInstances();
+			if (meth.getName().equals("getFullname") || meth.getName().equals("getName") || meth.getName().equals("getOwner")) {
+				assertEquals(1, annInstances.size());
+				AnnotationInstance annInst = annInstances.iterator().next();
+				assertSame(fmProp, annInst.getAnnotationType());
+				if (meth.getName().equals("getOwner")) {
+					Collection<AnnotationInstanceAttribute> aiAtts = annInst.getAttributes();
+					assertEquals(1, aiAtts.size());
+					AnnotationInstanceAttribute annAtt = aiAtts.iterator().next();
+					assertEquals( annInst, annAtt.getParentAnnotationInstance());
+					assertEquals( "true", annAtt.getValue());
+					assertEquals(decl, annAtt.getAnnotationTypeAttribute());
+				}
+			}
+			else if (meth.getName().equals("toString")) {
+				assertEquals(1, annInstances.size());
+			}
+			else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+
+		for (Attribute att : clazz.getAttributes()) {
+			assertEquals(0, att.getAnnotationInstances().size());
+		}
+
+	}
+
+	@Test
+	public void testClassParameterTypes() {
+		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dicoClass);
+		assertEquals("Dictionary", dicoClass.getName());
+		assertEquals(2, dicoClass.getTypes().size());
+		assertEquals(1, dicoClass.getParameters().size());
+		
+		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
+		assertNotNull(dicoParam);
+		assertEquals("B", dicoParam.getName());
+		
+		assertSame(dicoClass, dicoParam.getContainer());
+		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
+	}
+
+	@Test
+	public void testParameterTypeAsType() {
+		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
+		assertNotNull(gebb);
+		assertSame(1, gebb.getParameters().size());
+		
+		Parameter bnd = gebb.getParameters().iterator().next();
+		assertNotNull(bnd);
+		assertEquals("bnd", bnd.getName());
+		
+		Type b = bnd.getDeclaredType();
+		assertNotNull(b);
+		assertEquals("B", b.getName());
+		assertSame(ParameterType.class, b.getClass());
+		
+		ContainerEntity cont = b.getContainer();
+		assertNotNull(cont);
+		assertEquals("Dictionary", cont.getName());
+		assertSame(ParameterizableClass.class, cont.getClass());
+	}
+	
+	@Test
+	public void testFieldArgumentTypes() {
+		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
+		assertNotNull(famixAtt);
+		assertEquals("mapBind", famixAtt.getName());
+		//assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		//Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
+	}
+	
+	@Test
+	public void testMethodParameterArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				///assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+	}
+	
+	@Test
+	public void testMethodLocalVariableArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
+		assertNotNull(fmxMethod);
+		assertEquals(1, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
+			//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+			//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
+			if (fmxLocalVariable.getName().equals("ret")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxLocalVariable.getName().equals("l_name")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
+			if (fmxLocalVariable.getName().equals("fmx")) {
+				//assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
+			}
+			if (fmxLocalVariable.getName().equals("l")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+	}
+	
+	
+	@Test
+	public void testMethodReturnArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		//assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
+	}
+
+	@Test
+	public void testEnumDecl() {
+		fr.inria.verveine.core.gen.famix.Enum rk = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Rank");
+		assertNotNull(rk);
+		assertEquals("Rank", rk.getName());
+		//assertEquals(13, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Card"), rk.getBelongsTo());
+
+		EnumValue nine = TestVerveineUtils.detectElement(repo, EnumValue.class, "NINE");
+		assertNotNull(nine);
+		assertEquals("NINE", nine.getName());
+		assertSame(rk, nine.getParentEnum());
+		assertSame(rk, nine.getBelongsTo());
+
+		fr.inria.verveine.core.gen.famix.Enum st = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Suit");
+		assertNotNull(st);
+		assertEquals("Suit", st.getName());
+		//assertEquals(4, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "ad_hoc"), st.getBelongsTo());
+
+		EnumValue hrt = TestVerveineUtils.detectElement(repo, EnumValue.class, "HEARTS");
+		assertNotNull(hrt);
+		assertEquals("HEARTS", hrt.getName());
+		assertSame(st, hrt.getParentEnum());
+		assertSame(st, hrt.getBelongsTo());
+	}
+
+}
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 90)
@@ -0,0 +1,443 @@
+package fr.inria.verveine.extractor.java;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.ArrayAccess;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.Assignment;
+import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConditionalExpression;
+import org.eclipse.jdt.core.dom.Expression;
+import org.eclipse.jdt.core.dom.FieldAccess;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.IPackageBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.ImportDeclaration;
+import org.eclipse.jdt.core.dom.InfixExpression;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.Name;
+import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParenthesizedExpression;
+import org.eclipse.jdt.core.dom.QualifiedName;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleName;
+import org.eclipse.jdt.core.dom.SimpleType;
+import org.eclipse.jdt.core.dom.StringLiteral;
+import org.eclipse.jdt.core.dom.SuperFieldAccess;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeLiteral;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+
+import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/**
+ * AST Visitor that defines all the (Famix) entities of interest and links betgween them
+ * Famix entities are stored in a Map along with the (AST) IBindings to which they correspond
+ */
+public class VerveineRefVisitor extends ASTVisitor {
+
+	/** 
+	 * A dictionary allowing to recover created FAMIX Entities
+	 */
+	protected JavaDictionary dico;
+
+	/**
+	 * A stack that keeps the current definition context (package/class/method)
+	 */
+	protected EntityStack context;
+
+	public VerveineRefVisitor(JavaDictionary dico) {
+		this.dico = dico;
+		this.context = new EntityStack();
+	}
+
+	// VISITOR METHODS
+
+	public boolean visit(CompilationUnit node) {
+		PackageDeclaration pckg = node.getPackage();
+		if (pckg==null) {
+			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
+		}
+		else {
+			this.context.pushPckg( (Namespace)dico.getEntityByKey(pckg.resolveBinding()) );
+		}
+		return super.visit(node);
+
+	}
+
+	public void endVisit(CompilationUnit node) {
+		this.context.popPckg();
+		super.endVisit(node);
+	}
+
+	/**
+	 * creating reference from package of this compilation unit to imported package
+	 * not sure it is a good idea ?!?
+	 */
+	public boolean visit(ImportDeclaration node) {
+
+		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
+
+		IBinding importBnd = node.resolveBinding();
+		String importName = node.getName().getFullyQualifiedName();
+		if (importBnd instanceof IMethodBinding)  {
+			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
+		}
+		else if (importBnd instanceof IVariableBinding)  {
+			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
+		}
+		else if (importBnd instanceof ITypeBinding)  {
+			importBnd = ((ITypeBinding)importBnd).getPackage();
+			importName = dico.removeLastName(importName);
+		}
+		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
+		context.setLastReference( dico.createFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		
+		return super.visit(node);
+	}
+
+	public boolean visit(TypeDeclaration node) {
+		ITypeBinding bnd = node.resolveBinding();
+		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
+		this.context.pushClass(fmx );
+
+		dico.addFamixAnnotationInstances(bnd, fmx);
+
+		return super.visit(node);
+	}
+
+	public void endVisit(TypeDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(ClassInstanceCreation node) {
+		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
+		if (decl != null) {
+			ITypeBinding bnd = decl.resolveBinding();
+			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
+			this.context.pushClass(fmx);
+
+			dico.addFamixAnnotationInstances(bnd, fmx);
+		}
+		return super.visit(node);
+	}
+
+	public void endVisit(AnonymousClassDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(MethodDeclaration node) {
+		IMethodBinding bnd = node.resolveBinding();
+		Method meth = (Method) dico.getEntityByKey(bnd);
+
+		if (meth != null) {
+			this.context.pushMethod(meth);
+
+			dico.addFamixAnnotationInstances(bnd, meth);
+
+			// Exceptions
+			for (Name excepName : (List<Name>)node.thrownExceptions()) {
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				if (excepFmx != null) {
+					dico.createFamixDeclaredException(meth, excepFmx);
+				}
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	public void endVisit(MethodDeclaration node) {
+		this.context.popMethod();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, RefVisiting FieldDeclaration");
+		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
+			IVariableBinding bnd = vd.resolveBinding();
+			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
+
+			if (fmx != null) {
+				dico.addFamixAnnotationInstances(bnd, fmx);
+			}
+		}
+		return super.visit(node);
+	}
+
+	public boolean visit(MethodInvocation node) {
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
+		return super.visit(node);
+	}
+
+	@SuppressWarnings({ "static-access" })
+	public boolean visit(SuperMethodInvocation node) {
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		return super.visit(node);
+	}
+
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param calledBnd -- a binding for the method
+	 * @param calledName of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
+	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
+		BehaviouralEntity sender = this.context.topMethod();
+		if (sender != null) {
+			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			/* TODO old code, may not be valid anymore ...
+			   if (invoked == null) {
+				if (receiver != null && receiver.getName().equals("self")) {
+					receiver = this.context.topClass();
+				}
+				invoked = this.dico.ensureFamixMethod(calledName, receiver, list);
+				//invoked = this.dico.ensureFamixStubMethod(name);
+			}
+			if (invoked == null) {
+				invoked = this.dico.ensureFamixStubMethod(calledName);
+			}*/
+			context.setLastInvocation( dico.createFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+		}
+	}
+
+	public boolean visit(FieldAccess node) {
+		fieldAccess(node.resolveFieldBinding());
+		
+		return super.visit(node);
+	}
+
+	/* Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
+	 */
+	public boolean visit(QualifiedName node) {
+		IBinding bnd = node.resolveBinding();
+		if (bnd instanceof IVariableBinding) {
+			// apparently this is a field
+			fieldAccess((IVariableBinding) bnd);
+		}
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(CatchClause node) {
+		Method meth = this.context.topMethod();
+		Type excepClass = node.getException().getType();
+		if (meth != null) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
+			if (excepClass instanceof SimpleType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+			}
+			else if (excepClass instanceof QualifiedType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
+			}
+			if (excepFmx != null) {
+				dico.createFamixCaughtException(meth, excepFmx);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(ThrowStatement node) {
+		Method meth = this.context.topMethod();
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
+		if (excepFmx != null) {
+			dico.createFamixThrownException(meth, excepFmx);
+		}
+		return super.visit(node);
+	}
+
+	/**
+	 * Finds and/or create the Famix Entity receiving a message
+	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
+	 * @param expr -- the Java expression describing the receiver
+	 * @return the Famix Entity or null if could not find it
+	 */
+	@SuppressWarnings("static-access")
+	private NamedEntity getReceiver(Expression expr) {
+		// msg(), same as ThisExpression
+		if (expr == null) {
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+		}
+
+		// array[i].msg()
+		else if (expr instanceof ArrayAccess) {
+			return getReceiver(((ArrayAccess) expr).getArray());
+		}
+
+		// new type[].msg() -- TODO similar to ClassInstanceCreation
+		else if (expr instanceof ArrayCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ArrayCreation");
+			return null;
+		}
+
+		// (variable = value).msg()
+		else if (expr instanceof Assignment) {
+			return getReceiver(((Assignment) expr).getLeftHandSide());
+		}
+
+		// ((type)expr).msg()
+		else if (expr instanceof CastExpression) {
+			return getReceiver(((CastExpression) expr).getExpression());
+		}
+
+		// new Class().msg() -- TODO anonymous object of a known class ...
+		else if (expr instanceof ClassInstanceCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ClassInstanceCreation");
+			return null;
+		}
+
+		// (cond-expr ? then-expr : else-expr).msg()
+		else if (expr instanceof ConditionalExpression) {
+			// can be one or the other (then-expr/else-expr) so we choose one
+			NamedEntity ret = getReceiver(((ConditionalExpression) expr).getThenExpression());
+			if (ret == null) {
+				// can as well try the other
+				ret = getReceiver(((ConditionalExpression) expr).getElseExpression());
+			}
+			return ret;
+		}
+
+		// field.msg()
+		else if (expr instanceof FieldAccess) {
+			Attribute ret = null;
+			IVariableBinding bnd = ((FieldAccess) expr).resolveFieldBinding();
+			ret = dico.ensureFamixAttribute(bnd, ((FieldAccess) expr).getName().getIdentifier(), null, null);
+
+			return ret;
+		}
+
+		// (left-expr oper right-expr).msg()
+		else if (expr instanceof InfixExpression) {
+			// anonymous receiver
+			return null;
+		}
+
+		// msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof MethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: MethodInvocation");
+
+			return null;
+		}
+
+		// name.msg()
+		else if (expr instanceof Name) {
+			// can be a class or a variable name
+			IBinding bnd = ((Name) expr).resolveBinding();
+			if (bnd == null) {
+				return null;
+			}
+			NamedEntity ret = null;
+			if (bnd instanceof ITypeBinding) {
+				// msg() is a static method of Name
+				//TODO why returning a variable here? Should not it be the class itself?
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null), bnd.getName());
+			}
+			else if (bnd instanceof IVariableBinding) {
+				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
+				if ( ((IVariableBinding)bnd).isField() ) {
+					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
+				}
+				else if ( ((IVariableBinding)bnd).isParameter() ) {
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
+				}
+				else { // suppose it's a local variable
+					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
+				}
+			}
+			
+			return ret;
+		}
+
+		// (expr).msg()
+		else if (expr instanceof ParenthesizedExpression) {
+			return getReceiver(((ParenthesizedExpression) expr).getExpression());
+		}
+
+		// "string".msg() -- TODO similar to ClassInstanceCreation, anonymous String object
+		else if (expr instanceof StringLiteral) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: StringLiteral");
+			return null;
+		}
+
+		// super.field.msg()
+		else if (expr instanceof SuperFieldAccess) {
+			Attribute ret = null;
+			IVariableBinding bnd = ((SuperFieldAccess) expr).resolveFieldBinding();
+			ret = dico.ensureFamixAttribute(bnd, ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
+
+			return ret;
+		}
+
+		// super.msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof SuperMethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: SuperMethodInvocation");
+			
+			return null;
+		}
+		
+		// this.msg()
+		else if (expr instanceof ThisExpression) {
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+		}
+
+		// type.class.msg()
+		else if (expr instanceof TypeLiteral) {
+			// may be could specify: ensureFamixClass ??
+			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null);
+		}
+
+		// ... OTHER POSSIBLE EXPRESSIONS ?
+		else  {
+			System.err.println("WARNING: Unexpected receiver expression: "+expr.getClass().getName()+" (method called is" + expr.getClass().getName() + ".aMethod(...))");
+		}
+
+		return null;
+	}
+
+	/**
+	 * Handles an access to a field by creating the corresponding Famix Entity
+	 * @param bnd -- a binding for the field (i.e attribute)
+	 */
+	private void fieldAccess(IVariableBinding bnd) {
+		BehaviouralEntity accessor = this.context.topMethod();
+		if (accessor != null) {
+			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
+			if (accessed != null) {
+				context.setLastAccess( dico.createFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+					accessed.setParentType(dico.ensureFamixClassArray());
+				}
+			}
+		}
+	}
+
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 90)
@@ -0,0 +1,402 @@
+package fr.inria.verveine.extractor.java;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
+import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
+import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.AssertStatement;
+import org.eclipse.jdt.core.dom.Assignment;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConstructorInvocation;
+import org.eclipse.jdt.core.dom.ContinueStatement;
+import org.eclipse.jdt.core.dom.DoStatement;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
+import org.eclipse.jdt.core.dom.EnumDeclaration;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.ForStatement;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ReturnStatement;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.SwitchCase;
+import org.eclipse.jdt.core.dom.SwitchStatement;
+import org.eclipse.jdt.core.dom.SynchronizedStatement;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.TryStatement;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WhileStatement;
+
+import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+
+/**
+ * AST Visitor that defines all the (Famix) entities of interest
+ * Famix entities are stored in a Map along with the IBindings to which they correspond
+ */
+public class VerveineDefVisitor extends ASTVisitor {
+
+	/** 
+	 * A dictionary allowing to recover created FAMIX Entities
+	 */
+	protected JavaDictionary dico;
+
+	/**
+	 * A stack that keeps the current definition context (package/class/method)
+	 */
+	protected EntityStack context;
+
+	public VerveineDefVisitor(JavaDictionary dico) {
+		this.dico = dico;
+		this.context = new EntityStack();
+	}
+
+	// VISITOR METHODS
+
+	public boolean visit(CompilationUnit node) {
+//		System.err.println("TRACE, DefVisiting CompilationUnit");
+		Namespace fmx = null;
+		PackageDeclaration pckg = node.getPackage();
+		if (pckg==null) {
+			fmx = dico.ensureFamixNamespaceDefault();
+		}
+		else {
+			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
+			fmx.setIsStub(false);
+		}
+		this.context.pushPckg(fmx);
+		return super.visit(node);
+
+	}
+
+	public void endVisit(CompilationUnit node) {
+		this.context.popPckg();
+		super.endVisit(node);
+	}
+
+	public boolean visit(TypeDeclaration node) {
+		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+
+			this.context.pushClass(fmx);
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+		}
+
+		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
+		
+		return super.visit(node);
+	}
+
+	public void endVisit(TypeDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(ClassInstanceCreation node) {
+		//System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
+		if (decl != null) {
+			fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+
+			dico.addSourceAnchor(fmx, node);
+		}
+		this.context.pushClass(fmx);
+		return super.visit(node);
+	}
+
+	public void endVisit(ClassInstanceCreation node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			context.pushAnnotationType(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+
+	public void endVisit(AnnotationTypeDeclaration node) {
+		this.context.popAnnotationType();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeMemberDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+		IMethodBinding bnd = node.resolveBinding();
+		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			context.pushAnnotationMember(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+	public void endVisit(AnnotationTypeMemberDeclaration node) {
+		this.context.popAnnotationMember();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(EnumDeclaration node) {
+//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			for (EnumConstantDeclaration ecst : (List<EnumConstantDeclaration>)node.enumConstants()) {
+				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
+				ev.setIsStub(Boolean.FALSE);
+			}
+		}
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(MethodDeclaration node) {
+//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		
+		// some info needed to create the Famix Method
+		IMethodBinding bnd = node.resolveBinding();
+		Type retTyp = node.getReturnType2();
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+		// creating/recovering it
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes,
+											(retTyp == null) ? null : dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+											context.topClass());
+		
+		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
+			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+		}
+		
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			this.context.pushMethod(fmx);
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+
+			// creating the method's parameters
+			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				fr.inria.verveine.core.gen.famix.Type paramTyp = dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null);
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), param.getName().getIdentifier(), paramTyp, fmx);
+				if (fmxParam != null) {
+					fmxParam.setIsStub(false);
+				}
+				if (param.getType().isParameterizedType()) {
+					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
+				}
+			}
+		}
+		return super.visit(node);	
+	}
+
+	public void endVisit(MethodDeclaration node) {
+		int cyclo = context.getTopMethodCyclo();
+		int nos = context.getTopMethodNOS();
+		Method fmx = this.context.popMethod();
+		fmx.setNOS(nos);
+		fmx.setCyclo(cyclo);
+		super.endVisit(node);
+	}
+	
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, DefVisiting FieldDeclaration");
+		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
+			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
+
+			if (fmx != null) {
+				fmx.setIsStub(false);
+			}
+			if (node.getType().isParameterizedType()) {
+				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
+			}
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+		}
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationExpression node) {
+		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationStatement node) {
+		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		return super.visit(node);
+	}
+
+	private void visitVariablesDeclarations(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming here that the user is not interested in them 
+		if (nodeTyp.isPrimitiveType()) {
+			return;
+		}
+
+		for (VariableDeclarationFragment vd : fragments) {
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), dico.ensureFamixType(null, nodeTyp.toString(), null), context.topMethod());
+			if (fmx != null) {
+				fmx.setIsStub(false);
+				dico.addSourceAnchor(fmx, node);
+			}
+			if (nodeTyp.isParameterizedType()) {
+				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+			}
+		}
+	}
+
+	// METRICS: CYCLO, NOS
+	
+	public boolean visit(AssertStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(Assignment node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ContinueStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(DoStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(EnhancedForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(IfStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(MethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ReturnStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperMethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchCase node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SynchronizedStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ThrowStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(TryStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(WhileStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+}
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 90)
@@ -0,0 +1,1223 @@
+package fr.inria.verveine.extractor.java;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ArrayType;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
+import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMemberValuePairBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.IPackageBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.Modifier;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleType;
+import org.eclipse.jdt.core.dom.TypeParameter;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.Dictionary;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Enum;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.Type;
+import fr.inria.verveine.core.gen.famix.UnknownVariable;
+
+/**
+ * A {@link fr.inria.verveine.Dictionary} specialized for Java
+ * @author anquetil
+ */
+public class JavaDictionary extends Dictionary<IBinding> {
+
+	// a property added to CompilationUnits to record the name of the source file name they come from
+	public static final String SOURCE_FILENAME_PROPERTY = "verveine-source-filename";
+
+	public static final String OBJECT_NAME = "Object";
+	public static final String OBJECT_PACKAGE_NAME = "java.lang";
+	public static final String ARRAYS_NAME = "default[]";
+	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
+	public static final String STATIC_INIT_BLOCK_NAME = "<StaticInitializer>";
+
+	/**
+	 * @param famixRepo
+	 */
+	public JavaDictionary(Repository famixRepo) {
+		// should check whether there is already one in the repository
+		super(famixRepo);
+	}
+
+	/**
+	 * Returns a Famix Namespace associated with its IPackageBinding and/or name.
+	 * The Entity is created if it does not exist (see also {@link Dictionary#ensureFamixNamespace(Object, String)}).
+	 * Also creates or recovers recusively it's parent namespaces.<br>
+	 * At least one of <b>bnd</b> and <b>name</b> must be non null.
+	 * @param bnd -- the JDT Binding that may be used as a uniq key to recover this namespace
+	 * @param name -- fully qualified name of the namespace (e.g. 'java.lang')
+	 * @return the Famix Namespace found or created. May return null in case of a Famix error
+	 */
+	public Namespace ensureFamixNamespace(IPackageBinding bnd, String name) {
+		Namespace fmx = null;
+		Namespace parent = null;
+
+		if ( (name == null) && (bnd != null) ) {
+			name = bnd.getName();
+		}
+		
+		if (name.length() > 0) {
+			/* Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
+			 * (for example when creating parent packages of a package we have a binding for).
+			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
+			 * all is said and done. */
+			fmx = super.ensureFamixNamespace( bnd, name);
+			parent = this.ensureFamixNamespace(null, removeLastName(name));
+			// set the parentscope relationship
+			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
+				parent.addChildScopes(fmx);
+			}
+		}
+
+		return fmx;
+	}
+
+	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
+		
+		Type fmxType = null;
+		for (org.eclipse.jdt.core.dom.Type type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd, findTypeName(type), null);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
+			fmxTypes.add(fmxType);
+		}
+		return fmxTypes;
+	}
+
+	/**
+	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
+	 */
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
+
+		if (bnd == null) {
+			return super.ensureFamixType(null, name, owner);
+		}
+
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+
+		if (bnd.isClass() || bnd.isInterface()) {
+			return this.ensureFamixClass(bnd, name, owner);
+		}
+		
+		if (bnd.isPrimitive()) {
+			return ensureFamixPrimitiveType(bnd, name);
+		}
+
+		if (bnd.isEnum()) {
+			return ensureFamixEnum(bnd, name, owner);
+		}
+		
+		return super.ensureFamixType(bnd, name, owner);
+	}
+	
+	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
+		Type fmxType = null;
+		
+		for (TypeParameter type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd, null, null);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
+			fmxTypes.add(fmxType);
+		}
+		return fmxTypes;
+	}
+	
+	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
+		if (name == null) {
+			if (bnd == null) {
+				return null;
+			}
+			else {
+				name = bnd.getName();
+			}
+		}
+		return super.ensureFamixPrimitiveType(bnd, name);
+	}
+
+	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Enum fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixEnum(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- recover from name ?
+		for (fr.inria.verveine.core.gen.famix.Enum candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Enum.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixEnum(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public EnumValue ensureFamixEnumValue(IVariableBinding bnd,	String name, Enum owner) {
+		EnumValue fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of creating an EnumValue without a declaring Enum type? 
+			}
+			return super.ensureFamixEnumValue(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixEnum(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (EnumValue candidate : getEntityByName(EnumValue.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixEnumValue(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentEnum(owner);
+		}
+
+		return fmx;
+	}
+
+	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd, String name, ContainerEntity owner) {
+		AnnotationType fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationType(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IPackageBinding parentPckg = bnd.getPackage();
+			if (parentPckg != null) {
+				owner = this.ensureFamixNamespace(parentPckg, null);
+			}
+			else {
+				owner = this.ensureFamixNamespaceDefault();
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationType candidate : getEntityByName(AnnotationType.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationType(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(IMethodBinding bnd, String name, AnnotationType owner) {
+		AnnotationTypeAttribute fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			ITypeBinding parentType = bnd.getDeclaringClass();
+			if (parentType != null) {
+				owner = this.ensureFamixAnnotationType(parentType, null, null);
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationTypeAttribute candidate : getEntityByName(AnnotationTypeAttribute.class, name) ) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationTypeAttribute(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
+		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
+			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
+			
+			Collection<AnnotationInstanceAttribute> annAtts = new ArrayList<AnnotationInstanceAttribute>(); 
+			for (IMemberValuePairBinding annPV : annBnd.getDeclaredMemberValuePairs()) {
+				annAtts.add( createFamixAnnotationInstanceAttribute(ensureFamixAnnotationTypeAttribute(annPV.getMethodBinding(), annPV.getName(), annType), annPV.getValue().toString()));
+			}
+			
+			super.addFamixAnnotationInstance(fmx, annType, annAtts);
+		}
+	}
+
+	/**
+	 * Returns a Famix Class associated with the ITypeBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixNamespaceDefault();
+			}
+			return super.ensureFamixClass(null, name, owner);
+		}
+
+		// --------------- some special cases
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
+		}
+
+		if (bnd.isPrimitive()) {
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
+			return null;
+		}
+
+		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
+		// --------------- name
+		if (name == null) {
+			if (! bnd.isAnonymous()) {
+				name = bnd.getName();
+			}
+			else { // anonymous class
+				if (bnd.getSuperclass() != null) {
+					name = bnd.getSuperclass().getName();
+				}
+				if ( (name == null) || name.equals(OBJECT_NAME)) {
+					ITypeBinding[] intfcs = bnd.getInterfaces();
+					if ( (intfcs != null) && (intfcs.length > 0) ) {
+						name = bnd.getInterfaces()[0].getName();
+					}
+					else {
+						name = "???";
+					}
+				}
+				name = "anonymous(" + name + ")";
+			}
+		}
+		
+		if (name.equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- superclasses (including interfaces)
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		if (! bnd.isInterface()) {
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd != null) {
+				sups.add(this.ensureFamixClass(supbnd, null, null));
+			}
+			else {
+				sups.add( ensureFamixClassObject(null));
+			}
+		}
+		for (ITypeBinding intbnd : bnd.getInterfaces()) {
+			sups.add( ensureFamixClass(intbnd, null, null));
+		}
+
+		// --------------- recover from name ?
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixClass(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setIsInterface(bnd.isInterface());
+			Inheritance lastInheritance = null;
+			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
+			}
+			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
+			if (fmx.getIsAbstract()) {
+				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
+				fmx.addModifiers("abstract");
+			}
+		}
+	
+		return fmx;
+	}
+
+	/**
+	 * Checks whether the existing unmapped Famix Namespace matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound package, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
+			return false;
+		}
+
+		// names are equals and bnd is not mapped, so let's do it
+		mapToKey.put(bnd, candidate);
+		return true;
+	}
+
+	/**
+	 * Checks whether the existing unmapped Famix Type matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * We also check that the actual class of the candidate matches (can be a sub-class of FamixType). 
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix NamedEntity (Class, Type, PrimitiveType, Enum, AnnotationType)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapType(ITypeBinding bnd, NamedEntity candidate) {
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
+			return false;
+		}
+		
+		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
+			return checkAndMapClass(bnd, (Type) candidate);
+		}
+
+		if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
+			// names are equal so it's OK
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		
+		if (bnd.isAnnotation() && (candidate instanceof AnnotationType) ) {
+			if (checkAndMapNamespace(bnd.getPackage(), (Namespace) candidate.getBelongsTo())) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
+		
+		return false;
+	}
+
+	/**
+	 * Checks whether the existing unmapped Famix Class (or Interface or Enum) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapClass(ITypeBinding bnd, Type candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+		
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			if ( (bnd.isClass() || bnd.isInterface()) && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Class)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixClass: "+candidate.getName());
+				return false;
+			}
+			else if ( bnd.isEnum() && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Enum)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixEnum: "+candidate.getName());
+				return false;
+			}
+			else {
+				return true;
+			}
+		}
+		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
+			return false;
+		}
+
+		// names match, 'bnd' was not bound, check the owners
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
+		IMethodBinding methBnd = bnd.getDeclaringMethod(); // for classes, can enum be declared in methods?
+		if ( (methBnd != null) && (candidateOwner instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
+
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (classBnd != null) && (candidateOwner instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			if ( checkAndMapClass(classBnd, (Type)candidateOwner) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
+
+		IPackageBinding pckgBnd = bnd.getPackage();
+		if ( (candidateOwner instanceof Namespace) &&
+			 (checkAndMapNamespace(pckgBnd, (Namespace)candidateOwner)) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		else {
+			return false;
+		}
+	}
+
+	/**
+	 * Checks whether the existing unmapped Famix "Method" matches the binding.
+	 * Checks that the candidate has the same name and same signature as the JDT bound method, and checks recursively that owners also match.
+	 * Note that AnnotationTypeAttribute are treated as methods by JDT, so they are checked here.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (regular Method or AnnotationTypeAttribute)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapMethod(IMethodBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
+			return false;
+		}
+
+		// for methods, the name is not enough, we must test the signature also ...
+		// for AnnotationTypeAttribute, we don't need this
+		if (candidate instanceof Method) {
+			String sig = bnd.getName() + "(";
+			boolean first = true;
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
+				}
+				sig += ")";
+			}
+			if (! ((Method) candidate).getSignature().equals(sig)) {
+				return false;
+			}
+
+			// ... and the signature should include the return type
+			if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
+				return false;
+			}
+		}
+
+		// finally let's check the owners
+		ITypeBinding ownerBnd = bnd.getDeclaringClass();
+		NamedEntity candidateOwner = candidate.getBelongsTo();
+		if ( (candidateOwner  instanceof fr.inria.verveine.core.gen.famix.Class) &&
+				 (checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+		else if ( (candidateOwner instanceof AnnotationType) &&
+				(checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		else {
+			return false;
+		}
+	}
+
+	/**
+	 * Checks whether the existing unmapped Famix "Variable" (Attribute, Parameter, ...) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound variable, and checks recursively that owners also match.
+	 * The Famix candidate is a NamedEntity and not a StructuralEntity to allow dealing with Famix EnumValue that JDT treats as variables
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (a StructuralEntity or an EnumValue)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapVariable(IVariableBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = (NamedEntity)getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
+		IMethodBinding methBnd = bnd.getDeclaringMethod();
+		if ( (methBnd != null) && (candidateOwner  instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
+
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (candidateOwner instanceof Type) &&
+			 (checkAndMapType(classBnd, (Type)candidateOwner)) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		else {
+			return false;
+		}
+	}
+
+	/**
+	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
+	 * The Entity is created if it does not exist.
+	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
+		Method fmx = null;
+		String sig;
+		boolean first;
+
+		// signature is dealt in two places
+		// here we try to use the parameter of ensureFamixMethod to compute the list of parameter types of the FamixMethod
+		// if it does not work and binding is not null, we will have another chance to compute this list later
+		sig = "(";
+		first = true;
+		if (paramTypes != null) {
+			for (org.eclipse.jdt.core.dom.Type t : paramTypes) {
+				if (! first) {
+					sig += "," + findTypeName(t);
+				}
+				else {
+					sig += findTypeName(t);
+					first = false;
+				}
+			}
+			
+		}
+		sig += ")";
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (paramTypes == null) {
+				sig = name + "(???)";
+			}
+			else {
+				sig = name + sig;
+			}
+			if (owner == null) {
+				owner= ensureFamixClassStubOwner();
+			}
+			return super.ensureFamixMethod(null, name, sig, ret, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- signature
+		if (paramTypes == null) {
+			sig = "(";
+			first = true;
+			paramTypes = new ArrayList<org.eclipse.jdt.core.dom.Type>();
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
+				}
+			}
+			sig += ")";
+		}
+		sig = name + sig;
+
+		// --------------- return type
+		if ( (ret == null) && (! bnd.isConstructor()) ) {
+			ret = this.ensureFamixType(bnd.getReturnType(), null, null);
+		}
+		// else leave it to null ...
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (Method candidate : this.getEntityByName(Method.class, name)) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = ensureFamixMethod(bnd, name, sig, ret, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setDeclaredType(ret);
+			fmx.setSignature(sig);
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+	
+	public String findTypeName(org.eclipse.jdt.core.dom.Type t) {
+		if (t.isPrimitiveType()) {
+			return t.toString();
+		}
+		else if (t.isSimpleType()) {
+			return ((SimpleType)t).getName().getFullyQualifiedName();
+		}
+		else if (t.isQualifiedType()) {
+			return ((QualifiedType)t).getName().getIdentifier();
+		}
+		else if (t.isArrayType()) {
+			return findTypeName( ((ArrayType)t).getElementType() );
+		}
+		else if (t.isParameterizedType()) {
+			return "?";  // TODO
+		}
+		else { // it is a WildCardType
+			return "?"; // TODO
+		}
+	}
+
+	/**
+	 * Returns a Famix Attribute associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
+		Attribute fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of creating an attribute for which we ignore the declaring class? 
+			}
+			return super.ensureFamixAttribute(null, name, type, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- return type
+		if (type == null) {
+			type = this.ensureFamixType(bnd.getType(), null, null);
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (Attribute candidate : getEntityByName(Attribute.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixAttribute(bnd, name, type, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentType(owner);
+			fmx.setDeclaredType(type);	
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	/** Sets the modifiers (abstract, public, ...) of a FamixNamedEntity
+	 * @param fmx -- the FamixNamedEntity
+	 * @param mod -- a description of the modifiers as understood by org.eclipse.jdt.core.dom.Modifier
+	 */
+	private void setNamedEntityModifiers(NamedEntity fmx, int mod) {
+		if (Modifier.isAbstract(mod)) {
+			// don't know why there are two different ways to mark abstract classes !!!
+			// But this is a pain!
+			fmx.addModifiers("abstract");
+		}
+		fmx.setIsAbstract(new Boolean(Modifier.isAbstract(mod)));
+		fmx.setIsFinal(new Boolean(Modifier.isFinal(mod)));
+		fmx.setIsPrivate(new Boolean(Modifier.isPrivate(mod)));
+		fmx.setIsProtected(new Boolean(Modifier.isProtected(mod)));
+		fmx.setIsPublic(new Boolean(Modifier.isPublic(mod)));
+	}
+
+	/**
+	 * Returns a Famix Parameter associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Parameter ensureFamixParameter(IVariableBinding bnd, String name, Type typ, Method owner) {
+		Parameter fmx = null;
+
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixStubMethod("<"+name+"_owner>");
+			}
+			return super.ensureFamixParameter(null, name, typ, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+		}
+		
+		// --------------- recover from name ?
+		for (Parameter candidate : getEntityByName(Parameter.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixParameter(bnd, name, typ, owner);
+		}
+		
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentBehaviouralEntity(owner);
+			fmx.setDeclaredType(typ);	
+		}
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a Famix LocalVariable associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
+	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
+	 */
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, String name, Type typ, Method owner) {
+		LocalVariable fmx = null;
+
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of a local variable for which we ignore the declaring method?
+			}
+			return super.ensureFamixLocalVariable(null, name, typ, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+		}
+		
+		// --------------- recover from name ?
+		for (LocalVariable candidate : getEntityByName(LocalVariable.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixLocalVariable(bnd, name, typ, owner);
+		}
+		
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentBehaviouralEntity(owner);
+			fmx.setDeclaredType(typ);	
+		}
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 */
+	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
+//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
+		UnknownVariable fmx = (UnknownVariable) createFamixNamedEntity(UnknownVariable.class, name);
+		if (fmx!=null) {
+			fmx.setDeclaredType(type);
+		}
+		return fmx;
+	}
+
+	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+		Comment cmt = null;
+		if (jdoc != null) {
+			cmt = createFamixComment(jdoc.toString(), fmx);
+			addSourceAnchor(cmt, jdoc);
+		}
+		return cmt;
+	}
+
+	/**
+	 * Adds location information to a Famix Entity.
+	 * Location informations are: <b>name</b> of the source file and <b>line</b> position in this file. They are found in the JDT ASTNode: ast.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param fmx -- Famix Entity to add the anchor to
+	 * @param ast -- JDT ASTNode, where the information are extracted
+	 * @return the Famix SourceAnchor added to fmx. May be null in case of incorrect parameter ('fmx' or 'ast' == null) 
+	 */
+	public SourceAnchor addSourceAnchor(SourcedEntity fmx, ASTNode ast) {
+		FileAnchor fa = null;
+		
+		if ( (fmx != null) && (ast != null) ) {
+			// position in source file
+			int beg = ast.getStartPosition();
+			int end = beg + ast.getLength();
+			// find source file
+			while ( ! (ast instanceof CompilationUnit) ) {
+				ASTNode tmp = ast.getParent();
+				if ( (ast == null) || (tmp == ast) ) {
+					// if we are here, then we reached the top node without finding a CompilationUnit. This should not happen
+					return null;
+				}
+				else {
+					ast = tmp;
+				}
+			}
+			// now create the Famix SourceAnchor
+			fa = new FileAnchor();
+			fa.setFileName((String) ((CompilationUnit)ast).getProperty(SOURCE_FILENAME_PROPERTY));
+			fa.setStartLine(((CompilationUnit)ast).getLineNumber(beg));
+			fa.setEndLine(((CompilationUnit)ast).getLineNumber(end));
+			fmx.setSourceAnchor(fa);
+			famixRepo.add(fa);
+		}
+		
+		return fa;
+	}
+
+	/**
+	 * Creates or recovers a stub Famix Method
+	 * @param name of the method
+	 * @return the Famix Method
+	 */
+	public Method ensureFamixStubMethod(String name) {
+		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, ensureFamixClassStubOwner());  // cast needed to desambiguate the call
+	}
+
+	/**
+	 * Creates or recovers a Famix Namespace for the package of Java class "Object" (i.e. "java.lang").
+	 * Because "Object" is the root of the inheritance tree, it needs to be treated differently.
+	 * @param bnd -- a potential binding for the "java.lang" package
+	 * @return a Famix Namespace for "java.lang"
+	 */
+	public Namespace ensureFamixNamespaceJavaLang(IPackageBinding bnd) {
+		Namespace fmx = this.ensureFamixNamespace(bnd, OBJECT_PACKAGE_NAME);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers the Famix Class for "Object".
+	 * @param bnd -- a potential binding for the java "Object" class
+	 * @return a Famix class for "Object"
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
+		
+		if (fmx != null) {
+			fmx.setContainer( ensureFamixNamespaceJavaLang(null));
+			
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.TRUE);
+		}
+		// Note: "Object" has no superclass
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers the Famix Class for all arrays (<some-type> [])
+	 * In java arrays or objects of special classes (i.e. "I[" for an array of int).
+	 * JDT does not create a binding for these classes, so we create a stub one here. 
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
+		if (fmx != null) {
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
+			fmx.setContainer( ensureFamixNamespaceDefault());
+			
+			fmx.setIsAbstract(Boolean.FALSE);
+			fmx.setIsFinal(Boolean.FALSE);
+			fmx.setIsInterface(Boolean.FALSE);
+			fmx.setIsPrivate(Boolean.FALSE);
+			fmx.setIsProtected(Boolean.FALSE);
+			fmx.setIsPublic(Boolean.TRUE);
+		}
+
+		return fmx;
+	}
+
+	public String removeLastName(String qualifiedName) {
+		String ret = null;
+		int last = qualifiedName.lastIndexOf('.');
+		if (last > 0) {
+			// recursively creating the parent
+			ret = qualifiedName.substring(0, last);
+		}
+		else {
+			ret = "";
+		}
+
+		return ret;
+	}
+
+
+
+}
\ No newline at end of file
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 90)
@@ -0,0 +1,130 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+import fr.inria.verveine.core.VerveineParser;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/**
+ * A batch parser inspired from org.eclipse.jdt.internal.compiler.batch.Main (JDT-3.6)
+ * run with:
+ * java -cp lib/org.eclipse.jdt.core_3.6.0.v_A48.jar:../Fame:/usr/local/share/eclipse/plugins/org.eclipse.equinox.common_3.5.1.R35x_v20090807-1100.jar:/usr/local/share/eclipse/plugins/org.eclipse.equinox.preferences_3.2.301.R35x_v20091117.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.jobs_3.4.100.v20090429-1800.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.contenttype_3.4.1.R35x_v20090826-0451.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.resources_3.5.2.R35x_v20091203-1235.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.runtime_3.5.0.v20090525.jar:/usr/local/share/eclipse/plugins/org.eclipse.osgi_3.5.2.R35x_v20100126.jar:../Fame/lib/akuhn-util-r28011.jar:lib/fame.jar:bin fr.inria.verveine.extractor.java.VerveineJParser [files|directory]_to_parse
+ */
+
+public class VerveineJParser extends VerveineParser {
+
+	/**
+	 * The arguments that were passed to the parser
+	 * Needed to relativize the source file names
+	 */
+	private String[] initialArgs;
+	
+	public static void main(String[] args) {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(args);
+		parser.outputMSE();
+	}
+
+	private void setInitialArgs(String[] args) {
+		this.initialArgs = args;
+	}
+
+	public String[] getInitialArgs() {
+		return this.initialArgs;
+	}
+
+	@Override
+	public boolean compile(String[] argv) {
+		boolean ret;
+		/*if (this.linkToExisting()) {
+			this.expandNamespacesNames();
+		}*/
+
+		setInitialArgs(argv);
+		ret = super.compile(argv);
+		
+		this.compressNamespacesNames();
+		
+		return ret;
+	}
+
+	/**
+	 * As explained in JavaDictionary, Namespaces are created with their fully qualified name.
+	 * We need now to give them their simple name
+	 */
+	protected void compressNamespacesNames() {
+		for (Namespace ns : listAll(Namespace.class)) {
+			String name = ns.getName();
+			int last = name.lastIndexOf('.');
+			if (last >= 0) {
+				ns.setName(name.substring(last+1));
+			}
+		}
+	}
+
+	/**
+	 * @see VerveineJParser.compressNamespacesNames()
+	 */
+	protected void expandNamespacesNames() {
+		for (Namespace ns : listAll(Namespace.class)) {
+			expandNamespaceName(ns);
+		}		
+	}
+	
+	private void expandNamespaceName(Namespace ns) {
+		String name = ns.getName();
+		if (name.indexOf('.') > 0) {
+			return;
+		}
+		else {
+			Namespace parent = (Namespace) ns.getParentScope();
+			if (parent == null) {
+				return;
+			}
+			else {
+				expandNamespaceName(parent);
+				ns.setName(parent.getName()+"."+ns.getName());
+			}
+		}
+	}
+
+	/*
+	 *  Low-level API performing the actual parsing
+	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
+	 *  SHOULD NOT USE an internal JDT class. But I don't know how to do it otherwise
+	 */
+	public void performCompilation() {
+
+		this.compilerOptions = new CompilerOptions(this.options);
+		this.compilerOptions.performMethodsFullRecovery = false;
+		this.compilerOptions.performStatementsRecovery = false;
+
+		// NA --- beginning of parsing code --------------------------------------------------
+		String[] tmpclasspath=null;
+		if (this.checkedClasspaths!=null) {
+			tmpclasspath = new String[this.checkedClasspaths.length];
+			int i = 0;
+			for (Classpath cp : this.checkedClasspaths) {
+				tmpclasspath[i++] = cp.getPath();
+			}
+		}
+
+		ASTParser pars = ASTParser.newParser(AST.JLS3);
+		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
+				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
+				/*encodings*/null, 
+				/*includeRunningVMBootclasspath*/true);
+		pars.setResolveBindings(true);
+		pars.setKind(ASTParser.K_COMPILATION_UNIT);
+		pars.createASTs(/*sourceFilePaths*/this.filenames, 
+				/*encodings*/this.encodings, 
+				/*bindingKeys*/new String[0], 
+				/*requestor*/new FamixRequestor(getFamixRepo(), getInitialArgs()), 
+				/*monitor*/null);
+		// NA --- end of parsing code --------------------------------------------------
+	}
+	
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 90)
@@ -0,0 +1,40 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.FileASTRequestor;
+
+import ch.akuhn.fame.Repository;
+
+public class FamixRequestor extends FileASTRequestor {
+
+	protected Repository famixRepo;
+	
+	protected JavaDictionary famixDictionnary;
+
+	private String[] initialArgs;
+	
+	public FamixRequestor(Repository r, String[] initialArgs) {
+		this.famixRepo = r;
+		this.initialArgs = initialArgs;
+
+		this.famixDictionnary = new JavaDictionary(famixRepo);
+	}
+
+	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
+		
+		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
+		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
+		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
+		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
+	}
+
+	private Object relativePath(String sourceFilePath) {
+		for (String arg : initialArgs) {
+			int i = sourceFilePath.indexOf(arg);
+			if (i >= 0) {
+				return sourceFilePath.substring(i);
+			}
+		}
+		return sourceFilePath;
+	}
+}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs	(revision 90)
@@ -0,0 +1,12 @@
+#Thu Sep 16 21:04:28 CEST 2010
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
Index: verveine.core/mse/famix30_complete.mse
===================================================================
--- verveine.core/mse/famix30_complete.mse	(revision 84)
+++ verveine.core/mse/famix30_complete.mse	(revision 85)
@@ -1,987 +1,1017 @@
- (+(
 	(FM3.Package (id: 1)-		(name 'FILE')+		(name 'Hismo')
 		(classes 			(FM3.Class (id: 2)-				(name 'FileGroup')+				(name 'HismoEntityVersion')
 				(package (ref: 1)) 				(superclass (ref: 3))) 			(FM3.Class (id: 4)-				(name 'Folder')+				(name 'HismoInvocationHistory')
 				(package (ref: 1)) 				(superclass (ref: 5)))-			(FM3.Class (id: 6)-				(name 'File')+			(FM3.Class (id: 3)
+				(name 'HismoAbstractVersion')
 				(package (ref: 1))-				(superclass (ref: 5)))+				(superclass (ref: 6)))
 			(FM3.Class (id: 7)-				(name 'FolderGroup')+				(name 'HismoClassHierarchy')
 				(package (ref: 1))-				(superclass (ref: 3)))+				(superclass (ref: 5)))
+			(FM3.Class (id: 8)
+				(name 'HismoNamespaceHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 9)
+				(name 'HismoCoChangeHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 10)
+				(name 'HismoMethodHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 11)
+				(name 'HismoAttributeHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 12)
+				(name 'HismoFileHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 13)
+				(name 'HismoFolderHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 14)
+				(name 'HismoInheritanceDefinitionHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 15)
+				(name 'HismoModelHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 16)
+				(name 'HismoClassHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 17)
+				(name 'HismoHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 19)
+				(name 'HismoCoChangePattern')
+				(package (ref: 1))
+				(superclass (ref: 18)))
 			(FM3.Class (id: 5)-				(name 'AbstractFile')+				(name 'HismoAbstractHistory')
+				(package (ref: 1))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 20)
+				(name 'HismoPackageHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 21)
+				(name 'HismoNamespaceVersion')
+				(package (ref: 1))
+				(superclass (ref: 2)))
+			(FM3.Class (id: 22)
+				(name 'HismoClassHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 23)
+				(name 'HismoCoChangeVersion')
+				(package (ref: 1))
+				(superclass (ref: 3)))
+			(FM3.Class (id: 24)
+				(name 'HismoNamespaceHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 25)
+				(name 'HismoMethodHistoryGroup')
+				(package (ref: 1))
+				(superclass (ref: 17)))
+			(FM3.Class (id: 26)
+				(name 'HismoAccessHistory')
+				(package (ref: 1))
+				(superclass (ref: 5)))
+			(FM3.Class (id: 27)
+				(name 'HismoMethodVersion')
+				(package (ref: 1))
+				(superclass (ref: 2)))
+			(FM3.Class (id: 28)
+				(name 'HismoClassVersion')
 				(package (ref: 1))-				(superclass (ref: 8))+				(superclass (ref: 2)))))
+	(FM3.Package (id: 29)
+		(name 'FILE')
+		(classes
+			(FM3.Class (id: 30)
+				(name 'Folder')
+				(package (ref: 29))
+				(superclass (ref: 31)))
+			(FM3.Class (id: 32)
+				(name 'File')
+				(package (ref: 29))
+				(superclass (ref: 31)))
+			(FM3.Class (id: 33)
+				(name 'FileGroup')
+				(package (ref: 29))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 31)
+				(name 'AbstractFile')
+				(package (ref: 29))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 9)+					(FM3.Property (id: 34)
 						(name 'name')-						(class (ref: 5))+						(class (ref: 31))
+						(type (ref: String)))))
+			(FM3.Class (id: 35)
+				(name 'FolderGroup')
+				(package (ref: 29))
+				(superclass (ref: 18)))))
+	(FM3.Package (id: 36)
+		(name 'Moose')
+		(classes
+			(FM3.Class (id: 18)
+				(name 'Group')
+				(package (ref: 36))
+				(superclass (ref: 37)))
+			(FM3.Class (id: 38)
+				(name 'Entity')
+				(abstract true)
+				(package (ref: 36))
+				(superclass (ref: Object)))
+			(FM3.Class (id: 37)
+				(name 'AbsractGroup')
+				(abstract true)
+				(package (ref: 36))
+				(superclass (ref: 38)))
+			(FM3.Class (id: 39)
+				(name 'Model')
+				(package (ref: 36))
+				(superclass (ref: 37))
+				(attributes
+					(FM3.Property (id: 40)
+						(name 'sourceLanguage')
+						(class (ref: 39))
 						(type (ref: String)))))))-	(FM3.Package (id: 10)+	(FM3.Package (id: 41)
 		(name 'FAMIX') 		(classes-			(FM3.Class (id: 11)-				(name 'ClassGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 12)-				(name 'Parameter')-				(package (ref: 10))-				(superclass (ref: 13))+			(FM3.Class (id: 42)
+				(name 'ImplicitVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
 				(attributes-					(FM3.Property (id: 14)-						(name 'parentBehaviouralEntity')-						(class (ref: 12))-						(opposite (ref: 15))-						(type (ref: 16)))))-			(FM3.Class (id: 16)-				(name 'BehaviouralEntity')-				(package (ref: 10))-				(superclass (ref: 17))+					(FM3.Property (id: 44)
+						(name 'container')
+						(class (ref: 42))
+						(type (ref: 45)))))
+			(FM3.Class (id: 46)
+				(name 'FileAnchor')
+				(package (ref: 41))
+				(superclass (ref: 47))
 				(attributes-					(FM3.Property (id: 18)-						(name 'declaredType')-						(class (ref: 16))-						(type (ref: 19)))-					(FM3.Property (id: 20)-						(name 'outgoingInvocations')-						(class (ref: 16))-						(derived true)-						(multivalued true)-						(opposite (ref: 21))-						(type (ref: 22)))-					(FM3.Property (id: 23)-						(name 'signature')-						(class (ref: 16))+					(FM3.Property (id: 48)
+						(name 'fileName')
+						(class (ref: 46))
 						(type (ref: String)))-					(FM3.Property (id: 24)-						(name 'localVariables')-						(class (ref: 16))-						(derived true)-						(multivalued true)-						(opposite (ref: 25))-						(type (ref: 26)))-					(FM3.Property (id: 27)-						(name 'accesses')-						(class (ref: 16))-						(derived true)-						(multivalued true)-						(opposite (ref: 28))-						(type (ref: 29)))-					(FM3.Property (id: 30)-						(name 'incomingInvocations')-						(class (ref: 16))-						(derived true)-						(multivalued true)-						(opposite (ref: 31))-						(type (ref: 22)))-					(FM3.Property (id: 15)-						(name 'parameters')-						(class (ref: 16))-						(derived true)-						(multivalued true)-						(opposite (ref: 14))-						(type (ref: 12)))))-			(FM3.Class (id: 32)-				(name 'ParameterizableClass')-				(package (ref: 10))-				(superclass (ref: 33))+					(FM3.Property (id: 49)
+						(name 'startLine')
+						(class (ref: 46))
+						(type (ref: Number)))
+					(FM3.Property (id: 50)
+						(name 'endLine')
+						(class (ref: 46))
+						(type (ref: Number)))))
+			(FM3.Class (id: 51)
+				(name 'Access')
+				(package (ref: 41))
+				(superclass (ref: 52))
 				(attributes-					(FM3.Property (id: 34)-						(name 'parameters')-						(class (ref: 32))+					(FM3.Property (id: 53)
+						(name 'isWrite')
+						(class (ref: 51))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 54)
+						(name 'variable')
+						(class (ref: 51))
+						(opposite (ref: 55))
+						(type (ref: 43)))
+					(FM3.Property (id: 56)
+						(name 'accessor')
+						(class (ref: 51))
+						(opposite (ref: 57))
+						(type (ref: 58)))
+					(FM3.Property (id: 59)
+						(name 'isRead')
+						(class (ref: 51))
 						(derived true)-						(multivalued true)-						(type (ref: 35)))))-			(FM3.Class (id: 36)-				(name 'PrimitiveType')-				(package (ref: 10))-				(superclass (ref: 19)))-			(FM3.Class (id: 8)-				(name 'Entity')-				(package (ref: 10))-				(superclass (ref: Object))+						(type (ref: Boolean)))))
+			(FM3.Class (id: 60)
+				(name 'NamedEntity')
+				(package (ref: 41))
+				(superclass (ref: 61))
 				(attributes-					(FM3.Property (id: 37)-						(name 'annotationInstances')-						(class (ref: 8))+					(FM3.Property (id: 62)
+						(name 'isStub')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 63)
+						(name 'isAbstract')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 64)
+						(name 'name')
+						(class (ref: 60))
+						(type (ref: String)))
+					(FM3.Property (id: 65)
+						(name 'parentPackage')
+						(class (ref: 60))
+						(opposite (ref: 66))
+						(type (ref: 67)))
+					(FM3.Property (id: 68)
+						(name 'modifiers')
+						(class (ref: 60))
+						(multivalued true)
+						(type (ref: String)))
+					(FM3.Property (id: 69)
+						(name 'isProtected')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 70)
+						(name 'belongsTo')
+						(class (ref: 60))
+						(derived true)
+						(type (ref: 71)))
+					(FM3.Property (id: 72)
+						(name 'isPackage')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 73)
+						(name 'isPublic')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 74)
+						(name 'isPrivate')
+						(class (ref: 60))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 75)
+						(name 'receivingInvocations')
+						(class (ref: 60))
 						(derived true) 						(multivalued true)-						(opposite (ref: 38))-						(type (ref: 39)))))-			(FM3.Class (id: 40)+						(opposite (ref: 76))
+						(type (ref: 77)))
+					(FM3.Property (id: 78)
+						(name 'isFinal')
+						(class (ref: 60))
+						(type (ref: Boolean)))))
+			(FM3.Class (id: 79)
 				(name 'Comment')-				(package (ref: 10))-				(superclass (ref: 41))+				(package (ref: 41))
+				(superclass (ref: 61))
 				(attributes-					(FM3.Property (id: 42)+					(FM3.Property (id: 80)
 						(name 'content')-						(class (ref: 40))+						(class (ref: 79))
 						(type (ref: String)))-					(FM3.Property (id: 43)+					(FM3.Property (id: 81)
 						(name 'container')-						(class (ref: 40))-						(opposite (ref: 44))-						(type (ref: 41)))))-			(FM3.Class (id: 35)-				(name 'ParameterType')-				(package (ref: 10))-				(superclass (ref: 19)))-			(FM3.Class (id: 45)-				(name 'NamespaceGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 46)-				(name 'ParameterizedType')-				(package (ref: 10))-				(superclass (ref: 19))+						(class (ref: 79))
+						(opposite (ref: 82))
+						(type (ref: 61)))))
+			(FM3.Class (id: 83)
+				(name 'GlobalVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
 				(attributes-					(FM3.Property (id: 47)-						(name 'arguments')-						(class (ref: 46))-						(multivalued true)-						(type (ref: 19)))-					(FM3.Property (id: 48)-						(name 'parameterizableClass')-						(class (ref: 46))-						(type (ref: 32)))))-			(FM3.Class (id: 49)-				(name 'AnnotationType')-				(package (ref: 10))-				(superclass (ref: 50))+					(FM3.Property (id: 84)
+						(name 'parentScope')
+						(class (ref: 83))
+						(type (ref: 85)))
+					(FM3.Property (id: 86)
+						(name 'parentModule')
+						(class (ref: 83))
+						(opposite (ref: 87))
+						(type (ref: 88)))))
+			(FM3.Class (id: 89)
+				(name 'ThrownException')
+				(package (ref: 41))
+				(superclass (ref: 90))
 				(attributes-					(FM3.Property (id: 51)-						(name 'container')-						(class (ref: 49))-						(opposite (ref: 52))-						(type (ref: 17)))-					(FM3.Property (id: 53)-						(name 'instances')-						(class (ref: 49))+					(FM3.Property (id: 91)
+						(name 'definingMethod')
+						(class (ref: 89))
+						(opposite (ref: 92))
+						(type (ref: 93)))))
+			(FM3.Class (id: 94)
+				(name 'ParameterizableClass')
+				(package (ref: 41))
+				(superclass (ref: 95))
+				(attributes
+					(FM3.Property (id: 96)
+						(name 'parameters')
+						(class (ref: 94))
 						(derived true) 						(multivalued true)-						(opposite (ref: 54))-						(type (ref: 39)))-					(FM3.Property (id: 55)+						(type (ref: 97)))))
+			(FM3.Class (id: 98)
+				(name 'AnnotationInstance')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 99)
+						(name 'annotationType')
+						(class (ref: 98))
+						(opposite (ref: 100))
+						(type (ref: 101)))
+					(FM3.Property (id: 102)
+						(name 'annotatedEntity')
+						(class (ref: 98))
+						(opposite (ref: 103))
+						(type (ref: 6)))
+					(FM3.Property (id: 104)
 						(name 'attributes')-						(class (ref: 49))+						(class (ref: 98))
 						(derived true) 						(multivalued true)-						(opposite (ref: 56))-						(type (ref: 57)))))-			(FM3.Class (id: 58)-				(name 'Attribute')-				(package (ref: 10))-				(superclass (ref: 13))+						(opposite (ref: 105))
+						(type (ref: 106)))))
+			(FM3.Class (id: 107)
+				(name 'LocalVariable')
+				(package (ref: 41))
+				(superclass (ref: 43))
 				(attributes-					(FM3.Property (id: 59)-						(name 'hasClassScope')-						(class (ref: 58))-						(type (ref: Boolean)))-					(FM3.Property (id: 60)-						(name 'parentType')-						(class (ref: 58))-						(opposite (ref: 61))-						(type (ref: 19)))))-			(FM3.Class (id: 62)-				(name 'DeclaredException')-				(package (ref: 10))-				(superclass (ref: 63))+					(FM3.Property (id: 108)
+						(name 'parentBehaviouralEntity')
+						(class (ref: 107))
+						(opposite (ref: 109))
+						(type (ref: 58)))))
+			(FM3.Class (id: 61)
+				(name 'SourcedEntity')
+				(package (ref: 41))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 64)-						(name 'definingMethod')-						(class (ref: 62))-						(opposite (ref: 65))-						(type (ref: 66)))))-			(FM3.Class (id: 67)-				(name 'UnknownVariable')-				(package (ref: 10))-				(superclass (ref: 13)))-			(FM3.Class (id: 68)-				(name 'Inheritance')-				(package (ref: 10))-				(superclass (ref: 69))-				(attributes-					(FM3.Property (id: 70)-						(name 'superclass')-						(class (ref: 68))-						(opposite (ref: 71))-						(type (ref: 19)))-					(FM3.Property (id: 72)-						(name 'subclass')-						(class (ref: 68))-						(opposite (ref: 73))-						(type (ref: 19)))))-			(FM3.Class (id: 69)+					(FM3.Property (id: 82)
+						(name 'comments')
+						(class (ref: 61))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 81))
+						(type (ref: 79)))
+					(FM3.Property (id: 110)
+						(name 'declaredSourceLanguage')
+						(class (ref: 61))
+						(opposite (ref: 111))
+						(type (ref: 112)))
+					(FM3.Property (id: 113)
+						(name 'sourceAnchor')
+						(class (ref: 61))
+						(opposite (ref: 114))
+						(type (ref: 47)))))
+			(FM3.Class (id: 52)
 				(name 'Association')-				(package (ref: 10))-				(superclass (ref: 41))+				(package (ref: 41))
+				(superclass (ref: 61))
 				(attributes-					(FM3.Property (id: 74)-						(name 'from')-						(class (ref: 69))-						(derived true)-						(type (ref: 50)))-					(FM3.Property (id: 75)+					(FM3.Property (id: 115)
 						(name 'next')-						(class (ref: 69))+						(class (ref: 52))
 						(derived true)-						(opposite (ref: 76))-						(type (ref: 69)))-					(FM3.Property (id: 77)+						(opposite (ref: 116))
+						(type (ref: 52)))
+					(FM3.Property (id: 117)
 						(name 'to')-						(class (ref: 69))+						(class (ref: 52))
 						(derived true)-						(type (ref: 50)))-					(FM3.Property (id: 76)+						(type (ref: 60)))
+					(FM3.Property (id: 116)
 						(name 'previous')-						(class (ref: 69))-						(opposite (ref: 75))-						(type (ref: 69)))))-			(FM3.Class (id: 13)-				(name 'StructuralEntity')-				(package (ref: 10))-				(superclass (ref: 78))-				(attributes-					(FM3.Property (id: 79)-						(name 'declaredType')-						(class (ref: 13))-						(type (ref: 19)))-					(FM3.Property (id: 80)-						(name 'incomingAccesses')-						(class (ref: 13))+						(class (ref: 52))
+						(opposite (ref: 115))
+						(type (ref: 52)))
+					(FM3.Property (id: 118)
+						(name 'from')
+						(class (ref: 52))
 						(derived true)-						(multivalued true)-						(opposite (ref: 81))-						(type (ref: 29)))))-			(FM3.Class (id: 82)-				(name 'SmalltalkSourceLanguage')-				(package (ref: 10))-				(superclass (ref: 83)))-			(FM3.Class (id: 39)-				(name 'AnnotationInstance')-				(package (ref: 10))-				(superclass (ref: 8))+						(type (ref: 60)))))
+			(FM3.Class (id: 119)
+				(name 'SourceTextAnchor')
+				(package (ref: 41))
+				(superclass (ref: 47)))
+			(FM3.Class (id: 77)
+				(name 'Invocation')
+				(package (ref: 41))
+				(superclass (ref: 52))
 				(attributes-					(FM3.Property (id: 84)-						(name 'attributes')-						(class (ref: 39))-						(derived true)+					(FM3.Property (id: 120)
+						(name 'sender')
+						(class (ref: 77))
+						(opposite (ref: 121))
+						(type (ref: 58)))
+					(FM3.Property (id: 122)
+						(name 'signature')
+						(class (ref: 77))
+						(type (ref: String)))
+					(FM3.Property (id: 123)
+						(name 'candidates')
+						(class (ref: 77))
 						(multivalued true)-						(type (ref: 85)))-					(FM3.Property (id: 38)-						(name 'annotatedEntity')-						(class (ref: 39))-						(opposite (ref: 37))-						(type (ref: 8)))-					(FM3.Property (id: 54)-						(name 'annotationType')-						(class (ref: 39))-						(opposite (ref: 53))-						(type (ref: 49)))))-			(FM3.Class (id: 86)-				(name 'GlobalVariable')-				(package (ref: 10))-				(superclass (ref: 13))+						(opposite (ref: 124))
+						(type (ref: 58)))
+					(FM3.Property (id: 76)
+						(name 'receiver')
+						(class (ref: 77))
+						(opposite (ref: 75))
+						(type (ref: 60)))
+					(FM3.Property (id: 125)
+						(name 'receiverSourceCode')
+						(class (ref: 77))
+						(type (ref: String)))))
+			(FM3.Class (id: 106)
+				(name 'AnnotationInstanceAttribute')
+				(package (ref: 41))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 87)-						(name 'parentScope')-						(class (ref: 86))-						(opposite (ref: 88))-						(type (ref: 89)))-					(FM3.Property (id: 90)-						(name 'parentModule')-						(class (ref: 86))-						(type (ref: 91)))))-			(FM3.Class (id: 63)+					(FM3.Property (id: 126)
+						(name 'value')
+						(class (ref: 106))
+						(type (ref: String)))
+					(FM3.Property (id: 127)
+						(name 'annotationTypeAttribute')
+						(class (ref: 106))
+						(opposite (ref: 128))
+						(type (ref: 129)))
+					(FM3.Property (id: 105)
+						(name 'parentAnnotationInstance')
+						(class (ref: 106))
+						(opposite (ref: 104))
+						(type (ref: 98)))))
+			(FM3.Class (id: 130)
+				(name 'ClassGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 131)
+				(name 'SmalltalkSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 132)
+				(name 'Reference')
+				(package (ref: 41))
+				(superclass (ref: 52))
+				(attributes
+					(FM3.Property (id: 133)
+						(name 'target')
+						(class (ref: 132))
+						(opposite (ref: 134))
+						(type (ref: 71)))
+					(FM3.Property (id: 135)
+						(name 'source')
+						(class (ref: 132))
+						(opposite (ref: 136))
+						(type (ref: 71)))))
+			(FM3.Class (id: 137)
+				(name 'PrimitiveType')
+				(package (ref: 41))
+				(superclass (ref: 45)))
+			(FM3.Class (id: 90)
 				(name 'Exception')-				(package (ref: 10))-				(superclass (ref: 8))+				(package (ref: 41))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 92)+					(FM3.Property (id: 138)
 						(name 'exceptionClass')-						(class (ref: 63))-						(type (ref: 33)))))-			(FM3.Class (id: 93)-				(name 'EnumValue')-				(package (ref: 10))-				(superclass (ref: 50))-				(attributes-					(FM3.Property (id: 94)-						(name 'parentEnum')-						(class (ref: 93))+						(class (ref: 90))
 						(type (ref: 95)))))-			(FM3.Class (id: 96)-				(name 'FileAnchor')-				(package (ref: 10))-				(superclass (ref: 97))-				(attributes-					(FM3.Property (id: 98)-						(name 'fileName')-						(class (ref: 96))-						(type (ref: String)))-					(FM3.Property (id: 99)-						(name 'startLine')-						(class (ref: 96))-						(type (ref: Number)))-					(FM3.Property (id: 100)-						(name 'endLine')-						(class (ref: 96))-						(type (ref: Number)))))-			(FM3.Class (id: 101)-				(name 'SourceTextAnchor')-				(package (ref: 10))-				(superclass (ref: 97)))-			(FM3.Class (id: 97)-				(name 'SourceAnchor')-				(package (ref: 10))-				(superclass (ref: 8))+			(FM3.Class (id: 139)
+				(name 'Attribute')
+				(package (ref: 41))
+				(superclass (ref: 43))
 				(attributes-					(FM3.Property (id: 102)-						(name 'element')-						(class (ref: 97))-						(opposite (ref: 103))-						(type (ref: 41)))))-			(FM3.Class (id: 57)+					(FM3.Property (id: 140)
+						(name 'hasClassScope')
+						(class (ref: 139))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 141)
+						(name 'parentType')
+						(class (ref: 139))
+						(opposite (ref: 142))
+						(type (ref: 45)))))
+			(FM3.Class (id: 143)
+				(name 'UnknownVariable')
+				(package (ref: 41))
+				(superclass (ref: 43)))
+			(FM3.Class (id: 144)
+				(name 'CSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 129)
 				(name 'AnnotationTypeAttribute')-				(package (ref: 10))-				(superclass (ref: 50))+				(package (ref: 41))
+				(superclass (ref: 60))
 				(attributes-					(FM3.Property (id: 104)+					(FM3.Property (id: 145)
 						(name 'declaredType')-						(class (ref: 57))-						(type (ref: 19)))-					(FM3.Property (id: 56)-						(name 'parentAnnotationType')-						(class (ref: 57))-						(opposite (ref: 55))-						(type (ref: 49)))-					(FM3.Property (id: 105)+						(class (ref: 129))
+						(type (ref: 45)))
+					(FM3.Property (id: 128)
 						(name 'annotationAttributeInstances')-						(class (ref: 57))+						(class (ref: 129))
 						(derived true) 						(multivalued true)-						(type (ref: 85)))))-			(FM3.Class (id: 22)-				(name 'Invocation')-				(package (ref: 10))-				(superclass (ref: 69))+						(opposite (ref: 127))
+						(type (ref: 106)))
+					(FM3.Property (id: 146)
+						(name 'parentAnnotationType')
+						(class (ref: 129))
+						(opposite (ref: 147))
+						(type (ref: 101)))))
+			(FM3.Class (id: 45)
+				(name 'Type')
+				(package (ref: 41))
+				(superclass (ref: 71))
 				(attributes-					(FM3.Property (id: 21)-						(name 'sender')-						(class (ref: 22))-						(opposite (ref: 20))-						(type (ref: 16)))-					(FM3.Property (id: 106)-						(name 'signature')-						(class (ref: 22))-						(type (ref: String)))-					(FM3.Property (id: 107)-						(name 'receiver')-						(class (ref: 22))-						(opposite (ref: 108))-						(type (ref: 50)))-					(FM3.Property (id: 31)-						(name 'candidates')-						(class (ref: 22))+					(FM3.Property (id: 148)
+						(name 'superInheritances')
+						(class (ref: 45))
+						(derived true)
 						(multivalued true)-						(opposite (ref: 30))-						(type (ref: 16)))-					(FM3.Property (id: 109)-						(name 'receiverSourceCode')-						(class (ref: 22))-						(type (ref: String)))))-			(FM3.Class (id: 110)-				(name 'MethodGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 111)+						(opposite (ref: 149))
+						(type (ref: 150)))
+					(FM3.Property (id: 151)
+						(name 'subInheritances')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 152))
+						(type (ref: 150)))
+					(FM3.Property (id: 153)
+						(name 'container')
+						(class (ref: 45))
+						(opposite (ref: 154))
+						(type (ref: 71)))
+					(FM3.Property (id: 155)
+						(name 'methods')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 156))
+						(type (ref: 93)))
+					(FM3.Property (id: 142)
+						(name 'attributes')
+						(class (ref: 45))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 141))
+						(type (ref: 139)))))
+			(FM3.Class (id: 157)
+				(name 'Parameter')
+				(package (ref: 41))
+				(superclass (ref: 43))
+				(attributes
+					(FM3.Property (id: 158)
+						(name 'parentBehaviouralEntity')
+						(class (ref: 157))
+						(opposite (ref: 159))
+						(type (ref: 58)))))
+			(FM3.Class (id: 6)
+				(name 'Entity')
+				(package (ref: 41))
+				(superclass (ref: Object))
+				(attributes
+					(FM3.Property (id: 103)
+						(name 'annotationInstances')
+						(class (ref: 6))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 102))
+						(type (ref: 98)))))
+			(FM3.Class (id: 160)
+				(name 'EnumValue')
+				(package (ref: 41))
+				(superclass (ref: 60))
+				(attributes
+					(FM3.Property (id: 161)
+						(name 'parentEnum')
+						(class (ref: 160))
+						(opposite (ref: 162))
+						(type (ref: 163)))))
+			(FM3.Class (id: 164)
+				(name 'NamespaceGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 165)
 				(name 'Function')-				(package (ref: 10))-				(superclass (ref: 16))+				(package (ref: 41))
+				(superclass (ref: 58))
 				(attributes-					(FM3.Property (id: 112)+					(FM3.Property (id: 166)
 						(name 'parentModule')-						(class (ref: 111))-						(type (ref: 91)))-					(FM3.Property (id: 113)+						(class (ref: 165))
+						(opposite (ref: 167))
+						(type (ref: 88)))
+					(FM3.Property (id: 168)
 						(name 'parentScope')-						(class (ref: 111))-						(opposite (ref: 114))-						(type (ref: 89)))))-			(FM3.Class (id: 115)-				(name 'JavaSourceLanguage')-				(package (ref: 10))-				(superclass (ref: 83)))-			(FM3.Class (id: 116)-				(name 'CustomSourceLanguage')-				(package (ref: 10))-				(superclass (ref: 83))-				(attributes-					(FM3.Property (id: 117)-						(name 'name')-						(class (ref: 116))-						(type (ref: String)))))-			(FM3.Class (id: 78)+						(class (ref: 165))
+						(type (ref: 85)))))
+			(FM3.Class (id: 169)
 				(name 'LeafEntity')-				(package (ref: 10))-				(superclass (ref: 50)))-			(FM3.Class (id: 91)+				(package (ref: 41))
+				(superclass (ref: 60)))
+			(FM3.Class (id: 170)
+				(name 'CaughtException')
+				(package (ref: 41))
+				(superclass (ref: 90))
+				(attributes
+					(FM3.Property (id: 171)
+						(name 'definingMethod')
+						(class (ref: 170))
+						(opposite (ref: 172))
+						(type (ref: 93)))))
+			(FM3.Class (id: 88)
 				(name 'Module')-				(package (ref: 10))-				(superclass (ref: 89)))-			(FM3.Class (id: 118)-				(name 'Namespace')-				(package (ref: 10))-				(superclass (ref: 89)))-			(FM3.Class (id: 119)-				(name 'PackageGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 50)-				(name 'NamedEntity')-				(package (ref: 10))-				(superclass (ref: 41))+				(package (ref: 41))
+				(superclass (ref: 85)))
+			(FM3.Class (id: 101)
+				(name 'AnnotationType')
+				(package (ref: 41))
+				(superclass (ref: 60))
 				(attributes-					(FM3.Property (id: 120)-						(name 'isFinal')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 108)-						(name 'receivingInvocations')-						(class (ref: 50))+					(FM3.Property (id: 147)
+						(name 'attributes')
+						(class (ref: 101))
 						(derived true) 						(multivalued true)-						(opposite (ref: 107))-						(type (ref: 22)))-					(FM3.Property (id: 121)-						(name 'name')-						(class (ref: 50))-						(type (ref: String)))-					(FM3.Property (id: 122)-						(name 'isPublic')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 123)-						(name 'isProtected')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 124)-						(name 'parentPackage')-						(class (ref: 50))-						(opposite (ref: 125))-						(type (ref: 126)))-					(FM3.Property (id: 127)-						(name 'isStub')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 128)-						(name 'isPrivate')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 129)-						(name 'modifiers')-						(class (ref: 50))-						(multivalued true)-						(type (ref: String)))-					(FM3.Property (id: 130)-						(name 'isPackage')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 131)-						(name 'isAbstract')-						(class (ref: 50))-						(type (ref: Boolean)))-					(FM3.Property (id: 132)-						(name 'belongsTo')-						(class (ref: 50))+						(opposite (ref: 146))
+						(type (ref: 129)))
+					(FM3.Property (id: 173)
+						(name 'container')
+						(class (ref: 101))
+						(opposite (ref: 174))
+						(type (ref: 71)))
+					(FM3.Property (id: 100)
+						(name 'instances')
+						(class (ref: 101))
 						(derived true)-						(type (ref: 17)))))-			(FM3.Class (id: 126)+						(multivalued true)
+						(opposite (ref: 99))
+						(type (ref: 98)))))
+			(FM3.Class (id: 175)
+				(name 'PackageGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 176)
+				(name 'Namespace')
+				(package (ref: 41))
+				(superclass (ref: 85)))
+			(FM3.Class (id: 177)
+				(name 'DeclaredException')
+				(package (ref: 41))
+				(superclass (ref: 90))
+				(attributes
+					(FM3.Property (id: 178)
+						(name 'definingMethod')
+						(class (ref: 177))
+						(opposite (ref: 179))
+						(type (ref: 93)))))
+			(FM3.Class (id: 67)
 				(name 'Package')-				(package (ref: 10))-				(superclass (ref: 89))+				(package (ref: 41))
+				(superclass (ref: 85))
 				(attributes-					(FM3.Property (id: 125)+					(FM3.Property (id: 66)
 						(name 'childNamedEntities')-						(class (ref: 126))+						(class (ref: 67))
 						(derived true) 						(multivalued true)-						(opposite (ref: 124))-						(type (ref: 50)))))-			(FM3.Class (id: 133)-				(name 'ImplicitVariable')-				(package (ref: 10))-				(superclass (ref: 13))+						(opposite (ref: 65))
+						(type (ref: 60)))))
+			(FM3.Class (id: 150)
+				(name 'Inheritance')
+				(package (ref: 41))
+				(superclass (ref: 52))
 				(attributes-					(FM3.Property (id: 134)-						(name 'container')-						(class (ref: 133))-						(type (ref: 19)))))-			(FM3.Class (id: 66)-				(name 'Method')-				(package (ref: 10))-				(superclass (ref: 16))+					(FM3.Property (id: 152)
+						(name 'superclass')
+						(class (ref: 150))
+						(opposite (ref: 151))
+						(type (ref: 45)))
+					(FM3.Property (id: 149)
+						(name 'subclass')
+						(class (ref: 150))
+						(opposite (ref: 148))
+						(type (ref: 45)))))
+			(FM3.Class (id: 85)
+				(name 'ScopingEntity')
+				(package (ref: 41))
+				(superclass (ref: 71))
 				(attributes-					(FM3.Property (id: 135)-						(name 'thrownExceptions')-						(class (ref: 66))-						(derived true)-						(multivalued true)-						(opposite (ref: 136))-						(type (ref: 137)))-					(FM3.Property (id: 138)-						(name 'kind')-						(class (ref: 66))-						(type (ref: String)))-					(FM3.Property (id: 139)-						(name 'hasClassScope')-						(class (ref: 66))-						(type (ref: Boolean)))-					(FM3.Property (id: 65)-						(name 'declaredExceptions')-						(class (ref: 66))+					(FM3.Property (id: 87)
+						(name 'globalVariables')
+						(class (ref: 85))
 						(derived true) 						(multivalued true)-						(opposite (ref: 64))-						(type (ref: 62)))-					(FM3.Property (id: 140)-						(name 'caughtExceptions')-						(class (ref: 66))+						(opposite (ref: 86))
+						(type (ref: 83)))
+					(FM3.Property (id: 167)
+						(name 'functions')
+						(class (ref: 85))
 						(derived true) 						(multivalued true)-						(opposite (ref: 141))-						(type (ref: 142)))-					(FM3.Property (id: 143)-						(name 'parentType')-						(class (ref: 66))-						(opposite (ref: 144))-						(type (ref: 19)))))-			(FM3.Class (id: 83)-				(name 'SourceLanguage')-				(package (ref: 10))-				(superclass (ref: 8))-				(attributes-					(FM3.Property (id: 145)-						(name 'sourcedEntities')-						(class (ref: 83))+						(opposite (ref: 166))
+						(type (ref: 165)))
+					(FM3.Property (id: 180)
+						(name 'childScopes')
+						(class (ref: 85))
 						(derived true) 						(multivalued true)-						(opposite (ref: 146))-						(type (ref: 41)))-					(FM3.Property (id: 147)-						(name 'name')-						(class (ref: 83))-						(derived true)-						(type (ref: String)))))-			(FM3.Class (id: 29)-				(name 'Access')-				(package (ref: 10))-				(superclass (ref: 69))-				(attributes-					(FM3.Property (id: 28)-						(name 'accessor')-						(class (ref: 29))-						(opposite (ref: 27))-						(type (ref: 16)))-					(FM3.Property (id: 148)-						(name 'isWrite')-						(class (ref: 29))-						(type (ref: Boolean)))-					(FM3.Property (id: 81)-						(name 'variable')-						(class (ref: 29))-						(opposite (ref: 80))-						(type (ref: 13)))-					(FM3.Property (id: 149)-						(name 'isRead')-						(class (ref: 29))-						(derived true)-						(type (ref: Boolean)))))-			(FM3.Class (id: 150)+						(opposite (ref: 181))
+						(type (ref: 85)))
+					(FM3.Property (id: 181)
+						(name 'parentScope')
+						(class (ref: 85))
+						(opposite (ref: 180))
+						(type (ref: 85)))))
+			(FM3.Class (id: 182)
 				(name 'AnnotationTypeGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 89)-				(name 'ScopingEntity')-				(package (ref: 10))-				(superclass (ref: 17))+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 93)
+				(name 'Method')
+				(package (ref: 41))
+				(superclass (ref: 58))
 				(attributes-					(FM3.Property (id: 114)-						(name 'functions')-						(class (ref: 89))+					(FM3.Property (id: 179)
+						(name 'declaredExceptions')
+						(class (ref: 93))
 						(derived true) 						(multivalued true)-						(opposite (ref: 113))-						(type (ref: 111)))-					(FM3.Property (id: 151)-						(name 'parentScope')-						(class (ref: 89))-						(opposite (ref: 152))-						(type (ref: 89)))-					(FM3.Property (id: 88)-						(name 'globalVariables')-						(class (ref: 89))+						(opposite (ref: 178))
+						(type (ref: 177)))
+					(FM3.Property (id: 183)
+						(name 'hasClassScope')
+						(class (ref: 93))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 184)
+						(name 'kind')
+						(class (ref: 93))
+						(type (ref: String)))
+					(FM3.Property (id: 172)
+						(name 'caughtExceptions')
+						(class (ref: 93))
 						(derived true) 						(multivalued true)-						(opposite (ref: 87))-						(type (ref: 86)))-					(FM3.Property (id: 152)-						(name 'childScopes')-						(class (ref: 89))+						(opposite (ref: 171))
+						(type (ref: 170)))
+					(FM3.Property (id: 92)
+						(name 'thrownExceptions')
+						(class (ref: 93))
 						(derived true) 						(multivalued true)-						(opposite (ref: 151))-						(type (ref: 89)))))-			(FM3.Class (id: 142)-				(name 'CaughtException')-				(package (ref: 10))-				(superclass (ref: 63))-				(attributes-					(FM3.Property (id: 141)-						(name 'definingMethod')-						(class (ref: 142))-						(opposite (ref: 140))-						(type (ref: 66)))))-			(FM3.Class (id: 41)-				(name 'SourcedEntity')-				(package (ref: 10))-				(superclass (ref: 8))+						(opposite (ref: 91))
+						(type (ref: 89)))
+					(FM3.Property (id: 156)
+						(name 'parentType')
+						(class (ref: 93))
+						(opposite (ref: 155))
+						(type (ref: 45)))))
+			(FM3.Class (id: 185)
+				(name 'MethodGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 112)
+				(name 'SourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 44)-						(name 'comments')-						(class (ref: 41))+					(FM3.Property (id: 186)
+						(name 'name')
+						(class (ref: 112))
+						(derived true)
+						(type (ref: String)))
+					(FM3.Property (id: 111)
+						(name 'sourcedEntities')
+						(class (ref: 112))
 						(derived true) 						(multivalued true)-						(opposite (ref: 43))-						(type (ref: 40)))-					(FM3.Property (id: 103)-						(name 'sourceAnchor')-						(class (ref: 41))-						(opposite (ref: 102))-						(type (ref: 97)))-					(FM3.Property (id: 146)-						(name 'declaredSourceLanguage')-						(class (ref: 41))-						(opposite (ref: 145))-						(type (ref: 83)))))-			(FM3.Class (id: 137)-				(name 'ThrownException')-				(package (ref: 10))-				(superclass (ref: 63))+						(opposite (ref: 110))
+						(type (ref: 61)))))
+			(FM3.Class (id: 97)
+				(name 'ParameterType')
+				(package (ref: 41))
+				(superclass (ref: 45)))
+			(FM3.Class (id: 187)
+				(name 'ParameterizedType')
+				(package (ref: 41))
+				(superclass (ref: 45))
 				(attributes-					(FM3.Property (id: 136)-						(name 'definingMethod')-						(class (ref: 137))-						(opposite (ref: 135))-						(type (ref: 66)))))-			(FM3.Class (id: 17)+					(FM3.Property (id: 188)
+						(name 'arguments')
+						(class (ref: 187))
+						(multivalued true)
+						(type (ref: 45)))
+					(FM3.Property (id: 189)
+						(name 'parameterizableClass')
+						(class (ref: 187))
+						(type (ref: 94)))))
+			(FM3.Class (id: 71)
 				(name 'ContainerEntity')-				(package (ref: 10))-				(superclass (ref: 50))+				(package (ref: 41))
+				(superclass (ref: 60))
 				(attributes-					(FM3.Property (id: 153)+					(FM3.Property (id: 154)
 						(name 'types')-						(class (ref: 17))+						(class (ref: 71))
 						(derived true) 						(multivalued true)-						(opposite (ref: 154))-						(type (ref: 19)))-					(FM3.Property (id: 155)-						(name 'incomingReferences')-						(class (ref: 17))+						(opposite (ref: 153))
+						(type (ref: 45)))
+					(FM3.Property (id: 136)
+						(name 'outgoingReferences')
+						(class (ref: 71))
 						(derived true) 						(multivalued true)-						(opposite (ref: 156))-						(type (ref: 157)))-					(FM3.Property (id: 158)-						(name 'outgoingReferences')-						(class (ref: 17))+						(opposite (ref: 135))
+						(type (ref: 132)))
+					(FM3.Property (id: 134)
+						(name 'incomingReferences')
+						(class (ref: 71))
 						(derived true) 						(multivalued true)-						(opposite (ref: 159))-						(type (ref: 157)))-					(FM3.Property (id: 52)+						(opposite (ref: 133))
+						(type (ref: 132)))
+					(FM3.Property (id: 174)
 						(name 'definedAnnotationTypes')-						(class (ref: 17))+						(class (ref: 71))
 						(derived true) 						(multivalued true)-						(opposite (ref: 51))-						(type (ref: 49)))))-			(FM3.Class (id: 95)+						(opposite (ref: 173))
+						(type (ref: 101)))))
+			(FM3.Class (id: 163)
 				(name 'Enum')-				(package (ref: 10))-				(superclass (ref: 19)))-			(FM3.Class (id: 160)-				(name 'GlobalVariableGroup')-				(package (ref: 10))-				(superclass (ref: 3)))-			(FM3.Class (id: 85)-				(name 'AnnotationInstanceAttribute')-				(package (ref: 10))-				(superclass (ref: 8)))-			(FM3.Class (id: 19)-				(name 'Type')-				(package (ref: 10))-				(superclass (ref: 17))+				(package (ref: 41))
+				(superclass (ref: 45))
 				(attributes-					(FM3.Property (id: 61)-						(name 'attributes')-						(class (ref: 19))+					(FM3.Property (id: 162)
+						(name 'values')
+						(class (ref: 163))
 						(derived true) 						(multivalued true)-						(opposite (ref: 60))-						(type (ref: 58)))-					(FM3.Property (id: 144)-						(name 'methods')-						(class (ref: 19))+						(opposite (ref: 161))
+						(type (ref: 160)))))
+			(FM3.Class (id: 190)
+				(name 'JavaSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 191)
+				(name 'CustomSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112))
+				(attributes
+					(FM3.Property (id: 192)
+						(name 'name')
+						(class (ref: 191))
+						(type (ref: String)))))
+			(FM3.Class (id: 43)
+				(name 'StructuralEntity')
+				(package (ref: 41))
+				(superclass (ref: 169))
+				(attributes
+					(FM3.Property (id: 193)
+						(name 'declaredType')
+						(class (ref: 43))
+						(type (ref: 45)))
+					(FM3.Property (id: 55)
+						(name 'incomingAccesses')
+						(class (ref: 43))
 						(derived true) 						(multivalued true)-						(opposite (ref: 143))-						(type (ref: 66)))-					(FM3.Property (id: 154)-						(name 'container')-						(class (ref: 19))-						(opposite (ref: 153))-						(type (ref: 17)))-					(FM3.Property (id: 73)-						(name 'superInheritances')-						(class (ref: 19))+						(opposite (ref: 54))
+						(type (ref: 51)))))
+			(FM3.Class (id: 58)
+				(name 'BehaviouralEntity')
+				(package (ref: 41))
+				(superclass (ref: 71))
+				(attributes
+					(FM3.Property (id: 57)
+						(name 'accesses')
+						(class (ref: 58))
 						(derived true) 						(multivalued true)-						(opposite (ref: 72))-						(type (ref: 68)))-					(FM3.Property (id: 71)-						(name 'subInheritances')-						(class (ref: 19))+						(opposite (ref: 56))
+						(type (ref: 51)))
+					(FM3.Property (id: 194)
+						(name 'declaredType')
+						(class (ref: 58))
+						(type (ref: 45)))
+					(FM3.Property (id: 124)
+						(name 'incomingInvocations')
+						(class (ref: 58))
 						(derived true) 						(multivalued true)-						(opposite (ref: 70))-						(type (ref: 68)))))-			(FM3.Class (id: 33)+						(opposite (ref: 123))
+						(type (ref: 77)))
+					(FM3.Property (id: 121)
+						(name 'outgoingInvocations')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 120))
+						(type (ref: 77)))
+					(FM3.Property (id: 159)
+						(name 'parameters')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 158))
+						(type (ref: 157)))
+					(FM3.Property (id: 109)
+						(name 'localVariables')
+						(class (ref: 58))
+						(derived true)
+						(multivalued true)
+						(opposite (ref: 108))
+						(type (ref: 107)))
+					(FM3.Property (id: 195)
+						(name 'signature')
+						(class (ref: 58))
+						(type (ref: String)))))
+			(FM3.Class (id: 196)
+				(name 'GlobalVariableGroup')
+				(package (ref: 41))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 47)
+				(name 'SourceAnchor')
+				(package (ref: 41))
+				(superclass (ref: 6))
+				(attributes
+					(FM3.Property (id: 114)
+						(name 'element')
+						(class (ref: 47))
+						(opposite (ref: 113))
+						(type (ref: 61)))))
+			(FM3.Class (id: 197)
+				(name 'UnknownSourceLanguage')
+				(package (ref: 41))
+				(superclass (ref: 112)))
+			(FM3.Class (id: 95)
 				(name 'Class')-				(package (ref: 10))-				(superclass (ref: 19))+				(package (ref: 41))
+				(superclass (ref: 45))
 				(attributes-					(FM3.Property (id: 161)+					(FM3.Property (id: 198)
+						(name 'isInterface')
+						(class (ref: 95))
+						(type (ref: Boolean)))
+					(FM3.Property (id: 199)
 						(name 'isAbstract')-						(class (ref: 33))+						(class (ref: 95))
 						(derived true)-						(type (ref: Boolean)))-					(FM3.Property (id: 162)-						(name 'isInterface')-						(class (ref: 33)) 						(type (ref: Boolean)))))-			(FM3.Class (id: 26)-				(name 'LocalVariable')-				(package (ref: 10))-				(superclass (ref: 13))-				(attributes-					(FM3.Property (id: 25)-						(name 'parentBehaviouralEntity')-						(class (ref: 26))-						(opposite (ref: 24))-						(type (ref: 16)))))-			(FM3.Class (id: 163)-				(name 'UnknownSourceLanguage')-				(package (ref: 10))-				(superclass (ref: 83)))-			(FM3.Class (id: 164)+			(FM3.Class (id: 200)
 				(name 'SmalltalkMonticelloSourceLanguage')-				(package (ref: 10))-				(superclass (ref: 83)))-			(FM3.Class (id: 157)-				(name 'Reference')-				(package (ref: 10))-				(superclass (ref: 69))-				(attributes-					(FM3.Property (id: 156)-						(name 'target')-						(class (ref: 157))-						(opposite (ref: 155))-						(type (ref: 17)))-					(FM3.Property (id: 159)-						(name 'source')-						(class (ref: 157))-						(opposite (ref: 158))-						(type (ref: 17)))))))-	(FM3.Package (id: 165)+				(package (ref: 41))
+				(superclass (ref: 112)))))
+	(FM3.Package (id: 201)
 		(name 'Dude') 		(classes-			(FM3.Class (id: 166)-				(name 'MultiplicationGroup')-				(package (ref: 165))-				(superclass (ref: 3)))-			(FM3.Class (id: 167)+			(FM3.Class (id: 202)
 				(name 'DuplicationGroup')-				(package (ref: 165))-				(superclass (ref: 3)))-			(FM3.Class (id: 168)-				(name 'CodeLine')-				(package (ref: 165))-				(superclass (ref: 8)))-			(FM3.Class (id: 169)-				(name 'CodeFragment')-				(package (ref: 165))-				(superclass (ref: 8)))-			(FM3.Class (id: 170)+				(package (ref: 201))
+				(superclass (ref: 18)))
+			(FM3.Class (id: 203)
 				(name 'Duplication')-				(package (ref: 165))-				(superclass (ref: 8))+				(package (ref: 201))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 171)+					(FM3.Property (id: 204)
 						(name 'multiplicationInvolved')-						(class (ref: 170))-						(opposite (ref: 172))-						(type (ref: 173)))))-			(FM3.Class (id: 173)+						(class (ref: 203))
+						(opposite (ref: 205))
+						(type (ref: 206)))))
+			(FM3.Class (id: 207)
+				(name 'CodeLine')
+				(package (ref: 201))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 208)
+				(name 'CodeFragment')
+				(package (ref: 201))
+				(superclass (ref: 6)))
+			(FM3.Class (id: 206)
 				(name 'Multiplication')-				(package (ref: 165))-				(superclass (ref: 8))+				(package (ref: 201))
+				(superclass (ref: 6))
 				(attributes-					(FM3.Property (id: 172)+					(FM3.Property (id: 205)
 						(name 'duplications')-						(class (ref: 173))+						(class (ref: 206))
 						(derived true) 						(multivalued true)-						(opposite (ref: 171))-						(type (ref: 170)))))))-	(FM3.Package (id: 174)-		(name 'Hismo')-		(classes-			(FM3.Class (id: 175)-				(name 'HismoClassVersion')-				(package (ref: 174))-				(superclass (ref: 176)))-			(FM3.Class (id: 177)-				(name 'HismoMethodHistoryGroup')-				(package (ref: 174))-				(superclass (ref: 178)))-			(FM3.Class (id: 179)-				(name 'HismoPackageHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 181)-				(name 'HismoClassHierarchy')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 182)-				(name 'HismoCoChangeVersion')-				(package (ref: 174))-				(superclass (ref: 183)))-			(FM3.Class (id: 176)-				(name 'HismoEntityVersion')-				(package (ref: 174))-				(superclass (ref: 183)))-			(FM3.Class (id: 184)-				(name 'HismoClassHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 185)-				(name 'HismoNamespaceHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 178)-				(name 'HismoHistoryGroup')-				(package (ref: 174))-				(superclass (ref: 3)))-			(FM3.Class (id: 186)-				(name 'HismoAccessHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 187)-				(name 'HismoCoChangePattern')-				(package (ref: 174))-				(superclass (ref: 3)))-			(FM3.Class (id: 188)-				(name 'HismoInheritanceDefinitionHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 189)-				(name 'HismoModelHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 190)-				(name 'HismoNamespaceVersion')-				(package (ref: 174))-				(superclass (ref: 176)))-			(FM3.Class (id: 180)-				(name 'HismoAbstractHistory')-				(package (ref: 174))-				(superclass (ref: 8)))-			(FM3.Class (id: 191)-				(name 'HismoInvocationHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 192)-				(name 'HismoNamespaceHistoryGroup')-				(package (ref: 174))-				(superclass (ref: 178)))-			(FM3.Class (id: 193)-				(name 'HismoClassHistoryGroup')-				(package (ref: 174))-				(superclass (ref: 178)))-			(FM3.Class (id: 194)-				(name 'HismoMethodHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 195)-				(name 'HismoAttributeHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 196)-				(name 'HismoCoChangeHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 197)-				(name 'HismoMethodVersion')-				(package (ref: 174))-				(superclass (ref: 176)))-			(FM3.Class (id: 198)-				(name 'HismoFileHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 199)-				(name 'HismoFolderHistory')-				(package (ref: 174))-				(superclass (ref: 180)))-			(FM3.Class (id: 183)-				(name 'HismoAbstractVersion')-				(package (ref: 174))-				(superclass (ref: 8)))))-	(FM3.Package (id: 200)-		(name 'Moose')-		(classes-			(FM3.Class (id: 201)-				(name 'Entity')-				(abstract true)-				(package (ref: 200))-				(superclass (ref: Object)))-			(FM3.Class (id: 3)-				(name 'Group')-				(package (ref: 200))-				(superclass (ref: 202)))-			(FM3.Class (id: 203)-				(name 'Model')-				(package (ref: 200))-				(superclass (ref: 202))-				(attributes-					(FM3.Property (id: 204)-						(name 'sourceLanguage')-						(class (ref: 203))-						(type (ref: String)))))-			(FM3.Class (id: 202)-				(name 'AbsractGroup')-				(abstract true)-				(package (ref: 200))-				(superclass (ref: 201))))))+						(opposite (ref: 204))
+						(type (ref: 203)))))
+			(FM3.Class (id: 209)
+				(name 'MultiplicationGroup')
+				(package (ref: 201))
+				(superclass (ref: 18))))))
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 85)
@@ -13,10 +13,10 @@
     
     public static void importInto(MetaRepository metamodel) {
 		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
 		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
-		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
 		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 85)
@@ -12,31 +12,31 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
 		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
-		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAccessHistory.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 85)
@@ -12,11 +12,11 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.Multiplication.class);
-		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.dude.CodeLine.class);
 
     }
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 85)
@@ -12,10 +12,10 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.Group.class);
 		metamodel.with(fr.inria.verveine.core.gen.moose.Model.class);
 		metamodel.with(fr.inria.verveine.core.gen.moose.Entity.class);
-		metamodel.with(fr.inria.verveine.core.gen.moose.Group.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.AbsractGroup.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 85)
@@ -1,6 +1,7 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import ch.akuhn.fame.internal.MultivalueSet;
 import java.util.*;
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
@@ -41,13 +42,61 @@
         parentAnnotationType.getAttributes().add(this);
     }
     
-    @FameProperty(name = "annotationAttributeInstances", derived = true)
+    private Collection<AnnotationInstanceAttribute> annotationAttributeInstances; 
+
+    @FameProperty(name = "annotationAttributeInstances", opposite = "annotationTypeAttribute", derived = true)
     public Collection<AnnotationInstanceAttribute> getAnnotationAttributeInstances() {
-        // TODO: this is a derived property, implement this method manually.
-        throw new UnsupportedOperationException("Not yet implemented!");  
+        if (annotationAttributeInstances == null) {
+            annotationAttributeInstances = new MultivalueSet<AnnotationInstanceAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationInstanceAttribute e) {
+                    e.setAnnotationTypeAttribute(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstanceAttribute e) {
+                    e.setAnnotationTypeAttribute(AnnotationTypeAttribute.this);
+                }
+            };
+        }
+        return annotationAttributeInstances;
     }
+    
+    public void setAnnotationAttributeInstances(Collection<? extends AnnotationInstanceAttribute> annotationAttributeInstances) {
+        this.getAnnotationAttributeInstances().clear();
+        this.getAnnotationAttributeInstances().addAll(annotationAttributeInstances);
+    }                    
+    
         
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute one) {
+        this.getAnnotationAttributeInstances().add(one);
+    }   
+    
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute one, AnnotationInstanceAttribute... many) {
+        this.getAnnotationAttributeInstances().add(one);
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }   
+    
+    public void addAnnotationAttributeInstances(Iterable<? extends AnnotationInstanceAttribute> many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }   
+                
+    public void addAnnotationAttributeInstances(AnnotationInstanceAttribute[] many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAnnotationAttributeInstances().add(each);
+    }
+    
+    public int numberOfAnnotationAttributeInstances() {
+        return getAnnotationAttributeInstances().size();
+    }
 
+    public boolean hasAnnotationAttributeInstances() {
+        return !getAnnotationAttributeInstances().isEmpty();
+    }
+    
+                
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/EnumValue.java	(revision 85)
@@ -14,13 +14,19 @@
 
     private Enum parentEnum;
     
-    @FameProperty(name = "parentEnum")
+    @FameProperty(name = "parentEnum", opposite = "values")
     public Enum getParentEnum() {
         return parentEnum;
     }
 
     public void setParentEnum(Enum parentEnum) {
+        if (this.parentEnum != null) {
+            if (this.parentEnum.equals(parentEnum)) return;
+            this.parentEnum.getValues().remove(this);
+        }
         this.parentEnum = parentEnum;
+        if (parentEnum == null) return;
+        parentEnum.getValues().add(this);
     }
     
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 85)
@@ -14,23 +14,6 @@
 
 
 
-    private SourceLanguage declaredSourceLanguage = null;
-    
-    @FameProperty(name = "declaredSourceLanguage", opposite = "sourcedEntities")
-    public SourceLanguage getDeclaredSourceLanguage() {
-        return declaredSourceLanguage;
-    }
-
-    public void setDeclaredSourceLanguage(SourceLanguage declaredSourceLanguage) {
-        if (this.declaredSourceLanguage != null) {
-            if (this.declaredSourceLanguage.equals(declaredSourceLanguage)) return;
-            this.declaredSourceLanguage.getSourcedEntities().remove(this);
-        }
-        this.declaredSourceLanguage = declaredSourceLanguage;
-        if (declaredSourceLanguage == null) return;
-        declaredSourceLanguage.getSourcedEntities().add(this);
-    }
-    
     private SourceAnchor sourceAnchor;
     
     @FameProperty(name = "sourceAnchor", opposite = "element")
@@ -47,6 +30,23 @@
         }
     }
     
+    private SourceLanguage declaredSourceLanguage;
+    
+    @FameProperty(name = "declaredSourceLanguage", opposite = "sourcedEntities")
+    public SourceLanguage getDeclaredSourceLanguage() {
+        return declaredSourceLanguage;
+    }
+
+    public void setDeclaredSourceLanguage(SourceLanguage declaredSourceLanguage) {
+        if (this.declaredSourceLanguage != null) {
+            if (this.declaredSourceLanguage.equals(declaredSourceLanguage)) return;
+            this.declaredSourceLanguage.getSourcedEntities().remove(this);
+        }
+        this.declaredSourceLanguage = declaredSourceLanguage;
+        if (declaredSourceLanguage == null) return;
+        declaredSourceLanguage.getSourcedEntities().add(this);
+    }
+    
     private Collection<Comment> comments; 
 
     @FameProperty(name = "comments", opposite = "container", derived = true)
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Enum.java	(revision 85)
@@ -1,6 +1,9 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
 
@@ -11,7 +14,61 @@
 
 
 
+    private Collection<EnumValue> values; 
+
+    @FameProperty(name = "values", opposite = "parentEnum", derived = true)
+    public Collection<EnumValue> getValues() {
+        if (values == null) {
+            values = new MultivalueSet<EnumValue>() {
+                @Override
+                protected void clearOpposite(EnumValue e) {
+                    e.setParentEnum(null);
+                }
+                @Override
+                protected void setOpposite(EnumValue e) {
+                    e.setParentEnum(Enum.this);
+                }
+            };
+        }
+        return values;
+    }
+    
+    public void setValues(Collection<? extends EnumValue> values) {
+        this.getValues().clear();
+        this.getValues().addAll(values);
+    }                    
+    
+        
+    public void addValues(EnumValue one) {
+        this.getValues().add(one);
+    }   
+    
+    public void addValues(EnumValue one, EnumValue... many) {
+        this.getValues().add(one);
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }   
+    
+    public void addValues(Iterable<? extends EnumValue> many) {
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }   
+                
+    public void addValues(EnumValue[] many) {
+        for (EnumValue each : many)
+            this.getValues().add(each);
+    }
+    
+    public int numberOfValues() {
+        return getValues().size();
+    }
 
+    public boolean hasValues() {
+        return !getValues().isEmpty();
+    }
+    
+                
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/CSourceLanguage.java	(revision 85)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CSourceLanguage")
+public class CSourceLanguage extends SourceLanguage {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 85)
@@ -219,17 +219,6 @@
     public void setKind(String kind) {
         this.kind = kind;
     }
-   
-    private Collection<Type> declaredArgumentTypes;
-    
-    @FameProperty(name = "declaredArgumentTypes")
-    public Collection<Type> getDeclaredArgumentTypes() {
-        return declaredArgumentTypes;
-    }
-
-    public void setDeclaredArgumentTypes(Collection<Type> declaredArgumentTypes) {
-        this.declaredArgumentTypes = declaredArgumentTypes;
-    }
     
 
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 85)
@@ -106,17 +106,6 @@
         this.isPublic = isPublic;
     }
     
-    private Boolean isProtected;
-    
-    @FameProperty(name = "isProtected")
-    public Boolean getIsProtected() {
-        return isProtected;
-    }
-
-    public void setIsProtected(Boolean isProtected) {
-        this.isProtected = isProtected;
-    }
-    
     private Collection<Invocation> receivingInvocations; 
 
     @FameProperty(name = "receivingInvocations", opposite = "receiver", derived = true)
@@ -171,6 +160,17 @@
     }
     
                 
+    private Boolean isProtected;
+    
+    @FameProperty(name = "isProtected")
+    public Boolean getIsProtected() {
+        return isProtected;
+    }
+
+    public void setIsProtected(Boolean isProtected) {
+        this.isProtected = isProtected;
+    }
+    
     private Collection<String> modifiers; 
 
     @FameProperty(name = "modifiers")
@@ -211,7 +211,8 @@
     public boolean hasModifiers() {
         return !getModifiers().isEmpty();
     }
-            
+    
+                
     @FameProperty(name = "belongsTo", derived = true)
     public ContainerEntity getBelongsTo() {
         // TODO: this is a derived property, implement this method manually.
@@ -232,6 +233,7 @@
 
 	@Override
 	public String toString() {
+	// mainly for debugging purposes (in Eclipse debugger)
 		return "a " + this.getClass().getCanonicalName() + " named: " + this.getName();
 	}
     
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstanceAttribute.java	(revision 85)
@@ -1,6 +1,7 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
 import ch.akuhn.fame.FamePackage;
 
@@ -11,7 +12,52 @@
 
 
 
+    private AnnotationInstance parentAnnotationInstance;
+    
+    @FameProperty(name = "parentAnnotationInstance", opposite = "attributes")
+    public AnnotationInstance getParentAnnotationInstance() {
+        return parentAnnotationInstance;
+    }
+
+    public void setParentAnnotationInstance(AnnotationInstance parentAnnotationInstance) {
+        if (this.parentAnnotationInstance != null) {
+            if (this.parentAnnotationInstance.equals(parentAnnotationInstance)) return;
+            this.parentAnnotationInstance.getAttributes().remove(this);
+        }
+        this.parentAnnotationInstance = parentAnnotationInstance;
+        if (parentAnnotationInstance == null) return;
+        parentAnnotationInstance.getAttributes().add(this);
+    }
+    
+    private String value;
+    
+    @FameProperty(name = "value")
+    public String getValue() {
+        return value;
+    }
 
+    public void setValue(String value) {
+        this.value = value;
+    }
+    
+    private AnnotationTypeAttribute annotationTypeAttribute;
+    
+    @FameProperty(name = "annotationTypeAttribute", opposite = "annotationAttributeInstances")
+    public AnnotationTypeAttribute getAnnotationTypeAttribute() {
+        return annotationTypeAttribute;
+    }
+
+    public void setAnnotationTypeAttribute(AnnotationTypeAttribute annotationTypeAttribute) {
+        if (this.annotationTypeAttribute != null) {
+            if (this.annotationTypeAttribute.equals(annotationTypeAttribute)) return;
+            this.annotationTypeAttribute.getAnnotationAttributeInstances().remove(this);
+        }
+        this.annotationTypeAttribute = annotationTypeAttribute;
+        if (annotationTypeAttribute == null) return;
+        annotationTypeAttribute.getAnnotationAttributeInstances().add(this);
+    }
+    
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 85)
@@ -12,62 +12,63 @@
     }
     
     public static void importInto(MetaRepository metamodel) {
-		metamodel.with(fr.inria.verveine.core.gen.famix.EnumValue.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.CaughtException.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.LeafEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Type.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterType.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.PrimitiveType.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.JavaSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Access.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Exception.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.EnumValue.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Reference.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizedType.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ThrownException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Invocation.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownSourceLanguage.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ContainerEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Exception.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Enum.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkMonticelloSourceLanguage.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Attribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ImplicitVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.ScopingEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizableClass.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Module.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Package.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CustomSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ContainerEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LeafEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CaughtException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.DeclaredException.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.ImplicitVariable.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Method.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.SourceAnchor.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Module.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.CustomSourceLanguage.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ThrownException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizedType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.SmalltalkSourceLanguage.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.SourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.Parameter.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.Enum.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
 		metamodel.with(fr.inria.verveine.core.gen.famix.PackageGroup.class);
-		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.JavaSourceLanguage.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PrimitiveType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Type.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ParameterizableClass.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
 
     }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 85)
@@ -1,6 +1,7 @@
 // Automagically generated code, please do not change
 package fr.inria.verveine.core.gen.famix;
 
+import ch.akuhn.fame.internal.MultivalueSet;
 import java.util.*;
 import ch.akuhn.fame.FameProperty;
 import ch.akuhn.fame.FameDescription;
@@ -47,13 +48,61 @@
         annotationType.getInstances().add(this);
     }
     
-    @FameProperty(name = "attributes", derived = true)
+    private Collection<AnnotationInstanceAttribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentAnnotationInstance", derived = true)
     public Collection<AnnotationInstanceAttribute> getAttributes() {
-        // TODO: this is a derived property, implement this method manually.
-    	return null;
+        if (attributes == null) {
+            attributes = new MultivalueSet<AnnotationInstanceAttribute>() {
+                @Override
+                protected void clearOpposite(AnnotationInstanceAttribute e) {
+                    e.setParentAnnotationInstance(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstanceAttribute e) {
+                    e.setParentAnnotationInstance(AnnotationInstance.this);
+                }
+            };
+        }
+        return attributes;
     }
+    
+    public void setAttributes(Collection<? extends AnnotationInstanceAttribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
         
+    public void addAttributes(AnnotationInstanceAttribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(AnnotationInstanceAttribute one, AnnotationInstanceAttribute... many) {
+        this.getAttributes().add(one);
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends AnnotationInstanceAttribute> many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(AnnotationInstanceAttribute[] many) {
+        for (AnnotationInstanceAttribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
 
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
+
 
 }
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourceLanguage.java	(revision 85)
@@ -14,12 +14,6 @@
 
 
 
-    @FameProperty(name = "name", derived = true)
-    public String getName() {
-        // TODO: this is a derived property, implement this method manually.
-        throw new UnsupportedOperationException("Not yet implemented!");  
-    }
-    
     private Collection<SourcedEntity> sourcedEntities; 
 
     @FameProperty(name = "sourcedEntities", opposite = "declaredSourceLanguage", derived = true)
@@ -74,6 +68,14 @@
     }
     
                 
+    @FameProperty(name = "name", derived = true)
+    public String getName() {
+        // TODO: this is a derived property, implement this method manually.
+        //throw new UnsupportedOperationException("Not yet implemented!");
+    	String fullname = this.getClass().getName();
+    	return fullname.substring(0, fullname.indexOf("SourceLanguage"));
+    }
+    
 
 
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 85)
@@ -12,10 +12,11 @@
 
     public Class() {
 		super();
-		this.setIsInterface(Boolean.FALSE);
+		this.setIsInterface(Boolean.FALSE);  // by default assume a real class
 	}
 
-	@FameProperty(name = "isAbstract", derived = true)
+
+    @FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
         return this.getModifiers().contains("abstract");
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 85)
@@ -14,35 +14,30 @@
 
     private ScopingEntity parentScope;
     
-    @FameProperty(name = "parentScope", opposite = "globalVariables")
+    @FameProperty(name = "parentScope")
     public ScopingEntity getParentScope() {
         return parentScope;
     }
 
-    @Override
-	public ContainerEntity getBelongsTo() {
-		return getParentScope();
-	}
-
     public void setParentScope(ScopingEntity parentScope) {
-        if (this.parentScope != null) {
-            if (this.parentScope.equals(parentScope)) return;
-            this.parentScope.getGlobalVariables().remove(this);
-        }
         this.parentScope = parentScope;
-        if (parentScope == null) return;
-        parentScope.getGlobalVariables().add(this);
     }
     
     private Module parentModule;
     
-    @FameProperty(name = "parentModule")
+    @FameProperty(name = "parentModule", opposite = "globalVariables")
     public Module getParentModule() {
         return parentModule;
     }
 
     public void setParentModule(Module parentModule) {
+        if (this.parentModule != null) {
+            if (this.parentModule.equals(parentModule)) return;
+            this.parentModule.getGlobalVariables().remove(this);
+        }
         this.parentModule = parentModule;
+        if (parentModule == null) return;
+        parentModule.getGlobalVariables().add(this);
     }
     
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 85)
@@ -13,7 +13,8 @@
 public class Type extends ContainerEntity {
 
 
-	private Collection<Method> methods; 
+
+    private Collection<Method> methods; 
 
     @FameProperty(name = "methods", opposite = "parentType", derived = true)
     public Collection<Method> getMethods() {
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 85)
@@ -14,30 +14,30 @@
 
     private ScopingEntity parentScope;
     
-    @FameProperty(name = "parentScope", opposite = "functions")
+    @FameProperty(name = "parentScope")
     public ScopingEntity getParentScope() {
         return parentScope;
     }
 
     public void setParentScope(ScopingEntity parentScope) {
-        if (this.parentScope != null) {
-            if (this.parentScope.equals(parentScope)) return;
-            this.parentScope.getFunctions().remove(this);
-        }
         this.parentScope = parentScope;
-        if (parentScope == null) return;
-        parentScope.getFunctions().add(this);
     }
     
     private Module parentModule;
     
-    @FameProperty(name = "parentModule")
+    @FameProperty(name = "parentModule", opposite = "functions")
     public Module getParentModule() {
         return parentModule;
     }
 
     public void setParentModule(Module parentModule) {
+        if (this.parentModule != null) {
+            if (this.parentModule.equals(parentModule)) return;
+            this.parentModule.getFunctions().remove(this);
+        }
         this.parentModule = parentModule;
+        if (parentModule == null) return;
+        parentModule.getFunctions().add(this);
     }
     
 
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 84)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ParameterizableClass.java	(revision 85)
@@ -11,6 +11,8 @@
 @FameDescription("ParameterizableClass")
 public class ParameterizableClass extends Class {
 
+
+
     @FameProperty(name = "parameters", derived = true)
     public Collection<ParameterType> getParameters() {
         // this is a derived property, implement this method manually.
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 83)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 84)
@@ -8,8 +8,8 @@
 import org.eclipse.jdt.core.dom.ITypeBinding;
 
 import ch.akuhn.fame.Repository;
-
 import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
 import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
@@ -17,7 +17,8 @@
 import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
-import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.Enum;
+import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
@@ -30,13 +31,12 @@
 import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourceLanguage;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.ThrownException;
 import fr.inria.verveine.core.gen.famix.Type;
 
-enum Colors { Black,	Blue, Red };
-
 /**
  * A dictionnary of Famix entities to help create them and find them back
  * @author anquetil
@@ -46,13 +46,13 @@
  */
 public class Dictionary<B> {
 
-	Colors toto;
-	
 	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
 	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
 	public static final String SELF_NAME = "self";
 	public static final String SUPER_NAME = "super";
 
+	private SourceLanguage myLgge = null;
+	
 	/**
 	 * The FAMIX repository where all FAMIX entities are created and stored
 	 */
@@ -66,14 +66,14 @@
 	/**
 	 * Another dictionary to map a name to FAMIX Entities with this name
 	 */
-	protected Map<String,Collection<NamedEntity>> mapName;
+	private Map<String,Collection<NamedEntity>> mapName;
 
 	/**
 	 * Yet another dictionary for implicit variables ('self' and 'super')
 	 * Because they are implicit, they may not have a binding provided by the parser,
 	 * or may have the same binding than their associated class so they can't be kept easily in {@link Dictionary#mapToKey}
 	 */
-	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+	private Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
 
 	/**
 	 * Used to keep the two possible ImplicitVariable for a given Class binding
@@ -87,9 +87,10 @@
 	/** Constructor taking a FAMIX repository
 	 * @param famixRepo
 	 */
-	public Dictionary(Repository famixRepo) {
+	public Dictionary(Repository famixRepo, SourceLanguage lgge) {
 		this.famixRepo = famixRepo;
-		
+		this.myLgge = lgge;
+
 		this.mapToKey = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
 		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
@@ -99,7 +100,7 @@
 		}
 	}
 
-	protected void recoverExistingRepository() {
+	private void recoverExistingRepository() {
 		for (Object obj : famixRepo.getElements()) {
 			if (obj instanceof NamedEntity) {
 				mapEntityToName( ((NamedEntity)obj).getName(), (NamedEntity) obj);
@@ -127,7 +128,7 @@
 
 	}
 	
-	protected void mapEntityToName(String name, NamedEntity ent) {
+	private void mapEntityToName(String name, NamedEntity ent) {
 		Collection<NamedEntity> l_ent = mapName.get(name);
 		if (l_ent == null) {
 			l_ent = new LinkedList<NamedEntity>();
@@ -162,7 +163,7 @@
 	 * Returns the Famix Entity associated to the given binding.
 	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
 	 * In such a case, this method will always retrieve the Class associated to the binding.
-	 * To get an ImplicitVariable from the binding, uses {@link Dictionary#getImplicitVariableByBinding(Object, String)}
+	 * To get an ImplicitVariable from the binding, uses {@link Dictionary#getImplicitVariableByKey(Object, String)}
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
@@ -177,12 +178,12 @@
 
 	/**
 	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
-	 * The Entity is always created (see {@link Dictionary#ensureFamixEntity(Class, Object, String)}).
+	 * The Entity is always created (see {@link Dictionary#ensureFamixNamedEntity(Class, Object, String)}).
 	 * @param fmxClass -- the FAMIX class of the instance to create
 	 * @param name -- the name of the new instance must not be null (and this is not tested)
 	 * @return the FAMIX Entity or null in case of a FAMIX error
 	 */
-	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+	protected <T extends NamedEntity> T createFamixNamedEntity(Class<T> fmxClass, String name) {
 		T fmx = null;
 		try {
 			fmx = fmxClass.newInstance();
@@ -194,6 +195,7 @@
 		if (fmx != null) {
 			fmx.setName(name);
 			fmx.setIsStub(Boolean.TRUE);
+			fmx.setDeclaredSourceLanguage(myLgge);
 
 			mapEntityToName(name, fmx);
 			
@@ -214,7 +216,7 @@
 	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
 	 */
 	@SuppressWarnings("unchecked")
-	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+	protected <T extends NamedEntity> T ensureFamixNamedEntity(Class<T> fmxClass, B bnd, String name) {
 		T fmx = null;
 
 		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
@@ -232,7 +234,7 @@
 		// e.g. 2 parameters of 2 different methods but having the same name
 		// so we cannot recover just from the name
 
-		fmx = createFamixEntity(fmxClass, name);
+		fmx = createFamixNamedEntity(fmxClass, name);
 		if (bnd != null) {
 			mapToKey.put(bnd, fmx);
 		}
@@ -240,15 +242,6 @@
 		return fmx;
 	}
 
-	/**
-	 * Adds an already created Entity to the FAMIX repository
-	 * Used mainly for non-NamedEntity, for example relationships
-	 * @param e -- the FAMIX entity to add to the repository
-	 */
-	public void famixRepoAdd(Entity e) {
-		this.famixRepo.add(e);
-	}
-
 	///// ensure Famix Entities /////
 
 	/**
@@ -260,7 +253,7 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public Type ensureFamixType(B key, String name, ContainerEntity owner) {
-		Type fmx = ensureFamixEntity(Type.class, key, name);
+		Type fmx = ensureFamixNamedEntity(Type.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
@@ -273,7 +266,7 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(B key, String name, ContainerEntity owner) {
-		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixNamedEntity(fr.inria.verveine.core.gen.famix.Class.class, key, name);
 		fmx.setContainer(owner);
 		return fmx;
 	}
@@ -285,7 +278,7 @@
 	 * @return the FAMIX Class or null in case of a FAMIX error
 	 */
 	public ParameterizableClass ensureFamixParameterizableClass(String name) {
-		ParameterizableClass fmx = ensureFamixEntity(ParameterizableClass.class, null, name);
+		ParameterizableClass fmx = ensureFamixNamedEntity(ParameterizableClass.class, null, name);
 		fmx.setIsInterface(Boolean.FALSE);
 		return fmx;
 	}
@@ -297,7 +290,25 @@
 	 * @return the FAMIX ParameterType or null in case of a FAMIX error
 	 */
 	public ParameterType ensureFamixParameterType(String name) {
-		ParameterType fmx = ensureFamixEntity(ParameterType.class, null, name);
+		return ensureFamixNamedEntity(ParameterType.class, null, name);
+	}
+
+	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(B key, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Enum fmx = ensureFamixNamedEntity(fr.inria.verveine.core.gen.famix.Enum.class, key, name);
+		fmx.setContainer(owner);
+		return fmx;
+	}
+
+	public EnumValue ensureFamixEnumValue(B key, String name, Enum owner) {
+		EnumValue fmx = ensureFamixNamedEntity(EnumValue.class, key, name);
+		fmx.setParentEnum(owner);
+		return fmx;
+
+	}
+
+	public AnnotationType ensureFamixAnnotationType(B key, String name, ContainerEntity owner) {
+		AnnotationType fmx = ensureFamixNamedEntity(AnnotationType.class, key, name);
+		fmx.setContainer(owner);
 		return fmx;
 	}
 
@@ -311,7 +322,7 @@
 	 * @return the FAMIX Method or null in case of a FAMIX error
 	 */
 	public Method ensureFamixMethod(B key, String name, String sig, Type ret, Type owner) {
-		Method fmx = (Method) ensureFamixEntity(Method.class, key, name);
+		Method fmx = (Method) ensureFamixNamedEntity(Method.class, key, name);
 		fmx.setSignature(sig);
 		fmx.setDeclaredType(ret);
 		fmx.setParentType(owner);
@@ -324,10 +335,10 @@
 	 * @param name -- the name of the Famix Attribute (MUST NOT be null, but this is not checked)
 	 * @param type -- Famix Type of the Famix Attribute (should not be null, but it will work if it is)
 	 * @param owner -- Class defining the Famix Attribute (should not be null, but it will work if it is)
-	 * @return the FAMIX Attribute or null in case of a FAMIX error
+	 * @return the FAMIX Attribute or null in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(B key, String name, Type type, Type owner) {
-		Attribute fmx = ensureFamixEntity(Attribute.class, key, name);
+		Attribute fmx = ensureFamixNamedEntity(Attribute.class, key, name);
 		fmx.setParentType(owner);
 		fmx.setDeclaredType(type);
 		return fmx;
@@ -342,26 +353,13 @@
 	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
 	 */
 	public LocalVariable ensureFamixLocalVariable(B key, String name, Type type, BehaviouralEntity owner) {
-		LocalVariable fmx = ensureFamixEntity(LocalVariable.class, key, name);
+		LocalVariable fmx = ensureFamixNamedEntity(LocalVariable.class, key, name);
 		fmx.setParentBehaviouralEntity(owner);
 		fmx.setDeclaredType(type);
 		return fmx;
 	}
 
 	/**
-	 * Creates and returns a FAMIX Comment
-	 * @param cmt -- the content (String) of the comment 
-	 * @return the FAMIX Comment
-	 */
-	public Comment createFamixComment(String cmt) {
-		Comment fmx = new Comment();
-		fmx.setContent(cmt);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
-	}
-
-	/**
 	 * Creates and returns a FAMIX Comment and associates it with an Entity (ex: for Javadocs)
 	 * @param cmt -- the content (String) of the comment 
 	 * @param owner -- the entity concerned by this comment
@@ -377,18 +375,17 @@
 	}
 	
 	/**
-	 * Creates and returns a FAMIX Parameter and associates it with a BehaviouralEntity
-	 * @param identifier -- the name of the parameter
-	 * @param owner -- the entity concerned by this parameter
-	 * @param type -- the type of the parameter
-	 * @return the FAMIX parameter
+	 * Creates and returns a Famix Parameter and associates it with a BehaviouralEntity
+	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
+	 * @param name -- the name of the Famix Parameter (MUST NOT be null, but this is not checked)
+	 * @param type -- Famix Type of the Famix Parameter (should not be null, but it will work if it is)
+	 * @param owner -- Class defining the Famix Parameter (should not be null, but it will work if it is)
+	 * @return the Famix parameter or null in case of a Famix error
 	 */
-	public Parameter createFamixParameter(String identifier, BehaviouralEntity owner, Type type) {
-		Parameter fmx = new Parameter();
-		fmx.setName(identifier);
+	public Parameter ensureFamixParameter(B key, String name, Type type, BehaviouralEntity owner) {
+		Parameter fmx = ensureFamixNamedEntity(Parameter.class, key, name);
 		fmx.setParentBehaviouralEntity(owner);
 		fmx.setDeclaredType(type);
-		this.famixRepo.add(fmx);
 		
 		return fmx;
 	}
@@ -396,15 +393,13 @@
 	///// ensure Famix Relationships /////
 
 	/**
-	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
+	 * Returns a Famix Inheritance relationship between two Famix Classes (or Interfaces) creating it if needed.
+	 * All References in a context are linked one to the other
 	 * @param sup -- the super class
 	 * @param sub -- the sub class
+	 * @param prev -- previous Inheritance link in the same context or null if it is the first
 	 * @return the Inheritance relationship
 	 */
-	public Inheritance ensureFamixInheritance(Type sup, Type sub) {
-		return ensureFamixInheritance(sup, sub, null);
-	}
-	
 	public Inheritance ensureFamixInheritance(Type sup, Type sub, Association prev) {
 		for (Inheritance i : sup.getSubInheritances()) {
 			if (i.getSubclass() == sub) {
@@ -415,121 +410,115 @@
 		inh.setSuperclass(sup);
 		inh.setSubclass(sub);
 		chainPrevNext(prev,inh);
-		famixRepoAdd(inh);
+		this.famixRepo.add(inh);
+
 		return inh;
 	}
 
 	/**
-	 * Returns a Famix Reference between two Famix Entities creating it if needed
+	 * Creates a Famix Reference between two Famix Entities. All References in a context are linked one to the other
 	 * @param src -- source of the reference
 	 * @param tgt -- target of the reference
+	 * @param prev -- previous Reference in the same context or null if it is the first
 	 * @return the Reference
 	 */
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
-		return ensureFamixReference(src, tgt, null);
-	}
-	
-	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
+	public Reference createFamixReference(ContainerEntity src, ContainerEntity tgt, Association prev) {
 		Reference ref = new Reference();
 		ref.setTarget(tgt);
 		ref.setSource(src);
 		chainPrevNext(prev,ref);
-		famixRepoAdd(ref);
+		this.famixRepo.add(ref);
 		
 		return ref;
 	}
 
 	/**
-	 * Returns a Famix Invocation between two Famix Entities creating it if needed
+	 * Creates a Famix Invocation between two Famix Entities.  All Invocations in a context are linked one to the other
 	 * @param sender of the invocation
 	 * @param invoked -- method invoked
 	 * @param receiver of the invocation
+	 * @param prev -- previous Invocation in the same context or null if it is the first
 	 * @return the Invocation
 	 */
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
-		return ensureFamixInvocation(sender, invoked, receiver, null);
-	}
-
-	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
+	public Invocation createFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver, Association prev) {
 		Invocation invok = new Invocation();
 		invok.setReceiver(receiver);
 		invok.setSender(sender);
 		invok.setSignature(invoked.getSignature());
 		invok.addCandidates(invoked);
 		chainPrevNext(prev,invok);
-		famixRepoAdd(invok);
+		this.famixRepo.add(invok);
 		
 		return invok;
 	}
 
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
-		/* We keep multiple accesses from one method to a field */
+	/**
+	 * Creates a Famix Access between two Famix Entities. All Accesses in a context are linked one to the other
+	 * @param accessor
+	 * @param var -- variable accessed
+	 * @param isWrite -- whether the variable is written or read
+	 * @param prev -- previous Access in the same context or null if it is the first
+	 * @return the Access
+	 */
+	public Access createFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite, Association prev) {
 		Access acc = new Access();
 		acc.setAccessor(accessor);
 		acc.setVariable(var);
 		acc.setIsWrite(new Boolean(isWrite));
 		chainPrevNext(prev, acc);
-		famixRepoAdd(acc);
+		this.famixRepo.add(acc);
 		
 		return acc;
 	}
 
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var, boolean isWrite) {
-		return ensureFamixAccess(accessor, var, isWrite, null);
-	}
-	
-	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
-		return ensureFamixAccess(accessor, var, false, null);  // must set some default for isWrite and this one seems safer than the opposite
-	}
-
 	private void chainPrevNext(Association prev, Association next) {
 		if (prev != null) {
-			next.setPrevious(prev);  // not yet implemented in importer
+			next.setPrevious(prev);
 		}
 	}
 	
 	/**
-	 * Returns a Famix DeclaredException between a method and an Exception that it declares to throw
+	 * Creates a Famix DeclaredException between a method and an Exception that it declares to throw
 	 * @param meth -- the method throwing the exception
 	 * @param excep -- the exception declared to be thrown
 	 * @return the DeclaredException
 	 */
-	public DeclaredException ensureFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		DeclaredException decl = new DeclaredException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
+	public DeclaredException createFamixDeclaredException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		DeclaredException fmx = new DeclaredException();
+		fmx.setExceptionClass(excep);
+		fmx.setDefiningMethod(meth);
+		this.famixRepo.add(fmx);
+		return fmx;
 	}
 
 	/**
-	 * Returns a Famix CaughtException between a method and an Exception that is caught
+	 * CReates a Famix CaughtException between a method and an Exception that is caught
 	 * @param meth -- the method catching the exception
 	 * @param excep -- the exception caught
 	 * @return the CaughtException
 	 */
-	public CaughtException ensureFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		CaughtException decl = new CaughtException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
+	public CaughtException createFamixCaughtException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		CaughtException fmx = new CaughtException();
+		fmx.setExceptionClass(excep);
+		fmx.setDefiningMethod(meth);
+		this.famixRepo.add(fmx);
+		return fmx;
 	}
 
 	/**
-	 * Returns a Famix ThrownException between a method and an Exception that it (actually) throws.
-	 * Note: DeclaredException indicates that the method declares it can throw the exception,
-	 * here we state that the exception is actually thrown
+	 * Creates a Famix ThrownException between a method and an Exception that it (actually) throws.
+	 * Note: DeclaredException indicates only that the method <em>declares</em> it can throw the exception,
+	 * here we state that the exception is <em>actually thrown</em>
 	 * @param meth -- the method throwing the exception
 	 * @param excep -- the exception thrown
 	 * @return the ThrownException
 	 */
-	public ThrownException ensureFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
-		ThrownException decl = new ThrownException();
-		decl.setExceptionClass(excep);
-		decl.setDefiningMethod(meth);
-		famixRepoAdd(decl);
-		return decl;
+	public ThrownException createFamixThrownException(Method meth, fr.inria.verveine.core.gen.famix.Class excep) {
+		ThrownException fmx = new ThrownException();
+		fmx.setExceptionClass(excep);
+		fmx.setDefiningMethod(meth);
+		this.famixRepo.add(fmx);
+		return fmx;
 	}
 
 	///// Special Case: ImplicitVariables /////
@@ -540,7 +529,7 @@
 	 * @param bnd -- the binding
 	 * @return the Famix Entity associated to the binding or null if not found
 	 */
-	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
+	public ImplicitVariable getImplicitVariableByKey(B bnd, String iv_name) {
 		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd), iv_name);
 	}
 	
@@ -579,7 +568,7 @@
 		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
 		
 		if (fmx == null) {
-			fmx = (ImplicitVariable) createFamixEntity(ImplicitVariable.class, name);
+			fmx = (ImplicitVariable) createFamixNamedEntity(ImplicitVariable.class, name);
 			if (fmx!=null) {
 				fmx.setContainer(clazz);
 
@@ -626,7 +615,7 @@
 				fmx = l.iterator().next();
 			}
 			else {
-				fmx = createFamixEntity(fmxClass, name);
+				fmx = createFamixNamedEntity(fmxClass, name);
 			}
 			
 			if (key != null) {
@@ -667,7 +656,7 @@
 	 * @return the FAMIX PrimitiveType or null in case of a FAMIX error
 	 */
 	public PrimitiveType ensureFamixPrimitiveType(B key, String name) {
-		return ensureFamixEntity(PrimitiveType.class, key, name);
+		return ensureFamixNamedEntity(PrimitiveType.class, key, name);
 	}
 	
 	/**
@@ -682,5 +671,6 @@
 
 		return fmx;
 	}
+
 	
 }
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 83)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 84)
@@ -14,7 +14,7 @@
 
 
 
-    private SourceLanguage declaredSourceLanguage;
+    private SourceLanguage declaredSourceLanguage = null;
     
     @FameProperty(name = "declaredSourceLanguage", opposite = "sourcedEntities")
     public SourceLanguage getDeclaredSourceLanguage() {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 44)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 45)
@@ -17,6 +17,8 @@
 import org.eclipse.jdt.core.dom.ForStatement;
 import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
@@ -100,7 +102,8 @@
 
 	public boolean visit(TypeDeclaration node) {
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(node.resolveBinding());
+		ITypeBinding bnd = node.resolveBinding();
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -117,6 +120,11 @@
 			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 			dico.addSourceAnchor(cmt, jdoc);
 		}
+		//Annotation
+		for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+			AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+			dico.createFamixAnnotationInstance(fmx, annType);
+		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -210,6 +218,7 @@
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
 //			System.err.println("            Field: "+vd.getName().getIdentifier());
+			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
 			if (fmx != null) {
 				fmx.setIsStub(false);
@@ -228,6 +237,11 @@
 				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 				dico.addSourceAnchor(cmt, jdoc);
 			}
+			//Annotation
+			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+				dico.createFamixAnnotationInstance(fmx, annType);
+			}
 		}
 		return super.visit(node);
 	}
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 9)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 10)
@@ -32,6 +32,7 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 
 import fr.inria.verveine.extractor.java.BatchParser;
@@ -61,10 +62,11 @@
 
 	@Test
 	public void testEntitiesNumber() {
-		assertEquals(11+11, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {int,boolean,void,Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
 		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+5, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,<primitive>,java.lang,java.io,java}
+		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
 		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
 		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
 		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
@@ -159,14 +161,14 @@
 		assertEquals("methodWithEmptyBody", mweb.getName());
 		assertEquals("methodWithEmptyBody()", mweb.getSignature());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "void"), mweb.getDeclaredType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
 
 		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
 		assertNotNull(em);
 		assertEquals("equalsMultiple", em.getName());
 		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
 		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "boolean"), em.getDeclaredType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
 
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
 		assertNotNull(clazz);
@@ -257,7 +259,7 @@
 				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
 			}
 			if (p.getName().equals("rv")) {
-				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "boolean"), p.getDeclaredType());
+				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
 			}
 		}
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 9)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 10)
@@ -251,7 +251,7 @@
 			if (bnd != null) {
 				if (bnd instanceof ITypeBinding) {
 					// msg() is a static method of Name
-					ret = dico.createFamixUnknownVariable( dico.ensureFamixClass((ITypeBinding)bnd), bnd.getName());
+					ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd), bnd.getName());
 				}
 				else if (bnd instanceof IVariableBinding) {
 					if ( ((IVariableBinding)bnd).isField() ) {
@@ -308,7 +308,8 @@
 
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
-			return dico.ensureFamixClass( expr.resolveTypeBinding());
+			// may be could specify: ensureFamixClass ??
+			return dico.ensureFamixType( expr.resolveTypeBinding());
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 9)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 10)
@@ -22,8 +22,10 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.core.gen.famix.UnknownVariable;
 
 /**
@@ -37,7 +39,6 @@
 
 	public static final String OBJECT_NAME = "Object";
 	public static final String OBJECT_PACKAGE_NAME = "java.lang";
-	public static final String PRIMITIVE_PCKG_NAME = "<Primitive Package>";   // for int, boolean, .... types
 	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
 	public static final String STATIC_INIT_BLOCK_NAME = "<StaticInitializer>";
 
@@ -112,6 +113,38 @@
 		return fmx;
 	}
 
+	public Type ensureFamixType(ITypeBinding bnd) {
+
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
+			return null;
+		}
+
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
+		}
+		
+		if (bnd.isPrimitive()) {
+			return ensureFamixPrimitiveType(bnd);
+		}
+		else {
+			return ensureFamixClass(bnd);
+		}
+	}
+
+	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
+
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Primitive Type");
+			return null;
+		}
+		
+		PrimitiveType fmx = super.ensureFamixPrimitiveType(bnd.getName());
+		fmx.setIsStub(false);
+		mapBind.put(bnd, fmx);
+		return fmx;
+	}
+
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
@@ -134,6 +167,11 @@
 			bnd = bnd.getComponentType();
 		}
 		
+		if (bnd.isPrimitive()) {
+			System.err.println("Warning: cannot create Famix Class from aprimitive type");
+			return null;
+		}
+		
 		// container
 		IMethodBinding parentMtd = bnd.getDeclaringMethod();
 		if (parentMtd != null) {
@@ -150,12 +188,7 @@
 					owner = this.ensureFamixNamespace(parentPckg);
 				}
 				else {
-					if (bnd.isPrimitive()) {
-						owner = this.ensureFamixNamespacePrimitives();
-					}
-					else {
-						owner = this.ensureFamixNamespaceDefault();
-					}
+					owner = this.ensureFamixNamespaceDefault();
 				}
 			}
 		}
@@ -181,8 +214,8 @@
 		}
 
 		// superclass and/or implemented interfaces
-		if ( (! bnd.isPrimitive()) && (! bnd.getName().equals(OBJECT_NAME)) ) {
-			// "Object" and primitive types don't have a superclass
+		if (! bnd.getName().equals(OBJECT_NAME)) {
+			// "Object" does't have a superclass
 			
 			// superclass
 			if (! bnd.isInterface()) {
@@ -274,8 +307,8 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class parentClass = null;
-		fr.inria.verveine.core.gen.famix.Class rettyp = null;
+		fr.inria.verveine.core.gen.famix.Class owner = null;
+		Type rettyp = null;
 		String sig = null;
 		boolean wasBound = false;
 		
@@ -285,14 +318,14 @@
 		}
 
 		// owner
-		parentClass = this.ensureFamixClass(bnd.getDeclaringClass());
+		owner = this.ensureFamixClass(bnd.getDeclaringClass());
 
 		// return type
 		if (bnd.isConstructor()) {
 			// TODO what to put in metamodel?
 		}
 		else {
-			rettyp = this.ensureFamixClass(bnd.getReturnType());	
+			rettyp = this.ensureFamixType(bnd.getReturnType());	
 		}
 
 		// method signature
@@ -321,7 +354,7 @@
 			wasBound = false;
 			// trying to recover from name and other informations
 			for (Method candidate : getEntityByName(Method.class, bnd.getName()) ) {
-				if ( (candidate.getParentType() == parentClass) &&
+				if ( (candidate.getParentType() == owner) &&
 					 (candidate.getDeclaredType() == rettyp) &&
 					 (candidate.getSignature().equals(sig)) ) {
 					// we could also test that this candidate is not bound yet (to another bnd)
@@ -340,7 +373,7 @@
 		
 		if ((fmx!=null) && (! wasBound) ) {
 			// apparently we just created it or it already existed as a stub, so add information to it
-			fmx.setParentType(parentClass);
+			fmx.setParentType(owner);
 			fmx.setDeclaredType(rettyp);	
 			fmx.setName(bnd.getName());
 			fmx.setSignature(sig);
@@ -358,8 +391,8 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
-		fr.inria.verveine.core.gen.famix.Class parentClass = null;
-		fr.inria.verveine.core.gen.famix.Class typ = null;
+		fr.inria.verveine.core.gen.famix.Class owner = null;
+		Type typ = null;
 		boolean wasBound = false;
 
 		if (bnd == null) {
@@ -367,8 +400,8 @@
 			return null;
 		}
 
-		parentClass = this.ensureFamixClass(bnd.getDeclaringClass());
-		typ = this.ensureFamixClass(bnd.getType());
+		owner = this.ensureFamixClass(bnd.getDeclaringClass());
+		typ = this.ensureFamixType(bnd.getType());
 
 		// finally trying to recover the entity or creating it
 		Attribute fmx = null;
@@ -383,7 +416,7 @@
 			// trying to recover from name and other informationsparentBehaviouralEntity
 			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
 				if ( (! candidate.getIsStub()) &&
-					 (candidate.getParentType() == parentClass) &&
+					 (candidate.getParentType() == owner) &&
 					 (candidate.getDeclaredType() == typ) ) {
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
@@ -400,7 +433,7 @@
 		if ((fmx!=null) && (! wasBound) ) {
 			// apparently we just created it, so add information to it
 			setNamedEntityModifiers(fmx, bnd.getModifiers());
-			fmx.setParentType(parentClass);
+			fmx.setParentType(owner);
 			fmx.setDeclaredType(typ);	
 			fmx.setName(bnd.getName());
 		}
@@ -452,7 +485,7 @@
 			// declaring method
 			fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
 			// type of the attribute
-			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
+			fmx.setDeclaredType(this.ensureFamixType(bnd.getType()));
 		}
 		
 		return fmx;
@@ -466,8 +499,8 @@
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
-		Method parentMeth = null;
-		fr.inria.verveine.core.gen.famix.Class typ = null;
+		Method owner = null;
+		Type typ = null;
 		boolean wasBound = false;
 
 		if (bnd == null) {
@@ -475,8 +508,8 @@
 			return null;
 		}
 
-		parentMeth = this.ensureFamixMethod(bnd.getDeclaringMethod());
-		typ = this.ensureFamixClass(bnd.getType());
+		owner = this.ensureFamixMethod(bnd.getDeclaringMethod());
+		typ = this.ensureFamixType(bnd.getType());
 
 		// finally trying to recover the entity or creating it
 		LocalVariable fmx = null;
@@ -490,7 +523,7 @@
 			wasBound = false;
 			// trying to recover from name and other informationsparentBehaviouralEntity
 			for (LocalVariable candidate : getEntityByName(LocalVariable.class, bnd.getName()) ) {
-				if ( (candidate.getParentBehaviouralEntity() == parentMeth) &&
+				if ( (candidate.getParentBehaviouralEntity() == owner) &&
 					 (candidate.getDeclaredType() == typ) ) {
 					fmx = candidate;
 					mapBind.put(bnd, fmx);
@@ -506,8 +539,8 @@
 
 		if ( (fmx!=null) && (! wasBound) ) {
 			// apparently we just created it, so add information to it
-			fmx.setParentBehaviouralEntity(parentMeth);
-			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
+			fmx.setParentBehaviouralEntity(owner);
+			fmx.setDeclaredType(typ);
 		}
 		
 		return fmx;
@@ -520,11 +553,11 @@
 	 * @param bnd -- the JDT Binding 
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public UnknownVariable createFamixUnknownVariable(fr.inria.verveine.core.gen.famix.Class ofType, String name) {
+	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
 		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
-			fmx.setDeclaredType(ofType);
+			fmx.setDeclaredType(type);
 		}
 		return fmx;
 	}
@@ -592,17 +625,6 @@
 	}
 
 	/**
-	 * Creates or recovers a Famix Namespace for the primitive types in Java.
-	 * Because this package does not really exist, it has no binding.
-	 * @return a Famix Namespace
-	 */
-	public Namespace ensureFamixNamespacePrimitives() {
-		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, PRIMITIVE_PCKG_NAME);
-
-		return fmx;
-	}
-
-	/**
 	 * Creates or recovers the Famix Class for "Object".
 	 * @param bnd -- a potential binding for the java "Object" class
 	 * @return a Famix class for "Object"
@@ -624,4 +646,5 @@
 		return fmx;
 	}
 
+
 }
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 86)
+++ verveine.extractor.java/.classpath	(revision 87)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core">
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
 		<attributes>
 			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
 		</attributes>
@@ -14,7 +14,7 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
Index: verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 87)
@@ -0,0 +1,40 @@
+package ad_hoc;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Card {
+
+	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
+
+	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
+        SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
+
+    private final Rank rank;
+    private final Suit suit;
+    private Card(Rank rank, Suit suit) {
+        this.rank = rank;
+        this.suit = suit;
+    }
+
+    public Rank rank() { return rank; }
+    public Suit suit() { return suit; }
+    public String toString() { return rank + " of " + suit; }
+
+    private static final List<Card> protoDeck = new ArrayList<Card>();
+
+    // Initialize prototype deck
+    static {
+        for (Suit s : Suit.values())
+            for (Rank r : Rank.values()) {
+            	if (r == Rank.QUEEN) {
+            		System.out.println("God save the Queen!");
+            		}
+            	protoDeck.add(new Card(r, s));
+            }
+    }
+
+    public static ArrayList<Card> newDeck() {
+        return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
+    }
+}
Index: verveine.extractor.java/test_src/ad_hoc/Element.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 87)
@@ -0,0 +1,89 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame.fm3;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.Named;
+import ch.akuhn.fame.Nested;
+import ch.akuhn.fame.internal.Warnings;
+
+/**
+ * Abstract superclass of MSE metamodel.
+ * 
+ * This is an abstract class with attributes </p>
+ * <ul>
+ * <li>Element <code>owner</code> (derived)</li>
+ * <li>String <code>fullname</code> (derived)</li>
+ * <li>String <code>name</code></li>
+ * </ul>
+ * <p>
+ * with these constraints
+ * </p>
+ * <ul>
+ * <li> <code>name</code> must be alphanumeric</li>
+ * <li> <code>fullname</code> is derived recursively, concatenating
+ * <code>owner.fullname</code> and <code>name</code></li>
+ * <li> <code>fullname</code> is separated by dots, eg
+ * <code>MSE.Class.attributes</code></li>
+ * </ul>
+ * 
+ * @author Adrian Kuhn
+ * 
+ */
+@FamePackage("FM3")
+@FameDescription("Element")
+public abstract class Element implements Named, Nested {
+
+    private String name;
+
+    public Element() {
+    }
+
+    public Element(String name) {
+        this.name = name;
+    }
+
+    @FameProperty(derived = true)
+    public String getFullname() {
+        Element parent = this.getOwner();
+        return parent == null ? this.getName() : parent.getFullname() + "." + this.getName();
+    }
+
+    @FameProperty
+    public String getName() {
+        return name;
+    }
+
+    @FameProperty(derived = true)
+    public abstract Element getOwner();
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return this.getFullname();
+    }
+    
+    public abstract void checkConstraints(Warnings warnings);
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/ReadException.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 87)
@@ -0,0 +1,4 @@
+package OMGL2;
+public class ReadException extends Exception {
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 87)
@@ -0,0 +1,47 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Attaches FM3-related meta-information to class members (ie fields or
+ * methods).
+ * 
+ * @author akuhn
+ * 
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target( { ElementType.METHOD, ElementType.FIELD })
+public @interface FameProperty {
+
+    boolean container() default false;
+
+    boolean derived() default false;
+
+    String name() default "*";
+
+    String opposite() default "";
+
+    Class<?> type() default Void.class;
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 87)
@@ -0,0 +1,70 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+@Override
+@Deprecated
+public class Client {
+	
+	@Override
+	@Deprecated
+	private String num;
+	@Deprecated
+	private String nom;
+
+	@Deprecated
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+	
+	@Override
+	@Deprecated
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+	
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	@Override
+	@Deprecated
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 87)
@@ -1,231 +0,0 @@
-/**
- * Copyright (c) 2010 Nicolas Anquetil
- */
-package tests.fr.inria.verveine.extractor.java;
-
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-import java.util.Collection;
-import java.util.Iterator;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import test.fr.inria.verveine.core.TestVerveineUtils;
-import ch.akuhn.fame.Repository;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.Entity;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterType;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
-import fr.inria.verveine.core.gen.famix.Type;
-import fr.inria.verveine.extractor.java.JavaDictionary;
-import fr.inria.verveine.extractor.java.VerveineJParser;
-
-/**
- * @author Andre Hora
- * @since January 17, 2011
- *
- */
-public class VerveineJTest_Dictionary {
-
-	private Repository repo;
-
-	public VerveineJTest_Dictionary() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp() throws Exception {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/ad_hoc/Dictionary.java"});
-		repo = parser.getFamixRepo();
-	}
-
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-
-	@Test
-	public void testClassParameterTypes() {
-		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
-		assertNotNull(dicoClass);
-		assertEquals("Dictionary", dicoClass.getName());
-		assertEquals(2, dicoClass.getTypes().size());
-		assertEquals(1, dicoClass.getParameters().size());
-		
-		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
-		assertNotNull(dicoParam);
-		assertEquals("B", dicoParam.getName());
-		
-		assertSame(dicoClass, dicoParam.getContainer());
-		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
-	}
-
-	@Test
-	public void testParameterTypeAsType() {
-		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
-		assertNotNull(gebb);
-		assertSame(1, gebb.getParameters().size());
-		
-		Parameter bnd = gebb.getParameters().iterator().next();
-		assertNotNull(bnd);
-		assertEquals("bnd", bnd.getName());
-		
-		Type b = bnd.getDeclaredType();
-		assertNotNull(b);
-		assertEquals("B", b.getName());
-		assertSame(ParameterType.class, b.getClass());
-		
-		ContainerEntity cont = b.getContainer();
-		assertNotNull(cont);
-		assertEquals("Dictionary", cont.getName());
-		assertSame(ParameterizableClass.class, cont.getClass());
-	}
-	
-	/*Test
-	public void testFieldArgumentTypes() {
-		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
-		assertNotNull(famixAtt);
-		assertEquals("mapBind", famixAtt.getName());
-		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
-	}
-*/
-	
-	/*Test
-	public void testMethodParameterArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-	}
-	*/
-	
-	/*Test
-	public void testMethodLocalVariableArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
-		assertNotNull(fmxMethod);
-		assertEquals(1, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
-			assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-			assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
-			if (fmxLocalVariable.getName().equals("ret")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxLocalVariable.getName().equals("l_name")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
-			if (fmxLocalVariable.getName().equals("fmx")) {
-				assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
-			}
-			if (fmxLocalVariable.getName().equals("l")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-		}
-	}
-	*/
-	
-	/*Test
-	public void testMethodReturnArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
-	}
-	*/
-}
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 87)
@@ -59,7 +59,7 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
-		String[] files = new String[] {
+		/*String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -72,7 +72,7 @@
 		};
 
 		// separate parsing of each source file --------
-		/*for (String f : files) {
+		for (String f : files) {
 			parseFile(f);
 		}*/
 		// or parsing the entire project in one pass ---
@@ -86,7 +86,7 @@
 	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
 	 * @param file -- name of the file to parse
 	 */
-	private void parseFile(String file) {
+/*	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
 				"test_src/LANModel//moose/lan/",
@@ -100,7 +100,7 @@
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
 	}
-
+*/
 	@After
 	public void tearDown() {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
@@ -282,7 +282,7 @@
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
 		assertNotNull(obj);
-		assertTrue(ns.getIsStub());
+		assertTrue(obj.getIsStub());
 		assertSame(ns, obj.getContainer());
 		
 		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
@@ -294,7 +294,7 @@
 		assertNotNull(clazz);
 		assertFalse(clazz.getIsStub());
 		
-		/* [].length notused in the default test case 
+		/* [].length not used in the default test case 
 		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
 		assertNotNull(att);
 		clazz = (Class) att.getParentType();
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 87)
@@ -7,6 +7,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 import java.io.File;
 import java.util.Collection;
@@ -18,12 +19,22 @@
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
 /**
@@ -58,12 +69,12 @@
 	
 	@Test
 	public void testExceptions() {
-		// there are two "lire" methods, but both serve our purpose here so we just take the first that will be returned
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
 		assertNotNull(meth);
 		
 		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
-		
+		assertNotNull(excepClass);
+
 		assertEquals(1, meth.getDeclaredExceptions().size());
 		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
 		assertSame(meth, exD.getDefiningMethod());
@@ -75,7 +86,8 @@
 		assertSame(excepClass, exT.getExceptionClass());
 
 		excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "IOException");
-		
+		assertNotNull(excepClass);
+
 		assertEquals(1,meth.getCaughtExceptions().size());
 		CaughtException exC = meth.getCaughtExceptions().iterator().next();
 		assertSame(meth, exC.getDefiningMethod());
@@ -84,105 +96,266 @@
 	
 	@Test
 	public void testAnnotation() {
-		fr.inria.verveine.core.gen.famix.Class clazz;
-		Collection<AnnotationInstance> annInstances;
-		
-		AnnotationType annTypeOverride = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
-		assertNotNull(annTypeOverride);
-		assertEquals("Override", annTypeOverride.getName());
+		Collection<AnnotationType> l_FmProp = TestVerveineUtils.listElements(repo,AnnotationType.class, "FameProperty");
+		assertEquals(1, l_FmProp.size());
+
+		AnnotationType fmProp = l_FmProp.iterator().next();
+		assertNotNull(fmProp);
+		assertEquals("FameProperty", fmProp.getName());
+		//TODO assertFalse(fmProp.getIsStub());
 		
-		AnnotationType annTypeDeprecated = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Deprecated");
-		assertNotNull(annTypeDeprecated);
-		assertEquals("Deprecated", annTypeDeprecated.getName());
+		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
+		assertNotNull(fmPckg);
+		assertEquals("FamePackage", fmPckg.getName());
+		assertTrue(fmPckg.getIsStub());
 		
-		//Annotations to the class
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Client");
+		AnnotationType fmDesc = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FameDescription");
+		assertNotNull(fmDesc);
+		assertEquals("FameDescription", fmDesc.getName());
+		assertTrue(fmDesc.getIsStub());
+
+		// class annotations 
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Element");
 		assertNotNull(clazz);
-		annInstances = clazz.getAnnotationInstances();
+		Collection<AnnotationInstance> annInstances = clazz.getAnnotationInstances();
 		assertEquals(2, annInstances.size());
 		for (AnnotationInstance annotationInstance : annInstances) {
 			assertSame(clazz, annotationInstance.getAnnotatedEntity());
-			if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-				assertEquals("Override", annotationInstance.getAnnotationType().getName());
-				assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+			if (annotationInstance.getAnnotationType().getName().equals("FamePackage")) {
+				assertSame(fmPckg, annotationInstance.getAnnotationType());
 			} else {
-				assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-				assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+				assertEquals("FameDescription", annotationInstance.getAnnotationType().getName());
+				assertSame(fmDesc, annotationInstance.getAnnotationType());
 			}
 		}
-		//Annotations to the attributes
-		for (Attribute attribute : clazz.getAttributes()) {
-			annInstances = attribute.getAnnotationInstances();
-			if (attribute.getName().equals("num")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
-					assertSame(attribute, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (attribute.getName().equals("nom")) {
+
+		AnnotationTypeAttribute decl = null;
+		for (AnnotationTypeAttribute a : TestVerveineUtils.listElements(repo, AnnotationTypeAttribute.class, "derived")) {
+			if (a.getParentAnnotationType() == fmProp) {
+				decl = a;
+				break;
+			}
+		}
+		assertNotNull(decl);
+		
+		// Method annotations
+		for (Method meth : clazz.getMethods()) {
+			annInstances = meth.getAnnotationInstances();
+			if (meth.getName().equals("getFullname") || meth.getName().equals("getName") || meth.getName().equals("getOwner")) {
 				assertEquals(1, annInstances.size());
-				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
-					assertSame(attribute, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
+				AnnotationInstance annInst = annInstances.iterator().next();
+				assertSame(fmProp, annInst.getAnnotationType());
+				if (meth.getName().equals("getOwner")) {
+					Collection<AnnotationInstanceAttribute> aiAtts = annInst.getAttributes();
+					assertEquals(1, aiAtts.size());
+					AnnotationInstanceAttribute annAtt = aiAtts.iterator().next();
+					assertEquals( annInst, annAtt.getParentAnnotationInstance());
+					assertEquals( "true", annAtt.getValue());
+					assertEquals(decl, annAtt.getAnnotationTypeAttribute());
 				}
-			} else {
+			}
+			else if (meth.getName().equals("toString")) {
+				assertEquals(1, annInstances.size());
+			}
+			else {
 				assertEquals(0, annInstances.size());
 			}
 		}
-		//Annotations to the methods
-		for (Method method : clazz.getMethods()) {
-			annInstances = method.getAnnotationInstances();
-			if (method.getName().equals("Client")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (method.getName().equals("lire")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (method.getName().equals("setNum")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			}else {
-				assertEquals(0, annInstances.size());
+
+		for (Attribute att : clazz.getAttributes()) {
+			assertEquals(0, att.getAnnotationInstances().size());
+		}
+
+	}
+
+	@Test
+	public void testClassParameterTypes() {
+		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dicoClass);
+		assertEquals("Dictionary", dicoClass.getName());
+		assertEquals(2, dicoClass.getTypes().size());
+		assertEquals(1, dicoClass.getParameters().size());
+		
+		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
+		assertNotNull(dicoParam);
+		assertEquals("B", dicoParam.getName());
+		
+		assertSame(dicoClass, dicoParam.getContainer());
+		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
+	}
+
+	@Test
+	public void testParameterTypeAsType() {
+		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
+		assertNotNull(gebb);
+		assertSame(1, gebb.getParameters().size());
+		
+		Parameter bnd = gebb.getParameters().iterator().next();
+		assertNotNull(bnd);
+		assertEquals("bnd", bnd.getName());
+		
+		Type b = bnd.getDeclaredType();
+		assertNotNull(b);
+		assertEquals("B", b.getName());
+		assertSame(ParameterType.class, b.getClass());
+		
+		ContainerEntity cont = b.getContainer();
+		assertNotNull(cont);
+		assertEquals("Dictionary", cont.getName());
+		assertSame(ParameterizableClass.class, cont.getClass());
+	}
+	
+	@Test
+	public void testFieldArgumentTypes() {
+		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
+		assertNotNull(famixAtt);
+		assertEquals("mapBind", famixAtt.getName());
+		//assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		//Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
+	}
+	
+	@Test
+	public void testMethodParameterArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				///assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
 			}
 		}
 	}
+	
+	@Test
+	public void testMethodLocalVariableArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
+		assertNotNull(fmxMethod);
+		assertEquals(1, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
+			//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+			//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
+			if (fmxLocalVariable.getName().equals("ret")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxLocalVariable.getName().equals("l_name")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
+			if (fmxLocalVariable.getName().equals("fmx")) {
+				//assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
+			}
+			if (fmxLocalVariable.getName().equals("l")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+	}
+	
+	
+	@Test
+	public void testMethodReturnArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		//assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
+	}
+
+	@Test
+	public void testEnumDecl() {
+		fr.inria.verveine.core.gen.famix.Enum rk = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Rank");
+		assertNotNull(rk);
+		assertEquals("Rank", rk.getName());
+		//assertEquals(13, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Card"), rk.getBelongsTo());
+
+		EnumValue nine = TestVerveineUtils.detectElement(repo, EnumValue.class, "NINE");
+		assertNotNull(nine);
+		assertEquals("NINE", nine.getName());
+		assertSame(rk, nine.getParentEnum());
+		assertSame(rk, nine.getBelongsTo());
+
+		fr.inria.verveine.core.gen.famix.Enum st = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Suit");
+		assertNotNull(st);
+		assertEquals("Suit", st.getName());
+		//assertEquals(4, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "ad_hoc"), st.getBelongsTo());
+
+		EnumValue hrt = TestVerveineUtils.detectElement(repo, EnumValue.class, "HEARTS");
+		assertNotNull(hrt);
+		assertEquals("HEARTS", hrt.getName());
+		assertSame(st, hrt.getParentEnum());
+		assertSame(st, hrt.getBelongsTo());
+	}
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 87)
@@ -1,6 +1,5 @@
 package fr.inria.verveine.extractor.java;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
@@ -16,6 +15,7 @@
 import org.eclipse.jdt.core.dom.ConditionalExpression;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.FieldAccess;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
@@ -32,7 +32,6 @@
 import org.eclipse.jdt.core.dom.QualifiedType;
 import org.eclipse.jdt.core.dom.SimpleName;
 import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
@@ -41,6 +40,7 @@
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.TypeLiteral;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
@@ -114,13 +114,17 @@
 			importName = dico.removeLastName(importName);
 		}
 		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		context.setLastReference( dico.createFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(node.resolveBinding()));
+		ITypeBinding bnd = node.resolveBinding();
+		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
+		this.context.pushClass(fmx );
+
+		dico.addFamixAnnotationInstances(bnd, fmx);
 
 		return super.visit(node);
 	}
@@ -133,7 +137,11 @@
 	public boolean visit(ClassInstanceCreation node) {
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(decl.resolveBinding()));
+			ITypeBinding bnd = decl.resolveBinding();
+			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
+			this.context.pushClass(fmx);
+
+			dico.addFamixAnnotationInstances(bnd, fmx);
 		}
 		return super.visit(node);
 	}
@@ -146,35 +154,23 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 		IMethodBinding bnd = node.resolveBinding();
-		Type retTyp = node.getReturnType2();
-		Collection<Type> paramTypes = new ArrayList<Type>();
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				paramTypes.add(param.getType());
-		}
-		Method meth = null;
-		if (retTyp != null) {
-			meth = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-					context.topClass());
-		}
-		else {
-			meth = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					null,   // probably a constructor
-					context.topClass());
-		}
+		Method meth = (Method) dico.getEntityByKey(bnd);
 
-		this.context.pushMethod(meth);
-		for (Name excepName : (List<Name>)node.thrownExceptions()) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
-			if (excepFmx != null) {
-				dico.ensureFamixDeclaredException(meth, excepFmx);
+		if (meth != null) {
+			this.context.pushMethod(meth);
+
+			dico.addFamixAnnotationInstances(bnd, meth);
+
+			// Exceptions
+			for (Name excepName : (List<Name>)node.thrownExceptions()) {
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				if (excepFmx != null) {
+					dico.createFamixDeclaredException(meth, excepFmx);
+				}
 			}
 		}
-		return super.visit(node);	
+
+		return super.visit(node);
 	}
 
 	public void endVisit(MethodDeclaration node) {
@@ -182,6 +178,20 @@
 		super.endVisit(node);
 	}
 
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, RefVisiting FieldDeclaration");
+		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
+			IVariableBinding bnd = vd.resolveBinding();
+			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
+
+			if (fmx != null) {
+				dico.addFamixAnnotationInstances(bnd, fmx);
+			}
+		}
+		return super.visit(node);
+	}
+
 	public boolean visit(MethodInvocation node) {
 		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
 		return super.visit(node);
@@ -214,7 +224,7 @@
 			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(calledName);
 			}*/
-			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			context.setLastInvocation( dico.createFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
@@ -248,7 +258,7 @@
 				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
-				dico.ensureFamixCaughtException(meth, excepFmx);
+				dico.createFamixCaughtException(meth, excepFmx);
 			}
 		}
 
@@ -260,12 +270,11 @@
 		Method meth = this.context.topMethod();
 		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
-			dico.ensureFamixThrownException(meth, excepFmx);
+			dico.createFamixThrownException(meth, excepFmx);
 		}
 		return super.visit(node);
 	}
 
-
 	/**
 	 * Finds and/or create the Famix Entity receiving a message
 	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
@@ -358,7 +367,7 @@
 					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
-					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, context.topMethod());
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
 				}
 				else { // suppose it's a local variable
 					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -423,7 +432,7 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
-				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				context.setLastAccess( dico.createFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 87)
@@ -6,6 +6,8 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
+import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
 import org.eclipse.jdt.core.dom.AssertStatement;
 import org.eclipse.jdt.core.dom.Assignment;
@@ -15,14 +17,13 @@
 import org.eclipse.jdt.core.dom.ContinueStatement;
 import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
+import org.eclipse.jdt.core.dom.EnumDeclaration;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.ForStatement;
-import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
@@ -44,8 +45,9 @@
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -96,29 +98,20 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
+
+			this.context.pushClass(fmx);
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 		}
 
 		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
 		
-		dico.addSourceAnchor(fmx, node);
-		Javadoc jdoc = node.getJavadoc();
-		if (jdoc != null) {
-			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-			dico.addSourceAnchor(cmt, jdoc);
-		}
-		//Annotation
-		if (bnd != null) {
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
-			}
-		}
-		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
@@ -128,28 +121,82 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		//System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
+			fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			this.context.pushClass(fmx);
 		}
+		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
-	public void endVisit(AnonymousClassDeclaration node) {
+	public void endVisit(ClassInstanceCreation node) {
 		this.context.popClass();
 		super.endVisit(node);
 	}
-	
+
+	public boolean visit(AnnotationTypeDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			context.pushAnnotationType(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+
+	public void endVisit(AnnotationTypeDeclaration node) {
+		this.context.popAnnotationType();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeMemberDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+		IMethodBinding bnd = node.resolveBinding();
+		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			context.pushAnnotationMember(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+	public void endVisit(AnnotationTypeMemberDeclaration node) {
+		this.context.popAnnotationMember();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(EnumDeclaration node) {
+//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			for (EnumConstantDeclaration ecst : (List<EnumConstantDeclaration>)node.enumConstants()) {
+				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
+				ev.setIsStub(Boolean.FALSE);
+			}
+		}
+		return super.visit(node);
+	}
+
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
 		Type retTyp = node.getReturnType2();
@@ -157,60 +204,37 @@
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				paramTypes.add(param.getType());
 		}
-		Method fmx = null;
-		if (retTyp != null) {
-			fmx = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-					context.topClass());
-		}
-		else {
-			fmx = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					null,   // probably a constructor
-					context.topClass());
-		}
+		// creating/recovering it
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes,
+											(retTyp == null) ? null : dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+											context.topClass());
+		
 		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
 			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
 		}
 		
 		if (fmx != null) {
 			fmx.setIsStub(false);
+			
+			this.context.pushMethod(fmx);
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
+				fr.inria.verveine.core.gen.famix.Type paramTyp = dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null);
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), param.getName().getIdentifier(), paramTyp, fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
-				} else {
-					// Has no binding? It might be a Generic parameter
-					System.err.println("         Parameter="+param.getName().getIdentifier());
-					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null));
 				}
 				if (param.getType().isParameterizedType()) {
 					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
 				}
 			}
-			
-			dico.addSourceAnchor(fmx, node);
-			Javadoc jdoc = node.getJavadoc();
-			if (jdoc != null) {
-				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-				dico.addSourceAnchor(cmt, jdoc);
-			}
-			//Annotation
-			if (bnd != null) {
-				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-					dico.createFamixAnnotationInstance(fmx, annType);
-				}
-			}
-			this.context.pushMethod(fmx);
-			if (node.getBody() != null) {
-				context.setTopMethodCyclo(1);
-			}
-
 		}
 		return super.visit(node);	
 	}
@@ -228,7 +252,6 @@
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
 
 			if (fmx != null) {
@@ -239,18 +262,7 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			Javadoc jdoc = node.getJavadoc();
-			if (jdoc != null) {
-				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-				dico.addSourceAnchor(cmt, jdoc);
-			}
-			//Annotation
-			if (bnd != null) {
-				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-					dico.createFamixAnnotationInstance(fmx, annType);
-				}
-			}
+			dico.createFamixComment(node.getJavadoc(), fmx);
 		}
 		return super.visit(node);
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 87)
@@ -8,7 +8,9 @@
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ArrayType;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMemberValuePairBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
@@ -20,10 +22,15 @@
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
-import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Enum;
+import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
@@ -34,7 +41,6 @@
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.core.gen.famix.UnknownVariable;
 
@@ -57,6 +63,7 @@
 	 * @param famixRepo
 	 */
 	public JavaDictionary(Repository famixRepo) {
+		// should check whether there is already one in the repository
 		super(famixRepo);
 	}
 
@@ -115,19 +122,26 @@
 	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
 
 		if (bnd == null) {
-			return super.ensureFamixType(bnd, name, owner);
+			return super.ensureFamixType(null, name, owner);
 		}
 
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
+
+		if (bnd.isClass() || bnd.isInterface()) {
+			return this.ensureFamixClass(bnd, name, owner);
+		}
 		
 		if (bnd.isPrimitive()) {
 			return ensureFamixPrimitiveType(bnd, name);
 		}
-		else {
-			return this.ensureFamixClass(bnd, null, null);
+
+		if (bnd.isEnum()) {
+			return ensureFamixEnum(bnd, name, owner);
 		}
+		
+		return super.ensureFamixType(bnd, name, owner);
 	}
 	
 	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
@@ -157,24 +171,216 @@
 		}
 		return super.ensureFamixPrimitiveType(bnd, name);
 	}
-	
-	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
 
+	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Enum fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixEnum(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- recover from name ?
+		for (fr.inria.verveine.core.gen.famix.Enum candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Enum.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixEnum(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public EnumValue ensureFamixEnumValue(IVariableBinding bnd,	String name, Enum owner) {
+		EnumValue fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of creating an EnumValue without a declaring Enum type? 
+			}
+			return super.ensureFamixEnumValue(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixEnum(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (EnumValue candidate : getEntityByName(EnumValue.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixEnumValue(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentEnum(owner);
+		}
+
+		return fmx;
+	}
+
+	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd, String name, ContainerEntity owner) {
+		AnnotationType fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationType(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IPackageBinding parentPckg = bnd.getPackage();
+			if (parentPckg != null) {
+				owner = this.ensureFamixNamespace(parentPckg, null);
+			}
+			else {
+				owner = this.ensureFamixNamespaceDefault();
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationType candidate : getEntityByName(AnnotationType.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationType(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(IMethodBinding bnd, String name, AnnotationType owner) {
+		AnnotationTypeAttribute fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			ITypeBinding parentType = bnd.getDeclaringClass();
+			if (parentType != null) {
+				owner = this.ensureFamixAnnotationType(parentType, null, null);
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationTypeAttribute candidate : getEntityByName(AnnotationTypeAttribute.class, name) ) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationTypeAttribute(bnd, name, owner);
 		}
 		
-		AnnotationType fmx = ensureFamixUniqEntity(AnnotationType.class, null, bnd.getName());
-		fmx.setIsStub(true);
-		fmx.setContainer(ensureFamixNamespace(bnd.getPackage(), null));
-		mapToKey.put(bnd, fmx);
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
 		return fmx;
 	}
 
+	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
+		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
+			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
+			
+			Collection<AnnotationInstanceAttribute> annAtts = new ArrayList<AnnotationInstanceAttribute>(); 
+			for (IMemberValuePairBinding annPV : annBnd.getDeclaredMemberValuePairs()) {
+				annAtts.add( createFamixAnnotationInstanceAttribute(ensureFamixAnnotationTypeAttribute(annPV.getMethodBinding(), annPV.getName(), annType), annPV.getValue().toString()));
+			}
+			
+			super.addFamixAnnotationInstance(fmx, annType, annAtts);
+		}
+	}
+
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding.
-	 * The Entity is created if it does not exist.
+	 * The Entity is created if it does not exist.<br>
 	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
@@ -234,7 +440,7 @@
 		}
 
 		// --------------- owner
-		if ( (owner == null) && (bnd != null) ) {
+		if (owner == null) {
 			IMethodBinding parentMtd = bnd.getDeclaringMethod();
 			if (parentMtd != null) {
 				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
@@ -272,9 +478,9 @@
 		}
 
 		// --------------- recover from name ?
-		for (fr.inria.verveine.core.gen.famix.Class candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
-			if ( recoverAndMapClass(bnd, candidate) ) {
-				fmx = candidate;
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
 				break;
 			}
 		}
@@ -299,74 +505,74 @@
 		return fmx;
 	}
 
-	private boolean recoverAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Namespace matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound package, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		if (bnd.getName().equals(candidate.getName())) {
-			mapToKey.put(bnd, candidate);
-			return true;
-		}
-		return false;
+		// names are equals and bnd is not mapped, so let's do it
+		mapToKey.put(bnd, candidate);
+		return true;
 	}
 
-	private boolean recoverAndMapType(ITypeBinding bnd, Type candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Type matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * We also check that the actual class of the candidate matches (can be a sub-class of FamixType). 
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix NamedEntity (Class, Type, PrimitiveType, Enum, AnnotationType)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapType(ITypeBinding bnd, NamedEntity candidate) {
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
-		
+
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 		
-		if ( (bnd.isClass() || bnd.isInterface()) &&
-			 (candidate instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-			return recoverAndMapClass(bnd, (fr.inria.verveine.core.gen.famix.Class) candidate);
-		}
-		else if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
-			if ( (bnd.isPrimitive()) && (bnd.toString().equals(candidate.getName())) ) {
-				mapToKey.put(bnd, candidate);
-				return true;
-			}
-			else {
-				return false;
-			}
+		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
+			return checkAndMapClass(bnd, (Type) candidate);
 		}
-		else {
-			IMethodBinding methBnd = bnd.getDeclaringMethod();
-			if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-				if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
-					mapToKey.put(bnd, candidate);
-					return true;
-				}
-				else {
-					return false;
-				}
-			}
 
-			ITypeBinding classBnd = bnd.getDeclaringClass();
-			if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-				if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
-					mapToKey.put(bnd, candidate);
-					return true;
-				}
-				else {
-					return false;
-				}
-			}
-			
-			IPackageBinding pckgBnd = bnd.getPackage();
-			if ( (candidate.getBelongsTo() instanceof Namespace) &&
-				 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+		if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
+			// names are equal so it's OK
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		
+		if (bnd.isAnnotation() && (candidate instanceof AnnotationType) ) {
+			if (checkAndMapNamespace(bnd.getPackage(), (Namespace) candidate.getBelongsTo())) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -374,20 +580,48 @@
 				return false;
 			}
 		}
+		
+		return false;
 	}
 
-	private boolean recoverAndMapClass(ITypeBinding bnd, fr.inria.verveine.core.gen.famix.Class candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Class (or Interface or Enum) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapClass(ITypeBinding bnd, Type candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+		
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
-			return true;
+			if ( (bnd.isClass() || bnd.isInterface()) && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Class)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixClass: "+candidate.getName());
+				return false;
+			}
+			else if ( bnd.isEnum() && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Enum)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixEnum: "+candidate.getName());
+				return false;
+			}
+			else {
+				return true;
+			}
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+		// names match, 'bnd' was not bound, check the owners
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
+		IMethodBinding methBnd = bnd.getDeclaringMethod(); // for classes, can enum be declared in methods?
+		if ( (methBnd != null) && (candidateOwner instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -397,8 +631,8 @@
 		}
 
 		ITypeBinding classBnd = bnd.getDeclaringClass();
-		if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-			if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+		if ( (classBnd != null) && (candidateOwner instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			if ( checkAndMapClass(classBnd, (Type)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -408,8 +642,8 @@
 		}
 
 		IPackageBinding pckgBnd = bnd.getPackage();
-		if ( (candidate.getBelongsTo() instanceof Namespace) &&
-			 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+		if ( (candidateOwner instanceof Namespace) &&
+			 (checkAndMapNamespace(pckgBnd, (Namespace)candidateOwner)) ) {
 			mapToKey.put(bnd, candidate);
 			return true;
 		}
@@ -418,46 +652,87 @@
 		}
 	}
 
-	private boolean recoverAndMapMethod(IMethodBinding bnd, Method candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix "Method" matches the binding.
+	 * Checks that the candidate has the same name and same signature as the JDT bound method, and checks recursively that owners also match.
+	 * Note that AnnotationTypeAttribute are treated as methods by JDT, so they are checked here.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (regular Method or AnnotationTypeAttribute)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapMethod(IMethodBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		// for methods, the name is not enough, we must test the signature also 
-		String sig = bnd.getName() + "(";
-		boolean first = true;
-		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
-			if (! first) {
-				sig += "," + parBnd.getName();
+		// for methods, the name is not enough, we must test the signature also ...
+		// for AnnotationTypeAttribute, we don't need this
+		if (candidate instanceof Method) {
+			String sig = bnd.getName() + "(";
+			boolean first = true;
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
+				}
+				sig += ")";
 			}
-			else {
-				sig += parBnd.getName();
-				first = false;
+			if (! ((Method) candidate).getSignature().equals(sig)) {
+				return false;
 			}
-			sig += ")";
-		}
-		if (! candidate.getSignature().equals(sig)) {
-			return false;
+
+			// ... and the signature should include the return type
+			if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
+				return false;
+			}
 		}
 
+		// finally let's check the owners
 		ITypeBinding ownerBnd = bnd.getDeclaringClass();
-		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
-			 (recoverAndMapClass(ownerBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+		NamedEntity candidateOwner = candidate.getBelongsTo();
+		if ( (candidateOwner  instanceof fr.inria.verveine.core.gen.famix.Class) &&
+				 (checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
 				mapToKey.put(bnd, candidate);
-				// everything seems OK, but we still need to test return type which is not in the Moose signature
-				return recoverAndMapType(bnd.getReturnType(), candidate.getDeclaredType());
+				return true;
+			}
+		else if ( (candidateOwner instanceof AnnotationType) &&
+				(checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
-	private boolean recoverAndMapVariable(IVariableBinding bnd, StructuralEntity candidate) {
-		NamedEntity bound = (StructuralEntity)getEntityByKey(bnd); 
+	/**
+	 * Checks whether the existing unmapped Famix "Variable" (Attribute, Parameter, ...) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound variable, and checks recursively that owners also match.
+	 * The Famix candidate is a NamedEntity and not a StructuralEntity to allow dealing with Famix EnumValue that JDT treats as variables
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (a StructuralEntity or an EnumValue)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapVariable(IVariableBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = (NamedEntity)getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
@@ -465,9 +740,10 @@
 			return false;
 		}
 
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
 		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+		if ( (methBnd != null) && (candidateOwner  instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -477,8 +753,8 @@
 		}
 
 		ITypeBinding classBnd = bnd.getDeclaringClass();
-		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
-			 (recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+		if ( (candidateOwner instanceof Type) &&
+			 (checkAndMapType(classBnd, (Type)candidateOwner)) ) {
 			mapToKey.put(bnd, candidate);
 			return true;
 		}
@@ -489,9 +765,8 @@
 
 	/**
 	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
+	 * The Entity is created if it does not exist.
+	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
@@ -571,7 +846,7 @@
 		
 		// --------------- recover from name ?
 		for (Method candidate : this.getEntityByName(Method.class, name)) {
-			if ( recoverAndMapMethod(bnd, candidate) ) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -612,9 +887,10 @@
 	}
 
 	/**
-	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)} 
-	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
+	 * Returns a Famix Attribute associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
 		Attribute fmx = null;
@@ -625,7 +901,7 @@
 				return null;
 			}
 			if (owner == null) {
-				return null;  // what would be the interest of an attribute for which we ignore the declaring class? 
+				return null;  // what would be the interest of creating an attribute for which we ignore the declaring class? 
 			}
 			return super.ensureFamixAttribute(null, name, type, owner);
 		}
@@ -639,7 +915,6 @@
 		if (type == null) {
 			type = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
@@ -648,7 +923,7 @@
 		
 		// --------------- recover from name ?
 		for (Attribute candidate : getEntityByName(Attribute.class, name) ) {
-			if ( recoverAndMapVariable(bnd, candidate) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -685,52 +960,62 @@
 	}
 
 	/**
-	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
+	 * Returns a Famix Parameter associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Parameter ensureFamixParameter(IVariableBinding bnd, Method owner) {
-		boolean wasBound = false;
-		
+	public Parameter ensureFamixParameter(IVariableBinding bnd, String name, Type typ, Method owner) {
+		Parameter fmx = null;
+
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix Parameter");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixStubMethod("<"+name+"_owner>");
+			}
+			return super.ensureFamixParameter(null, name, typ, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
 		}
 
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+
+		// --------------- owner
 		if (owner == null) {
 			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
 		}
 		
-		// actually it seems to be very little chances that the parameter already exist.
-		// but who knows? Does not hurt to try
-		Parameter fmx = (Parameter) getEntityByKey(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- recover from name ?
+		for (Parameter candidate : getEntityByName(Parameter.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
 		}
-		else {
-			wasBound = false;
-			fmx = (Parameter) ensureFamixEntity(Parameter.class, bnd, bnd.getName());
+		if (fmx == null) {
+			fmx = super.ensureFamixParameter(bnd, name, typ, owner);
 		}
 		
-		if ( (fmx!=null) && (! wasBound) ) {
-			// declaring method
-			if (bnd.getDeclaringMethod() != null) {
-				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null));  // cast needed to desambiguate the call
-			} else {
-				fmx.setParentBehaviouralEntity(owner);
-			}
-			// type of the attribute
-			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), null, null));
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentBehaviouralEntity(owner);
+			fmx.setDeclaredType(typ);	
 		}
-		
+
 		return fmx;
 	}
 	
 	/**
-	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * Returns a Famix LocalVariable associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
 	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
 	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
@@ -756,7 +1041,6 @@
 		if (typ == null) {
 			typ = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
@@ -765,7 +1049,7 @@
 		
 		// --------------- recover from name ?
 		for (LocalVariable candidate : getEntityByName(LocalVariable.class, name) ) {
-			if ( recoverAndMapVariable(bnd, candidate) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -788,26 +1072,20 @@
 	 */
 	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
-		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
+		UnknownVariable fmx = (UnknownVariable) createFamixNamedEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
 		}
 		return fmx;
 	}
-	
-	/**
-	 * Creates and returns a FAMIX AnnotationInstance and associates it with an Entity and an AnnotationType
-	 * @param name -- the name (String) of the annotation 
-	 * @param owner -- the entity concerned by this annotation
-	 * @return the FAMIX AnnotationInstance
-	 */
-	public AnnotationInstance createFamixAnnotationInstance(SourcedEntity owner, AnnotationType annType) {
-		AnnotationInstance fmx = new AnnotationInstance();
-		fmx.setAnnotatedEntity(owner);
-		fmx.setAnnotationType(annType);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
+
+	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+		Comment cmt = null;
+		if (jdoc != null) {
+			cmt = createFamixComment(jdoc.toString(), fmx);
+			addSourceAnchor(cmt, jdoc);
+		}
+		return cmt;
 	}
 
 	/**
@@ -898,7 +1176,7 @@
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 
 		return fmx;
 	}
@@ -912,7 +1190,7 @@
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
 		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
 		if (fmx != null) {
-			ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 			fmx.setContainer( ensureFamixNamespaceDefault());
 			
 			fmx.setIsAbstract(Boolean.FALSE);
@@ -926,7 +1204,6 @@
 		return fmx;
 	}
 
-
 	public String removeLastName(String qualifiedName) {
 		String ret = null;
 		int last = qualifiedName.lastIndexOf('.');
@@ -941,4 +1218,6 @@
 		return ret;
 	}
 
+
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 87)
@@ -35,7 +35,6 @@
 	public String[] getInitialArgs() {
 		return this.initialArgs;
 	}
-	
 
 	@Override
 	public boolean compile(String[] argv) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 87)
@@ -16,6 +16,7 @@
 	public FamixRequestor(Repository r, String[] initialArgs) {
 		this.famixRepo = r;
 		this.initialArgs = initialArgs;
+
 		this.famixDictionnary = new JavaDictionary(famixRepo);
 	}
 
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 50)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 51)
@@ -121,9 +121,11 @@
 			dico.addSourceAnchor(cmt, jdoc);
 		}
 		//Annotation
-		for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-			AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-			dico.createFamixAnnotationInstance(fmx, annType);
+		if (bnd != null) {
+			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+				dico.createFamixAnnotationInstance(fmx, annType);
+			}
 		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
@@ -191,9 +193,11 @@
 				dico.addSourceAnchor(cmt, jdoc);
 			}
 			//Annotation
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
+			if (bnd != null) {
+				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+					dico.createFamixAnnotationInstance(fmx, annType);
+				}
 			}
 			this.context.pushMethod(fmx);
 			if (node.getBody() != null) {
@@ -238,9 +242,11 @@
 				dico.addSourceAnchor(cmt, jdoc);
 			}
 			//Annotation
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
+			if (bnd != null) {
+				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+					dico.createFamixAnnotationInstance(fmx, annType);
+				}
 			}
 		}
 		return super.visit(node);
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java	(revision 23)
@@ -0,0 +1,28 @@
+package OMGL2;
+import java.io.BufferedReader;
+
+
+public class SequSynchro {
+
+	public static void parcours(BufferedReader in_cli, BufferedReader in_four) {
+		Client cli;
+		Fournisseur four;
+		
+		cli = Client.lire(in_cli);
+		four = Fournisseur.lire(in_four);
+		while ( (cli != null) && (four != null) ) {
+			if (four.estFournisseur(cli)) {
+				System.out.println(cli.toString()+" a pour fournisseur: ["+four.getNum()+"] "+four.getNom());
+				cli = Client.lire(in_cli);
+				four = Fournisseur.lire(in_four);
+			}
+			else if (cli.getNum().compareTo(four.getNumCli()) < 0) {
+				cli = Client.lire(in_cli);
+			}
+			else {
+				four = Fournisseur.lire(in_four);
+			}
+		}
+	}
+	
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java	(revision 23)
@@ -0,0 +1,81 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+public class Fournisseur {
+
+	private String num;
+	private String nom;
+	private String numCli;
+	
+	public Fournisseur(String num, String nom, String numCli) {
+		this.setNum(num);
+		this.setNom(nom);
+		this.setNumCli(numCli);
+	}
+
+	public static Fournisseur lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		String numCli = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				if (c != '.') {
+					c = (char)in.read();
+				}
+				nom += c;
+			}
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				numCli += c;
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Fournisseur(num, nom, numCli);
+		
+	}
+
+	public String toString() {
+		return "fournisseur: ["+getNum()+"] "+getNom()+" du client no. "+getNumCli();
+	}
+	
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+
+	public void setNumCli(String numCli) {
+		this.numCli = numCli;
+	}
+
+	public String getNumCli() {
+		return numCli;
+	}
+
+	
+	public boolean estFournisseur(Client cli) {
+		return getNumCli().equals(cli.getNum());
+	}
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java	(revision 23)
@@ -0,0 +1,30 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.StringReader;
+
+
+
+public class Main {
+
+	public static void main(String[] args) throws IOException {
+		//mainFiles();
+		mainStrings();
+	}
+
+	public static void mainFiles() throws IOException {
+		File client = new File("client.dat") ;
+	    File fourni =  new File("fournisseur.dat");
+
+	    SequSynchro.parcours(new BufferedReader(new FileReader(client)), new BufferedReader(new FileReader(fourni)));
+	}
+
+	public static void mainStrings() throws IOException {
+		String client = "00001Jean Valjean.00002Bernard Lermitte.";
+	    String fourni =  "10001Thibeaudeau et frere.0000110002Chez Marius.00002";
+
+	    SequSynchro.parcours(new BufferedReader(new StringReader(client)), new BufferedReader(new StringReader(fourni)));
+	}
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java	(revision 23)
@@ -0,0 +1,4 @@
+package OMGL2;
+public class ReadException extends Exception {
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 23)
@@ -0,0 +1,62 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+
+
+public class Client {
+
+	private String num;
+	private String nom;
+	
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 22)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 23)
@@ -1,484 +0,0 @@
-/**
- * Copyright (c) 2010 Simon Denier
- */
-package tests.fr.inria.verveine.extractor.java;
-
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-import java.util.Collection;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import test.fr.inria.verveine.core.TestVerveineUtils;
-import ch.akuhn.fame.Repository;
-import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.Comment;
-import fr.inria.verveine.core.gen.famix.FileAnchor;
-import fr.inria.verveine.core.gen.famix.Inheritance;
-import fr.inria.verveine.core.gen.famix.Invocation;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.PrimitiveType;
-import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.extractor.java.JavaDictionary;
-import fr.inria.verveine.extractor.java.VerveineJParser;
-
-/**
- * @author Simon Denier
- * @since May 28, 2010
- *
- */
-public class VerveineExtractorJavaTest {
-
-	private static final String A_CLASS_NAME = "--aClassName--";
-
-	private Repository repo;
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp() throws Exception {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/LANModel"});
-		parser.renameNamespaces();
-		repo = parser.getFamixRepo();
-	}
-
-	@Test
-	public void testEntitiesNumber() {
-		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
-		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
-		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-	}
-
-	@Test
-	public void testClassProperties() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		assertEquals("Node", nodeClass.getName());
-		assertEquals(11, nodeClass.getMethods().size());
-		assertEquals(2, nodeClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
-		assertFalse(nodeClass.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
-		assertNotNull(interfce);
-		assertEquals("IPrinter", interfce.getName());
-		assertEquals(1, interfce.getMethods().size());
-		assertEquals(0, interfce.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
-		assertTrue(interfce.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
-		assertNotNull(innerClass);
-		assertEquals("XPrinter", innerClass.getName());
-		assertEquals(2, innerClass.getMethods().size());
-		assertEquals(1, innerClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
-		assertFalse(innerClass.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
-		assertNotNull(anonClass);
-		assertEquals("anonymous(IPrinter)", anonClass.getName());
-		assertEquals(1, anonClass.getMethods().size());
-		assertEquals(0, anonClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
-		assertFalse(anonClass.getIsInterface());
-	}
-
-	@Test
-	public void testNamedEntities() {
-		JavaDictionary dico = new JavaDictionary(repo);
-		
-		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
-		
-		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
-		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
-		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
-
-		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
-		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
-		assertSame(obj, dico.ensureFamixClassObject(null));
-		assertEquals(0, obj.getSuperInheritances().size());
-		assertSame(javaLang, obj.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
-		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
-		assertSame(fmx, dico.ensureFamixClassStubOwner());
-	}
-
-	@Test
-	public void testInheritance() {
-		fr.inria.verveine.core.gen.famix.Class clazz;
-		Collection<Inheritance> superInheritances;
-		Inheritance inh;
-		
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
-		assertNotNull(clazz);
-		superInheritances = clazz.getSuperInheritances();
-		assertEquals(1, superInheritances.size());
-		inh = superInheritances.iterator().next();
-		assertSame(clazz, inh.getSubclass());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
-
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		superInheritances = clazz.getSuperInheritances();
-		assertEquals(1, superInheritances.size());
-		inh = superInheritances.iterator().next();
-		assertSame(clazz, inh.getSubclass());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
-	}
-
-	@Test
-	public void testMethodProperties() {
-		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
-		assertNotNull(mweb);
-		assertEquals("methodWithEmptyBody", mweb.getName());
-		assertEquals("methodWithEmptyBody()", mweb.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
-
-		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
-		assertNotNull(em);
-		assertEquals("equalsMultiple", em.getName());
-		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
-
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
-		assertNotNull(clazz);
-		Method n = null;
-		for (Method m : clazz.getMethods()) {
-			if (m.getName().equals("name")) {
-				n = m;
-				break;
-			}
-		}
-		assertNotNull(n);
-		assertEquals("name", n.getName());
-		assertEquals("name()", n.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
-	}
-
-	@Test
-	public void testFieldType() {
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		Collection<Attribute> l_atts = clazz.getAttributes();
-		assertEquals(2, l_atts.size());
-		for (Attribute a : l_atts) {
-			if (a.getName().equals("nextNode")) {
-				assertSame(clazz, a.getParentType());
-				assertSame(clazz, a.getDeclaredType());
-			}
-			else if (a.getName().equals("name")) {
-				assertSame(clazz, a.getParentType());
-				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
-			}
-		}
-	}
-
-	@Test
-	public void testStubs() {
-		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
-		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
-		assertNotNull(ns);
-		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
-		assertTrue(ns.getIsStub());
-			
-		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
-		assertNotNull(obj);
-		assertTrue(ns.getIsStub());
-		assertSame(ns, obj.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
-		assertNotNull(str);
-		assertTrue(str.getIsStub());
-		assertSame(ns, str.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		assertFalse(clazz.getIsStub());
-		
-		/* [].length notused in the default test case 
-		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
-		assertNotNull(att);
-		clazz = (Class) att.getParentType();
-		assertNotNull(clazz);
-		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
-	}
-
-	@Test
-	public void testParameter() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		for (Method mNode : nodeClass.getMethods()) {
-			if ( (mNode.getName().equals("Node")) ||
-				 (mNode.getName().equals("methodWithEmptyBody")) ||
-				 (mNode.getName().equals("canOriginate")) ||
-				 (mNode.getName().equals("canOutput")) ) {
-				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
-			}
-			else if ( (mNode.getName().equals("name")) ||
-					  (mNode.getName().equals("nextNode")) ) {
-				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
-			}
-			else if ( (mNode.getName().equals("accept")) ||
-					 (mNode.getName().equals("send")) ||
-					 (mNode.getName().equals("printOn")) ) {
-				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
-			}
-		}
-		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
-		assertNotNull(iprintClass);
-		Method mPrint = iprintClass.getMethods().iterator().next();
-		assertEquals(2, mPrint.getParameters().size());
-		for (Parameter p : mPrint.getParameters()) {
-			assertSame(mPrint, p.getParentBehaviouralEntity());
-			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
-			if (p.getName().equals("contents")) {
-				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
-			}
-			if (p.getName().equals("rv")) {
-				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
-			}
-		}
-	}
-
-	@Test
-	public void testInvocation() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		for (Method mNode : nodeClass.getMethods()) {
-			if ( (mNode.getName().equals("name")) ||
-				 (mNode.getName().equals("nextNode")) ||
-				 (mNode.getName().equals("methodWithEmptyBody")) ||
-				 (mNode.getName().equals("canOutput")) ||
-				 (mNode.getName().equals("canOriginate")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
-			}
-			else if ( (mNode.getName().equals("Node")) ||
-					  (mNode.getName().equals("accept")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
-			}
-			else if (mNode.getName().equals("send"))  {
-				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
-			}
-			else if (mNode.getName().equals("printOn")) {
-				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
-			}
-		}
-		
-		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
-		assertNotNull(sdaClass);
-		for (Method mSDA : sdaClass.getMethods()) {
-			for (Invocation inv : mSDA.getOutgoingInvocations()) {
-				assertTrue( "Unexpected method signature: "+inv.getSignature(),
-							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
-				if (inv.getSignature().equals("equalsSingle (String)")) {
-					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
-					assertEquals("self", inv.getReceiver().getName());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
-				}
-				else if (inv.getSignature().equals("id ()")) {
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
-					assertEquals("self", inv.getReceiver().getName());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
-				}
-				else if (inv.getSignature().equals("equals (Object)")) {
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
-					assertEquals(null, inv.getReceiver());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
-				}
-			}
-		}
-	}
-	
-	@Test
-	public void testAccess() {
-		Attribute att;
-		BehaviouralEntity accessor;
-		
-		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
-		assertNotNull(att);
-		assertSame(2, att.getIncomingAccesses().size());
-		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
-		assertSame(Method.class, accessor.getClass());
-		assertEquals("name", accessor.getName());
-		assertEquals("Node", ((Method)accessor).getParentType().getName());
-
-		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
-		assertNotNull(att);
-		assertSame(1, att.getIncomingAccesses().size());
-		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
-		assertSame(Method.class, accessor.getClass());
-		assertEquals("setServerType", accessor.getName());
-		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
-
-		// finds method PrintServer.output()
-		Method output = null;
-		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
-			if (m.getParentType().getName().equals("PrintServer")) {
-				output = m;
-				break;
-			}
-		}
-		assertNotNull(output);
-		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
-		for (Access acc : output.getAccesses()) {
-			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
-						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
-			assertEquals(output, acc.getAccessor());
-		}
-	}
-
-	@Test
-	public void testSourceAnchors() {
-		SourceAnchor anc = null;
-		
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
-		assertNotNull(clazz);
-
-		anc = clazz.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(clazz, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
-		assertEquals(17, ((FileAnchor)anc).getStartLine());
-		assertEquals(31, ((FileAnchor)anc).getEndLine());
-
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-
-		anc = clazz.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(clazz, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
-		assertEquals(6, ((FileAnchor)anc).getStartLine());
-		assertEquals(70, ((FileAnchor)anc).getEndLine());
-		
-		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
-		assertNotNull(meth);
-
-		anc = meth.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(meth, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
-		assertEquals(39, ((FileAnchor)anc).getStartLine());
-		assertEquals(41, ((FileAnchor)anc).getEndLine());
-		
-		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
-		assertNotNull(meth);
-
-		anc = att.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(att, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
-		assertEquals(15, ((FileAnchor)anc).getStartLine());
-		assertEquals(15, ((FileAnchor)anc).getEndLine());
-		
-	}
-
-	@Test
-	public void testModifiers() {
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
-		assertNotNull(clazz);
-		assertFalse(clazz.getIsInterface());
-		assertTrue(clazz.getIsAbstract());
-		assertTrue(clazz.getModifiers().contains("abstract"));
-		assertTrue(clazz.getIsPublic());
-		assertFalse(clazz.getIsPrivate());
-		assertFalse(clazz.getIsProtected());
-		assertFalse(clazz.getIsFinal());
-		
-		assertEquals(3, clazz.getMethods().size());
-		for (Method m : clazz.getMethods()) {
-			assertTrue(m.getIsPublic());
-			assertFalse(m.getIsPrivate());
-			assertFalse(m.getIsProtected());
-			assertFalse(m.getIsFinal());
-			if (m.getName().equals("output")) {
-				assertTrue(m.getIsAbstract());
-			}
-			else {
-				assertFalse(m.getIsAbstract());
-			}
-		}
-		
-		assertEquals(1, clazz.getAttributes().size());
-		Attribute a = clazz.getAttributes().iterator().next();
-		assertFalse(a.getIsPublic());
-		assertFalse(a.getIsPrivate());
-		assertTrue(a.getIsProtected());
-		assertFalse(a.getIsFinal());
-	}
-
-	@Test
-	public void testComment() {	
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
-		assertNotNull(clazz);
-		Collection<Comment> cmts = clazz.getComments();
-		assertEquals(1, cmts.size());
-		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
-		assertEquals(6, ((FileAnchor)anc).getStartLine());
-		assertEquals(10, ((FileAnchor)anc).getEndLine());
-
-		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
-		assertNotNull(meth);
-		cmts = meth.getComments();
-		assertEquals(1, cmts.size());
-		anc = cmts.iterator().next().getSourceAnchor();
-		assertEquals(31, ((FileAnchor)anc).getStartLine());
-		assertEquals(34, ((FileAnchor)anc).getEndLine());
-
-	}
-	
-	@Test
-	public void testMetric() {	
-		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
-			assertNotNull(m);
-			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
-			assertNotNull(owner);
-			if (owner.getName().equals("OutputServer")) {
-			assertEquals(2, m.getCyclo());
-				assertEquals(6, m.getNOS());
-			}
-			else if (owner.getName().equals("Node")) {
-				assertEquals(1, m.getCyclo());
-				assertEquals(1, m.getNOS());
-			}
-			else if (owner.getName().equals("WorkStation")) {
-				assertEquals(2, m.getCyclo());
-				assertEquals(7, m.getNOS());
-			}
-		}		
-	}
-
-}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 23)
@@ -0,0 +1,484 @@
+/**
+ * Copyright (c) 2010 Simon Denier
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Collection;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.extractor.java.JavaDictionary;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Simon Denier
+ * @since May 28, 2010
+ *
+ */
+public class VerveineJTest_LanModel {
+
+	private static final String A_CLASS_NAME = "--aClassName--";
+
+	private Repository repo;
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/LANModel"});
+		parser.renameNamespaces();
+		repo = parser.getFamixRepo();
+	}
+
+	@Test
+	public void testEntitiesNumber() {
+		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
+		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+	}
+
+	@Test
+	public void testClassProperties() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		assertEquals("Node", nodeClass.getName());
+		assertEquals(11, nodeClass.getMethods().size());
+		assertEquals(2, nodeClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
+		assertFalse(nodeClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(interfce);
+		assertEquals("IPrinter", interfce.getName());
+		assertEquals(1, interfce.getMethods().size());
+		assertEquals(0, interfce.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
+		assertTrue(interfce.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(innerClass);
+		assertEquals("XPrinter", innerClass.getName());
+		assertEquals(2, innerClass.getMethods().size());
+		assertEquals(1, innerClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
+		assertFalse(innerClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
+		assertNotNull(anonClass);
+		assertEquals("anonymous(IPrinter)", anonClass.getName());
+		assertEquals(1, anonClass.getMethods().size());
+		assertEquals(0, anonClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
+		assertFalse(anonClass.getIsInterface());
+	}
+
+	@Test
+	public void testNamedEntities() {
+		JavaDictionary dico = new JavaDictionary(repo);
+		
+		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
+		
+		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
+		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
+		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
+
+		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
+		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
+		assertSame(obj, dico.ensureFamixClassObject(null));
+		assertEquals(0, obj.getSuperInheritances().size());
+		assertSame(javaLang, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
+		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
+		assertSame(fmx, dico.ensureFamixClassStubOwner());
+	}
+
+	@Test
+	public void testInheritance() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<Inheritance> superInheritances;
+		Inheritance inh;
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
+	}
+
+	@Test
+	public void testMethodProperties() {
+		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
+		assertNotNull(mweb);
+		assertEquals("methodWithEmptyBody", mweb.getName());
+		assertEquals("methodWithEmptyBody()", mweb.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
+
+		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
+		assertNotNull(em);
+		assertEquals("equalsMultiple", em.getName());
+		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
+
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
+		assertNotNull(clazz);
+		Method n = null;
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name")) {
+				n = m;
+				break;
+			}
+		}
+		assertNotNull(n);
+		assertEquals("name", n.getName());
+		assertEquals("name()", n.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
+	}
+
+	@Test
+	public void testFieldType() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		Collection<Attribute> l_atts = clazz.getAttributes();
+		assertEquals(2, l_atts.size());
+		for (Attribute a : l_atts) {
+			if (a.getName().equals("nextNode")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(clazz, a.getDeclaredType());
+			}
+			else if (a.getName().equals("name")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testStubs() {
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
+		assertNotNull(ns);
+		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
+		assertTrue(ns.getIsStub());
+			
+		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
+		assertNotNull(obj);
+		assertTrue(ns.getIsStub());
+		assertSame(ns, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
+		assertNotNull(str);
+		assertTrue(str.getIsStub());
+		assertSame(ns, str.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsStub());
+		
+		/* [].length notused in the default test case 
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
+		assertNotNull(att);
+		clazz = (Class) att.getParentType();
+		assertNotNull(clazz);
+		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
+	}
+
+	@Test
+	public void testParameter() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("Node")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOriginate")) ||
+				 (mNode.getName().equals("canOutput")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
+			}
+			else if ( (mNode.getName().equals("name")) ||
+					  (mNode.getName().equals("nextNode")) ) {
+				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
+			}
+			else if ( (mNode.getName().equals("accept")) ||
+					 (mNode.getName().equals("send")) ||
+					 (mNode.getName().equals("printOn")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
+			}
+		}
+		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(iprintClass);
+		Method mPrint = iprintClass.getMethods().iterator().next();
+		assertEquals(2, mPrint.getParameters().size());
+		for (Parameter p : mPrint.getParameters()) {
+			assertSame(mPrint, p.getParentBehaviouralEntity());
+			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
+			if (p.getName().equals("contents")) {
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
+			}
+			if (p.getName().equals("rv")) {
+				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testInvocation() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("name")) ||
+				 (mNode.getName().equals("nextNode")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOutput")) ||
+				 (mNode.getName().equals("canOriginate")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
+			}
+			else if ( (mNode.getName().equals("Node")) ||
+					  (mNode.getName().equals("accept")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("send"))  {
+				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("printOn")) {
+				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
+			}
+		}
+		
+		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(sdaClass);
+		for (Method mSDA : sdaClass.getMethods()) {
+			for (Invocation inv : mSDA.getOutgoingInvocations()) {
+				assertTrue( "Unexpected method signature: "+inv.getSignature(),
+							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
+				if (inv.getSignature().equals("equalsSingle (String)")) {
+					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
+				}
+				else if (inv.getSignature().equals("id ()")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+				else if (inv.getSignature().equals("equals (Object)")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals(null, inv.getReceiver());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+			}
+		}
+	}
+	
+	@Test
+	public void testAccess() {
+		Attribute att;
+		BehaviouralEntity accessor;
+		
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
+		assertNotNull(att);
+		assertSame(2, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("name", accessor.getName());
+		assertEquals("Node", ((Method)accessor).getParentType().getName());
+
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
+		assertNotNull(att);
+		assertSame(1, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("setServerType", accessor.getName());
+		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
+
+		// finds method PrintServer.output()
+		Method output = null;
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
+			if (m.getParentType().getName().equals("PrintServer")) {
+				output = m;
+				break;
+			}
+		}
+		assertNotNull(output);
+		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		for (Access acc : output.getAccesses()) {
+			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
+						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
+			assertEquals(output, acc.getAccessor());
+		}
+	}
+
+	@Test
+	public void testSourceAnchors() {
+		SourceAnchor anc = null;
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
+		assertEquals(17, ((FileAnchor)anc).getStartLine());
+		assertEquals(31, ((FileAnchor)anc).getEndLine());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(70, ((FileAnchor)anc).getEndLine());
+		
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
+		assertNotNull(meth);
+
+		anc = meth.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(meth, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
+		assertEquals(39, ((FileAnchor)anc).getStartLine());
+		assertEquals(41, ((FileAnchor)anc).getEndLine());
+		
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
+		assertNotNull(meth);
+
+		anc = att.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(att, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
+		assertEquals(15, ((FileAnchor)anc).getStartLine());
+		assertEquals(15, ((FileAnchor)anc).getEndLine());
+		
+	}
+
+	@Test
+	public void testModifiers() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsInterface());
+		assertTrue(clazz.getIsAbstract());
+		assertTrue(clazz.getModifiers().contains("abstract"));
+		assertTrue(clazz.getIsPublic());
+		assertFalse(clazz.getIsPrivate());
+		assertFalse(clazz.getIsProtected());
+		assertFalse(clazz.getIsFinal());
+		
+		assertEquals(3, clazz.getMethods().size());
+		for (Method m : clazz.getMethods()) {
+			assertTrue(m.getIsPublic());
+			assertFalse(m.getIsPrivate());
+			assertFalse(m.getIsProtected());
+			assertFalse(m.getIsFinal());
+			if (m.getName().equals("output")) {
+				assertTrue(m.getIsAbstract());
+			}
+			else {
+				assertFalse(m.getIsAbstract());
+			}
+		}
+		
+		assertEquals(1, clazz.getAttributes().size());
+		Attribute a = clazz.getAttributes().iterator().next();
+		assertFalse(a.getIsPublic());
+		assertFalse(a.getIsPrivate());
+		assertTrue(a.getIsProtected());
+		assertFalse(a.getIsFinal());
+	}
+
+	@Test
+	public void testComment() {	
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		Collection<Comment> cmts = clazz.getComments();
+		assertEquals(1, cmts.size());
+		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(10, ((FileAnchor)anc).getEndLine());
+
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
+		assertNotNull(meth);
+		cmts = meth.getComments();
+		assertEquals(1, cmts.size());
+		anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(31, ((FileAnchor)anc).getStartLine());
+		assertEquals(34, ((FileAnchor)anc).getEndLine());
+
+	}
+	
+	@Test
+	public void testMetric() {	
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
+			assertNotNull(m);
+			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
+			assertNotNull(owner);
+			if (owner.getName().equals("OutputServer")) {
+			assertEquals(2, m.getCyclo());
+				assertEquals(6, m.getNOS());
+			}
+			else if (owner.getName().equals("Node")) {
+				assertEquals(1, m.getCyclo());
+				assertEquals(1, m.getNOS());
+			}
+			else if (owner.getName().equals("WorkStation")) {
+				assertEquals(2, m.getCyclo());
+				assertEquals(7, m.getNOS());
+			}
+		}		
+	}
+
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 23)
@@ -0,0 +1,67 @@
+/**
+ * Copyright (c) 2010 Simon Denier
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Simon Denier
+ * @since May 28, 2010
+ *
+ */
+public class VerveineJTest_AdHoc {
+
+	private Repository repo;
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/ad_hoc"});
+		parser.renameNamespaces();
+		repo = parser.getFamixRepo();
+	}
+
+	@Test
+	public void testExceptions() {
+		// there are two "lire" methods, but both serve our purpose here so we just take the first that will be returned
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
+		assertNotNull(meth);
+		
+		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
+		
+		assertEquals(1, meth.getDeclaredExceptions().size());
+		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
+		assertSame(meth, exD.getDefiningMethod());
+		assertSame(excepClass, exD.getExceptionClass());
+		
+		assertEquals(1, meth.getThrownExceptions().size());
+		ThrownException exT = meth.getThrownExceptions().iterator().next();
+		assertSame(meth, exT.getDefiningMethod());
+		assertSame(excepClass, exT.getExceptionClass());
+
+		excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "IOException");
+		
+		assertEquals(1,meth.getCaughtExceptions().size());
+		CaughtException exC = meth.getCaughtExceptions().iterator().next();
+		assertSame(meth, exC.getDefiningMethod());
+		assertSame(excepClass, exC.getExceptionClass());
+	}
+
+}
Index: verveine.core/src/fr/inria/verveine/core/VerveineParser.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 85)
+++ verveine.core/src/fr/inria/verveine/core/VerveineParser.java	(revision 86)
@@ -14,6 +14,7 @@
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.FAMIXModel;
+import fr.inria.verveine.core.gen.famix.SourceLanguage;
 
 public class VerveineParser extends Main {
 
@@ -21,6 +22,8 @@
 	
 	private Repository famixRepo;
 
+	SourceLanguage myLgge = null;
+
 	public VerveineParser() {
 		this(new PrintWriter(System.out),
 				new PrintWriter(System.err),
@@ -37,7 +40,11 @@
 				customDefaultOptions,
 				compilationProgress);
 		
-		setFamixRepo(new Repository(FAMIXModel.metamodel()));
+		Repository repo = new Repository(FAMIXModel.metamodel());
+		setFamixRepo(repo);
+		if (myLgge != null) {
+			repo.add( myLgge);
+		}
 	}
 
 	public boolean linkToExisting() {
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 85)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 86)
@@ -3,11 +3,13 @@
 import java.util.Stack;
 
 import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
+import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Reference;
 
@@ -19,35 +21,60 @@
 	public static final int EMPTY_NOS = 0;
 	
 	private Namespace fmxPckg;
-	private Stack<ClassStack> fmxClass;
-	
-	// for debugging
-	private boolean tracing = false;;
+	private Stack<ClassStack> fmxType;
 
 	/**
 	 * A structure to hold a Famix class and its current method
 	 */
 	public class ClassStack {
-		private fr.inria.verveine.core.gen.famix.Class fmxClass;
-		private Method fmxMethod;
+		private NamedEntity fmxType;  // can be a FamixClass or a FamixAnnotationType
+		private NamedEntity fmxMember; // can be a FamixMethod or a FamixAnnotationAttribute
 		private int metric_cyclo = EMPTY_CYCLO;  // Cyclomatic Complexity
-		private int metric_nos = EMPTY_NOS;    // Number Of Statements
+		private int metric_nos = EMPTY_NOS;      // Number Of Statements
 		
 		
- 		public ClassStack(fr.inria.verveine.core.gen.famix.Class e) {
-			fmxClass = e;
-			clearFmxMethod();
+ 		public ClassStack(NamedEntity e) {
+			fmxType = e;
+			clearFmxMember();
 		}
 
 		public fr.inria.verveine.core.gen.famix.Class getFmxClass() {
-			return fmxClass;
+			if (fmxType instanceof fr.inria.verveine.core.gen.famix.Class) {
+				return (fr.inria.verveine.core.gen.famix.Class) fmxType;
+			}
+			else {
+				return null;
+			}
+		}
+
+		public AnnotationType getFmxAnnotationType() {
+			if (fmxType instanceof AnnotationType) {
+				return (AnnotationType) fmxType;
+			}
+			else {
+				return null;
+			}
 		}
 
 		/**
 		 * Returns the Famix  Method on top of the context stack
 		 */
 		public Method getFmxMethod() {
-			return fmxMethod;
+			if (fmxMember instanceof Method) {
+				return (Method) fmxMember;
+			}
+			else {
+				return null;
+			}
+		}
+
+		public AnnotationTypeAttribute getFmxAnnotationAttribute() {
+			if (fmxMember instanceof AnnotationTypeAttribute) {
+				return (AnnotationTypeAttribute) fmxMember;
+			}
+			else {
+				return null;
+			}
 		}
 
 		/**
@@ -68,8 +95,13 @@
 		 * Reset the Famix Method on top of the context stack
 		 */
 		public void setFmxMethod(Method fmxMethod) {
-			clearFmxMethod();
-			this.fmxMethod = fmxMethod;
+			clearFmxMember();
+			this.fmxMember = fmxMethod;
+		}
+
+		public void setFmxAnnotationAttribute(AnnotationTypeAttribute fmxAtt) {
+			clearFmxMember();
+			this.fmxMember = fmxAtt;
 		}
 
 		/**
@@ -103,16 +135,16 @@
 		/**
 		 * Empties the context stack of Famix classes
 		 */
-		public void clearFmxClass() {
-			fmxClass = null;
-			clearFmxMethod();
+		public void clearFmxType() {
+			fmxType = null;
+			clearFmxMember();
 		}
 		
 		/**
 		 * Empties the Famix Method on top of the context stack
 		 */
-		public void clearFmxMethod() {
-			fmxMethod = null;
+		public void clearFmxMember() {
+			fmxMember = null;
 			metric_cyclo = EMPTY_CYCLO;
 			metric_nos = EMPTY_NOS;
 			setLastInvocation(null);
@@ -164,20 +196,12 @@
 		clearPckg();  // initializes (to empty) Pckgs, classes and methods
 	}
 
-	public boolean isTracing() {
-		return tracing;
-	}
-
-	public void setTracing(boolean tracing) {
-		this.tracing = tracing;
-	}
-
-	private ClassStack getTopClass() {
-		if (fmxClass.isEmpty()) {
+	private ClassStack getTopType() {
+		if (fmxType.isEmpty()) {
 			return null;
 		}
 		else {
-			return fmxClass.peek();
+			return fmxType.peek();
 		}
 	}
 
@@ -187,13 +211,19 @@
 	 * Pushes an entity on top of the "context stack"
 	 * @param e -- the entity
 	 */
-	public void push(ContainerEntity e) {
+	public void push(NamedEntity e) {
 		if (e instanceof Method) {
 			pushMethod((Method) e);
 		}
 		else if (e instanceof fr.inria.verveine.core.gen.famix.Class) {
 			pushClass((fr.inria.verveine.core.gen.famix.Class) e);
 		}
+		else if (e instanceof AnnotationTypeAttribute) {
+			pushAnnotationMember((AnnotationTypeAttribute) e);
+		}
+		else if (e instanceof AnnotationType) {
+			pushAnnotationType((AnnotationType) e);
+		}
 		else if (e instanceof Namespace) {
 			pushPckg((Namespace) e);
 		}
@@ -205,11 +235,7 @@
 	 * @param e -- the Famix method
 	 */
 	public void pushPckg(Namespace e) {
-		if (this.tracing) {
-			System.out.println("TRACE: pushPckg "+e.getName());
-		}
-		clearClasses();
-		//setLastAssoc(null);
+		clearTypes();
 		fmxPckg = e;
 	}
 
@@ -218,10 +244,11 @@
 	 * @param e -- the Famix class
 	 */
 	public void pushClass(fr.inria.verveine.core.gen.famix.Class e) {
-		if (this.tracing) {
-			System.out.println("TRACE: pushClass "+e.getName());
-		}
-		fmxClass.push(new ClassStack(e));
+		fmxType.push(new ClassStack(e));
+	}
+
+	public void pushAnnotationType(AnnotationType e) {
+		fmxType.push(new ClassStack(e));
 	}
 
 	/**
@@ -229,26 +256,26 @@
 	 * @param e -- the Famix method
 	 */
 	public void pushMethod(Method e) {
-		if (this.tracing) {
-			System.out.println("TRACE: pushMethod "+e.getName());
-		}
-		getTopClass().setFmxMethod(e);
-		
+		getTopType().setFmxMethod(e);
 	}
 
+	public void pushAnnotationMember(AnnotationTypeAttribute fmx) {
+		getTopType().setFmxAnnotationAttribute(fmx);	
+	}
+	
 	/**
 	 * Empties the context stack of package and associated classes
 	 */
 	public void clearPckg() {
-		clearClasses();
+		clearTypes();
 		fmxPckg = null;
 	}
 
 	/**
 	 * Empties the context stack of Famix classes
 	 */
-	public void clearClasses() {
-		fmxClass = new Stack<ClassStack>();
+	public void clearTypes() {
+		fmxType = new Stack<ClassStack>();
 	}
 	
 	// READ FROM THE STACK
@@ -262,9 +289,6 @@
 	public Namespace popPckg() {
 		Namespace ret = fmxPckg;
 		clearPckg();
-		if (this.tracing) {
-			System.out.println("TRACE: popPckg "+ret.getName());
-		}
 		return ret;
 	}
 
@@ -274,12 +298,14 @@
 	 * @return the Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class popClass() {
-		ClassStack tmp = fmxClass.pop();
-		if (this.tracing) {
-			System.out.println("TRACE: popClass "+tmp.getFmxClass().getName());
-		}
+		ClassStack tmp = fmxType.pop();
 		return tmp.getFmxClass();
 	}
+	
+	public AnnotationType popAnnotationType() {
+		ClassStack tmp = fmxType.pop();
+		return tmp.getFmxAnnotationType();
+	}
 
 	/**
 	 * Pops the top Famix method of the current class on top of the "context stack"
@@ -287,13 +313,16 @@
 	 * @return the Famix method
 	 */
 	public Method popMethod() {
-		ClassStack tmp = getTopClass();
+		ClassStack tmp = getTopType();
 		Method ret = tmp.getFmxMethod();
-		tmp.clearFmxMethod();
-		
-		if (this.tracing) {
-			System.out.println("TRACE: popMethod "+ret.getName());
-		}
+		tmp.clearFmxMember();
+		return ret;
+	}
+	
+	public AnnotationTypeAttribute popAnnotationMember() {
+		ClassStack tmp = getTopType();
+		AnnotationTypeAttribute ret = tmp.getFmxAnnotationAttribute();
+		tmp.clearFmxMember();
 		return ret;
 	}
 
@@ -304,7 +333,7 @@
 	 */
 	public ContainerEntity top() {
 		ContainerEntity ret = null;
-		ClassStack topc = getTopClass();
+		ClassStack topc = getTopType();
 		if (topc != null) {
 			ret = topc.getFmxMethod();
 			if (ret == null) {
@@ -333,7 +362,11 @@
 	 * @return the Famix class
 	 */
 	public fr.inria.verveine.core.gen.famix.Class topClass() {
-		return getTopClass().getFmxClass();
+		return getTopType().getFmxClass();
+	}
+
+	public AnnotationType topAnnotationType() {
+		return getTopType().getFmxAnnotationType();
 	}
 	
 	/**
@@ -342,7 +375,11 @@
 	 * @return the Famix method
 	 */
 	public Method topMethod() {
-		return getTopClass().getFmxMethod();
+		return getTopType().getFmxMethod();
+	}
+
+	public AnnotationTypeAttribute topAnnotationMember() {
+		return getTopType().getFmxAnnotationAttribute();
 	}
 
 	// PROPERTIES OF THE TOP METHOD
@@ -351,8 +388,8 @@
 	 * Returns the Cyclomatic complexity of the Famix Method on top of the context stack
 	 */
 	public int getTopMethodCyclo() {
-		if (getTopClass() != null) {
-			return getTopClass().getFmxMethodCyclo();
+		if (getTopType() != null) {
+			return getTopType().getFmxMethodCyclo();
 		}
 		else {
 			return EMPTY_CYCLO;
@@ -363,8 +400,8 @@
 	 * Returns the Number of Statements of the Famix Method on top of the context stack
 	 */
 	public int getTopMethodNOS() {
-		if (getTopClass() != null) {
-			return getTopClass().getFmxMethodNOS();
+		if (getTopType() != null) {
+			return getTopType().getFmxMethodNOS();
 		}
 		else {
 			return EMPTY_NOS;
@@ -375,8 +412,8 @@
 	 * Sets the Cyclomatic complexity of the Famix Method on top of the context stack
 	 */
 	public void setTopMethodCyclo(int c) {
-		if (getTopClass() != null) {
-			getTopClass().setFmxMethodCyclo(c);
+		if (getTopType() != null) {
+			getTopType().setFmxMethodCyclo(c);
 		}
 	}
 
@@ -384,8 +421,8 @@
 	 * Sets to the Number of Statements of the Famix Method on top of the context stack
 	 */
 	public void setTopMethodNOS(int n) {
-		if (getTopClass() != null) {
-			getTopClass().setFmxMethodNOS(n);
+		if (getTopType() != null) {
+			getTopType().setFmxMethodNOS(n);
 		}
 	}
 	
@@ -393,8 +430,8 @@
 	 * Adds to the Cyclomatic complexity of the Famix Method on top of the context stack
 	 */
 	public void addTopMethodCyclo(int c) {
-		if (getTopClass() != null) {
-			getTopClass().addFmxMethodCyclo(c);
+		if (getTopType() != null) {
+			getTopType().addFmxMethodCyclo(c);
 		}
 	}
 
@@ -402,10 +439,10 @@
 	 * Adds to the Number of Statements of the Famix Method on top of the context stack
 	 */
 	public void addTopMethodNOS(int n) {
-		if (getTopClass() != null) {
-			getTopClass().addFmxMethodNOS(n);
+		if (getTopType() != null) {
+			getTopType().addFmxMethodNOS(n);
 		}
 	}
-	
+
 }
 
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 85)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 86)
@@ -5,11 +5,12 @@
 import java.util.LinkedList;
 import java.util.Map;
 
-import org.eclipse.jdt.core.dom.ITypeBinding;
-
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Association;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
@@ -31,7 +32,6 @@
 import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.Reference;
-import fr.inria.verveine.core.gen.famix.SourceLanguage;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
 import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.ThrownException;
@@ -51,8 +51,6 @@
 	public static final String SELF_NAME = "self";
 	public static final String SUPER_NAME = "super";
 
-	private SourceLanguage myLgge = null;
-	
 	/**
 	 * The FAMIX repository where all FAMIX entities are created and stored
 	 */
@@ -87,9 +85,8 @@
 	/** Constructor taking a FAMIX repository
 	 * @param famixRepo
 	 */
-	public Dictionary(Repository famixRepo, SourceLanguage lgge) {
+	public Dictionary(Repository famixRepo) {
 		this.famixRepo = famixRepo;
-		this.myLgge = lgge;
 
 		this.mapToKey = new Hashtable<B,NamedEntity>();
 		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
@@ -195,7 +192,6 @@
 		if (fmx != null) {
 			fmx.setName(name);
 			fmx.setIsStub(Boolean.TRUE);
-			fmx.setDeclaredSourceLanguage(myLgge);
 
 			mapEntityToName(name, fmx);
 			
@@ -312,6 +308,35 @@
 		return fmx;
 	}
 
+	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(B key, String name, AnnotationType owner) {
+		AnnotationTypeAttribute fmx = ensureFamixNamedEntity(AnnotationTypeAttribute.class, key, name);
+		fmx.setParentAnnotationType(owner);
+		return fmx;
+	}
+
+	public AnnotationInstance createFamixAnnotationInstance(AnnotationType annType) {
+		AnnotationInstance fmx = new AnnotationInstance();
+		fmx.setAnnotationType(annType);
+		famixRepo.add(fmx);
+		return fmx;
+	}
+
+	public void addFamixAnnotationInstance(NamedEntity fmx, AnnotationType annType, Collection<AnnotationInstanceAttribute> annAtts) {
+		AnnotationInstance annInst = createFamixAnnotationInstance(annType);
+		if (annAtts != null) {
+			annInst.addAttributes(annAtts);
+		}
+		fmx.addAnnotationInstances( annInst);
+	}
+	
+	public AnnotationInstanceAttribute createFamixAnnotationInstanceAttribute(AnnotationTypeAttribute att, String val) {
+		AnnotationInstanceAttribute fmx = new AnnotationInstanceAttribute();
+		fmx.setAnnotationTypeAttribute(att);
+		fmx.setValue(val);
+		famixRepo.add(fmx);
+		return fmx;
+	}
+
 	/**
 	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
 	 * @param key to which the entity will be mapped (may be null, but then it will be difficult to recover the entity)
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 85)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationTypeAttribute.java	(revision 86)
@@ -32,6 +32,11 @@
         return parentAnnotationType;
     }
 
+    @Override
+	public ContainerEntity getBelongsTo() {
+		return null;
+	}
+
     public void setParentAnnotationType(AnnotationType parentAnnotationType) {
         if (this.parentAnnotationType != null) {
             if (this.parentAnnotationType.equals(parentAnnotationType)) return;
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 85)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 86)
@@ -216,7 +216,7 @@
     @FameProperty(name = "belongsTo", derived = true)
     public ContainerEntity getBelongsTo() {
         // TODO: this is a derived property, implement this method manually.
-        throw new UnsupportedOperationException("NamedEntity.getBelongsTo() Not implemented in this class, use the proper subclass!"); 
+        throw new UnsupportedOperationException("NamedEntity.getBelongsTo() Not implemented in this class, use the proper subclass ("+this.getClass().getName()+")"); 
     }
     
     private Boolean isFinal;
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 32)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 33)
@@ -17,6 +17,7 @@
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.NamedEntity;
@@ -154,6 +155,7 @@
 		String identifier = null;
 		boolean wasBound = false;
 		
+		
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
 			return null;
@@ -221,11 +223,17 @@
 			// superclass
 			if (! bnd.isInterface()) {
 				ITypeBinding supbnd = bnd.getSuperclass();
-				if (supbnd == null) {
+				ITypeBinding[] intsbnd = bnd.getInterfaces();
+				if (supbnd == null && intsbnd.length == 0) {
 					sups.add( ensureFamixClassObject(null));
 				}
 				else {
-					sups.add( ensureFamixClass(supbnd));
+					if (supbnd != null) {
+						sups.add(ensureFamixClass(supbnd));
+					}
+					for (ITypeBinding intbnd : intsbnd) {
+						sups.add( ensureFamixClass(intbnd));
+					}
 				}
 			}
 			else {
@@ -288,8 +296,9 @@
 			fmx.setContainer(owner);
 			if (sups.size() > 0) {
 				// some types don't have superclass
+				Inheritance lastInheritance = null;
 				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-					ensureFamixInheritance(sup, fmx);
+					lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 				}
 			}
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
