Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/akuhn-util-r28011.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/akuhn-util-r28011.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 111)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 112)
@@ -26,16 +26,20 @@
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
 import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.Entity;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.ImplicitVariable;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -60,7 +64,8 @@
 	@Before
 	public void setUp() throws Exception {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
-		String[] files = new String[] {
+
+		/*String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -76,14 +81,14 @@
 		// separate parsing of each source file --------
 		for (String f : files) {
 			parseFile(f);
-		}
+		}*/
 
 		// or parsing the entire project in one pass ---
-		/*VerveineJParser parser = new VerveineJParser();
+		VerveineJParser parser = new VerveineJParser();
 		repo = parser.getFamixRepo();
 		parser.setOptions(new String[] {"test_src/LANModel/"});
 		parser.parse();
-		parser.outputMSE();*/
+		parser.outputMSE();
 	}
 
 	/**
@@ -124,6 +129,21 @@
 	}
 
 	@Test
+	public void testBelongsTo() {
+		for ( Type e : repo.all(Type.class) ) {
+			if (! (e instanceof PrimitiveType) ) {
+				assertNotNull("a Type '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+			}
+		}
+		for ( BehaviouralEntity e : repo.all(BehaviouralEntity.class) ) {
+			assertNotNull("a BehaviouralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+		for ( StructuralEntity e : repo.all(StructuralEntity.class) ) {
+			assertNotNull("a StructuralEntity '"+e.getName()+"' does not belong to anything", e.getBelongsTo());
+		}
+	}
+
+	@Test
 	public void testClassProperties() {
 		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(nodeClass);
@@ -280,7 +300,7 @@
 		assertNotNull(ns);
 		assertEquals(9, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
-			
+
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
 		assertNotNull(obj);
 		assertTrue(obj.getIsStub());
@@ -481,7 +501,7 @@
 			}
 		}
 		assertNotNull(output);
-		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		assertEquals(4, output.getAccesses().size());
 		for (Access acc : output.getAccesses()) {
 			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
 						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 111)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 112)
@@ -93,7 +93,7 @@
 		AnnotationType fmProp = l_FmProp.iterator().next();
 		assertNotNull(fmProp);
 		assertEquals("FameProperty", fmProp.getName());
-		//TODO assertFalse(fmProp.getIsStub());
+		// FIXME assertFalse(fmProp.getIsStub());
 		
 		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
 		assertNotNull(fmPckg);
@@ -158,7 +158,7 @@
 		}
 
 	}
-	
+
 	@Test
 	public void testClassVar() {
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
@@ -177,7 +177,7 @@
 			}
 		}
 		
-		assertEquals(2, meth.getAccesses().size());
+		assertEquals(2, meth.getAccesses().size());  // ImplicitVariable.class + mapBind
 		boolean classFieldFound = false;
 		for (Access acc : meth.getAccesses()) {
 			if (acc.getTo().getName().equals("class")) {
@@ -194,6 +194,8 @@
 
 		assertEquals("Dictionary", dico.getName());
 		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
+// FIXME: Collection<NamedEntity> belongsTo getEntityByName !!
+
 		assertEquals(1, dico.getParameters().size());
 
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
@@ -203,10 +205,9 @@
 		assertSame(dico, dicoParam.getContainer());
 		assertSame(dicoParam, dico.getParameters().iterator().next());
 
-		/* Collection<Object> is not seen as parameterizable by JDT 		 */
-		 ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
-		 assertNotNull(collec);
-
+		/* Collection<Object> is not seen as parameterizable by JDT */
+		ParameterizableClass collec = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Collection");
+		assertNotNull(collec);
 	}
 
 	@Test
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 112)
@@ -226,7 +226,19 @@
 	}
 
 	public boolean visit(MethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
+		Expression callingExpr = node.getExpression();
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(callingExpr));
+		if (callingExpr instanceof SimpleName) {
+			// we might have a hidden FieldAccess here
+			IBinding bnd = ((Name) callingExpr).resolveBinding();
+			if ( (bnd != null) && (bnd instanceof IVariableBinding) && ((IVariableBinding)bnd).isField() ){
+				BehaviouralEntity accessor = this.context.topMethod();
+				Attribute accessed = this.dico.ensureFamixAttribute(bnd, ((SimpleName)callingExpr).getIdentifier(), null, /*owner*/context.topClass());
+				// 'owner' note: using a field without anything before, it must belongs to the currently parsed class
+				
+				context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+			}
+		}
 		return super.visit(node);
 	}
 
@@ -245,7 +257,15 @@
 	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/null);  // cast needed to desambiguate the call
+			Method invoked = null;
+			if (receiver instanceof StructuralEntity) {
+				fr.inria.verveine.core.gen.famix.Type varTyp = ((StructuralEntity)receiver).getDeclaredType();
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/varTyp);  // cast needed to desambiguate the call
+			}
+			else {
+				// method static of a class called on the class
+				invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, /*retType*/null, /*owner*/(fr.inria.verveine.core.gen.famix.Type)receiver);  // cast needed to desambiguate the call
+			}
 			context.setLastInvocation( dico.addFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
@@ -261,14 +281,15 @@
 		return super.visit(node);
 	}
 
-	/* Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
+	/*
+	 * Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
 	 */
 	public boolean visit(QualifiedName node) {
 		IBinding bnd = node.resolveBinding();
 		if (bnd instanceof IVariableBinding) {
 			// apparently this is a field
 			BehaviouralEntity accessor = this.context.topMethod();
-			Attribute accessed = this.dico.ensureFamixAttribute(bnd, node.getName().getIdentifier(), null, null);
+			Attribute accessed = this.dico.ensureFamixAttribute((IVariableBinding)bnd, node.getName().getIdentifier(), null, null);  // cast needed to access the proper method
 			if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 				accessed.setParentType(dico.ensureFamixClassArray());
 			}
@@ -277,6 +298,22 @@
 		return super.visit(node);
 	}
 
+	/* 
+	 * Another FieldAccess in disguise: SomeClass.class
+	 */
+	public boolean visit(TypeLiteral node) {
+		Attribute accessed;
+		fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
+		BehaviouralEntity accessor = this.context.topMethod();
+		accessed =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
+		if ( (accessed != null) && (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+			accessed.setParentType(dico.ensureFamixClassArray());
+		}
+		context.setLastAccess( dico.addFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+
+		return super.visit(node);
+	}
+
 	@Override
 	public boolean visit(CatchClause node) {
 		Method meth = this.context.topMethod();
@@ -360,12 +397,10 @@
 
 		// field.msg()
 		else if (expr instanceof FieldAccess) {
-			BehaviouralEntity accessor = this.context.topMethod();
 			Attribute ret = dico.ensureFamixAttribute(((FieldAccess) expr).resolveFieldBinding(), ((FieldAccess) expr).getName().getIdentifier(), null, null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -394,17 +429,15 @@
 			if (bnd instanceof ITypeBinding) {
 				// msg() is a static method of Name
 				//TODO why returning a variable here? Should not it be the class itself?
-				ret = dico.ensureFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null, context.top()), bnd.getName());
 			}
 			else if (bnd instanceof IVariableBinding) {
 				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
 				if ( ((IVariableBinding)bnd).isField() ) {
 					ret = dico.ensureFamixAttribute((IVariableBinding)bnd, varName, null, null);
-					BehaviouralEntity accessor = this.context.topMethod();
 					if ( (ret != null) && (((Attribute) ret).getParentType() == null) && (ret.getName().equals("length")) ) {
 						((Attribute) ret).setParentType(dico.ensureFamixClassArray());
 					}
-					context.setLastAccess( dico.addFamixAccess(accessor, (Attribute) ret, /*isWrite*/false, context.getLastAccess()) );
 
 					return ret;
 				}
@@ -432,12 +465,10 @@
 
 		// super.field.msg()
 		else if (expr instanceof SuperFieldAccess) {
-			BehaviouralEntity accessor = this.context.topMethod();
 			Attribute ret = dico.ensureFamixAttribute(((SuperFieldAccess) expr).resolveFieldBinding(), ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
 			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
 				ret.setParentType(dico.ensureFamixClassArray());
 			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
@@ -459,12 +490,7 @@
 			// similar to a field access
 			Attribute ret;
 			fr.inria.verveine.core.gen.famix.Type javaMetaClass = dico.ensureFamixMetaClass(null); 
-			BehaviouralEntity accessor = this.context.topMethod();
 			ret =  dico.ensureFamixAttribute(null, "class", javaMetaClass, javaMetaClass);
-			if ( (ret != null) && (ret.getParentType() == null) && (ret.getName().equals("length")) ) {
-				ret.setParentType(dico.ensureFamixClassArray());
-			}
-			context.setLastAccess( dico.addFamixAccess(accessor, ret, /*isWrite*/false, context.getLastAccess()) );
 
 			return ret;
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 112)
@@ -120,7 +120,7 @@
 			this.context.pushClass(fmx);
 
 			dico.addSourceAnchor(fmx, node);
-			dico.ensureFamixComment(node.getJavadoc(), fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 			
 			for (TypeParameter tp : tparams) {
 				// if there is a type parameter, then fmx will be a Famix ParameterizableClass
@@ -236,14 +236,6 @@
 		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
-		//Type retTyp = node.getReturnType2();
-		/*fr.inria.verveine.core.gen.famix.Type fmxTyp;
-		if (retTyp == null) {
-			fmxTyp = null;
-		}
-		else {
-			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner* /null, context.top());
-		}*/
 
 		Collection<Type> paramTypes = new ArrayList<Type>();
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
@@ -251,13 +243,9 @@
 		}
 
 		// creating/recovering it (creates it with a null return type because might need this FamixMethod to create the return type.
-		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, null, context.topClass());
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes, /*retType*/null, context.topClass());
 		fr.inria.verveine.core.gen.famix.Type fmxTyp = referedType(node.getReturnType2(), fmx);
 
-		//if (retTyp != null && retTyp.isParameterizedType()) {
-			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)retTyp).typeArguments()));
-		//}
-		
 		if (fmx != null) {
 			fmx.setIsStub(false);
 			
@@ -268,7 +256,7 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			dico.ensureFamixComment(node.getJavadoc(), fmx);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 
 			// creating the method's parameters
 			List<VariableDeclaration> paramAsVarList;
@@ -309,7 +297,7 @@
 		fr.inria.verveine.core.gen.famix.Type varTyp = referedType(node.getType(), context.topClass());
 		for (StructuralEntity att : visitVariablesDeclarations(node, varTyp, (List<VariableDeclaration>)node.fragments(), context.topClass()) ) {
 			dico.addSourceAnchor(att, node);
-			dico.ensureFamixComment(node.getJavadoc(), att);
+			dico.createFamixComment(node.getJavadoc(), att);
 		}
 		return super.visit(node);
 	}
@@ -346,7 +334,6 @@
 		return super.visit(node);
 	}
 
-	@SuppressWarnings("unchecked")
 	private Collection<StructuralEntity> visitVariablesDeclarations(ASTNode node, fr.inria.verveine.core.gen.famix.Type varTyp, List<VariableDeclaration> fragments, ContainerEntity ctxt) {
 		Collection<StructuralEntity> ret = new ArrayList<StructuralEntity>();
 
@@ -381,14 +368,10 @@
 		return ret;
 	}
 
-	/**
-	 * @param typ
-	 * @param ctxt
-	 * @return
-	 */
+	@SuppressWarnings("unchecked")
 	private fr.inria.verveine.core.gen.famix.Type referedType(Type typ, ContainerEntity ctxt) {
 		fr.inria.verveine.core.gen.famix.Type fmxTyp = null;
-		
+
 		if (typ == null) {
 			return null;
 		}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 112)
@@ -235,7 +235,7 @@
 		}
 
 		// --------------- recover from name ?
-		for (Type candidate : this.getEntityByName(Type.class, name)) {
+		for (Type candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
 			if ( checkAndMapClass(bnd, candidate) ) {
 				fmx = (Class) candidate;
 				break;
@@ -330,10 +330,20 @@
 			return super.ensureFamixParameterizedType(null, name, generic, owner);
 		}
 
+		fmx = (ParameterizedType)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
 		}
+		// remove parameter types from name
+		int i = name.indexOf('<');
+		if (i > 0) {
+			name = name.substring(0, i);
+		}
 
 		// --------------- owner
 		if (owner == null) {
@@ -366,12 +376,7 @@
 
 		// --------------- generic
 		if (generic == null) {
-			String genName = name;
-			int i = name.indexOf('<');
-			if (i > 0) {
-				genName = name.substring(0, i);
-			}
-			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), genName, owner, /*isGeneric*/true);
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
 		}
 
 		// --------------- recover from name ?
@@ -412,6 +417,11 @@
 			return super.ensureFamixEnum(null, name, owner);
 		}
 
+		fmx = (fr.inria.verveine.core.gen.famix.Enum)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -474,6 +484,11 @@
 			return super.ensureFamixEnumValue(null, name, owner);
 		}
 
+		fmx = (EnumValue)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -514,6 +529,11 @@
 			return super.ensureFamixAnnotationType(null, name, owner);
 		}
 
+		fmx = (AnnotationType)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -561,6 +581,11 @@
 			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
 		}
 
+		fmx = (AnnotationTypeAttribute)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -934,7 +959,7 @@
 	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
+	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, Type owner) {
 		Method fmx = null;
 		String sig;
 		boolean first;
@@ -975,6 +1000,11 @@
 			return super.ensureFamixMethod(null, name, sig, ret, owner);
 		}
 
+		fmx = (Method)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1089,6 +1119,11 @@
 			return super.ensureFamixAttribute(null, name, type, owner);
 		}
 
+		fmx = (Attribute)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1170,6 +1205,11 @@
 			return super.createFamixParameter(null, name, typ, owner);
 		}
 
+		fmx = (Parameter)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1224,6 +1264,11 @@
 			return super.ensureFamixLocalVariable(null, name, typ, owner);
 		}
 
+		fmx = (LocalVariable)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
+		}
+
 		// --------------- name
 		if (name == null) {
 			name = bnd.getName();
@@ -1260,10 +1305,10 @@
 	}
 	
 	/**
-	 * Returns a Famix UnknownVariable. The Entity is created if it does not exist.
+	 * Creates and returns a Famix UnknownVariable.
 	 */
-	public UnknownVariable ensureFamixUnknownVariable(Type type, String name) {
-//		System.err.println("TRACE -- ensureFamixUnknownVariable: "+name);
+	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
+//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
 		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
@@ -1271,7 +1316,7 @@
 		return fmx;
 	}
 
-	public Comment ensureFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
 		Comment cmt = null;
 		if (jdoc != null) {
 			cmt = createFamixComment(jdoc.toString(), fmx);
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 112)
@@ -20,11 +20,18 @@
 
 public class VerveineJParser extends VerveineParser {
 
+	public static final String DEFAULT_CODE_VERSION = JavaCore.VERSION_1_5;
+	
+
+	protected String codeVers = null;
+	
+	
 	/**
 	 * The arguments that were passed to the parser
 	 * Needed to relativize the source file names
 	 */
-	private Collection<String> sourceFiles;
+	private Collection<String> argPath;
+	private Collection<String> argFiles;
 	
 	private ASTParser jdtParser = null;
 	
@@ -35,35 +42,91 @@
 	}
 	
 	public void setOptions(String[] args) {
-		// we assume java 1.5 code for now, this should be configurable
+		Collection<String> classPath = new ArrayList<String>();
+		argPath = new ArrayList<String>();
+		argFiles = new ArrayList<String>();
+
+        int i = 0;
+        while (i < args.length && args[i].startsWith("-")) {
+        	String arg;
+            arg = args[i++];
+
+            if (arg.equals("-h")) {
+            	usage();
+            }
+            else if (arg.matches("-1\\.[1-7]") || arg.matches("-[1-7]")) {
+            	setCodeVersion(arg);
+            }
+            else if (arg.equals("-cp")) {
+                if (i < args.length) {
+                	classPath.add(args[++i]);
+                }
+                else {
+                	System.err.println("-cp requires a classPath");
+                }
+
+            }
+        }
+        while (i < args.length) {
+        	String arg;
+            arg = args[i++];
+        	if ( arg.endsWith(".java") && new File(arg).isFile() ) {
+        		argFiles.add(arg);
+        	}
+        	else {
+        		argPath.add(arg);
+        	}
+        }
+
+		jdtParser.setEnvironment(classPath.toArray(new String[0]), argPath.toArray(new String[0]), null, true);
+		jdtParser.setResolveBindings(true);
+		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
+
 		@SuppressWarnings("unchecked")
 		Map<String,String> options = JavaCore.getOptions();
-		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
-		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5);
-		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
+		
+		if (codeVers == null) {
+			codeVers = DEFAULT_CODE_VERSION;
+		}
+		options.put(JavaCore.COMPILER_COMPLIANCE, codeVers);
+		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, codeVers);
+		options.put(JavaCore.COMPILER_SOURCE, codeVers);
+
 		jdtParser.setCompilerOptions(options);
+	}
 
-		Collection<String> classPath = new ArrayList<String>();
-		Collection<String> sourcePath = new ArrayList<String>();
-		sourceFiles = new ArrayList<String>();
-		for (int i=0; i < args.length; i++) {
-			String current = args[i];
-			if (current.equals("-cp")) {
-				classPath.add(args[++i]);
-			}
-			else if (current.endsWith(".java")) {
-				sourceFiles.add(current);
-			}
-			else {
-				sourcePath.add(current);
-			}
+	protected void usage() {
+		System.err.println("Usage: VerveineJ [-h] [-cp CLASSPATH] [-1.1 | -1 | -1.2 | -2 | ... | -1.7 | -7] <files-to-parse> | <dirs-to-parse>");
+		System.exit(0);
+
+	}
+	protected void setCodeVersion(String arg) {
+		if (codeVers != null) {
+			System.err.println("Trying to set twice code versions: "+ codeVers + " and "+ arg);
+			usage();
 		}
-		
-		jdtParser.setEnvironment(classPath.toArray(new String[0]), sourcePath.toArray(new String[0]), null, true);
-		jdtParser.setResolveBindings(true);
-		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
-		
-		collectJavaFiles(sourcePath, sourceFiles);
+		else if (arg.equals("-1.1") || arg.equals("-1")) {
+			codeVers = JavaCore.VERSION_1_1;
+		}
+		else if (arg.equals("-1.2") || arg.equals("-2")) {
+			codeVers = JavaCore.VERSION_1_2;
+		}
+		else if (arg.equals("-1.3") || arg.equals("-3")) {
+			codeVers = JavaCore.VERSION_1_3;
+		}
+		else if (arg.equals("-1.4") || arg.equals("-4")) {
+			codeVers = JavaCore.VERSION_1_4;
+		}
+		else if (arg.equals("-1.5") || arg.equals("-5")) {
+			codeVers = JavaCore.VERSION_1_5;
+		}
+		else if (arg.equals("-1.6") || arg.equals("-6")) {
+			codeVers = JavaCore.VERSION_1_6;
+		}
+		else if (arg.equals("-1.7") || arg.equals("-7")) {
+			codeVers = JavaCore.VERSION_1_7;
+		}
+
 	}
 
 	private void collectJavaFiles(Collection<String> paths, Collection<String> files) {
@@ -93,11 +156,17 @@
 	}
 
 	public void parse() {
+		ArrayList<String> sourceFiles = new ArrayList<String>();
+
 		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
 		}
 
-		FamixRequestor req = new FamixRequestor(getFamixRepo(), new String[0]);
+		FamixRequestor req = new FamixRequestor(getFamixRepo(), argPath, argFiles);
+
+		sourceFiles.addAll(argFiles);
+		collectJavaFiles(argPath, sourceFiles);
+
 		jdtParser.createASTs(sourceFiles.toArray(new String[0]), null, new String[0], req, null);
 		
 		this.compressNamespacesNames();
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 111)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 112)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.Collection;
+
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.FileASTRequestor;
 
@@ -11,11 +13,13 @@
 	
 	protected JavaDictionary famixDictionnary;
 
-	private String[] initialArgs;
+	private Collection<String> argsDir;
+	private Collection<String> argsFile;
 	
-	public FamixRequestor(Repository r, String[] initialArgs) {
+	public FamixRequestor(Repository r, Collection<String> argsDir, Collection<String> argsFile) {
 		this.famixRepo = r;
-		this.initialArgs = initialArgs;
+		this.argsDir = argsDir;
+		this.argsFile = argsFile;
 
 		this.famixDictionnary = new JavaDictionary(famixRepo);
 	}
@@ -28,13 +32,19 @@
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
 
-	private Object relativePath(String sourceFilePath) {
-		for (String arg : initialArgs) {
-			int i = sourceFilePath.indexOf(arg);
-			if (i >= 0) {
-				return sourceFilePath.substring(i);
+	private Object relativePath(String fullPath) {
+		for (String f : argsFile) {
+			if (fullPath.endsWith(f)) {
+				return f;
+			}
+		}
+
+		for (String d : argsDir) {
+			int i = fullPath.indexOf(d);
+			if (i >= 0) {  // if fullPath contains d
+				return fullPath.substring(i);
 			}
 		}
-		return sourceFilePath;
+		return fullPath;
 	}
 }
Index: verveine.extractor.java/build.xml
===================================================================
--- verveine.extractor.java/build.xml	(revision 111)
+++ verveine.extractor.java/build.xml	(revision 112)
@@ -6,7 +6,7 @@
 	<property name="build.dir"    location="bin" />
 	<property name="docs.dir"     location="docs" />
 	<property name="dist.dir"     location="lib" />
-	<property name="verveine.jar" location="${dist.dir}/verveine.extractor,java.jar" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.extractor.java.jar" />
 
 	<!-- Variables used for JUnit testin -->
 	<property name="test.dir" location="src/tests/fr/inria/verveine/extractor/java/" />
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 53)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 54)
@@ -104,6 +104,7 @@
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
+		//fmx.setTypeArguments(dico.ensureFamixTypes(node.typeParameters()));
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -160,7 +161,7 @@
 		this.context.popClass();
 		super.endVisit(node);
 	}
-
+	
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
@@ -173,16 +174,23 @@
 			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
-			fmx.setSignature(fmx.getName()+" (???)");
-			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+			//fmx.setSignature(fmx.getName()+" (???)");
+			fmx.setSignature(dico.stubMethodSignature(node));
+			//fmx.setDeclaredType( dico.ensureFamixClassObject(null));
+			// Has no binding? It might be a Generic type
+			fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
 		}
-
-		if (fmx != null) {			
+		if (fmx != null) {
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding());
+//				System.err.println(param.getName().getIdentifier());
+//				System.err.println(param.resolveBinding()==null);
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
+				} else {
+					// Has no binding? It might be a Generic parameter
+					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, param.getType().toString());
 				}
 			}
 			
@@ -232,7 +240,9 @@
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
 				// should try to find type name from 'node.getType()' ?
-				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				// Has no binding? It might be a Generic type
+				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
 			}
 			
 			dico.addSourceAnchor(fmx, node);
@@ -281,8 +291,9 @@
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
 				// should try to find type name from 'node.getType()' ?
-				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-
+				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+				// Has no binding? It might be a Generic type
+				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
 		}
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 17)
+++ verveine.extractor.java/.classpath	(revision 18)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/verveine.core/src/fr/inria/verveine/core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
@@ -14,6 +14,6 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar" sourcepath="/verveine.core"/>
-	<classpathentry kind="lib" path="lib/famix.jar"/>
+	<classpathentry kind="lib" path="lib/famix.jar" sourcepath="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 17)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 18)
@@ -1,11 +1,14 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.core.dom.ASTVisitor;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
 import org.eclipse.jdt.core.dom.ArrayAccess;
 import org.eclipse.jdt.core.dom.ArrayCreation;
 import org.eclipse.jdt.core.dom.Assignment;
 import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.ConditionalExpression;
@@ -24,10 +27,14 @@
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.QualifiedName;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleType;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
 import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.TypeLiteral;
 
@@ -126,8 +133,19 @@
 		super.endVisit(node);
 	}
 
+	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		this.context.pushMethod((Method)dico.ensureFamixMethod(node.resolveBinding()));
+		Method meth = dico.ensureFamixMethod(node.resolveBinding());
+		this.context.pushMethod(meth);
+		for (Name excepName : (List<Name>)node.thrownExceptions()) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding());
+			if (excepFmx == null) {
+				excepFmx = this.dico.ensureFamixClass(excepName.getFullyQualifiedName());
+			}
+			if (excepFmx != null) {
+				dico.ensureFamixDeclaredException(meth, excepFmx);
+			}
+		}
 		return super.visit(node);	
 	}
 
@@ -165,6 +183,39 @@
 		return super.visit(node);
 	}
 
+	@Override
+	public boolean visit(CatchClause node) {
+		Method meth = this.context.topMethod();
+		Type excepClass = node.getException().getType();
+		if (meth != null) {
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding());
+			if (excepFmx == null) {
+				if (excepClass instanceof SimpleType) {
+					excepFmx = this.dico.ensureFamixClass(((SimpleType) excepClass).getName().getFullyQualifiedName());
+				}
+				else if (excepClass instanceof QualifiedType) {
+					excepFmx = this.dico.ensureFamixClass(((QualifiedType) excepClass).getName().getIdentifier());
+				}
+			}
+			if (excepFmx != null) {
+				dico.ensureFamixCaughtException(meth, excepFmx);
+			}
+		}
+
+		return super.visit(node);
+	}
+
+	@Override
+	public boolean visit(ThrowStatement node) {
+		Method meth = this.context.topMethod();
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding());
+		if (excepFmx != null) {
+			dico.ensureFamixThrownException(meth, excepFmx);
+		}
+		return super.visit(node);
+	}
+
+
 	/**
 	 * Finds and/or create the Famix Entity receiving a message
 	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 17)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 18)
@@ -115,7 +115,6 @@
 	}
 
 	public Type ensureFamixType(ITypeBinding bnd) {
-
 		if (bnd == null) {
 			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
 			return null;
@@ -169,7 +168,8 @@
 		}
 		
 		if (bnd.isPrimitive()) {
-			System.err.println("Warning: cannot create Famix Class from aprimitive type");
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
+			System.err.println("Warning: cannot create Famix Class from a primitive type");
 			return null;
 		}
 		
@@ -255,9 +255,12 @@
 					break;
 				}
 				else if ( candidate.getIsStub() ) {
-					ContainerEntity ownerBnd = owner;
-					ContainerEntity ownerStub = candidate.getBelongsTo();
-					while ( (! (ownerBnd instanceof Namespace)) &&
+					// find out whether this candidate is defined in the same namespace as the binding received in parameter
+					ContainerEntity ownerBnd = owner;  // the owner of the bounded entity received as parameter
+					ContainerEntity ownerStub = candidate.getBelongsTo();  // the owner of the current candidate
+					while ( (ownerBnd != null) &&
+							(ownerStub != null) &&
+							(! (ownerBnd instanceof Namespace)) &&
 							(ownerBnd.getClass() == ownerStub.getClass()) &&
 							ownerBnd.getName().equals(ownerStub.getName()) ) {
 								ownerBnd = ownerBnd.getBelongsTo();
