Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 82)
+++ verveine.extractor.java/.classpath	(revision 83)
@@ -2,7 +2,11 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core">
+		<attributes>
+			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
Index: verveine.extractor.java/test_src/Dictionary/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 82)
+++ verveine.extractor.java/test_src/Dictionary/Dictionary.java	(revision 83)
@@ -1,143 +0,0 @@
-package fr.inria.verveine.core;
-
-import java.util.Collection;
-import java.util.Hashtable;
-import java.util.LinkedList;
-import java.util.Map;
-
-import ch.akuhn.fame.Repository;
-
-import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Association;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.CaughtException;
-import fr.inria.verveine.core.gen.famix.Comment;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.DeclaredException;
-import fr.inria.verveine.core.gen.famix.Entity;
-import fr.inria.verveine.core.gen.famix.ImplicitVariable;
-import fr.inria.verveine.core.gen.famix.Inheritance;
-import fr.inria.verveine.core.gen.famix.Invocation;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.PrimitiveType;
-import fr.inria.verveine.core.gen.famix.Reference;
-import fr.inria.verveine.core.gen.famix.SourcedEntity;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
-import fr.inria.verveine.core.gen.famix.ThrownException;
-
-public class Dictionary<B> {
-
-	protected Map<B,NamedEntity> mapBind;
-
-	protected Map<String,Collection<NamedEntity>> mapName;
-
-	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
-
-	protected class ImplicitVars {
-		public ImplicitVariable self_iv;
-		public ImplicitVariable super_iv;
-	}
-
-	/* method added to test a specific bug with constructor declaration having a null binding */
-	public Dictionary(T arg) {
-		System.out.println(arg + " is not used");
-	}
-	
-	public Dictionary(Repository famixRepo) {
-		this.famixRepo = famixRepo;
-		
-		this.mapBind = new Hashtable<B,NamedEntity>();
-		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
-		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
-		
-		if (! this.famixRepo.isEmpty()) {
-			recoverExistingRepository();
-		}
-	}
-	
-	@SuppressWarnings("unchecked")
-	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
-		Collection<T> ret = new LinkedList<T>();
-		Collection<NamedEntity> l_name = mapName.get(name);
-		
-		if (l_name != null ) {
-			for (NamedEntity obj : l_name) {
-				if (fmxClass.isInstance(obj)) {
-					ret.add((T) obj);
-				}
-			}
-		}
-
-		return ret;
-	}
-
-	public NamedEntity getEntityByBinding(B bnd) {
-		if (bnd == null) {
-			return null;
-		}
-		else {
-			return mapBind.get(bnd);
-		}
-	}
-
-	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
-		T fmx = null;
-
-		try {
-			fmx = fmxClass.newInstance();
-		} catch (Exception e) {
-			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
-			e.printStackTrace();
-		}
-		
-		if (fmx != null) {
-			fmx.setName(name);
-			fmx.setIsStub(Boolean.TRUE);
-
-			mapEntityToName(name, fmx);
-			
-			// put new entity in Famix repository
-			this.famixRepo.add(fmx);
-		}
-
-		return fmx;
-	}
-	
-	@SuppressWarnings("unchecked")
-	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
-		T fmx = null;
-		
-		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
-			return null;
-		}
-		
-		if (bnd != null) {
-			fmx = (T) getEntityByBinding(bnd);
-		}
-		else {
-			// Unfortunately different entities with the same name and same type may exist
-			// e.g. 2 parameters of 2 different methods but having the same name
-			// so we must recreate a new entity each time
-
-			//fmxEnt = getEntityByName(fmxClass, name);
-		}
-
-		if (fmx != null) {
-			return fmx;
-		}
-
-		fmx = createFamixEntity(fmxClass, name);
-		// put new entity in mappers
-		if (bnd != null) {
-			mapBind.put(bnd, fmx);
-		}
-		
-		return fmx;
-	}
-	
-}
Index: verveine.extractor.java/test_src/ad_hoc/Dictionary.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Dictionary.java	(revision 83)
@@ -0,0 +1,143 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Association;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+
+public class Dictionary<B> {
+
+	protected Map<B,NamedEntity> mapBind;
+
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	protected class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+
+	/* method added to test a specific bug with constructor declaration having a null binding */
+	public Dictionary(T arg) {
+		System.out.println(arg + " is not used");
+	}
+	
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+		
+		if (! this.famixRepo.isEmpty()) {
+			recoverExistingRepository();
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	public NamedEntity getEntityByBinding(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapBind.get(bnd);
+		}
+	}
+
+	protected <T extends NamedEntity> T createFamixEntity(Class<T> fmxClass, String name) {
+		T fmx = null;
+
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			mapEntityToName(name, fmx);
+			
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		else {
+			// Unfortunately different entities with the same name and same type may exist
+			// e.g. 2 parameters of 2 different methods but having the same name
+			// so we must recreate a new entity each time
+
+			//fmxEnt = getEntityByName(fmxClass, name);
+		}
+
+		if (fmx != null) {
+			return fmx;
+		}
+
+		fmx = createFamixEntity(fmxClass, name);
+		// put new entity in mappers
+		if (bnd != null) {
+			mapBind.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+	
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 82)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 83)
@@ -54,7 +54,7 @@
 	@Before
 	public void setUp() throws Exception {
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/Dictionary"});
+		parser.compile(new String[] {"test_src/ad_hoc/Dictionary.java"});
 		repo = parser.getFamixRepo();
 	}
 
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 82)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 83)
@@ -36,7 +36,6 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -72,10 +71,14 @@
 				"server/PrintServer.java"
 		};
 
-		// separate parsing of each source file
-		for (String f : files) {
+		// separate parsing of each source file --------
+		/*for (String f : files) {
 			parseFile(f);
-		}
+		}*/
+		// or parsing the entire project in one pass ---
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(	new String[] {"test_src/LANModel/moose/lan/"});
+		repo = parser.getFamixRepo();
 	}
 
 	/**
@@ -86,7 +89,7 @@
 	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
-				"test_src/LANModel/",
+				"test_src/LANModel//moose/lan/",
 				"test_src/LANModel/moose/lan/"+file
 				};
 		
@@ -105,21 +108,18 @@
 	
 	@Test
 	public void testEntitiesNumber() {
-		for (Type t : TestVerveineUtils.selectElementsOfType(repo, Type.class) ) {
-			System.out.println("TEST TYPES "+t.getName()+"   --> "+t.getClass().getCanonicalName());
-		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
-		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(6+24, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
-		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-		assertEquals(1, TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
-		assertEquals(2, TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
+		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1,  TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+4,   TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26,    TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54,    TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(6+24,  TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//6 internal + 24 from imported packages/classes
+		assertEquals(25,    TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0,     TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+		assertEquals(1,     TestVerveineUtils.selectElementsOfType(repo,AnnotationType.class).size()); //Override
+		assertEquals(2,     TestVerveineUtils.selectElementsOfType(repo,AnnotationInstance.class).size()); //PrintServer.output, SingleDestinationAddress.isDestinationFor
 	}
 
 	@Test
@@ -161,7 +161,7 @@
 	public void testNamedEntities() {
 		JavaDictionary dico = new JavaDictionary(repo);
 		
-		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
+		assertNotSame(dico.ensureFamixClass(null, A_CLASS_NAME, null),dico.ensureFamixClass(null, A_CLASS_NAME, null));
 		
 		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
 		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 83)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTVisitor;
@@ -28,7 +30,9 @@
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleName;
 import org.eclipse.jdt.core.dom.SimpleType;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
@@ -74,7 +78,7 @@
 			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
 		}
 		else {
-			this.context.pushPckg( (Namespace)dico.getEntityByBinding(pckg.resolveBinding()) );
+			this.context.pushPckg( (Namespace)dico.getEntityByKey(pckg.resolveBinding()) );
 		}
 		return super.visit(node);
 
@@ -94,23 +98,29 @@
 		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
 
 		IBinding importBnd = node.resolveBinding();
+		String importName = node.getName().getFullyQualifiedName();
 		if (importBnd instanceof IMethodBinding)  {
 			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
 		}
 		else if (importBnd instanceof IVariableBinding)  {
 			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
+			importName = dico.removeLastName(importName);
+			importName = dico.removeLastName(importName);
 		}
 		else if (importBnd instanceof ITypeBinding)  {
 			importBnd = ((ITypeBinding)importBnd).getPackage();
+			importName = dico.removeLastName(importName);
 		}
-
-		context.setLastReference( dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd), context.getLastReference()) );
+		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
+		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(node.resolveBinding()));
+		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(node.resolveBinding()));
 
 		return super.visit(node);
 	}
@@ -123,7 +133,7 @@
 	public boolean visit(ClassInstanceCreation node) {
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(decl.resolveBinding()));
+			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(decl.resolveBinding()));
 		}
 		return super.visit(node);
 	}
@@ -135,16 +145,31 @@
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
-		Method meth = dico.ensureFamixMethod(node.resolveBinding());
-		if (meth == null) {
-			meth = dico.ensureFamixMethod(node, context.topClass());
+		IMethodBinding bnd = node.resolveBinding();
+		Type retTyp = node.getReturnType2();
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+		Method meth = null;
+		if (retTyp != null) {
+			meth = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+					context.topClass());
+		}
+		else {
+			meth = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					null,   // probably a constructor
+					context.topClass());
 		}
+
 		this.context.pushMethod(meth);
 		for (Name excepName : (List<Name>)node.thrownExceptions()) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding());
-			if (excepFmx == null) {
-				excepFmx = this.dico.ensureFamixClass(excepName.getFullyQualifiedName());
-			}
+			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
 			if (excepFmx != null) {
 				dico.ensureFamixDeclaredException(meth, excepFmx);
 			}
@@ -158,16 +183,41 @@
 	}
 
 	public boolean visit(MethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()), node.arguments().size());
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
 		return super.visit(node);
 	}
 
-	@SuppressWarnings("static-access")
+	@SuppressWarnings({ "static-access" })
 	public boolean visit(SuperMethodInvocation node) {
-		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME), node.arguments().size());
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
 		return super.visit(node);
 	}
 
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param calledBnd -- a binding for the method
+	 * @param calledName of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
+	private void methodInvocation(IMethodBinding calledBnd, String calledName, NamedEntity receiver) {
+		BehaviouralEntity sender = this.context.topMethod();
+		if (sender != null) {
+			Method invoked = this.dico.ensureFamixMethod(calledBnd, calledName, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			/* TODO old code, may not be valid anymore ...
+			   if (invoked == null) {
+				if (receiver != null && receiver.getName().equals("self")) {
+					receiver = this.context.topClass();
+				}
+				invoked = this.dico.ensureFamixMethod(calledName, receiver, list);
+				//invoked = this.dico.ensureFamixStubMethod(name);
+			}
+			if (invoked == null) {
+				invoked = this.dico.ensureFamixStubMethod(calledName);
+			}*/
+			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+		}
+	}
+
 	public boolean visit(FieldAccess node) {
 		fieldAccess(node.resolveFieldBinding());
 		
@@ -190,14 +240,12 @@
 		Method meth = this.context.topMethod();
 		Type excepClass = node.getException().getType();
 		if (meth != null) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding());
-			if (excepFmx == null) {
-				if (excepClass instanceof SimpleType) {
-					excepFmx = this.dico.ensureFamixClass(((SimpleType) excepClass).getName().getFullyQualifiedName());
-				}
-				else if (excepClass instanceof QualifiedType) {
-					excepFmx = this.dico.ensureFamixClass(((QualifiedType) excepClass).getName().getIdentifier());
-				}
+			fr.inria.verveine.core.gen.famix.Class excepFmx = null;
+			if (excepClass instanceof SimpleType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((SimpleType) excepClass).getName().getFullyQualifiedName(), null);
+			}
+			else if (excepClass instanceof QualifiedType) {
+				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
 				dico.ensureFamixCaughtException(meth, excepFmx);
@@ -210,7 +258,7 @@
 	@Override
 	public boolean visit(ThrowStatement node) {
 		Method meth = this.context.topMethod();
-		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding());
+		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
 			dico.ensureFamixThrownException(meth, excepFmx);
 		}
@@ -273,12 +321,7 @@
 		else if (expr instanceof FieldAccess) {
 			Attribute ret = null;
 			IVariableBinding bnd = ((FieldAccess) expr).resolveFieldBinding();
-			if (bnd == null) {
-				ret = dico.ensureFamixAttribute(((FieldAccess)expr).getName().getIdentifier());
-			}
-			else {
-				ret = this.dico.ensureFamixAttribute(bnd);
-			}
+			ret = dico.ensureFamixAttribute(bnd, ((FieldAccess) expr).getName().getIdentifier(), null, null);
 
 			return ret;
 		}
@@ -298,24 +341,27 @@
 
 		// name.msg()
 		else if (expr instanceof Name) {
-			NamedEntity ret = null;
 			// can be a class or a variable name
 			IBinding bnd = ((Name) expr).resolveBinding();
-			if (bnd != null) {
-				if (bnd instanceof ITypeBinding) {
-					// msg() is a static method of Name
-					ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, this.context.top()), bnd.getName());
+			if (bnd == null) {
+				return null;
+			}
+			NamedEntity ret = null;
+			if (bnd instanceof ITypeBinding) {
+				// msg() is a static method of Name
+				//TODO why returning a variable here? Should not it be the class itself?
+				ret = dico.createFamixUnknownVariable( dico.ensureFamixType((ITypeBinding)bnd, null, null), bnd.getName());
+			}
+			else if (bnd instanceof IVariableBinding) {
+				String varName = ( ((Name)expr).isSimpleName() ? ((SimpleName)expr).getFullyQualifiedName() : ((QualifiedName)expr).getName().getIdentifier());
+				if ( ((IVariableBinding)bnd).isField() ) {
+					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
 				}
-				else if (bnd instanceof IVariableBinding) {
-					if ( ((IVariableBinding)bnd).isField() ) {
-						ret = dico.ensureFamixAttribute( (IVariableBinding)bnd);
-					}
-					else if ( ((IVariableBinding)bnd).isParameter() ) {
-						ret = dico.ensureFamixParameter( (IVariableBinding)bnd);
-					}
-					else { // suppose it's a local variable
-						ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, context.topMethod());
-					}
+				else if ( ((IVariableBinding)bnd).isParameter() ) {
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, context.topMethod());
+				}
+				else { // suppose it's a local variable
+					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
 				}
 			}
 			
@@ -337,12 +383,7 @@
 		else if (expr instanceof SuperFieldAccess) {
 			Attribute ret = null;
 			IVariableBinding bnd = ((SuperFieldAccess) expr).resolveFieldBinding();
-			if (bnd == null) {
-				ret = dico.ensureFamixAttribute(((SuperFieldAccess)expr).getName().getIdentifier());
-			}
-			else {
-				ret = this.dico.ensureFamixAttribute(bnd);
-			}
+			ret = dico.ensureFamixAttribute(bnd, ((SuperFieldAccess) expr).getName().getIdentifier(), null, null);
 
 			return ret;
 		}
@@ -362,7 +403,7 @@
 		// type.class.msg()
 		else if (expr instanceof TypeLiteral) {
 			// may be could specify: ensureFamixClass ??
-			return dico.ensureFamixType( expr.resolveTypeBinding(), this.context.top());
+			return dico.ensureFamixType( expr.resolveTypeBinding(), null, null);
 		}
 
 		// ... OTHER POSSIBLE EXPRESSIONS ?
@@ -380,7 +421,7 @@
 	private void fieldAccess(IVariableBinding bnd) {
 		BehaviouralEntity accessor = this.context.topMethod();
 		if (accessor != null) {
-			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
+			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
 				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
@@ -390,29 +431,4 @@
 		}
 	}
 
-	/**
-	 * Handles an invocation of a method by creating the corresponding Famix Entity
-	 * @param bnd -- a binding for the method
-	 * @param name of the method invoked
-	 * @param receiver of the call, i.e. the object to which the message is sent
-	 */
-	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver, int numberOfArguments) {
-		BehaviouralEntity sender = this.context.topMethod();
-		if (sender != null) {
-			Method invoked = this.dico.ensureFamixMethod(bnd);
-			if (invoked == null) {
-				if (receiver != null && receiver.getName().equals("self")) {
-					receiver = this.context.topClass();
-				}
-				invoked = this.dico.ensureFamixMethod(name, receiver, numberOfArguments);
-				//invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			if (invoked == null) {
-				invoked = this.dico.ensureFamixStubMethod(name);
-			}
-			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
-		}
-	}
-
-
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 83)
@@ -1,5 +1,7 @@
 package fr.inria.verveine.extractor.java;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
@@ -24,7 +26,6 @@
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -36,7 +37,6 @@
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeParameter;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
@@ -50,7 +50,6 @@
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 
 /**
  * AST Visitor that defines all the (Famix) entities of interest
@@ -83,15 +82,8 @@
 			fmx = dico.ensureFamixNamespaceDefault();
 		}
 		else {
-			fmx = dico.ensureFamixNamespace(pckg.resolveBinding());
-			if (fmx != null) {
-				fmx.setIsStub(false);
-			}
-			else {
-				System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName() + ", fallbacks to creating a stub");
-				// try again without binding
-				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
-			}
+			fmx = dico.ensureFamixNamespace(pckg.resolveBinding(), pckg.getName().getFullyQualifiedName());
+			fmx.setIsStub(false);
 		}
 		this.context.pushPckg(fmx);
 		return super.visit(node);
@@ -104,43 +96,14 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-//		System.out.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
-		fr.inria.verveine.core.gen.famix.Class fmx = null;
-
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
-
-		// Dealing with Parameterized classes
-		List<TypeParameter> nodeParameters = node.typeParameters();
-
-//System.out.println("                                        size="+nodeParameters.size());
-		if (nodeParameters.size() > 0) {
-			fmx = dico.ensureFamixParameterizableClass(bnd);
-		}
-		else {
-			fmx = dico.ensureFamixClass(bnd);
-		}
-		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
-		else {
-			System.err.println("         Class="+node.getName().getIdentifier() + ",  fallback to creating a stub");
-			if (nodeParameters.size() > 0) {
-				fmx = dico.ensureFamixParameterizableClass(node.getName().getIdentifier());
-			}
-			else {
-				fmx = dico.ensureFamixClass(node.getName().getIdentifier());
-			}
-			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
-			fmx.setContainer( context.top());
-		}
 
-		// Dealing with Parameterized classes: adding the parameters
-		if (nodeParameters.size() > 0) {
-			for (TypeParameter param : nodeParameters) {
-				dico.ensureFamixParameterType(param.getName().getIdentifier(), (ParameterizableClass)fmx);
-			}
-		}
+		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
 		
 		dico.addSourceAnchor(fmx, node);
 		Javadoc jdoc = node.getJavadoc();
@@ -148,7 +111,6 @@
 			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
 			dico.addSourceAnchor(cmt, jdoc);
 		}
-		
 		//Annotation
 		if (bnd != null) {
 			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
@@ -156,7 +118,6 @@
 				dico.createFamixAnnotationInstance(fmx, annType);
 			}
 		}
-		
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -170,16 +131,11 @@
 //		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding());
+			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
-			else {
-				System.err.println("         Class="+"anonymous(??),  fallback to creating a stub");
-				fmx = dico.ensureFamixClass("anonymous(??)");
-				dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
-				fmx.setContainer( context.top());
-			}
+
 			dico.addSourceAnchor(fmx, node);
 			this.context.pushClass(fmx);
 		}
@@ -194,24 +150,34 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
-		Method fmx = dico.ensureFamixMethod(bnd);
-		if (fmx != null) {
-			fmx.setIsStub(false);
+		Type retTyp = node.getReturnType2();
+		Collection<Type> paramTypes = new ArrayList<Type>();
+		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
+				paramTypes.add(param.getType());
+		}
+		Method fmx = null;
+		if (retTyp != null) {
+			fmx = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+					context.topClass());
 		}
 		else {
-			System.err.println("         Method="+node.getName().getIdentifier());
-			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
-			fmx.setParentType(context.topClass());
-			fmx.setSignature(dico.stubMethodSignature(node));
-			if (! node.isConstructor()) {
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
-			}
+			fmx = dico.ensureFamixMethod(bnd,
+					node.getName().getIdentifier(),
+					paramTypes,
+					null,   // probably a constructor
+					context.topClass());
 		}
 		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
-			fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
 		}
+		
 		if (fmx != null) {
+			fmx.setIsStub(false);
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
@@ -220,7 +186,7 @@
 				} else {
 					// Has no binding? It might be a Generic parameter
 					System.err.println("         Parameter="+param.getName().getIdentifier());
-					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), param.getType().toString(), this.context.topClass()));
+					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null));
 				}
 				if (param.getType().isParameterizedType()) {
 					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
@@ -262,26 +228,16 @@
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-//			System.err.println("            Field: "+vd.getName().getIdentifier());
 			IVariableBinding bnd = vd.resolveBinding();
-			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
-			
-			//((ParameterizedType)node.getType()).typeArguments();
+			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
+
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
-			else {
-				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
-				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
-				fmx.setParentType(context.topClass());
-				// should try to find type name from 'node.getType()' ?
-				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-				// Has no binding? It might be a Generic type
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
-			}
 			if (node.getType().isParameterizedType()) {
 				//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
 			}
+
 			dico.addSourceAnchor(fmx, node);
 			Javadoc jdoc = node.getJavadoc();
 			if (jdoc != null) {
@@ -302,35 +258,28 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationExpression node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
-		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
 	@SuppressWarnings("unchecked")
 	public boolean visit(VariableDeclarationStatement node) {
 		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
-		visitVariableDeclaration(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		visitVariablesDeclarations(node, node.getType(), (List<VariableDeclarationFragment>)node.fragments());
 		return super.visit(node);
 	}
 
-	private void visitVariableDeclaration(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+	private void visitVariablesDeclarations(ASTNode node, Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+		// we don't declare (local) variables that have a primitive type
+		// because we are assuming here that the user is not interested in them 
 		if (nodeTyp.isPrimitiveType()) {
 			return;
 		}
 
 		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), context.topMethod());
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), vd.getName().getIdentifier(), dico.ensureFamixType(null, nodeTyp.toString(), null), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
-			}
-			else {
-				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
-				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
-				fmx.setParentBehaviouralEntity(context.topMethod());
-				// should try to find type name from 'node.getType()' ?
-				//fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
-				// Has no binding? It might be a Generic type
-				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
 			if (nodeTyp.isParameterizedType()) {
@@ -339,7 +288,6 @@
 		}
 	}
 
-
 	// METRICS: CYCLO, NOS
 	
 	public boolean visit(AssertStatement node) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 83)
@@ -6,15 +6,16 @@
 import java.util.List;
 
 import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ArrayType;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
 import org.eclipse.jdt.core.dom.IVariableBinding;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.Modifier;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SimpleType;
 import org.eclipse.jdt.core.dom.TypeParameter;
 
 import ch.akuhn.fame.Repository;
@@ -30,11 +31,10 @@
 import fr.inria.verveine.core.gen.famix.NamedEntity;
 import fr.inria.verveine.core.gen.famix.Namespace;
 import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterType;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.core.gen.famix.UnknownVariable;
 
@@ -61,56 +61,29 @@
 	}
 
 	/**
-	 * Returns a Famix Namespace associated with the IPackageBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public Namespace ensureFamixNamespace(IPackageBinding bnd) {
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Namespace");
-			return null;
-		}
-
-		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, null);
-
-		return fmx;
-	}
-
-	@Override
-	public Namespace ensureFamixNamespace(String name) {
-		Namespace fmx = ensureFamixNamespaceWithParentScope(null, name);
-
-		return fmx;
-	}
-
-	/**
-	 * Creates or recovers a namespace. Also creates or recovers recusively it's parent namespaces.
-	 * At least one of <b>bnd</b> and <b>name</b> must be passed.
-	 * <p>Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
-	 * (for example when creating parent packages of a package we have a binding for).
-	 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
-	 * all is said and done.</p>
-	 * @param bnd - the (optional) binding for the namespace
-	 * @param name - the (optional) full name for the namespace
-	 * @return the namespace created or null
+	 * Returns a Famix Namespace associated with its IPackageBinding and/or name.
+	 * The Entity is created if it does not exist (see also {@link Dictionary#ensureFamixNamespace(Object, String)}).
+	 * Also creates or recovers recusively it's parent namespaces.<br>
+	 * At least one of <b>bnd</b> and <b>name</b> must be non null.
+	 * @param bnd -- the JDT Binding that may be used as a uniq key to recover this namespace
+	 * @param name -- fully qualified name of the namespace (e.g. 'java.lang')
+	 * @return the Famix Namespace found or created. May return null in case of a Famix error
 	 */
-	private Namespace ensureFamixNamespaceWithParentScope(IPackageBinding bnd, String name) {
+	public Namespace ensureFamixNamespace(IPackageBinding bnd, String name) {
 		Namespace fmx = null;
 		Namespace parent = null;
-		
-		if (bnd != null) {
+
+		if ( (name == null) && (bnd != null) ) {
 			name = bnd.getName();
 		}
 		
-		if ( (name!=null) && (name.length() > 0) ) {
-			fmx = ensureFamixUniqEntity(Namespace.class, bnd, name);
-			// compute parent's name and creates parent
-			int last = name.lastIndexOf('.');
-			if (last > 0) {
-				parent = ensureFamixNamespaceWithParentScope(null, name.substring(0, last));
-			}
+		if (name.length() > 0) {
+			/* Note: Packages are created with their fully-qualified name to simplify recovering them when we don't have a binding
+			 * (for example when creating parent packages of a package we have a binding for).
+			 * Because the preferred solution in Moose is to give their simple names to packages, they must be post-processed when
+			 * all is said and done. */
+			fmx = super.ensureFamixNamespace( bnd, name);
+			parent = this.ensureFamixNamespace(null, removeLastName(name));
 			// set the parentscope relationship
 			if ( (parent != null) && (fmx != null) && (fmx.getParentScope() == null)) {
 				parent.addChildScopes(fmx);
@@ -120,108 +93,51 @@
 		return fmx;
 	}
 
-	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
-	 * Checks for: primitive type, interface, class, parameterizable class
-	 * @param bnd -- JDT binding for the type
-	 * @return the type recovered or created, or null in case of an error
-	 */
-	public Type ensureFamixType(ITypeBinding bnd, ContainerEntity ctxt) {
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Type");
-			return null;
+	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+		Collection<Type> fmxTypes = new ArrayList<Type>();
+		
+		Type fmxType = null;
+		for (org.eclipse.jdt.core.dom.Type type : types) {
+			ITypeBinding bnd = type.resolveBinding();
+			if (bnd != null) {
+				fmxType = ensureFamixType(bnd, findTypeName(type), null);
+			} else {
+				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
+			}
+			fmxTypes.add(fmxType);
 		}
-		return ensureFamixType(bnd, bnd.getName(), ctxt);
+		return fmxTypes;
 	}
 
-	/** Creates or recovers a FAMIX Type. Tries to guess the exact subclass of Type of the entity.
-	 * Checks for: primitive type, interface, class, parameterizable class
-	 * Types are more difficult entities, they can be recovered from their binding or from their name in their context
-	 * @param bnd -- JDT binding for the type
-	 * @param name -- name of the type
-	 * @return the type recovered or created, or null in case of an error
+	/**
+	 * Recovers or creates a Famix Type (see also {@link Dictionary#ensureFamixType(Object, String, ContainerEntity)}
 	 */
-	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity ctxt) {
-		Type fmx = null;
-	
-		if (bnd != null) {
-			bnd = findNonArrayType(bnd);
-			
-			fmx = (Type) getEntityByBinding(bnd);
-			
-			if (fmx != null) {
-				return fmx;
-			}
+	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
 
-			fmx = findTypeInContext(name, ctxt);
-			if (fmx != null) {
-				mapBind.put(bnd, fmx);
-				return fmx;
-			}
-		}
-		
-		if ( (fmx == null) && (bnd != null) ) {		
-			// not found, will have to create it
-			// from the binding
-			if (bnd.isPrimitive()) {
-				fmx = ensureFamixPrimitiveType(bnd);
-			}
-			else if (bnd.isClass())  {
-				fmx = ensureFamixClass(bnd);
-			}
-			else if (bnd.isGenericType())  {
-				fmx = ensureFamixParameterizableClass(bnd);
-			}
-			else if (bnd.isParameterizedType())  {
-				fmx = super.ensureFamixType(bnd.getName());
-				mapBind.put(bnd, fmx);
-			}
-			else {
-				fmx = super.ensureFamixType(bnd.getName());
-				mapBind.put(bnd, fmx);
-			}
+		if (bnd == null) {
+			return super.ensureFamixType(bnd, name, owner);
 		}
 
-		if (fmx == null) {
-			// not found and not created by binding (probably null), will have to create it
-			// from its name
-			fmx = this.ensureFamixType(name);
-		}
-		return fmx;
-	}
-	
-	/** Searches for a type with the given name in the context (a Famix Method or Famix Type)
-	 * If the context is a method, zsearches in its owner. Otherwise returns null.
-	 * See {@link getEntityByName} to search an entity by its name outside any special context
-	 * @param name of the type to look for
-	 * @param ctxt -- context of the search
-	 * @return the Famix Type found or null
-	 */
-	private Type findTypeInContext(String name, ContainerEntity ctxt) {
-		if (ctxt == null) {
-//System.out.println("lookfor type"+ name+"  in NULL context  :-(");
-			return null;
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
 		}
-//System.out.println("lookfor type"+ name+"  in context:" +ctxt.getName());
-		for (Type typ : ctxt.getTypes()) {
-			if (typ.getName().equals(name)) {
-				return typ;
-			}
+		
+		if (bnd.isPrimitive()) {
+			return ensureFamixPrimitiveType(bnd, name);
 		}
-		if (ctxt instanceof Method) {
-			return findTypeInContext(name, ctxt.getBelongsTo());
+		else {
+			return this.ensureFamixClass(bnd, null, null);
 		}
-		
-		return null;
 	}
-
-	//TODO remove this method
-	public Collection<Type> ensureFamixTypes(List<org.eclipse.jdt.core.dom.Type> types) {
+	
+	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
 		Collection<Type> fmxTypes = new ArrayList<Type>();
 		Type fmxType = null;
-		for (org.eclipse.jdt.core.dom.Type type : types) {
+		
+		for (TypeParameter type : types) {
 			ITypeBinding bnd = type.resolveBinding();
 			if (bnd != null) {
-				fmxType = ensureFamixType(bnd, null);
+				fmxType = ensureFamixType(bnd, null, null);
 			} else {
 				fmxType = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, type.toString());
 			}
@@ -230,144 +146,149 @@
 		return fmxTypes;
 	}
 	
-	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd) {
-
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Primitive Type");
-			return null;
+	public PrimitiveType ensureFamixPrimitiveType(ITypeBinding bnd, String name) {
+		if (name == null) {
+			if (bnd == null) {
+				return null;
+			}
+			else {
+				name = bnd.getName();
+			}
 		}
-		
-		PrimitiveType fmx = super.ensureFamixPrimitiveType(bnd.getName());
-		mapBind.put(bnd, fmx);
-		return fmx;
+		return super.ensureFamixPrimitiveType(bnd, name);
 	}
 	
 	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
 
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
 			return null;
 		}
 		
 		AnnotationType fmx = ensureFamixUniqEntity(AnnotationType.class, null, bnd.getName());
 		fmx.setIsStub(true);
-		fmx.setContainer(ensureFamixNamespace(bnd.getPackage()));
-		mapBind.put(bnd, fmx);
+		fmx.setContainer(ensureFamixNamespace(bnd.getPackage(), null));
+		mapToKey.put(bnd, fmx);
 		return fmx;
 	}
 
 	/**
-	 * Returns a Famix ParameterType (in a ParameterizableClass) with the given name
-	 * We cannot use bindings here since they are usually null (TODO check the javadoc)
-	 * @param paramName -- the name of the ParameterType
-	 * @param owner -- the ParameterizableClass that defines this ParameterType
-	 * @return the Famix Entity created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public ParameterType ensureFamixParameterType(String paramName, ParameterizableClass owner) {
-		//System.err.println("TRACE: ensureFamixParameterType( "+paramName+" , "+owner.getName()+" )");
-		ParameterType fmx = null;
-System.out.println("creating CLASS: "+paramName+"   type: ParameterType");
-		fmx = ensureFamixParameterType(paramName);
-
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
-		fmx.setContainer( owner);
-
-		return fmx;
-	}
-	
-	/**
-	 * Returns a Famix Parameterizable Class associated with the ITypeBinding similarly to ensureFamixClass for normal classes
-	 * @param bnd -- the JDT Binding 
+	 * Returns a Famix Class associated with the ITypeBinding.
+	 * The Entity is created if it does not exist.
+	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public ParameterizableClass ensureFamixParameterizableClass(ITypeBinding bnd) {
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixNamespaceDefault();
+			}
+			return super.ensureFamixClass(null, name, owner);
 		}
 
-		bnd = findNonArrayType(bnd);
-
-		return ensureFamixClassOrSub(ParameterizableClass.class, bnd, findClassOwner(bnd));
-	}
-
-	/**
-	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd) {
+		// --------------- some special cases
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
+		}
 
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
+		if (bnd.isPrimitive()) {
+			// should have called ensureFamixPrimitiveType(bnd). Why are we here ?
 			return null;
 		}
 
-		if (bnd.getName().equals(OBJECT_NAME)) {
-			return ensureFamixClassObject(bnd);
+		fmx = (fr.inria.verveine.core.gen.famix.Class)getEntityByKey(bnd);	// to avoid useless computations if we can
+		if (fmx != null) {
+			return fmx;
 		}
 
-		bnd = findNonArrayType(bnd);
-
-		return ensureFamixClassOrSub(fr.inria.verveine.core.gen.famix.Class.class, bnd, findClassOwner(bnd));
-	}
+		// --------------- name
+		if (name == null) {
+			if (! bnd.isAnonymous()) {
+				name = bnd.getName();
+			}
+			else { // anonymous class
+				if (bnd.getSuperclass() != null) {
+					name = bnd.getSuperclass().getName();
+				}
+				if ( (name == null) || name.equals(OBJECT_NAME)) {
+					ITypeBinding[] intfcs = bnd.getInterfaces();
+					if ( (intfcs != null) && (intfcs.length > 0) ) {
+						name = bnd.getInterfaces()[0].getName();
+					}
+					else {
+						name = "???";
+					}
+				}
+				name = "anonymous(" + name + ")";
+			}
+		}
 		
-	/**
-	 * Create a FamixClass or one of its subclass
-	 * @param bnd -- the JDT Binding. If null the methods silently returns null
-	 */
-	@SuppressWarnings("unchecked")
-	private <T extends fr.inria.verveine.core.gen.famix.Class>
-			T ensureFamixClassOrSub( Class<T> fmxClass, ITypeBinding bnd, ContainerEntity owner) {
-
-		String identifier = findClassName(bnd);
-//System.out.println("ensure CLASS: "+identifier+"   type: "+fmxClass.getCanonicalName());
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = findClassSupers(bnd);
+		if (name.equals(OBJECT_NAME)) {
+			return ensureFamixClassObject(bnd);
+		}
 
-		// finally trying to recover the entity or creating it
-		T fmx = null;
-		// ... trying to recover from binding
-		fmx = (T) getEntityByBinding(bnd);
+		// --------------- owner
+		if ( (owner == null) && (bnd != null) ) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
 
-		boolean wasBound = false;
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- superclasses (including interfaces)
+		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		if (! bnd.isInterface()) {
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd != null) {
+				sups.add(this.ensureFamixClass(supbnd, null, null));
+			}
+			else {
+				sups.add( ensureFamixClassObject(null));
+			}
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informations
-			for (T candidate : getEntityByName(fmxClass, identifier) ) {
-				if (candidate.getContainer() == owner) {
-					// could test superclass also...
-					fmx = candidate;
-					break;
-				}
+		for (ITypeBinding intbnd : bnd.getInterfaces()) {
+			sups.add( ensureFamixClass(intbnd, null, null));
+		}
+
+		// --------------- recover from name ?
+		for (fr.inria.verveine.core.gen.famix.Class candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
+			if ( recoverAndMapClass(bnd, candidate) ) {
+				fmx = candidate;
+				break;
 			}
 		}
-		
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			// note: name might be different from bnd.getName() in the case of anonymous class
-			fmx = (T) ensureFamixEntity(fmxClass, bnd, identifier);
+			fmx = super.ensureFamixClass(bnd, name, owner);
 		}
 		
-		if ((fmx!=null) && (! wasBound)) {
-			// apparently we just created it or it already existed but was not bound, so add information to it
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setIsInterface(bnd.isInterface());
-			fmx.setContainer(owner);
-			if (sups.size() > 0) {
-				// some types don't have superclass
-				Inheritance lastInheritance = null;
-				for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
-					lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
-				}
+			Inheritance lastInheritance = null;
+			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
-			if (! wasBound) {
-				mapBind.put(bnd, fmx);
-			}
-			// modifiers
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
 			if (fmx.getIsAbstract()) {
 				// don't know why there must be two different ways to mark abstract classes !!! But this is a pain!
@@ -378,189 +299,136 @@
 		return fmx;
 	}
 
-	/** Find the "basic" type of something that may be an array
-	 * @param bnd -- non null binding for the class definition
-	 * @return the "basic" (non array) type binding
-	 */
-	private ITypeBinding findNonArrayType(ITypeBinding bnd) {
-		while (bnd.isArray()) {
-			bnd = bnd.getComponentType();
+	private boolean recoverAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+
+		if (bnd.getName().equals(candidate.getName())) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
-		return bnd;
+		return false;
 	}
 
-	/** 
-	 * Finds and returns the superclass and/or implemented interfaces of a class declaration
-	 * @param bnd -- non null binding for the class definition
-	 * @return the list of super types
-	 */
-	private Collection<fr.inria.verveine.core.gen.famix.Class> findClassSupers(ITypeBinding bnd) {
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
-		if (! bnd.getName().equals(OBJECT_NAME)) {
-			// "Object" doesn't have a superclass
-			
-			// superclass
-			if (! bnd.isInterface()) {
-				ITypeBinding supbnd = bnd.getSuperclass();
-				ITypeBinding[] intsbnd = bnd.getInterfaces();
-				if (supbnd == null && intsbnd.length == 0) {
-					sups.add( ensureFamixClassObject(null));
-				}
-				else {
-					if (supbnd != null) {
-						//TODO ensureFamixType ??
-						sups.add(ensureFamixClass(supbnd));
-					}
-					for (ITypeBinding intbnd : intsbnd) {
-						//TODO ensureFamixType ??
-						sups.add( ensureFamixClass(intbnd));
-					}
-				}
+	private boolean recoverAndMapType(ITypeBinding bnd, Type candidate) {
+		if (bnd.isArray()) {
+			bnd = bnd.getElementType();
+		}
+		
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+		
+		if ( (bnd.isClass() || bnd.isInterface()) &&
+			 (candidate instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			return recoverAndMapClass(bnd, (fr.inria.verveine.core.gen.famix.Class) candidate);
+		}
+		else if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
+			if ( (bnd.isPrimitive()) && (bnd.toString().equals(candidate.getName())) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
 			}
 			else {
-				for (ITypeBinding supbnd : bnd.getInterfaces()) {
-					//TODO ensureFamixType ??
-					sups.add( ensureFamixClass(supbnd));
-				}
+				return false;
 			}
 		}
-		return sups;
-	}
-
-	/** Finds and returns the name of a class declaration, especially for anonymous class
-	 * @param bnd -- non null binding for the class definition
-	 * @return the name
-	 */
-	private String findClassName(ITypeBinding bnd) {
-		String identifier = null;
-		if (! bnd.isAnonymous()) {
-			identifier = bnd.getName();
-		}
 		else {
-			if (bnd.getSuperclass() != null) {
-				identifier = bnd.getSuperclass().getName();
-			}
-			if ( (identifier == null) || identifier.equals(OBJECT_NAME)) {
-				ITypeBinding[] intfcs = bnd.getInterfaces();
-				if ( (intfcs != null) && (intfcs.length > 0) ) {
-					identifier = bnd.getInterfaces()[0].getName();
+			IMethodBinding methBnd = bnd.getDeclaringMethod();
+			if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+				if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+					mapToKey.put(bnd, candidate);
+					return true;
 				}
 				else {
-					identifier = "???";
+					return false;
 				}
 			}
-			identifier = "anonymous(" + identifier + ")";
-		}
-		return identifier;
-	}
 
-	/** Finds and returns the owner of a class declaration
-	 * It can be a method (anonymous class), a class (inner class, or ParameterType), or a package (normal class)
-	 * @param bnd -- non null binding for the class definition
-	 * @return the owner found
-	 */
-	private ContainerEntity findClassOwner(ITypeBinding bnd) {
-		ContainerEntity owner = null;
-		IMethodBinding parentMtd = bnd.getDeclaringMethod();
-		if (parentMtd != null) {
-			owner = this.ensureFamixMethod(parentMtd);
-		}
-		else {
-			ITypeBinding parentClass = bnd.getDeclaringClass();
-			if (parentClass != null) {
-				owner = this.ensureFamixClass(parentClass);
-			}
-			else {
-				IPackageBinding parentPckg = bnd.getPackage();
-				if (parentPckg != null) {
-					owner = this.ensureFamixNamespace(parentPckg);
+			ITypeBinding classBnd = bnd.getDeclaringClass();
+			if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+				if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+					mapToKey.put(bnd, candidate);
+					return true;
 				}
 				else {
-					owner = this.ensureFamixNamespaceDefault();
+					return false;
 				}
 			}
+			
+			IPackageBinding pckgBnd = bnd.getPackage();
+			if ( (candidate.getBelongsTo() instanceof Namespace) &&
+				 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
 		}
-		return owner;
 	}
 
-	/**
-	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
-	 */
-	public Method ensureFamixMethod(IMethodBinding bnd) {
-		Type owner = null;
-		Type rettyp = null;
-		String sig = null;
-		boolean wasBound = false;
-		
-		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Method");
-			return null;
+	private boolean recoverAndMapClass(ITypeBinding bnd, fr.inria.verveine.core.gen.famix.Class candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
 		}
-
-		// owner
-		owner = this.ensureFamixType(bnd.getDeclaringClass(), null);
+		else if (bound != null) {
+			return false;
+		}
 
-		// return type
-		if (! bnd.isConstructor()) {
-			rettyp = this.ensureFamixType(bnd.getReturnType(), /*context*/owner); // the context is the declaring class
+		IMethodBinding methBnd = bnd.getDeclaringMethod();
+		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
 		}
-		// TODO   else what?
 
-		sig = computeSignature(bnd);
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
+			}
+			else {
+				return false;
+			}
+		}
 
-		// finally trying to recover the entity or creating it
-		Method fmx = null;
-		// ... trying to recover from binding
-		fmx = (Method) getEntityByBinding(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		IPackageBinding pckgBnd = bnd.getPackage();
+		if ( (candidate.getBelongsTo() instanceof Namespace) &&
+			 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
 		else {
-			wasBound = false;
-			// trying to recover from name and other informations
-			for (Method candidate : getEntityByName(Method.class, bnd.getName()) ) {
-				if ( (candidate.getParentType() == owner) &&
-					 (candidate.getDeclaredType() == rettyp) &&
-					 (candidate.getSignature().equals(sig)) ) {
-					// we could also test that this candidate is not bound yet (to another bnd)
-					// but it would require significant modifications and might not be that useful?
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
-			}
+			return false;
 		}
-		
-		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = (Method) ensureFamixEntity(Method.class, bnd, bnd.getName());
+	}
+
+	private boolean recoverAndMapMethod(IMethodBinding bnd, Method candidate) {
+		NamedEntity bound = getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
 		}
-		
-		if ((fmx!=null) && (! wasBound) ) {
-			// apparently we just created it or it already existed as a stub, so add information to it
-			fmx.setParentType(owner);
-			fmx.setDeclaredType(rettyp);	
-			fmx.setName(bnd.getName());
-			fmx.setSignature(sig);
-			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		else if (bound != null) {
+			return false;
 		}
 
-		return fmx;
-	}
-
-	/** Computes the signature of a method from its binding
-	 * @param bnd -- bJDT binding of the method
-	 * @return the signature of the method in a String
-	 */
-	private String computeSignature(IMethodBinding bnd) {
-		String sig;
-		// method signature
-		sig = bnd.getName() + "(";
+		// for methods, the name is not enough, we must test the signature also 
+		String sig = bnd.getName() + "(";
 		boolean first = true;
 		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
 			if (! first) {
@@ -570,112 +438,230 @@
 				sig += parBnd.getName();
 				first = false;
 			}
+			sig += ")";
 		}
-		sig += ")";
-		return sig;
+		if (! candidate.getSignature().equals(sig)) {
+			return false;
+		}
+
+		ITypeBinding ownerBnd = bnd.getDeclaringClass();
+		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
+			 (recoverAndMapClass(ownerBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+				mapToKey.put(bnd, candidate);
+				// everything seems OK, but we still need to test return type which is not in the Moose signature
+				return recoverAndMapType(bnd.getReturnType(), candidate.getDeclaredType());
+		}
+		else {
+			return false;
+		}
 	}
-	
-	@SuppressWarnings("unchecked")
-	public String stubMethodSignature(MethodDeclaration node) {
-		String sig = node.getName().getIdentifier() + "(";
-		boolean first = true;
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-			if (! first) {
-				sig += "," + param.getType().toString();
+
+	private boolean recoverAndMapVariable(IVariableBinding bnd, StructuralEntity candidate) {
+		NamedEntity bound = (StructuralEntity)getEntityByKey(bnd); 
+		if (bound == candidate) {
+			return true;
+		}
+		else if (bound != null) {
+			return false;
+		}
+
+		IMethodBinding methBnd = bnd.getDeclaringMethod();
+		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
+			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+				mapToKey.put(bnd, candidate);
+				return true;
 			}
 			else {
-				sig += param.getType().toString();
-				first = false;
+				return false;
 			}
 		}
-		sig += ")";
-		return sig;
+
+		ITypeBinding classBnd = bnd.getDeclaringClass();
+		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
+			 (recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		else {
+			return false;
+		}
 	}
-	
-	public Method ensureFamixMethod(String identifier, NamedEntity owner, int numberOfParameters) {
+
+	/**
+	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
 		Method fmx = null;
-		if (owner != null) {
-			for (Method candidate : getEntityByName(Method.class, identifier) ) {
-				if ((candidate.getParentType() == owner) && (candidate.getParameters().size() == numberOfParameters)) {
-					fmx = candidate;
-					break;
+		String sig;
+		boolean first;
+
+		// signature is dealt in two places
+		// here we try to use the parameter of ensureFamixMethod to compute the list of parameter types of the FamixMethod
+		// if it does not work and binding is not null, we will have another chance to compute this list later
+		sig = "(";
+		first = true;
+		if (paramTypes != null) {
+			for (org.eclipse.jdt.core.dom.Type t : paramTypes) {
+				if (! first) {
+					sig += "," + findTypeName(t);
+				}
+				else {
+					sig += findTypeName(t);
+					first = false;
 				}
 			}
-		} else {
-			for (Method candidate : getEntityByName(Method.class, identifier) ) {
-				if (candidate.getParameters().size() == numberOfParameters) {
-					fmx = candidate;
-					break;
+			
+		}
+		sig += ")";
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (paramTypes == null) {
+				sig = name + "(???)";
+			}
+			else {
+				sig = name + sig;
+			}
+			if (owner == null) {
+				owner= ensureFamixClassStubOwner();
+			}
+			return super.ensureFamixMethod(null, name, sig, ret, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- signature
+		if (paramTypes == null) {
+			sig = "(";
+			first = true;
+			paramTypes = new ArrayList<org.eclipse.jdt.core.dom.Type>();
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
 				}
 			}
+			sig += ")";
 		}
-		return fmx;
-	}
-	
-	public Method ensureFamixMethod(MethodDeclaration node, fr.inria.verveine.core.gen.famix.Class owner) {
-		Method fmx = null;
-		for (Method candidate : getEntityByName(Method.class, node.getName().getIdentifier()) ) {
-			if ((candidate.getParentType() == owner) && (candidate.getSignature().equals(stubMethodSignature(node))) ) {
+		sig = name + sig;
+
+		// --------------- return type
+		if ( (ret == null) && (! bnd.isConstructor()) ) {
+			ret = this.ensureFamixType(bnd.getReturnType(), null, null);
+		}
+		// else leave it to null ...
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (Method candidate : this.getEntityByName(Method.class, name)) {
+			if ( recoverAndMapMethod(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
 		}
+		if (fmx == null) {
+			fmx = ensureFamixMethod(bnd, name, sig, ret, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setDeclaredType(ret);
+			fmx.setSignature(sig);
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
 		return fmx;
 	}
-		
+	
+	public String findTypeName(org.eclipse.jdt.core.dom.Type t) {
+		if (t.isPrimitiveType()) {
+			return t.toString();
+		}
+		else if (t.isSimpleType()) {
+			return ((SimpleType)t).getName().getFullyQualifiedName();
+		}
+		else if (t.isQualifiedType()) {
+			return ((QualifiedType)t).getName().getIdentifier();
+		}
+		else if (t.isArrayType()) {
+			return findTypeName( ((ArrayType)t).getElementType() );
+		}
+		else if (t.isParameterizedType()) {
+			return "?";  // TODO
+		}
+		else { // it is a WildCardType
+			return "?"; // TODO
+		}
+	}
+
 	/**
-	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)} 
+	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
-	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
-		Type owner = null;
-		Type typ = null;
-		boolean wasBound = false;
+	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
+		Attribute fmx = null;
 
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Attribute");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of an attribute for which we ignore the declaring class? 
+			}
+			return super.ensureFamixAttribute(null, name, type, owner);
 		}
 
-		owner = this.ensureFamixType(bnd.getDeclaringClass(), /*context*/null); // the context is the declaring class=owner
-		typ = this.ensureFamixType(bnd.getType(), owner);
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
 
-		// finally trying to recover the entity or creating it
-		Attribute fmx = null;
-		// ... trying to recover from binding
-		fmx = (Attribute) getEntityByBinding(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- return type
+		if (type == null) {
+			type = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informationsparentBehaviouralEntity
-			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
-				if ( //(! candidate.getIsStub()) &&
-					 (candidate.getParentType() == owner) &&
-					 (candidate.getDeclaredType() == typ) ) {
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
-			}
+		// else leave it to null ...
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixClass(bnd.getDeclaringClass(), null, null);
 		}
 		
+		// --------------- recover from name ?
+		for (Attribute candidate : getEntityByName(Attribute.class, name) ) {
+			if ( recoverAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = ensureFamixEntity(Attribute.class, bnd, bnd.getName());
+			fmx = super.ensureFamixAttribute(bnd, name, type, owner);
 		}
 		
-		if ((fmx!=null) && (! wasBound) ) {
-			// apparently we just created it, so add information to it
-			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setParentType(owner);
-			fmx.setDeclaredType(typ);	
-			fmx.setName(bnd.getName());
+			fmx.setDeclaredType(type);	
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
 		}
 
 		return fmx;
@@ -709,13 +695,17 @@
 		boolean wasBound = false;
 		
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix Parameter");
+			System.err.println("Warning: Unexpected null binding to Famix Parameter");
 			return null;
 		}
 
-		// actually it seems to be very little chances that the parameter alreasy exist.
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+		}
+		
+		// actually it seems to be very little chances that the parameter already exist.
 		// but who knows? Does not hurt to try
-		Parameter fmx = (Parameter) getEntityByBinding(bnd);
+		Parameter fmx = (Parameter) getEntityByKey(bnd);
 		
 		if (fmx != null) {
 			wasBound = true;
@@ -728,90 +718,73 @@
 		if ( (fmx!=null) && (! wasBound) ) {
 			// declaring method
 			if (bnd.getDeclaringMethod() != null) {
-				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
+				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null));  // cast needed to desambiguate the call
 			} else {
 				fmx.setParentBehaviouralEntity(owner);
 			}
 			// type of the attribute
-//System.out.println("looking for parameter type:"+bnd.getName()+"  context="+owner.getName());
-			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), /*context*/owner));
+			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), null, null));
 		}
 		
 		return fmx;
 	}
 	
-	public Parameter ensureFamixParameter(IVariableBinding bnd) {
-		return ensureFamixParameter(bnd, null);
-	}
-
 	/**
 	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
+	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
-	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, Method fmxMethod) {
-		Method owner = null;
-		Type typ = null;
-		boolean wasBound = false;
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd, String name, Type typ, Method owner) {
+		LocalVariable fmx = null;
 
 		if (bnd == null) {
-//			System.err.println("Warning: Unexpected null binding to Famix LocalVariable");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of a local variable for which we ignore the declaring method?
+			}
+			return super.ensureFamixLocalVariable(null, name, typ, owner);
 		}
 
-		owner = this.ensureFamixMethod(bnd.getDeclaringMethod());
-		if (owner == null) {
-			owner = fmxMethod;
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
 		}
-		typ = this.ensureFamixType(bnd.getType(), /*context*/fmxMethod);
 
-		// finally trying to recover the entity or creating it
-		LocalVariable fmx = null;
-		// ... trying to recover from binding
-		fmx = (LocalVariable) getEntityByBinding(bnd);
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+		// else leave it to null ...
 
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
 		}
-		else {
-			wasBound = false;
-			// trying to recover from name and other informationsparentBehaviouralEntity
-			for (LocalVariable candidate : getEntityByName(LocalVariable.class, bnd.getName()) ) {
-				if ( (candidate.getParentBehaviouralEntity() == owner) &&
-					 (candidate.getDeclaredType() == typ) ) {
-					fmx = candidate;
-					mapBind.put(bnd, fmx);
-					break;
-				}
+		
+		// --------------- recover from name ?
+		for (LocalVariable candidate : getEntityByName(LocalVariable.class, name) ) {
+			if ( recoverAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
 			}
 		}
-		
 		if (fmx == null) {
-			// could not recover it, creating a new entity
-			fmx = ensureFamixEntity(LocalVariable.class, bnd, bnd.getName());
+			fmx = super.ensureFamixLocalVariable(bnd, name, typ, owner);
 		}
-
-		if ( (fmx!=null) && (! wasBound) ) {
-			// apparently we just created it, so add information to it
+		
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setParentBehaviouralEntity(owner);
-			fmx.setDeclaredType(typ);
+			fmx.setDeclaredType(typ);	
 		}
-		
+
 		return fmx;
 	}
 	
-	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
-		return ensureFamixLocalVariable(bnd, null);
-	}
-	
 	/**
 	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
-	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
@@ -856,7 +829,7 @@
 			while ( ! (ast instanceof CompilationUnit) ) {
 				ASTNode tmp = ast.getParent();
 				if ( (ast == null) || (tmp == ast) ) {
-					// we reached the top node without finding a CompilationUnit. This would be strange, but what can one do ... ?
+					// if we are here, then we reached the top node without finding a CompilationUnit. This should not happen
 					return null;
 				}
 				else {
@@ -881,12 +854,7 @@
 	 * @return the Famix Method
 	 */
 	public Method ensureFamixStubMethod(String name) {
-		Method fmx = ensureFamixMethod(name);
-		fmx.setSignature(name + " (<unknown-stub>)");
-		fmx.setParentType( ensureFamixClassStubOwner());
-		fmx.setDeclaredType(ensureFamixClassObject(null));
-		
-		return fmx;
+		return ensureFamixMethod(null, name, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, ensureFamixClassStubOwner());  // cast needed to desambiguate the call
 	}
 
 	/**
@@ -896,7 +864,7 @@
 	 * @return a Famix Namespace for "java.lang"
 	 */
 	public Namespace ensureFamixNamespaceJavaLang(IPackageBinding bnd) {
-		Namespace fmx = ensureFamixNamespaceWithParentScope(bnd, OBJECT_PACKAGE_NAME);
+		Namespace fmx = this.ensureFamixNamespace(bnd, OBJECT_PACKAGE_NAME);
 
 		return fmx;
 	}
@@ -958,4 +926,19 @@
 		return fmx;
 	}
 
+
+	public String removeLastName(String qualifiedName) {
+		String ret = null;
+		int last = qualifiedName.lastIndexOf('.');
+		if (last > 0) {
+			// recursively creating the parent
+			ret = qualifiedName.substring(0, last);
+		}
+		else {
+			ret = "";
+		}
+
+		return ret;
+	}
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 82)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 83)
@@ -40,9 +40,9 @@
 	@Override
 	public boolean compile(String[] argv) {
 		boolean ret;
-		if (this.linkToExisting()) {
+		/*if (this.linkToExisting()) {
 			this.expandNamespacesNames();
-		}
+		}*/
 
 		setInitialArgs(argv);
 		ret = super.compile(argv);
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 5)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 6)
@@ -15,7 +15,7 @@
     @FameProperty(name = "isAbstract", derived = true)
     public Boolean getIsAbstract() {
         // TODO: this is a derived property, implement this method manually.
-        return this.getModifiers().contains("abstract");
+        return super.getIsAbstract() || this.getModifiers().contains("abstract");
     }
     
     private Boolean isInterface;
