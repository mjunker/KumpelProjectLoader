Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 63)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 64)
@@ -24,6 +24,7 @@
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
@@ -104,7 +105,6 @@
 //		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd);
-		//fmx.setTypeArguments(dico.ensureFamixTypes(node.typeParameters()));
 		if (fmx != null) {
 			fmx.setIsStub(false);
 		}
@@ -115,6 +115,8 @@
 			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
 			fmx.setContainer( context.top());
 		}
+		fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
+		
 		dico.addSourceAnchor(fmx, node);
 		Javadoc jdoc = node.getJavadoc();
 		if (jdoc != null) {
@@ -171,7 +173,7 @@
 			fmx.setIsStub(false);
 		}
 		else {
-			System.err.println("         Method="+node.getName().getIdentifier() + ",  fallback to creating a stub");
+			System.err.println("         Method="+node.getName().getIdentifier());
 			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
 			fmx.setParentType(context.topClass());
 			//fmx.setSignature(fmx.getName()+" (???)");
@@ -180,18 +182,23 @@
 			// Has no binding? It might be a Generic type
 			fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getReturnType2().toString()));
 		}
+		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
+			fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
+		}
 		if (fmx != null) {
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-//				System.err.println(param.getName().getIdentifier());
-//				System.err.println(param.resolveBinding()==null);
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
 				} else {
 					// Has no binding? It might be a Generic parameter
+					System.err.println("         Parameter="+param.getName().getIdentifier());
 					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, param.getType().toString());
 				}
+				if (param.getType().isParameterizedType()) {
+					fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
+				}
 			}
 			
 			dico.addSourceAnchor(fmx, node);
@@ -232,11 +239,13 @@
 //			System.err.println("            Field: "+vd.getName().getIdentifier());
 			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
+			
+			//((ParameterizedType)node.getType()).typeArguments();
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 			else {
-				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
 				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
 				fmx.setParentType(context.topClass());
 				// should try to find type name from 'node.getType()' ?
@@ -244,7 +253,9 @@
 				// Has no binding? It might be a Generic type
 				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, node.getType().toString()));
 			}
-			
+			if (node.getType().isParameterizedType()) {
+				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getType()).typeArguments()));
+			}
 			dico.addSourceAnchor(fmx, node);
 			Javadoc jdoc = node.getJavadoc();
 			if (jdoc != null) {
@@ -282,12 +293,12 @@
 		}
 
 		for (VariableDeclarationFragment vd : fragments) {
-			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding());
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding(), context.topMethod());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 			else {
-				System.err.println("         Variable="+vd.getName().getFullyQualifiedName() + ",  fallback to creating a stub");
+				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
 				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
 				fmx.setParentBehaviouralEntity(context.topMethod());
 				// should try to find type name from 'node.getType()' ?
@@ -296,6 +307,9 @@
 				fmx.setDeclaredType(dico.ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, nodeTyp.toString()));
 				dico.addSourceAnchor(fmx, node);
 			}
+			if (nodeTyp.isParameterizedType()) {
+				fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)nodeTyp).typeArguments()));
+			}
 		}
 	}
 
@@ -399,4 +413,4 @@
 		return super.visit(node);
 	}
 
-}
+}
\ No newline at end of file
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 11)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 12)
@@ -368,6 +368,17 @@
 		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
 		assertEquals(17, ((FileAnchor)anc).getStartLine());
 		assertEquals(31, ((FileAnchor)anc).getEndLine());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(70, ((FileAnchor)anc).getEndLine());
 		
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
 		assertNotNull(meth);
@@ -426,4 +437,27 @@
 		assertTrue(a.getIsProtected());
 		assertFalse(a.getIsFinal());
 	}
+
+
+	@Test
+	public void testMetric() {	
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
+			assertNotNull(m);
+			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
+			assertNotNull(owner);
+			if (owner.getName().equals("OutputServer")) {
+			assertEquals(2, m.getCyclo());
+				assertEquals(6, m.getNOS());
+			}
+			else if (owner.getName().equals("Node")) {
+				assertEquals(1, m.getCyclo());
+				assertEquals(1, m.getNOS());
+			}
+			else if (owner.getName().equals("WorkStation")) {
+				assertEquals(2, m.getCyclo());
+				assertEquals(7, m.getNOS());
+			}
+		}		
+	}
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 12)
@@ -320,16 +320,29 @@
 		return null;
 	}
 
+	/**
+	 * Handles an access to a field by creating the corresponding Famix Entity
+	 * @param bnd -- a binding for the field (i.e attribute)
+	 */
 	private void fieldAccess(IVariableBinding bnd) {
 		BehaviouralEntity accessor = this.context.topMethod();
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
 			if (accessed != null) {
 				dico.ensureFamixAccess(accessor, accessed);
+				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
+					accessed.setParentType(dico.ensureFamixClassArray());
+				}
 			}
 		}
 	}
 
+	/**
+	 * Handles an invocation of a method by creating the corresponding Famix Entity
+	 * @param bnd -- a binding for the method
+	 * @param name of the method invoked
+	 * @param receiver of the call, i.e. the object to which the message is sent
+	 */
 	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver) {
 		BehaviouralEntity sender = this.context.topMethod();
 		if (sender != null) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 12)
@@ -5,17 +5,37 @@
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTVisitor;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.AssertStatement;
+import org.eclipse.jdt.core.dom.Assignment;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConstructorInvocation;
+import org.eclipse.jdt.core.dom.ContinueStatement;
+import org.eclipse.jdt.core.dom.DoStatement;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.ForStatement;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.SwitchCase;
+import org.eclipse.jdt.core.dom.SwitchStatement;
+import org.eclipse.jdt.core.dom.SynchronizedStatement;
+import org.eclipse.jdt.core.dom.TagElement;
+import org.eclipse.jdt.core.dom.ThrowStatement;
+import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WhileStatement;
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
@@ -89,6 +109,10 @@
 			fmx.setContainer( context.top());
 		}
 		dico.addSourceAnchor(fmx, node);
+		if (context.getLastComment() != null) {
+			dico.createFamixComment(context.getLastComment(), fmx);
+			context.clearLastComment();
+		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
@@ -138,8 +162,8 @@
 			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
 		}
 
-		// creating the method's parameters
-		if (fmx != null) {
+		if (fmx != null) {			
+			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding());
 				if (fmxParam != null) {
@@ -148,13 +172,25 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
+			if (context.getLastComment() != null) {
+				dico.createFamixComment(context.getLastComment(), fmx);
+				context.clearLastComment();
+			}
 			this.context.pushMethod(fmx);
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
 		}
 		return super.visit(node);	
 	}
 
 	public void endVisit(MethodDeclaration node) {
-		this.context.popMethod();
+		int cyclo = context.getTopMethodCyclo();
+		int nos = context.getTopMethodNOS();
+		Method fmx = this.context.popMethod();
+		fmx.setNOS(nos);
+		fmx.setCyclo(cyclo);
 		super.endVisit(node);
 	}
 
@@ -176,6 +212,10 @@
 			}
 			
 			dico.addSourceAnchor(fmx, node);
+			if (context.getLastComment() != null) {
+				dico.createFamixComment(context.getLastComment(), fmx);
+				context.clearLastComment();
+			}
 		}
 		return super.visit(node);
 	}
@@ -216,4 +256,116 @@
 		}
 	}
 
+	@Override
+	@SuppressWarnings("unchecked")
+	public boolean visit(Javadoc node) {
+		String comment = "/** ";
+		for (TagElement tag : (List<TagElement>)node.tags()) {
+			comment += tag.toString();
+		}
+		comment += "\n */";
+		this.context.setLastComment(comment);
+		return super.visit(node);
+	}
+
+
+	// METRICS: CYCLO, NOS
+	
+	public boolean visit(AssertStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(Assignment node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ContinueStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(DoStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(EnhancedForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ForStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(IfStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(MethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ReturnStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperConstructorInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SuperMethodInvocation node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchCase node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SwitchStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(SynchronizedStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(ThrowStatement node) {
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(TryStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
+	public boolean visit(WhileStatement node) {
+		this.context.addTopMethodCyclo(1);
+		this.context.addTopMethodNOS(1);
+		return super.visit(node);
+	}
+
 }
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 11)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 12)
@@ -39,6 +39,7 @@
 
 	public static final String OBJECT_NAME = "Object";
 	public static final String OBJECT_PACKAGE_NAME = "java.lang";
+	public static final String ARRAYS_NAME = "default[]";
 	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
 	public static final String STATIC_INIT_BLOCK_NAME = "<StaticInitializer>";
 
@@ -453,7 +454,6 @@
 		fmx.setIsPublic(Modifier.isPublic(mod));
 	}
 
-
 	/**
 	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
 	 * The JDT Binding is a unique representation of a java entity within the AST.
@@ -640,7 +640,10 @@
 		return fmx;
 	}
 
-	@Override
+	/**
+	 * Creates or recovers the Famix Class that will own all stub methods (for which the real owner is unknown)
+	 * @return a Famix class
+	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
 		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
@@ -648,5 +651,18 @@
 		return fmx;
 	}
 
+	/**
+	 * Creates or recovers the Famix Class for all arrays (<some-type> [])
+	 * In java arrays or objects of special classes (i.e. "I[" for an array of int).
+	 * JDT does not create a binding for these classes, so we create a stub one here. 
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
+		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+		fmx.setContainer( ensureFamixNamespaceDefault());
+
+		return fmx;
+	}
 
 }
