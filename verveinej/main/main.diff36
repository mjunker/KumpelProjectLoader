Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 86)
+++ verveine.extractor.java/.classpath	(revision 87)
@@ -2,7 +2,7 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core">
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/dom">
 		<attributes>
 			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
 		</attributes>
@@ -14,7 +14,7 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
-	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
 	<classpathentry kind="output" path="bin"/>
Index: verveine.extractor.java/test_src/ad_hoc/Card.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Card.java	(revision 87)
@@ -0,0 +1,40 @@
+package ad_hoc;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Card {
+
+	public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };
+
+	public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX,
+        SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE }
+
+    private final Rank rank;
+    private final Suit suit;
+    private Card(Rank rank, Suit suit) {
+        this.rank = rank;
+        this.suit = suit;
+    }
+
+    public Rank rank() { return rank; }
+    public Suit suit() { return suit; }
+    public String toString() { return rank + " of " + suit; }
+
+    private static final List<Card> protoDeck = new ArrayList<Card>();
+
+    // Initialize prototype deck
+    static {
+        for (Suit s : Suit.values())
+            for (Rank r : Rank.values()) {
+            	if (r == Rank.QUEEN) {
+            		System.out.println("God save the Queen!");
+            		}
+            	protoDeck.add(new Card(r, s));
+            }
+    }
+
+    public static ArrayList<Card> newDeck() {
+        return new ArrayList<Card>(protoDeck); // Return copy of prototype deck
+    }
+}
Index: verveine.extractor.java/test_src/ad_hoc/Element.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Element.java	(revision 87)
@@ -0,0 +1,89 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame.fm3;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.Named;
+import ch.akuhn.fame.Nested;
+import ch.akuhn.fame.internal.Warnings;
+
+/**
+ * Abstract superclass of MSE metamodel.
+ * 
+ * This is an abstract class with attributes </p>
+ * <ul>
+ * <li>Element <code>owner</code> (derived)</li>
+ * <li>String <code>fullname</code> (derived)</li>
+ * <li>String <code>name</code></li>
+ * </ul>
+ * <p>
+ * with these constraints
+ * </p>
+ * <ul>
+ * <li> <code>name</code> must be alphanumeric</li>
+ * <li> <code>fullname</code> is derived recursively, concatenating
+ * <code>owner.fullname</code> and <code>name</code></li>
+ * <li> <code>fullname</code> is separated by dots, eg
+ * <code>MSE.Class.attributes</code></li>
+ * </ul>
+ * 
+ * @author Adrian Kuhn
+ * 
+ */
+@FamePackage("FM3")
+@FameDescription("Element")
+public abstract class Element implements Named, Nested {
+
+    private String name;
+
+    public Element() {
+    }
+
+    public Element(String name) {
+        this.name = name;
+    }
+
+    @FameProperty(derived = true)
+    public String getFullname() {
+        Element parent = this.getOwner();
+        return parent == null ? this.getName() : parent.getFullname() + "." + this.getName();
+    }
+
+    @FameProperty
+    public String getName() {
+        return name;
+    }
+
+    @FameProperty(derived = true)
+    public abstract Element getOwner();
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return this.getFullname();
+    }
+    
+    public abstract void checkConstraints(Warnings warnings);
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/ReadException.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/ReadException.java	(revision 87)
@@ -0,0 +1,4 @@
+package OMGL2;
+public class ReadException extends Exception {
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/FameProperty.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/FameProperty.java	(revision 87)
@@ -0,0 +1,47 @@
+//  Copyright (c) 2007-2008 Adrian Kuhn <akuhn(a)iam.unibe.ch>
+//  
+//  This file is part of 'Fame (for Java)'.
+//  
+//  'Fame (for Java)' is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or (at your
+//  option) any later version.
+//  
+//  'Fame (for Java)' is distributed in the hope that it will be useful, but
+//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+//  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+//  License for more details.
+//  
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with 'Fame (for Java)'. If not, see <http://www.gnu.org/licenses/>.
+//  
+
+package ch.akuhn.fame;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Attaches FM3-related meta-information to class members (ie fields or
+ * methods).
+ * 
+ * @author akuhn
+ * 
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target( { ElementType.METHOD, ElementType.FIELD })
+public @interface FameProperty {
+
+    boolean container() default false;
+
+    boolean derived() default false;
+
+    String name() default "*";
+
+    String opposite() default "";
+
+    Class<?> type() default Void.class;
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/Client.java	(revision 87)
@@ -0,0 +1,70 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+@Override
+@Deprecated
+public class Client {
+	
+	@Override
+	@Deprecated
+	private String num;
+	@Deprecated
+	private String nom;
+
+	@Deprecated
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+	
+	@Override
+	@Deprecated
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+	
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	@Override
+	@Deprecated
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_Dictionary.java	(revision 87)
@@ -1,231 +0,0 @@
-/**
- * Copyright (c) 2010 Nicolas Anquetil
- */
-package tests.fr.inria.verveine.extractor.java;
-
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-import java.util.Collection;
-import java.util.Iterator;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import test.fr.inria.verveine.core.TestVerveineUtils;
-import ch.akuhn.fame.Repository;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.ContainerEntity;
-import fr.inria.verveine.core.gen.famix.Entity;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.NamedEntity;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.ParameterType;
-import fr.inria.verveine.core.gen.famix.ParameterizableClass;
-import fr.inria.verveine.core.gen.famix.Type;
-import fr.inria.verveine.extractor.java.JavaDictionary;
-import fr.inria.verveine.extractor.java.VerveineJParser;
-
-/**
- * @author Andre Hora
- * @since January 17, 2011
- *
- */
-public class VerveineJTest_Dictionary {
-
-	private Repository repo;
-
-	public VerveineJTest_Dictionary() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-	
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp() throws Exception {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/ad_hoc/Dictionary.java"});
-		repo = parser.getFamixRepo();
-	}
-
-	@After
-	public void tearDown() {
-		new File(VerveineJParser.OUTPUT_FILE).delete();
-	}
-
-	@Test
-	public void testClassParameterTypes() {
-		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
-		assertNotNull(dicoClass);
-		assertEquals("Dictionary", dicoClass.getName());
-		assertEquals(2, dicoClass.getTypes().size());
-		assertEquals(1, dicoClass.getParameters().size());
-		
-		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
-		assertNotNull(dicoParam);
-		assertEquals("B", dicoParam.getName());
-		
-		assertSame(dicoClass, dicoParam.getContainer());
-		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
-	}
-
-	@Test
-	public void testParameterTypeAsType() {
-		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
-		assertNotNull(gebb);
-		assertSame(1, gebb.getParameters().size());
-		
-		Parameter bnd = gebb.getParameters().iterator().next();
-		assertNotNull(bnd);
-		assertEquals("bnd", bnd.getName());
-		
-		Type b = bnd.getDeclaredType();
-		assertNotNull(b);
-		assertEquals("B", b.getName());
-		assertSame(ParameterType.class, b.getClass());
-		
-		ContainerEntity cont = b.getContainer();
-		assertNotNull(cont);
-		assertEquals("Dictionary", cont.getName());
-		assertSame(ParameterizableClass.class, cont.getClass());
-	}
-	
-	/*Test
-	public void testFieldArgumentTypes() {
-		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
-		assertNotNull(famixAtt);
-		assertEquals("mapBind", famixAtt.getName());
-		assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
-		Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
-	}
-*/
-	
-	/*Test
-	public void testMethodParameterArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(3, fmxMethod.getParameters().size());
-		for (Parameter fmxParameter : fmxMethod.getParameters()) {
-			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
-			if (fmxParameter.getName().equals("fmxClass")) {
-				assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxParameter.getName().equals("bnd")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-			if (fmxParameter.getName().equals("name")) {
-				assertNull(fmxParameter.getDeclaredArgumentTypes());
-			}
-		}
-	}
-	*/
-	
-	/*Test
-	public void testMethodLocalVariableArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
-		assertNotNull(fmxMethod);
-		assertEquals(1, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
-			assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-			assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
-			if (fmxLocalVariable.getName().equals("ret")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-			if (fmxLocalVariable.getName().equals("l_name")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-		}
-		
-		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
-		assertNotNull(fmxMethod);
-		assertEquals(2, fmxMethod.getLocalVariables().size());
-		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
-			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
-			if (fmxLocalVariable.getName().equals("fmx")) {
-				assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
-			}
-			if (fmxLocalVariable.getName().equals("l")) {
-				assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
-				assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
-			}
-		}
-	}
-	*/
-	
-	/*Test
-	public void testMethodReturnArgumentTypes() {
-		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
-		assertNotNull(fmxMethod);
-		assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
-	}
-	*/
-}
\ No newline at end of file
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 87)
@@ -59,7 +59,7 @@
 	 */
 	@Before
 	public void setUp() throws Exception {
-		String[] files = new String[] {
+		/*String[] files = new String[] {
 				"AbstractDestinationAddress.java",
 				"Node.java",
 				"Packet.java",
@@ -72,7 +72,7 @@
 		};
 
 		// separate parsing of each source file --------
-		/*for (String f : files) {
+		for (String f : files) {
 			parseFile(f);
 		}*/
 		// or parsing the entire project in one pass ---
@@ -86,7 +86,7 @@
 	 * The "separate parsing" mechanism should ensure that linkages are appropriately done
 	 * @param file -- name of the file to parse
 	 */
-	private void parseFile(String file) {
+/*	private void parseFile(String file) {
 		String[] args = new String[] {
 				"-cp",
 				"test_src/LANModel//moose/lan/",
@@ -100,7 +100,7 @@
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
 	}
-
+*/
 	@After
 	public void tearDown() {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
@@ -282,7 +282,7 @@
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
 		assertNotNull(obj);
-		assertTrue(ns.getIsStub());
+		assertTrue(obj.getIsStub());
 		assertSame(ns, obj.getContainer());
 		
 		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
@@ -294,7 +294,7 @@
 		assertNotNull(clazz);
 		assertFalse(clazz.getIsStub());
 		
-		/* [].length notused in the default test case 
+		/* [].length not used in the default test case 
 		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
 		assertNotNull(att);
 		clazz = (Class) att.getParentType();
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 86)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 87)
@@ -7,6 +7,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 import java.io.File;
 import java.util.Collection;
@@ -18,12 +19,22 @@
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.EnumValue;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.ParameterType;
+import fr.inria.verveine.core.gen.famix.ParameterizableClass;
 import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
 /**
@@ -58,12 +69,12 @@
 	
 	@Test
 	public void testExceptions() {
-		// there are two "lire" methods, but both serve our purpose here so we just take the first that will be returned
 		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
 		assertNotNull(meth);
 		
 		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
-		
+		assertNotNull(excepClass);
+
 		assertEquals(1, meth.getDeclaredExceptions().size());
 		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
 		assertSame(meth, exD.getDefiningMethod());
@@ -75,7 +86,8 @@
 		assertSame(excepClass, exT.getExceptionClass());
 
 		excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "IOException");
-		
+		assertNotNull(excepClass);
+
 		assertEquals(1,meth.getCaughtExceptions().size());
 		CaughtException exC = meth.getCaughtExceptions().iterator().next();
 		assertSame(meth, exC.getDefiningMethod());
@@ -84,105 +96,266 @@
 	
 	@Test
 	public void testAnnotation() {
-		fr.inria.verveine.core.gen.famix.Class clazz;
-		Collection<AnnotationInstance> annInstances;
-		
-		AnnotationType annTypeOverride = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
-		assertNotNull(annTypeOverride);
-		assertEquals("Override", annTypeOverride.getName());
+		Collection<AnnotationType> l_FmProp = TestVerveineUtils.listElements(repo,AnnotationType.class, "FameProperty");
+		assertEquals(1, l_FmProp.size());
+
+		AnnotationType fmProp = l_FmProp.iterator().next();
+		assertNotNull(fmProp);
+		assertEquals("FameProperty", fmProp.getName());
+		//TODO assertFalse(fmProp.getIsStub());
 		
-		AnnotationType annTypeDeprecated = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Deprecated");
-		assertNotNull(annTypeDeprecated);
-		assertEquals("Deprecated", annTypeDeprecated.getName());
+		AnnotationType fmPckg = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FamePackage");
+		assertNotNull(fmPckg);
+		assertEquals("FamePackage", fmPckg.getName());
+		assertTrue(fmPckg.getIsStub());
 		
-		//Annotations to the class
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Client");
+		AnnotationType fmDesc = TestVerveineUtils.detectElement(repo,AnnotationType.class, "FameDescription");
+		assertNotNull(fmDesc);
+		assertEquals("FameDescription", fmDesc.getName());
+		assertTrue(fmDesc.getIsStub());
+
+		// class annotations 
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Element");
 		assertNotNull(clazz);
-		annInstances = clazz.getAnnotationInstances();
+		Collection<AnnotationInstance> annInstances = clazz.getAnnotationInstances();
 		assertEquals(2, annInstances.size());
 		for (AnnotationInstance annotationInstance : annInstances) {
 			assertSame(clazz, annotationInstance.getAnnotatedEntity());
-			if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-				assertEquals("Override", annotationInstance.getAnnotationType().getName());
-				assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+			if (annotationInstance.getAnnotationType().getName().equals("FamePackage")) {
+				assertSame(fmPckg, annotationInstance.getAnnotationType());
 			} else {
-				assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-				assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+				assertEquals("FameDescription", annotationInstance.getAnnotationType().getName());
+				assertSame(fmDesc, annotationInstance.getAnnotationType());
 			}
 		}
-		//Annotations to the attributes
-		for (Attribute attribute : clazz.getAttributes()) {
-			annInstances = attribute.getAnnotationInstances();
-			if (attribute.getName().equals("num")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
-					assertSame(attribute, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (attribute.getName().equals("nom")) {
+
+		AnnotationTypeAttribute decl = null;
+		for (AnnotationTypeAttribute a : TestVerveineUtils.listElements(repo, AnnotationTypeAttribute.class, "derived")) {
+			if (a.getParentAnnotationType() == fmProp) {
+				decl = a;
+				break;
+			}
+		}
+		assertNotNull(decl);
+		
+		// Method annotations
+		for (Method meth : clazz.getMethods()) {
+			annInstances = meth.getAnnotationInstances();
+			if (meth.getName().equals("getFullname") || meth.getName().equals("getName") || meth.getName().equals("getOwner")) {
 				assertEquals(1, annInstances.size());
-				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
-					assertSame(attribute, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
+				AnnotationInstance annInst = annInstances.iterator().next();
+				assertSame(fmProp, annInst.getAnnotationType());
+				if (meth.getName().equals("getOwner")) {
+					Collection<AnnotationInstanceAttribute> aiAtts = annInst.getAttributes();
+					assertEquals(1, aiAtts.size());
+					AnnotationInstanceAttribute annAtt = aiAtts.iterator().next();
+					assertEquals( annInst, annAtt.getParentAnnotationInstance());
+					assertEquals( "true", annAtt.getValue());
+					assertEquals(decl, annAtt.getAnnotationTypeAttribute());
 				}
-			} else {
+			}
+			else if (meth.getName().equals("toString")) {
+				assertEquals(1, annInstances.size());
+			}
+			else {
 				assertEquals(0, annInstances.size());
 			}
 		}
-		//Annotations to the methods
-		for (Method method : clazz.getMethods()) {
-			annInstances = method.getAnnotationInstances();
-			if (method.getName().equals("Client")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (method.getName().equals("lire")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			} else if (method.getName().equals("setNum")) {
-				assertEquals(2, annInstances.size());
-				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
-					assertSame(method, annotationInstance.getAnnotatedEntity());
-					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
-						assertEquals("Override", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
-					} else {
-						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
-						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
-					}
-				}
-			}else {
-				assertEquals(0, annInstances.size());
+
+		for (Attribute att : clazz.getAttributes()) {
+			assertEquals(0, att.getAnnotationInstances().size());
+		}
+
+	}
+
+	@Test
+	public void testClassParameterTypes() {
+		ParameterizableClass dicoClass = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
+		assertNotNull(dicoClass);
+		assertEquals("Dictionary", dicoClass.getName());
+		assertEquals(2, dicoClass.getTypes().size());
+		assertEquals(1, dicoClass.getParameters().size());
+		
+		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
+		assertNotNull(dicoParam);
+		assertEquals("B", dicoParam.getName());
+		
+		assertSame(dicoClass, dicoParam.getContainer());
+		assertSame(dicoParam, dicoClass.getParameters().iterator().next());
+	}
+
+	@Test
+	public void testParameterTypeAsType() {
+		Method gebb = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByBinding");
+		assertNotNull(gebb);
+		assertSame(1, gebb.getParameters().size());
+		
+		Parameter bnd = gebb.getParameters().iterator().next();
+		assertNotNull(bnd);
+		assertEquals("bnd", bnd.getName());
+		
+		Type b = bnd.getDeclaredType();
+		assertNotNull(b);
+		assertEquals("B", b.getName());
+		assertSame(ParameterType.class, b.getClass());
+		
+		ContainerEntity cont = b.getContainer();
+		assertNotNull(cont);
+		assertEquals("Dictionary", cont.getName());
+		assertSame(ParameterizableClass.class, cont.getClass());
+	}
+	
+	@Test
+	public void testFieldArgumentTypes() {
+		Attribute famixAtt = TestVerveineUtils.detectElement(repo, Attribute.class, "mapBind");
+		assertNotNull(famixAtt);
+		assertEquals("mapBind", famixAtt.getName());
+		//assertEquals(2, famixAtt.getDeclaredArgumentTypes().size());
+		//Iterator<Type> it = famixAtt.getDeclaredArgumentTypes().iterator();
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "B"), it.next());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), it.next());
+	}
+	
+	@Test
+	public void testMethodParameterArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "createFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				///assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(3, fmxMethod.getParameters().size());
+		for (Parameter fmxParameter : fmxMethod.getParameters()) {
+			assertTrue(fmxParameter.getName().equals("fmxClass") || fmxParameter.getName().equals("bnd") || fmxParameter.getName().equals("name"));
+			if (fmxParameter.getName().equals("fmxClass")) {
+				//assertEquals(1, fmxParameter.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxParameter.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxParameter.getName().equals("bnd")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
+			}
+			if (fmxParameter.getName().equals("name")) {
+				//assertNull(fmxParameter.getDeclaredArgumentTypes());
 			}
 		}
 	}
+	
+	@Test
+	public void testMethodLocalVariableArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "mapEntityToName");
+		assertNotNull(fmxMethod);
+		assertEquals(1, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("l_ent"));
+			//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+			//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("ret") || fmxLocalVariable.getName().equals("l_name"));
+			if (fmxLocalVariable.getName().equals("ret")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+			if (fmxLocalVariable.getName().equals("l_name")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "NamedEntity"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+		
+		fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "ensureFamixUniqEntity");
+		assertNotNull(fmxMethod);
+		assertEquals(2, fmxMethod.getLocalVariables().size());
+		for (LocalVariable fmxLocalVariable : fmxMethod.getLocalVariables()) {
+			assertTrue(fmxLocalVariable.getName().equals("fmx") || fmxLocalVariable.getName().equals("l"));
+			if (fmxLocalVariable.getName().equals("fmx")) {
+				//assertNull(fmxLocalVariable.getDeclaredArgumentTypes());
+			}
+			if (fmxLocalVariable.getName().equals("l")) {
+				//assertEquals(1, fmxLocalVariable.getDeclaredArgumentTypes().size());
+				//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxLocalVariable.getDeclaredArgumentTypes().iterator().next());
+			}
+		}
+	}
+	
+	
+	@Test
+	public void testMethodReturnArgumentTypes() {
+		Method fmxMethod = TestVerveineUtils.detectElement(repo, Method.class, "getEntityByName");
+		assertNotNull(fmxMethod);
+		//assertEquals(1, fmxMethod.getDeclaredArgumentTypes().size());
+		//assertSame(TestVerveineUtils.detectElement(repo, Type.class, "T"), fmxMethod.getDeclaredArgumentTypes().iterator().next());
+	}
+
+	@Test
+	public void testEnumDecl() {
+		fr.inria.verveine.core.gen.famix.Enum rk = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Rank");
+		assertNotNull(rk);
+		assertEquals("Rank", rk.getName());
+		//assertEquals(13, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "Card"), rk.getBelongsTo());
+
+		EnumValue nine = TestVerveineUtils.detectElement(repo, EnumValue.class, "NINE");
+		assertNotNull(nine);
+		assertEquals("NINE", nine.getName());
+		assertSame(rk, nine.getParentEnum());
+		assertSame(rk, nine.getBelongsTo());
+
+		fr.inria.verveine.core.gen.famix.Enum st = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Enum.class, "Suit");
+		assertNotNull(st);
+		assertEquals("Suit", st.getName());
+		//assertEquals(4, card.getValues().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "ad_hoc"), st.getBelongsTo());
+
+		EnumValue hrt = TestVerveineUtils.detectElement(repo, EnumValue.class, "HEARTS");
+		assertNotNull(hrt);
+		assertEquals("HEARTS", hrt.getName());
+		assertSame(st, hrt.getParentEnum());
+		assertSame(st, hrt.getBelongsTo());
+	}
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 87)
@@ -1,6 +1,5 @@
 package fr.inria.verveine.extractor.java;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
@@ -16,6 +15,7 @@
 import org.eclipse.jdt.core.dom.ConditionalExpression;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.FieldAccess;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
@@ -32,7 +32,6 @@
 import org.eclipse.jdt.core.dom.QualifiedType;
 import org.eclipse.jdt.core.dom.SimpleName;
 import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
@@ -41,6 +40,7 @@
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.TypeLiteral;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.Attribute;
@@ -114,13 +114,17 @@
 			importName = dico.removeLastName(importName);
 		}
 		Namespace fmxDest = dico.ensureFamixNamespace( (IPackageBinding)importBnd, importName);
-		context.setLastReference( dico.ensureFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
+		context.setLastReference( dico.createFamixReference(fmxSrc, fmxDest, context.getLastReference()) );
 		
 		return super.visit(node);
 	}
 
 	public boolean visit(TypeDeclaration node) {
-		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(node.resolveBinding()));
+		ITypeBinding bnd = node.resolveBinding();
+		fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd);
+		this.context.pushClass(fmx );
+
+		dico.addFamixAnnotationInstances(bnd, fmx);
 
 		return super.visit(node);
 	}
@@ -133,7 +137,11 @@
 	public boolean visit(ClassInstanceCreation node) {
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(decl.resolveBinding()));
+			ITypeBinding bnd = decl.resolveBinding();
+			fr.inria.verveine.core.gen.famix.Class fmx = (fr.inria.verveine.core.gen.famix.Class)dico.getEntityByKey(bnd); 
+			this.context.pushClass(fmx);
+
+			dico.addFamixAnnotationInstances(bnd, fmx);
 		}
 		return super.visit(node);
 	}
@@ -146,35 +154,23 @@
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 		IMethodBinding bnd = node.resolveBinding();
-		Type retTyp = node.getReturnType2();
-		Collection<Type> paramTypes = new ArrayList<Type>();
-		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				paramTypes.add(param.getType());
-		}
-		Method meth = null;
-		if (retTyp != null) {
-			meth = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-					context.topClass());
-		}
-		else {
-			meth = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					null,   // probably a constructor
-					context.topClass());
-		}
+		Method meth = (Method) dico.getEntityByKey(bnd);
 
-		this.context.pushMethod(meth);
-		for (Name excepName : (List<Name>)node.thrownExceptions()) {
-			fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
-			if (excepFmx != null) {
-				dico.ensureFamixDeclaredException(meth, excepFmx);
+		if (meth != null) {
+			this.context.pushMethod(meth);
+
+			dico.addFamixAnnotationInstances(bnd, meth);
+
+			// Exceptions
+			for (Name excepName : (List<Name>)node.thrownExceptions()) {
+				fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(excepName.resolveTypeBinding(), excepName.getFullyQualifiedName(), null);
+				if (excepFmx != null) {
+					dico.createFamixDeclaredException(meth, excepFmx);
+				}
 			}
 		}
-		return super.visit(node);	
+
+		return super.visit(node);
 	}
 
 	public void endVisit(MethodDeclaration node) {
@@ -182,6 +178,20 @@
 		super.endVisit(node);
 	}
 
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, RefVisiting FieldDeclaration");
+		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
+			IVariableBinding bnd = vd.resolveBinding();
+			Attribute fmx = (Attribute) dico.getEntityByKey(bnd);
+
+			if (fmx != null) {
+				dico.addFamixAnnotationInstances(bnd, fmx);
+			}
+		}
+		return super.visit(node);
+	}
+
 	public boolean visit(MethodInvocation node) {
 		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
 		return super.visit(node);
@@ -214,7 +224,7 @@
 			if (invoked == null) {
 				invoked = this.dico.ensureFamixStubMethod(calledName);
 			}*/
-			context.setLastInvocation( dico.ensureFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
+			context.setLastInvocation( dico.createFamixInvocation(sender, invoked, receiver, context.getLastInvocation()) );
 		}
 	}
 
@@ -248,7 +258,7 @@
 				excepFmx = this.dico.ensureFamixClass(excepClass.resolveBinding(), ((QualifiedType) excepClass).getName().getIdentifier(), null);
 			}
 			if (excepFmx != null) {
-				dico.ensureFamixCaughtException(meth, excepFmx);
+				dico.createFamixCaughtException(meth, excepFmx);
 			}
 		}
 
@@ -260,12 +270,11 @@
 		Method meth = this.context.topMethod();
 		fr.inria.verveine.core.gen.famix.Class excepFmx = this.dico.ensureFamixClass(node.getExpression().resolveTypeBinding(), null, null);
 		if (excepFmx != null) {
-			dico.ensureFamixThrownException(meth, excepFmx);
+			dico.createFamixThrownException(meth, excepFmx);
 		}
 		return super.visit(node);
 	}
 
-
 	/**
 	 * Finds and/or create the Famix Entity receiving a message
 	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
@@ -358,7 +367,7 @@
 					ret = dico.ensureFamixAttribute(bnd, varName, null, null);
 				}
 				else if ( ((IVariableBinding)bnd).isParameter() ) {
-					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, context.topMethod());
+					ret = dico.ensureFamixParameter( (IVariableBinding)bnd, varName, null, context.topMethod());
 				}
 				else { // suppose it's a local variable
 					ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd, varName, null, context.topMethod());
@@ -423,7 +432,7 @@
 		if (accessor != null) {
 			Attribute accessed = this.dico.ensureFamixAttribute(bnd, null, null, null);
 			if (accessed != null) {
-				context.setLastAccess( dico.ensureFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
+				context.setLastAccess( dico.createFamixAccess(accessor, accessed, /*isWrite*/false, context.getLastAccess()) );
 				if ( (accessed.getParentType() == null) && (accessed.getName().equals("length")) ) {
 					accessed.setParentType(dico.ensureFamixClassArray());
 				}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 87)
@@ -6,6 +6,8 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
+import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
 import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
 import org.eclipse.jdt.core.dom.AssertStatement;
 import org.eclipse.jdt.core.dom.Assignment;
@@ -15,14 +17,13 @@
 import org.eclipse.jdt.core.dom.ContinueStatement;
 import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
+import org.eclipse.jdt.core.dom.EnumDeclaration;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.ForStatement;
-import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IVariableBinding;
 import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.Javadoc;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
@@ -44,8 +45,9 @@
 
 import fr.inria.verveine.core.EntityStack;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
 import fr.inria.verveine.core.gen.famix.Method;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -96,29 +98,20 @@
 	}
 
 	public boolean visit(TypeDeclaration node) {
-//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		//System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
 		ITypeBinding bnd = node.resolveBinding();
 		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(bnd, node.getName().getIdentifier(), context.top());
 		if (fmx != null) {
 			fmx.setIsStub(false);
+
+			this.context.pushClass(fmx);
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
 		}
 
 		//TODO fmx.setParameterTypes(dico.ensureFamixTypesParameters(node.typeParameters()));
 		
-		dico.addSourceAnchor(fmx, node);
-		Javadoc jdoc = node.getJavadoc();
-		if (jdoc != null) {
-			Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-			dico.addSourceAnchor(cmt, jdoc);
-		}
-		//Annotation
-		if (bnd != null) {
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
-			}
-		}
-		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
@@ -128,28 +121,82 @@
 	}
 
 	public boolean visit(ClassInstanceCreation node) {
-//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		//System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
 		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
 		if (decl != null) {
-			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
+			fmx = this.dico.ensureFamixClass(decl.resolveBinding(), null, context.top());
 			if (fmx != null) {
 				fmx.setIsStub(false);
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			this.context.pushClass(fmx);
 		}
+		this.context.pushClass(fmx);
 		return super.visit(node);
 	}
 
-	public void endVisit(AnonymousClassDeclaration node) {
+	public void endVisit(ClassInstanceCreation node) {
 		this.context.popClass();
 		super.endVisit(node);
 	}
-	
+
+	public boolean visit(AnnotationTypeDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeDeclaration: "+node.getName().getIdentifier());
+		ITypeBinding bnd = node.resolveBinding();
+		AnnotationType fmx = dico.ensureFamixAnnotationType(bnd, node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			context.pushAnnotationType(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+
+	public void endVisit(AnnotationTypeDeclaration node) {
+		this.context.popAnnotationType();
+		super.endVisit(node);
+	}
+
+	public boolean visit(AnnotationTypeMemberDeclaration node) {
+		//System.err.println("TRACE, DefVisiting AnnotationTypeMemberDeclaration: "+node.getName().getIdentifier());
+		IMethodBinding bnd = node.resolveBinding();
+		AnnotationTypeAttribute fmx = dico.ensureFamixAnnotationTypeAttribute(bnd, node.getName().getIdentifier(), context.topAnnotationType());
+		if (fmx != null) {
+			fmx.setIsStub(false);
+			
+			context.pushAnnotationMember(fmx);
+		}
+
+		return super.visit(node);
+	}
+
+	public void endVisit(AnnotationTypeMemberDeclaration node) {
+		this.context.popAnnotationMember();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(EnumDeclaration node) {
+//		System.err.println("TRACE, DefVisiting EnumDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Enum fmx = dico.ensureFamixEnum(node.resolveBinding(), node.getName().getIdentifier(), context.top());
+		if (fmx != null) {
+			fmx.setIsStub(Boolean.FALSE);
+			
+			for (EnumConstantDeclaration ecst : (List<EnumConstantDeclaration>)node.enumConstants()) {
+				EnumValue ev = dico.ensureFamixEnumValue(ecst.resolveVariable(), ecst.getName().getIdentifier(), fmx);
+				ev.setIsStub(Boolean.FALSE);
+			}
+		}
+		return super.visit(node);
+	}
+
 	@SuppressWarnings("unchecked")
 	public boolean visit(MethodDeclaration node) {
 //		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		
 		// some info needed to create the Famix Method
 		IMethodBinding bnd = node.resolveBinding();
 		Type retTyp = node.getReturnType2();
@@ -157,60 +204,37 @@
 		for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
 				paramTypes.add(param.getType());
 		}
-		Method fmx = null;
-		if (retTyp != null) {
-			fmx = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
-					context.topClass());
-		}
-		else {
-			fmx = dico.ensureFamixMethod(bnd,
-					node.getName().getIdentifier(),
-					paramTypes,
-					null,   // probably a constructor
-					context.topClass());
-		}
+		// creating/recovering it
+		Method fmx = dico.ensureFamixMethod(bnd, node.getName().getIdentifier(), paramTypes,
+											(retTyp == null) ? null : dico.ensureFamixType(retTyp.resolveBinding(), retTyp.toString(), null),
+											context.topClass());
+		
 		if (node.getReturnType2() != null && node.getReturnType2().isParameterizedType()) {
 			//TODO fmx.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)node.getReturnType2()).typeArguments()));
 		}
 		
 		if (fmx != null) {
 			fmx.setIsStub(false);
+			
+			this.context.pushMethod(fmx);
+			if (node.getBody() != null) {
+				context.setTopMethodCyclo(1);
+			}
+
+			dico.addSourceAnchor(fmx, node);
+			dico.createFamixComment(node.getJavadoc(), fmx);
+
 			// creating the method's parameters
 			for (SingleVariableDeclaration param : (List<SingleVariableDeclaration>)node.parameters()) {
-				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), fmx);
+				fr.inria.verveine.core.gen.famix.Type paramTyp = dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null);
+				Parameter fmxParam = dico.ensureFamixParameter(param.resolveBinding(), param.getName().getIdentifier(), paramTyp, fmx);
 				if (fmxParam != null) {
 					fmxParam.setIsStub(false);
-				} else {
-					// Has no binding? It might be a Generic parameter
-					System.err.println("         Parameter="+param.getName().getIdentifier());
-					fmxParam = dico.createFamixParameter(param.getName().getIdentifier(), fmx, dico.ensureFamixType(param.getType().resolveBinding(), dico.findTypeName(param.getType()), null));
 				}
 				if (param.getType().isParameterizedType()) {
 					//TODO fmxParam.setDeclaredArgumentTypes(dico.ensureFamixTypes(((ParameterizedType)param.getType()).typeArguments()));
 				}
 			}
-			
-			dico.addSourceAnchor(fmx, node);
-			Javadoc jdoc = node.getJavadoc();
-			if (jdoc != null) {
-				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-				dico.addSourceAnchor(cmt, jdoc);
-			}
-			//Annotation
-			if (bnd != null) {
-				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-					dico.createFamixAnnotationInstance(fmx, annType);
-				}
-			}
-			this.context.pushMethod(fmx);
-			if (node.getBody() != null) {
-				context.setTopMethodCyclo(1);
-			}
-
 		}
 		return super.visit(node);	
 	}
@@ -228,7 +252,6 @@
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
 		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
-			IVariableBinding bnd = vd.resolveBinding();
 			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding(), vd.getName().getFullyQualifiedName(), dico.ensureFamixType(null, node.getType().toString(), null), context.topClass());
 
 			if (fmx != null) {
@@ -239,18 +262,7 @@
 			}
 
 			dico.addSourceAnchor(fmx, node);
-			Javadoc jdoc = node.getJavadoc();
-			if (jdoc != null) {
-				Comment cmt = dico.createFamixComment(jdoc.toString(), fmx);
-				dico.addSourceAnchor(cmt, jdoc);
-			}
-			//Annotation
-			if (bnd != null) {
-				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-					dico.createFamixAnnotationInstance(fmx, annType);
-				}
-			}
+			dico.createFamixComment(node.getJavadoc(), fmx);
 		}
 		return super.visit(node);
 	}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 87)
@@ -8,7 +8,9 @@
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ArrayType;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
 import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMemberValuePairBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.IPackageBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
@@ -20,10 +22,15 @@
 
 import ch.akuhn.fame.Repository;
 import fr.inria.verveine.core.Dictionary;
-import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationInstanceAttribute;
 import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.AnnotationTypeAttribute;
 import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.Class;
+import fr.inria.verveine.core.gen.famix.Comment;
 import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Enum;
+import fr.inria.verveine.core.gen.famix.EnumValue;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.LocalVariable;
@@ -34,7 +41,6 @@
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
 import fr.inria.verveine.core.gen.famix.SourcedEntity;
-import fr.inria.verveine.core.gen.famix.StructuralEntity;
 import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.core.gen.famix.UnknownVariable;
 
@@ -57,6 +63,7 @@
 	 * @param famixRepo
 	 */
 	public JavaDictionary(Repository famixRepo) {
+		// should check whether there is already one in the repository
 		super(famixRepo);
 	}
 
@@ -115,19 +122,26 @@
 	public Type ensureFamixType(ITypeBinding bnd, String name, ContainerEntity owner) {
 
 		if (bnd == null) {
-			return super.ensureFamixType(bnd, name, owner);
+			return super.ensureFamixType(null, name, owner);
 		}
 
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
+
+		if (bnd.isClass() || bnd.isInterface()) {
+			return this.ensureFamixClass(bnd, name, owner);
+		}
 		
 		if (bnd.isPrimitive()) {
 			return ensureFamixPrimitiveType(bnd, name);
 		}
-		else {
-			return this.ensureFamixClass(bnd, null, null);
+
+		if (bnd.isEnum()) {
+			return ensureFamixEnum(bnd, name, owner);
 		}
+		
+		return super.ensureFamixType(bnd, name, owner);
 	}
 	
 	public Collection<Type> ensureFamixTypesParameters(List<TypeParameter> types) {
@@ -157,24 +171,216 @@
 		}
 		return super.ensureFamixPrimitiveType(bnd, name);
 	}
-	
-	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd) {
 
+	public fr.inria.verveine.core.gen.famix.Enum ensureFamixEnum(ITypeBinding bnd, String name, ContainerEntity owner) {
+		fr.inria.verveine.core.gen.famix.Enum fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding, cannot create Famix Annotation Type");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixEnum(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IMethodBinding parentMtd = bnd.getDeclaringMethod();
+			if (parentMtd != null) {
+				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
+			}
+			else {
+				ITypeBinding parentClass = bnd.getDeclaringClass();
+				if (parentClass != null) {
+					owner = this.ensureFamixClass(parentClass, null, null);
+				}
+				else {
+					IPackageBinding parentPckg = bnd.getPackage();
+					if (parentPckg != null) {
+						owner = this.ensureFamixNamespace(parentPckg, null);
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// --------------- recover from name ?
+		for (fr.inria.verveine.core.gen.famix.Enum candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Enum.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixEnum(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public EnumValue ensureFamixEnumValue(IVariableBinding bnd,	String name, Enum owner) {
+		EnumValue fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				return null;  // what would be the interest of creating an EnumValue without a declaring Enum type? 
+			}
+			return super.ensureFamixEnumValue(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			owner = ensureFamixEnum(bnd.getDeclaringClass(), null, null);
+		}
+		
+		// --------------- recover from name ?
+		for (EnumValue candidate : getEntityByName(EnumValue.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+		if (fmx == null) {
+			fmx = super.ensureFamixEnumValue(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentEnum(owner);
+		}
+
+		return fmx;
+	}
+
+	public AnnotationType ensureFamixAnnotationType(ITypeBinding bnd, String name, ContainerEntity owner) {
+		AnnotationType fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationType(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			IPackageBinding parentPckg = bnd.getPackage();
+			if (parentPckg != null) {
+				owner = this.ensureFamixNamespace(parentPckg, null);
+			}
+			else {
+				owner = this.ensureFamixNamespaceDefault();
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationType candidate : getEntityByName(AnnotationType.class, name) ) {
+			if ( checkAndMapType(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationType(bnd, name, owner);
+		}
+		
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
+		return fmx;
+	}
+
+	public AnnotationTypeAttribute ensureFamixAnnotationTypeAttribute(IMethodBinding bnd, String name, AnnotationType owner) {
+		AnnotationTypeAttribute fmx = null;
+
+		// if Binding is null, we can only rely on provided parameters, so lets do it now and return
+		if (bnd == null) {
+			if (name == null) {
+				return null;
+			}
+			return super.ensureFamixAnnotationTypeAttribute(null, name, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
+		}
+
+		// --------------- owner
+		if (owner == null) {
+			ITypeBinding parentType = bnd.getDeclaringClass();
+			if (parentType != null) {
+				owner = this.ensureFamixAnnotationType(parentType, null, null);
+			}
+		}
+
+		// --------------- recover from name ?
+		for (AnnotationTypeAttribute candidate : getEntityByName(AnnotationTypeAttribute.class, name) ) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
+		}
+
+		if (fmx == null) {
+			fmx = super.ensureFamixAnnotationTypeAttribute(bnd, name, owner);
 		}
 		
-		AnnotationType fmx = ensureFamixUniqEntity(AnnotationType.class, null, bnd.getName());
-		fmx.setIsStub(true);
-		fmx.setContainer(ensureFamixNamespace(bnd.getPackage(), null));
-		mapToKey.put(bnd, fmx);
+		if (fmx!=null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			setNamedEntityModifiers(fmx, bnd.getModifiers());
+		}
+
 		return fmx;
 	}
 
+	public void addFamixAnnotationInstances(IBinding bnd, NamedEntity fmx) {
+		for (IAnnotationBinding annBnd : bnd.getAnnotations()) {
+			AnnotationType annType = ensureFamixAnnotationType(annBnd.getAnnotationType(), null, null);
+			
+			Collection<AnnotationInstanceAttribute> annAtts = new ArrayList<AnnotationInstanceAttribute>(); 
+			for (IMemberValuePairBinding annPV : annBnd.getDeclaredMemberValuePairs()) {
+				annAtts.add( createFamixAnnotationInstanceAttribute(ensureFamixAnnotationTypeAttribute(annPV.getMethodBinding(), annPV.getName(), annType), annPV.getValue().toString()));
+			}
+			
+			super.addFamixAnnotationInstance(fmx, annType, annAtts);
+		}
+	}
+
 	/**
 	 * Returns a Famix Class associated with the ITypeBinding.
-	 * The Entity is created if it does not exist.
+	 * The Entity is created if it does not exist.<br>
 	 * Params: see {@link Dictionary#ensureFamixClass(Object, String, ContainerEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
@@ -234,7 +440,7 @@
 		}
 
 		// --------------- owner
-		if ( (owner == null) && (bnd != null) ) {
+		if (owner == null) {
 			IMethodBinding parentMtd = bnd.getDeclaringMethod();
 			if (parentMtd != null) {
 				owner = this.ensureFamixMethod(parentMtd, null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
@@ -272,9 +478,9 @@
 		}
 
 		// --------------- recover from name ?
-		for (fr.inria.verveine.core.gen.famix.Class candidate : this.getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, name)) {
-			if ( recoverAndMapClass(bnd, candidate) ) {
-				fmx = candidate;
+		for (Type candidate : this.getEntityByName(Type.class, name)) {
+			if ( checkAndMapClass(bnd, candidate) ) {
+				fmx = (Class) candidate;
 				break;
 			}
 		}
@@ -299,74 +505,74 @@
 		return fmx;
 	}
 
-	private boolean recoverAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Namespace matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound package, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapNamespace(IPackageBinding bnd, Namespace candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		if (bnd.getName().equals(candidate.getName())) {
-			mapToKey.put(bnd, candidate);
-			return true;
-		}
-		return false;
+		// names are equals and bnd is not mapped, so let's do it
+		mapToKey.put(bnd, candidate);
+		return true;
 	}
 
-	private boolean recoverAndMapType(ITypeBinding bnd, Type candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Type matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * We also check that the actual class of the candidate matches (can be a sub-class of FamixType). 
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix NamedEntity (Class, Type, PrimitiveType, Enum, AnnotationType)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapType(ITypeBinding bnd, NamedEntity candidate) {
 		if (bnd.isArray()) {
 			bnd = bnd.getElementType();
 		}
-		
+
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 		
-		if ( (bnd.isClass() || bnd.isInterface()) &&
-			 (candidate instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-			return recoverAndMapClass(bnd, (fr.inria.verveine.core.gen.famix.Class) candidate);
-		}
-		else if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
-			if ( (bnd.isPrimitive()) && (bnd.toString().equals(candidate.getName())) ) {
-				mapToKey.put(bnd, candidate);
-				return true;
-			}
-			else {
-				return false;
-			}
+		if ( bnd.isClass() || bnd.isInterface() || bnd.isEnum() ) {
+			return checkAndMapClass(bnd, (Type) candidate);
 		}
-		else {
-			IMethodBinding methBnd = bnd.getDeclaringMethod();
-			if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-				if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
-					mapToKey.put(bnd, candidate);
-					return true;
-				}
-				else {
-					return false;
-				}
-			}
 
-			ITypeBinding classBnd = bnd.getDeclaringClass();
-			if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-				if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
-					mapToKey.put(bnd, candidate);
-					return true;
-				}
-				else {
-					return false;
-				}
-			}
-			
-			IPackageBinding pckgBnd = bnd.getPackage();
-			if ( (candidate.getBelongsTo() instanceof Namespace) &&
-				 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+		if ( bnd.isPrimitive() && (candidate instanceof PrimitiveType) ) {
+			// names are equal so it's OK
+			mapToKey.put(bnd, candidate);
+			return true;
+		}
+		
+		if (bnd.isAnnotation() && (candidate instanceof AnnotationType) ) {
+			if (checkAndMapNamespace(bnd.getPackage(), (Namespace) candidate.getBelongsTo())) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -374,20 +580,48 @@
 				return false;
 			}
 		}
+		
+		return false;
 	}
 
-	private boolean recoverAndMapClass(ITypeBinding bnd, fr.inria.verveine.core.gen.famix.Class candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix Class (or Interface or Enum) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound type, and checks recursively that owners also match.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapClass(ITypeBinding bnd, Type candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+		
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
-			return true;
+			if ( (bnd.isClass() || bnd.isInterface()) && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Class)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixClass: "+candidate.getName());
+				return false;
+			}
+			else if ( bnd.isEnum() && (! (candidate instanceof fr.inria.verveine.core.gen.famix.Enum)) ) {
+				System.err.println("JavaDictionary.checkAndMapClass() found a FamixType that should be a FamixEnum: "+candidate.getName());
+				return false;
+			}
+			else {
+				return true;
+			}
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+		// names match, 'bnd' was not bound, check the owners
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
+		IMethodBinding methBnd = bnd.getDeclaringMethod(); // for classes, can enum be declared in methods?
+		if ( (methBnd != null) && (candidateOwner instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -397,8 +631,8 @@
 		}
 
 		ITypeBinding classBnd = bnd.getDeclaringClass();
-		if ( (classBnd != null) && (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) ) {
-			if ( recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo()) ) {
+		if ( (classBnd != null) && (candidateOwner instanceof fr.inria.verveine.core.gen.famix.Class) ) {
+			if ( checkAndMapClass(classBnd, (Type)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -408,8 +642,8 @@
 		}
 
 		IPackageBinding pckgBnd = bnd.getPackage();
-		if ( (candidate.getBelongsTo() instanceof Namespace) &&
-			 (recoverAndMapNamespace(pckgBnd, (Namespace) candidate.getBelongsTo())) ) {
+		if ( (candidateOwner instanceof Namespace) &&
+			 (checkAndMapNamespace(pckgBnd, (Namespace)candidateOwner)) ) {
 			mapToKey.put(bnd, candidate);
 			return true;
 		}
@@ -418,46 +652,87 @@
 		}
 	}
 
-	private boolean recoverAndMapMethod(IMethodBinding bnd, Method candidate) {
+	/**
+	 * Checks whether the existing unmapped Famix "Method" matches the binding.
+	 * Checks that the candidate has the same name and same signature as the JDT bound method, and checks recursively that owners also match.
+	 * Note that AnnotationTypeAttribute are treated as methods by JDT, so they are checked here.
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (regular Method or AnnotationTypeAttribute)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapMethod(IMethodBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
 		NamedEntity bound = getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
 		else if (bound != null) {
+			// already bound to something else
+			// May be should continue to see if we need to merge two FamixEntities representing the same thing .... ?
+			// Not sure it does actually happen
 			return false;
 		}
 
-		// for methods, the name is not enough, we must test the signature also 
-		String sig = bnd.getName() + "(";
-		boolean first = true;
-		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
-			if (! first) {
-				sig += "," + parBnd.getName();
+		// for methods, the name is not enough, we must test the signature also ...
+		// for AnnotationTypeAttribute, we don't need this
+		if (candidate instanceof Method) {
+			String sig = bnd.getName() + "(";
+			boolean first = true;
+			for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+				if (! first) {
+					sig += "," + parBnd.getName();
+				}
+				else {
+					sig += parBnd.getName();
+					first = false;
+				}
+				sig += ")";
 			}
-			else {
-				sig += parBnd.getName();
-				first = false;
+			if (! ((Method) candidate).getSignature().equals(sig)) {
+				return false;
 			}
-			sig += ")";
-		}
-		if (! candidate.getSignature().equals(sig)) {
-			return false;
+
+			// ... and the signature should include the return type
+			if (! checkAndMapType(bnd.getReturnType(), ((Method) candidate).getDeclaredType()) ) {
+				return false;
+			}
 		}
 
+		// finally let's check the owners
 		ITypeBinding ownerBnd = bnd.getDeclaringClass();
-		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
-			 (recoverAndMapClass(ownerBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+		NamedEntity candidateOwner = candidate.getBelongsTo();
+		if ( (candidateOwner  instanceof fr.inria.verveine.core.gen.famix.Class) &&
+				 (checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
 				mapToKey.put(bnd, candidate);
-				// everything seems OK, but we still need to test return type which is not in the Moose signature
-				return recoverAndMapType(bnd.getReturnType(), candidate.getDeclaredType());
+				return true;
+			}
+		else if ( (candidateOwner instanceof AnnotationType) &&
+				(checkAndMapClass(ownerBnd, (Type)candidateOwner)) ) {
+			mapToKey.put(bnd, candidate);
+			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
-	private boolean recoverAndMapVariable(IVariableBinding bnd, StructuralEntity candidate) {
-		NamedEntity bound = (StructuralEntity)getEntityByKey(bnd); 
+	/**
+	 * Checks whether the existing unmapped Famix "Variable" (Attribute, Parameter, ...) matches the binding.
+	 * Checks that the candidate has the same name as the JDT bound variable, and checks recursively that owners also match.
+	 * The Famix candidate is a NamedEntity and not a StructuralEntity to allow dealing with Famix EnumValue that JDT treats as variables
+	 * @param bnd -- a JDT binding that we are trying to match to the candidate
+	 * @param candidate -- a Famix Entity (a StructuralEntity or an EnumValue)
+	 * @return whether the binding matches the candidate (if <b>true</b>, the mapping is recorded)
+	 */
+	private boolean checkAndMapVariable(IVariableBinding bnd, NamedEntity candidate) {
+		if (! bnd.getName().equals(candidate.getName())) {
+			return false;
+		}
+
+		NamedEntity bound = (NamedEntity)getEntityByKey(bnd); 
 		if (bound == candidate) {
 			return true;
 		}
@@ -465,9 +740,10 @@
 			return false;
 		}
 
+		ContainerEntity candidateOwner = candidate.getBelongsTo();
 		IMethodBinding methBnd = bnd.getDeclaringMethod();
-		if ( (methBnd != null) && (candidate.getBelongsTo() instanceof Method) ) {
-			if ( recoverAndMapMethod(methBnd, (Method) candidate.getBelongsTo()) ) {
+		if ( (methBnd != null) && (candidateOwner  instanceof Method) ) {
+			if ( checkAndMapMethod(methBnd, (Method)candidateOwner) ) {
 				mapToKey.put(bnd, candidate);
 				return true;
 			}
@@ -477,8 +753,8 @@
 		}
 
 		ITypeBinding classBnd = bnd.getDeclaringClass();
-		if ( (candidate.getBelongsTo() instanceof fr.inria.verveine.core.gen.famix.Class) &&
-			 (recoverAndMapClass(classBnd, (fr.inria.verveine.core.gen.famix.Class) candidate.getBelongsTo())) ) {
+		if ( (candidateOwner instanceof Type) &&
+			 (checkAndMapType(classBnd, (Type)candidateOwner)) ) {
 			mapToKey.put(bnd, candidate);
 			return true;
 		}
@@ -489,9 +765,8 @@
 
 	/**
 	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
+	 * The Entity is created if it does not exist.
+	 * Params: see {@link Dictionary#ensureFamixMethod(Object, String, String, Type, Type)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Method ensureFamixMethod(IMethodBinding bnd, String name, Collection<org.eclipse.jdt.core.dom.Type> paramTypes, Type ret, fr.inria.verveine.core.gen.famix.Class owner) {
@@ -571,7 +846,7 @@
 		
 		// --------------- recover from name ?
 		for (Method candidate : this.getEntityByName(Method.class, name)) {
-			if ( recoverAndMapMethod(bnd, candidate) ) {
+			if ( checkAndMapMethod(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -612,9 +887,10 @@
 	}
 
 	/**
-	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.<br>
-	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)} 
-	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
+	 * Returns a Famix Attribute associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixAttribute(Object, String, Type, Type)}.
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
 	public Attribute ensureFamixAttribute(IVariableBinding bnd, String name, Type type, Type owner) {
 		Attribute fmx = null;
@@ -625,7 +901,7 @@
 				return null;
 			}
 			if (owner == null) {
-				return null;  // what would be the interest of an attribute for which we ignore the declaring class? 
+				return null;  // what would be the interest of creating an attribute for which we ignore the declaring class? 
 			}
 			return super.ensureFamixAttribute(null, name, type, owner);
 		}
@@ -639,7 +915,6 @@
 		if (type == null) {
 			type = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
@@ -648,7 +923,7 @@
 		
 		// --------------- recover from name ?
 		for (Attribute candidate : getEntityByName(Attribute.class, name) ) {
-			if ( recoverAndMapVariable(bnd, candidate) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -685,52 +960,62 @@
 	}
 
 	/**
-	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
-	 * The JDT Binding is a unique representation of a java entity within the AST.
-	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
-	 * @param bnd -- the JDT Binding 
+	 * Returns a Famix Parameter associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
+	 * Params: see {@link Dictionary#ensureFamixParameter(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}.
 	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
 	 */
-	public Parameter ensureFamixParameter(IVariableBinding bnd, Method owner) {
-		boolean wasBound = false;
-		
+	public Parameter ensureFamixParameter(IVariableBinding bnd, String name, Type typ, Method owner) {
+		Parameter fmx = null;
+
 		if (bnd == null) {
-			System.err.println("Warning: Unexpected null binding to Famix Parameter");
-			return null;
+			if (name == null) {
+				return null;
+			}
+			if (owner == null) {
+				owner = ensureFamixStubMethod("<"+name+"_owner>");
+			}
+			return super.ensureFamixParameter(null, name, typ, owner);
+		}
+
+		// --------------- name
+		if (name == null) {
+			name = bnd.getName();
 		}
 
+		// --------------- return type
+		if (typ == null) {
+			typ = this.ensureFamixType(bnd.getType(), null, null);
+		}
+
+		// --------------- owner
 		if (owner == null) {
 			owner = ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null);  // cast needed to desambiguate the call
 		}
 		
-		// actually it seems to be very little chances that the parameter already exist.
-		// but who knows? Does not hurt to try
-		Parameter fmx = (Parameter) getEntityByKey(bnd);
-		
-		if (fmx != null) {
-			wasBound = true;
+		// --------------- recover from name ?
+		for (Parameter candidate : getEntityByName(Parameter.class, name) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
+				fmx = candidate;
+				break;
+			}
 		}
-		else {
-			wasBound = false;
-			fmx = (Parameter) ensureFamixEntity(Parameter.class, bnd, bnd.getName());
+		if (fmx == null) {
+			fmx = super.ensureFamixParameter(bnd, name, typ, owner);
 		}
 		
-		if ( (fmx!=null) && (! wasBound) ) {
-			// declaring method
-			if (bnd.getDeclaringMethod() != null) {
-				fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod(), null, (Collection<org.eclipse.jdt.core.dom.Type>)null, null, null));  // cast needed to desambiguate the call
-			} else {
-				fmx.setParentBehaviouralEntity(owner);
-			}
-			// type of the attribute
-			fmx.setDeclaredType(this.ensureFamixType(bnd.getType(), null, null));
+		if (fmx != null) {
+			// we just created it or it was not bound, so we make sure it has the right information in it
+			fmx.setParentBehaviouralEntity(owner);
+			fmx.setDeclaredType(typ);	
 		}
-		
+
 		return fmx;
 	}
 	
 	/**
-	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * Returns a Famix LocalVariable associated with the IVariableBinding.
+	 * The Entity is created if it does not exist.<br>
 	 * Params: see {@link Dictionary#ensureFamixLocalVariable(Object, String, Type, fr.inria.verveine.core.gen.famix.BehaviouralEntity)}
 	 * @return the Famix Entity found or created. May return null if <b>bnd</b> and <b>name</b> are null, or <b>bnd</b> and <b>owner</b> are null, or in case of a Famix error
 	 */
@@ -756,7 +1041,6 @@
 		if (typ == null) {
 			typ = this.ensureFamixType(bnd.getType(), null, null);
 		}
-		// else leave it to null ...
 
 		// --------------- owner
 		if (owner == null) {
@@ -765,7 +1049,7 @@
 		
 		// --------------- recover from name ?
 		for (LocalVariable candidate : getEntityByName(LocalVariable.class, name) ) {
-			if ( recoverAndMapVariable(bnd, candidate) ) {
+			if ( checkAndMapVariable(bnd, candidate) ) {
 				fmx = candidate;
 				break;
 			}
@@ -788,26 +1072,20 @@
 	 */
 	public UnknownVariable createFamixUnknownVariable(Type type, String name) {
 //		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
-		UnknownVariable fmx = (UnknownVariable) createFamixEntity(UnknownVariable.class, name);
+		UnknownVariable fmx = (UnknownVariable) createFamixNamedEntity(UnknownVariable.class, name);
 		if (fmx!=null) {
 			fmx.setDeclaredType(type);
 		}
 		return fmx;
 	}
-	
-	/**
-	 * Creates and returns a FAMIX AnnotationInstance and associates it with an Entity and an AnnotationType
-	 * @param name -- the name (String) of the annotation 
-	 * @param owner -- the entity concerned by this annotation
-	 * @return the FAMIX AnnotationInstance
-	 */
-	public AnnotationInstance createFamixAnnotationInstance(SourcedEntity owner, AnnotationType annType) {
-		AnnotationInstance fmx = new AnnotationInstance();
-		fmx.setAnnotatedEntity(owner);
-		fmx.setAnnotationType(annType);
-		this.famixRepo.add(fmx);
-		
-		return fmx;
+
+	public Comment createFamixComment(org.eclipse.jdt.core.dom.Comment jdoc, NamedEntity fmx) {
+		Comment cmt = null;
+		if (jdoc != null) {
+			cmt = createFamixComment(jdoc.toString(), fmx);
+			addSourceAnchor(cmt, jdoc);
+		}
+		return cmt;
 	}
 
 	/**
@@ -898,7 +1176,7 @@
 	 */
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
 		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
-		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 
 		return fmx;
 	}
@@ -912,7 +1190,7 @@
 	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassArray() {
 		fr.inria.verveine.core.gen.famix.Class fmx = ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, ARRAYS_NAME);
 		if (fmx != null) {
-			ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+			ensureFamixInheritance(ensureFamixClassObject(null), fmx, /*prev*/null);
 			fmx.setContainer( ensureFamixNamespaceDefault());
 			
 			fmx.setIsAbstract(Boolean.FALSE);
@@ -926,7 +1204,6 @@
 		return fmx;
 	}
 
-
 	public String removeLastName(String qualifiedName) {
 		String ret = null;
 		int last = qualifiedName.lastIndexOf('.');
@@ -941,4 +1218,6 @@
 		return ret;
 	}
 
+
+
 }
\ No newline at end of file
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 87)
@@ -35,7 +35,6 @@
 	public String[] getInitialArgs() {
 		return this.initialArgs;
 	}
-	
 
 	@Override
 	public boolean compile(String[] argv) {
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 86)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 87)
@@ -16,6 +16,7 @@
 	public FamixRequestor(Repository r, String[] initialArgs) {
 		this.famixRepo = r;
 		this.initialArgs = initialArgs;
+
 		this.famixDictionnary = new JavaDictionary(famixRepo);
 	}
 
Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 50)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 51)
@@ -121,9 +121,11 @@
 			dico.addSourceAnchor(cmt, jdoc);
 		}
 		//Annotation
-		for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-			AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-			dico.createFamixAnnotationInstance(fmx, annType);
+		if (bnd != null) {
+			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+				dico.createFamixAnnotationInstance(fmx, annType);
+			}
 		}
 		this.context.pushClass(fmx);
 		return super.visit(node);
@@ -191,9 +193,11 @@
 				dico.addSourceAnchor(cmt, jdoc);
 			}
 			//Annotation
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
+			if (bnd != null) {
+				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+					dico.createFamixAnnotationInstance(fmx, annType);
+				}
 			}
 			this.context.pushMethod(fmx);
 			if (node.getBody() != null) {
@@ -238,9 +242,11 @@
 				dico.addSourceAnchor(cmt, jdoc);
 			}
 			//Annotation
-			for (IAnnotationBinding abnd : bnd.getAnnotations()) {
-				AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
-				dico.createFamixAnnotationInstance(fmx, annType);
+			if (bnd != null) {
+				for (IAnnotationBinding abnd : bnd.getAnnotations()) {
+					AnnotationType annType = dico.ensureFamixAnnotationType(abnd.getAnnotationType());
+					dico.createFamixAnnotationInstance(fmx, annType);
+				}
 			}
 		}
 		return super.visit(node);
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/SequSynchro.java	(revision 23)
@@ -0,0 +1,28 @@
+package OMGL2;
+import java.io.BufferedReader;
+
+
+public class SequSynchro {
+
+	public static void parcours(BufferedReader in_cli, BufferedReader in_four) {
+		Client cli;
+		Fournisseur four;
+		
+		cli = Client.lire(in_cli);
+		four = Fournisseur.lire(in_four);
+		while ( (cli != null) && (four != null) ) {
+			if (four.estFournisseur(cli)) {
+				System.out.println(cli.toString()+" a pour fournisseur: ["+four.getNum()+"] "+four.getNom());
+				cli = Client.lire(in_cli);
+				four = Fournisseur.lire(in_four);
+			}
+			else if (cli.getNum().compareTo(four.getNumCli()) < 0) {
+				cli = Client.lire(in_cli);
+			}
+			else {
+				four = Fournisseur.lire(in_four);
+			}
+		}
+	}
+	
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Fournisseur.java	(revision 23)
@@ -0,0 +1,81 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+public class Fournisseur {
+
+	private String num;
+	private String nom;
+	private String numCli;
+	
+	public Fournisseur(String num, String nom, String numCli) {
+		this.setNum(num);
+		this.setNom(nom);
+		this.setNumCli(numCli);
+	}
+
+	public static Fournisseur lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		String numCli = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				if (c != '.') {
+					c = (char)in.read();
+				}
+				nom += c;
+			}
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				numCli += c;
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Fournisseur(num, nom, numCli);
+		
+	}
+
+	public String toString() {
+		return "fournisseur: ["+getNum()+"] "+getNom()+" du client no. "+getNumCli();
+	}
+	
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+
+	public void setNumCli(String numCli) {
+		this.numCli = numCli;
+	}
+
+	public String getNumCli() {
+		return numCli;
+	}
+
+	
+	public boolean estFournisseur(Client cli) {
+		return getNumCli().equals(cli.getNum());
+	}
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Main.java	(revision 23)
@@ -0,0 +1,30 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.StringReader;
+
+
+
+public class Main {
+
+	public static void main(String[] args) throws IOException {
+		//mainFiles();
+		mainStrings();
+	}
+
+	public static void mainFiles() throws IOException {
+		File client = new File("client.dat") ;
+	    File fourni =  new File("fournisseur.dat");
+
+	    SequSynchro.parcours(new BufferedReader(new FileReader(client)), new BufferedReader(new FileReader(fourni)));
+	}
+
+	public static void mainStrings() throws IOException {
+		String client = "00001Jean Valjean.00002Bernard Lermitte.";
+	    String fourni =  "10001Thibeaudeau et frere.0000110002Chez Marius.00002";
+
+	    SequSynchro.parcours(new BufferedReader(new StringReader(client)), new BufferedReader(new StringReader(fourni)));
+	}
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/ReadException.java	(revision 23)
@@ -0,0 +1,4 @@
+package OMGL2;
+public class ReadException extends Exception {
+
+}
Index: verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java
===================================================================
--- verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 0)
+++ verveine.extractor.java/test_src/ad_hoc/OMGL2/Client.java	(revision 23)
@@ -0,0 +1,62 @@
+package OMGL2;
+import java.io.BufferedReader;
+import java.io.IOException;
+
+
+
+
+public class Client {
+
+	private String num;
+	private String nom;
+	
+	public Client(String num, String nom) {
+		this.setNum(num);
+		this.setNom(nom);
+	}
+
+	public static Client lire(BufferedReader in) throws ReadException {
+		String nom = "";
+		String num = "";
+		char c = ' ';
+		
+		try {
+			for (int i=0; (i<5) && in.ready(); i++) {
+				c = (char)in.read();
+				num += c;
+			}
+			while ( in.ready() && (c != '.')) {
+				c = (char)in.read();
+				if (c != '.') {
+					nom += c;
+				}
+			}
+		} catch (IOException e) {
+			throw new ReadException();
+			return null;
+		}
+		
+		return new Client(num, nom);
+		
+	}
+
+	public String toString() {
+		return "client: ["+getNum()+"] "+getNom();
+	}
+	
+	public void setNum(String num) {
+		this.num = num;
+	}
+
+	public String getNum() {
+		return num;
+	}
+
+	public void setNom(String nom) {
+		this.nom = nom;
+	}
+
+	public String getNom() {
+		return nom;
+	}
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 22)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 23)
@@ -1,484 +0,0 @@
-/**
- * Copyright (c) 2010 Simon Denier
- */
-package tests.fr.inria.verveine.extractor.java;
-
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-import java.util.Collection;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import test.fr.inria.verveine.core.TestVerveineUtils;
-import ch.akuhn.fame.Repository;
-import fr.inria.verveine.core.gen.famix.Access;
-import fr.inria.verveine.core.gen.famix.Attribute;
-import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
-import fr.inria.verveine.core.gen.famix.Comment;
-import fr.inria.verveine.core.gen.famix.FileAnchor;
-import fr.inria.verveine.core.gen.famix.Inheritance;
-import fr.inria.verveine.core.gen.famix.Invocation;
-import fr.inria.verveine.core.gen.famix.LocalVariable;
-import fr.inria.verveine.core.gen.famix.Method;
-import fr.inria.verveine.core.gen.famix.Namespace;
-import fr.inria.verveine.core.gen.famix.Parameter;
-import fr.inria.verveine.core.gen.famix.PrimitiveType;
-import fr.inria.verveine.core.gen.famix.SourceAnchor;
-import fr.inria.verveine.extractor.java.JavaDictionary;
-import fr.inria.verveine.extractor.java.VerveineJParser;
-
-/**
- * @author Simon Denier
- * @since May 28, 2010
- *
- */
-public class VerveineExtractorJavaTest {
-
-	private static final String A_CLASS_NAME = "--aClassName--";
-
-	private Repository repo;
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp() throws Exception {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/LANModel"});
-		parser.renameNamespaces();
-		repo = parser.getFamixRepo();
-	}
-
-	@Test
-	public void testEntitiesNumber() {
-		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
-		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
-		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
-		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
-		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
-		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
-		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
-		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
-		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
-		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
-	}
-
-	@Test
-	public void testClassProperties() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		assertEquals("Node", nodeClass.getName());
-		assertEquals(11, nodeClass.getMethods().size());
-		assertEquals(2, nodeClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
-		assertFalse(nodeClass.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
-		assertNotNull(interfce);
-		assertEquals("IPrinter", interfce.getName());
-		assertEquals(1, interfce.getMethods().size());
-		assertEquals(0, interfce.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
-		assertTrue(interfce.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
-		assertNotNull(innerClass);
-		assertEquals("XPrinter", innerClass.getName());
-		assertEquals(2, innerClass.getMethods().size());
-		assertEquals(1, innerClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
-		assertFalse(innerClass.getIsInterface());
-
-		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
-		assertNotNull(anonClass);
-		assertEquals("anonymous(IPrinter)", anonClass.getName());
-		assertEquals(1, anonClass.getMethods().size());
-		assertEquals(0, anonClass.getAttributes().size());
-		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
-		assertFalse(anonClass.getIsInterface());
-	}
-
-	@Test
-	public void testNamedEntities() {
-		JavaDictionary dico = new JavaDictionary(repo);
-		
-		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
-		
-		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
-		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
-		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
-
-		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
-		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
-		assertSame(obj, dico.ensureFamixClassObject(null));
-		assertEquals(0, obj.getSuperInheritances().size());
-		assertSame(javaLang, obj.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
-		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
-		assertSame(fmx, dico.ensureFamixClassStubOwner());
-	}
-
-	@Test
-	public void testInheritance() {
-		fr.inria.verveine.core.gen.famix.Class clazz;
-		Collection<Inheritance> superInheritances;
-		Inheritance inh;
-		
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
-		assertNotNull(clazz);
-		superInheritances = clazz.getSuperInheritances();
-		assertEquals(1, superInheritances.size());
-		inh = superInheritances.iterator().next();
-		assertSame(clazz, inh.getSubclass());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
-
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		superInheritances = clazz.getSuperInheritances();
-		assertEquals(1, superInheritances.size());
-		inh = superInheritances.iterator().next();
-		assertSame(clazz, inh.getSubclass());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
-	}
-
-	@Test
-	public void testMethodProperties() {
-		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
-		assertNotNull(mweb);
-		assertEquals("methodWithEmptyBody", mweb.getName());
-		assertEquals("methodWithEmptyBody()", mweb.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
-
-		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
-		assertNotNull(em);
-		assertEquals("equalsMultiple", em.getName());
-		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
-
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
-		assertNotNull(clazz);
-		Method n = null;
-		for (Method m : clazz.getMethods()) {
-			if (m.getName().equals("name")) {
-				n = m;
-				break;
-			}
-		}
-		assertNotNull(n);
-		assertEquals("name", n.getName());
-		assertEquals("name()", n.getSignature());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
-		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
-	}
-
-	@Test
-	public void testFieldType() {
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		Collection<Attribute> l_atts = clazz.getAttributes();
-		assertEquals(2, l_atts.size());
-		for (Attribute a : l_atts) {
-			if (a.getName().equals("nextNode")) {
-				assertSame(clazz, a.getParentType());
-				assertSame(clazz, a.getDeclaredType());
-			}
-			else if (a.getName().equals("name")) {
-				assertSame(clazz, a.getParentType());
-				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
-			}
-		}
-	}
-
-	@Test
-	public void testStubs() {
-		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
-		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
-		assertNotNull(ns);
-		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
-		assertTrue(ns.getIsStub());
-			
-		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
-		assertNotNull(obj);
-		assertTrue(ns.getIsStub());
-		assertSame(ns, obj.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
-		assertNotNull(str);
-		assertTrue(str.getIsStub());
-		assertSame(ns, str.getContainer());
-		
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-		assertFalse(clazz.getIsStub());
-		
-		/* [].length notused in the default test case 
-		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
-		assertNotNull(att);
-		clazz = (Class) att.getParentType();
-		assertNotNull(clazz);
-		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
-	}
-
-	@Test
-	public void testParameter() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		for (Method mNode : nodeClass.getMethods()) {
-			if ( (mNode.getName().equals("Node")) ||
-				 (mNode.getName().equals("methodWithEmptyBody")) ||
-				 (mNode.getName().equals("canOriginate")) ||
-				 (mNode.getName().equals("canOutput")) ) {
-				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
-			}
-			else if ( (mNode.getName().equals("name")) ||
-					  (mNode.getName().equals("nextNode")) ) {
-				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
-			}
-			else if ( (mNode.getName().equals("accept")) ||
-					 (mNode.getName().equals("send")) ||
-					 (mNode.getName().equals("printOn")) ) {
-				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
-			}
-		}
-		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
-		assertNotNull(iprintClass);
-		Method mPrint = iprintClass.getMethods().iterator().next();
-		assertEquals(2, mPrint.getParameters().size());
-		for (Parameter p : mPrint.getParameters()) {
-			assertSame(mPrint, p.getParentBehaviouralEntity());
-			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
-			if (p.getName().equals("contents")) {
-				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
-			}
-			if (p.getName().equals("rv")) {
-				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
-			}
-		}
-	}
-
-	@Test
-	public void testInvocation() {
-		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(nodeClass);
-		for (Method mNode : nodeClass.getMethods()) {
-			if ( (mNode.getName().equals("name")) ||
-				 (mNode.getName().equals("nextNode")) ||
-				 (mNode.getName().equals("methodWithEmptyBody")) ||
-				 (mNode.getName().equals("canOutput")) ||
-				 (mNode.getName().equals("canOriginate")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
-			}
-			else if ( (mNode.getName().equals("Node")) ||
-					  (mNode.getName().equals("accept")) ) {
-				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
-			}
-			else if (mNode.getName().equals("send"))  {
-				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
-			}
-			else if (mNode.getName().equals("printOn")) {
-				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
-			}
-		}
-		
-		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
-		assertNotNull(sdaClass);
-		for (Method mSDA : sdaClass.getMethods()) {
-			for (Invocation inv : mSDA.getOutgoingInvocations()) {
-				assertTrue( "Unexpected method signature: "+inv.getSignature(),
-							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
-				if (inv.getSignature().equals("equalsSingle (String)")) {
-					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
-					assertEquals("self", inv.getReceiver().getName());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
-				}
-				else if (inv.getSignature().equals("id ()")) {
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
-					assertEquals("self", inv.getReceiver().getName());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
-				}
-				else if (inv.getSignature().equals("equals (Object)")) {
-					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
-					assertEquals(null, inv.getReceiver());
-					assertEquals(1, inv.getCandidates().size());
-					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
-				}
-			}
-		}
-	}
-	
-	@Test
-	public void testAccess() {
-		Attribute att;
-		BehaviouralEntity accessor;
-		
-		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
-		assertNotNull(att);
-		assertSame(2, att.getIncomingAccesses().size());
-		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
-		assertSame(Method.class, accessor.getClass());
-		assertEquals("name", accessor.getName());
-		assertEquals("Node", ((Method)accessor).getParentType().getName());
-
-		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
-		assertNotNull(att);
-		assertSame(1, att.getIncomingAccesses().size());
-		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
-		assertSame(Method.class, accessor.getClass());
-		assertEquals("setServerType", accessor.getName());
-		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
-
-		// finds method PrintServer.output()
-		Method output = null;
-		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
-			if (m.getParentType().getName().equals("PrintServer")) {
-				output = m;
-				break;
-			}
-		}
-		assertNotNull(output);
-		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
-		for (Access acc : output.getAccesses()) {
-			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
-						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
-			assertEquals(output, acc.getAccessor());
-		}
-	}
-
-	@Test
-	public void testSourceAnchors() {
-		SourceAnchor anc = null;
-		
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
-		assertNotNull(clazz);
-
-		anc = clazz.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(clazz, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
-		assertEquals(17, ((FileAnchor)anc).getStartLine());
-		assertEquals(31, ((FileAnchor)anc).getEndLine());
-
-		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
-		assertNotNull(clazz);
-
-		anc = clazz.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(clazz, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
-		assertEquals(6, ((FileAnchor)anc).getStartLine());
-		assertEquals(70, ((FileAnchor)anc).getEndLine());
-		
-		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
-		assertNotNull(meth);
-
-		anc = meth.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(meth, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
-		assertEquals(39, ((FileAnchor)anc).getStartLine());
-		assertEquals(41, ((FileAnchor)anc).getEndLine());
-		
-		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
-		assertNotNull(meth);
-
-		anc = att.getSourceAnchor();
-		assertNotNull(anc);
-		assertSame(att, anc.getElement());
-		assertSame(FileAnchor.class, anc.getClass());
-		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
-		assertEquals(15, ((FileAnchor)anc).getStartLine());
-		assertEquals(15, ((FileAnchor)anc).getEndLine());
-		
-	}
-
-	@Test
-	public void testModifiers() {
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
-		assertNotNull(clazz);
-		assertFalse(clazz.getIsInterface());
-		assertTrue(clazz.getIsAbstract());
-		assertTrue(clazz.getModifiers().contains("abstract"));
-		assertTrue(clazz.getIsPublic());
-		assertFalse(clazz.getIsPrivate());
-		assertFalse(clazz.getIsProtected());
-		assertFalse(clazz.getIsFinal());
-		
-		assertEquals(3, clazz.getMethods().size());
-		for (Method m : clazz.getMethods()) {
-			assertTrue(m.getIsPublic());
-			assertFalse(m.getIsPrivate());
-			assertFalse(m.getIsProtected());
-			assertFalse(m.getIsFinal());
-			if (m.getName().equals("output")) {
-				assertTrue(m.getIsAbstract());
-			}
-			else {
-				assertFalse(m.getIsAbstract());
-			}
-		}
-		
-		assertEquals(1, clazz.getAttributes().size());
-		Attribute a = clazz.getAttributes().iterator().next();
-		assertFalse(a.getIsPublic());
-		assertFalse(a.getIsPrivate());
-		assertTrue(a.getIsProtected());
-		assertFalse(a.getIsFinal());
-	}
-
-	@Test
-	public void testComment() {	
-		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
-		assertNotNull(clazz);
-		Collection<Comment> cmts = clazz.getComments();
-		assertEquals(1, cmts.size());
-		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
-		assertEquals(6, ((FileAnchor)anc).getStartLine());
-		assertEquals(10, ((FileAnchor)anc).getEndLine());
-
-		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
-		assertNotNull(meth);
-		cmts = meth.getComments();
-		assertEquals(1, cmts.size());
-		anc = cmts.iterator().next().getSourceAnchor();
-		assertEquals(31, ((FileAnchor)anc).getStartLine());
-		assertEquals(34, ((FileAnchor)anc).getEndLine());
-
-	}
-	
-	@Test
-	public void testMetric() {	
-		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
-			assertNotNull(m);
-			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
-			assertNotNull(owner);
-			if (owner.getName().equals("OutputServer")) {
-			assertEquals(2, m.getCyclo());
-				assertEquals(6, m.getNOS());
-			}
-			else if (owner.getName().equals("Node")) {
-				assertEquals(1, m.getCyclo());
-				assertEquals(1, m.getNOS());
-			}
-			else if (owner.getName().equals("WorkStation")) {
-				assertEquals(2, m.getCyclo());
-				assertEquals(7, m.getNOS());
-			}
-		}		
-	}
-
-}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 23)
@@ -0,0 +1,484 @@
+/**
+ * Copyright (c) 2010 Simon Denier
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Collection;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Comment;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.PrimitiveType;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.extractor.java.JavaDictionary;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Simon Denier
+ * @since May 28, 2010
+ *
+ */
+public class VerveineJTest_LanModel {
+
+	private static final String A_CLASS_NAME = "--aClassName--";
+
+	private Repository repo;
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/LANModel"});
+		parser.renameNamespaces();
+		repo = parser.getFamixRepo();
+	}
+
+	@Test
+	public void testEntitiesNumber() {
+		assertEquals(11+8, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(3, TestVerveineUtils.selectElementsOfType(repo,PrimitiveType.class).size());//int,boolean,void
+		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+4, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,java.lang,java.io,java}
+		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
+		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+	}
+
+	@Test
+	public void testClassProperties() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		assertEquals("Node", nodeClass.getName());
+		assertEquals(11, nodeClass.getMethods().size());
+		assertEquals(2, nodeClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "lan"), nodeClass.getContainer());
+		assertFalse(nodeClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class interfce = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(interfce);
+		assertEquals("IPrinter", interfce.getName());
+		assertEquals(1, interfce.getMethods().size());
+		assertEquals(0, interfce.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo, Namespace.class, "server"), interfce.getContainer());
+		assertTrue(interfce.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(innerClass);
+		assertEquals("XPrinter", innerClass.getName());
+		assertEquals(2, innerClass.getMethods().size());
+		assertEquals(1, innerClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
+		assertFalse(innerClass.getIsInterface());
+
+		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
+		assertNotNull(anonClass);
+		assertEquals("anonymous(IPrinter)", anonClass.getName());
+		assertEquals(1, anonClass.getMethods().size());
+		assertEquals(0, anonClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
+		assertFalse(anonClass.getIsInterface());
+	}
+
+	@Test
+	public void testNamedEntities() {
+		JavaDictionary dico = new JavaDictionary(repo);
+		
+		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
+		
+		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
+		assertEquals( JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
+		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
+
+		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
+		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
+		assertSame(obj, dico.ensureFamixClassObject(null));
+		assertEquals(0, obj.getSuperInheritances().size());
+		assertSame(javaLang, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
+		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
+		assertSame(fmx, dico.ensureFamixClassStubOwner());
+	}
+
+	@Test
+	public void testInheritance() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<Inheritance> superInheritances;
+		Inheritance inh;
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
+	}
+
+	@Test
+	public void testMethodProperties() {
+		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
+		assertNotNull(mweb);
+		assertEquals("methodWithEmptyBody", mweb.getName());
+		assertEquals("methodWithEmptyBody()", mweb.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "void"), mweb.getDeclaredType());
+
+		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
+		assertNotNull(em);
+		assertEquals("equalsMultiple", em.getName());
+		assertEquals("equalsMultiple(AbstractDestinationAddress)", em.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), em.getDeclaredType());
+
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
+		assertNotNull(clazz);
+		Method n = null;
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name")) {
+				n = m;
+				break;
+			}
+		}
+		assertNotNull(n);
+		assertEquals("name", n.getName());
+		assertEquals("name()", n.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
+	}
+
+	@Test
+	public void testFieldType() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		Collection<Attribute> l_atts = clazz.getAttributes();
+		assertEquals(2, l_atts.size());
+		for (Attribute a : l_atts) {
+			if (a.getName().equals("nextNode")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(clazz, a.getDeclaredType());
+			}
+			else if (a.getName().equals("name")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testStubs() {
+		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
+		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
+		assertNotNull(ns);
+		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
+		assertTrue(ns.getIsStub());
+			
+		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
+		assertNotNull(obj);
+		assertTrue(ns.getIsStub());
+		assertSame(ns, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
+		assertNotNull(str);
+		assertTrue(str.getIsStub());
+		assertSame(ns, str.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsStub());
+		
+		/* [].length notused in the default test case 
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
+		assertNotNull(att);
+		clazz = (Class) att.getParentType();
+		assertNotNull(clazz);
+		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
+	}
+
+	@Test
+	public void testParameter() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("Node")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOriginate")) ||
+				 (mNode.getName().equals("canOutput")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
+			}
+			else if ( (mNode.getName().equals("name")) ||
+					  (mNode.getName().equals("nextNode")) ) {
+				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
+			}
+			else if ( (mNode.getName().equals("accept")) ||
+					 (mNode.getName().equals("send")) ||
+					 (mNode.getName().equals("printOn")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
+			}
+		}
+		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(iprintClass);
+		Method mPrint = iprintClass.getMethods().iterator().next();
+		assertEquals(2, mPrint.getParameters().size());
+		for (Parameter p : mPrint.getParameters()) {
+			assertSame(mPrint, p.getParentBehaviouralEntity());
+			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
+			if (p.getName().equals("contents")) {
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
+			}
+			if (p.getName().equals("rv")) {
+				assertSame(TestVerveineUtils.detectElement(repo,PrimitiveType.class, "boolean"), p.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testInvocation() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("name")) ||
+				 (mNode.getName().equals("nextNode")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOutput")) ||
+				 (mNode.getName().equals("canOriginate")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
+			}
+			else if ( (mNode.getName().equals("Node")) ||
+					  (mNode.getName().equals("accept")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("send"))  {
+				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("printOn")) {
+				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
+			}
+		}
+		
+		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(sdaClass);
+		for (Method mSDA : sdaClass.getMethods()) {
+			for (Invocation inv : mSDA.getOutgoingInvocations()) {
+				assertTrue( "Unexpected method signature: "+inv.getSignature(),
+							inv.getSignature().equals("equalsSingle(String)") || inv.getSignature().equals("id()") || inv.getSignature().equals("equals(Object)"));
+				if (inv.getSignature().equals("equalsSingle (String)")) {
+					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
+				}
+				else if (inv.getSignature().equals("id ()")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+				else if (inv.getSignature().equals("equals (Object)")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals(null, inv.getReceiver());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+			}
+		}
+	}
+	
+	@Test
+	public void testAccess() {
+		Attribute att;
+		BehaviouralEntity accessor;
+		
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
+		assertNotNull(att);
+		assertSame(2, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("name", accessor.getName());
+		assertEquals("Node", ((Method)accessor).getParentType().getName());
+
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
+		assertNotNull(att);
+		assertSame(1, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("setServerType", accessor.getName());
+		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
+
+		// finds method PrintServer.output()
+		Method output = null;
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
+			if (m.getParentType().getName().equals("PrintServer")) {
+				output = m;
+				break;
+			}
+		}
+		assertNotNull(output);
+		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		for (Access acc : output.getAccesses()) {
+			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
+						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
+			assertEquals(output, acc.getAccessor());
+		}
+	}
+
+	@Test
+	public void testSourceAnchors() {
+		SourceAnchor anc = null;
+		
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class XPrinter", ((FileAnchor)anc).getFileName().endsWith("moose/lan/server/PrintServer.java"));
+		assertEquals(17, ((FileAnchor)anc).getStartLine());
+		assertEquals(31, ((FileAnchor)anc).getEndLine());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+
+		anc = clazz.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(clazz, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for class Node", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Node.java"));
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(70, ((FileAnchor)anc).getEndLine());
+		
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsMultiple");
+		assertNotNull(meth);
+
+		anc = meth.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(meth, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for method SingleDestinationAddress.equalsMultiple()", ((FileAnchor)anc).getFileName().endsWith("moose/lan/SingleDestinationAddress.java"));
+		assertEquals(39, ((FileAnchor)anc).getStartLine());
+		assertEquals(41, ((FileAnchor)anc).getEndLine());
+		
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "originator");
+		assertNotNull(meth);
+
+		anc = att.getSourceAnchor();
+		assertNotNull(anc);
+		assertSame(att, anc.getElement());
+		assertSame(FileAnchor.class, anc.getClass());
+		assertTrue("Wrong file source for field Packet.originator", ((FileAnchor)anc).getFileName().endsWith("moose/lan/Packet.java"));
+		assertEquals(15, ((FileAnchor)anc).getStartLine());
+		assertEquals(15, ((FileAnchor)anc).getEndLine());
+		
+	}
+
+	@Test
+	public void testModifiers() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer");
+		assertNotNull(clazz);
+		assertFalse(clazz.getIsInterface());
+		assertTrue(clazz.getIsAbstract());
+		assertTrue(clazz.getModifiers().contains("abstract"));
+		assertTrue(clazz.getIsPublic());
+		assertFalse(clazz.getIsPrivate());
+		assertFalse(clazz.getIsProtected());
+		assertFalse(clazz.getIsFinal());
+		
+		assertEquals(3, clazz.getMethods().size());
+		for (Method m : clazz.getMethods()) {
+			assertTrue(m.getIsPublic());
+			assertFalse(m.getIsPrivate());
+			assertFalse(m.getIsProtected());
+			assertFalse(m.getIsFinal());
+			if (m.getName().equals("output")) {
+				assertTrue(m.getIsAbstract());
+			}
+			else {
+				assertFalse(m.getIsAbstract());
+			}
+		}
+		
+		assertEquals(1, clazz.getAttributes().size());
+		Attribute a = clazz.getAttributes().iterator().next();
+		assertFalse(a.getIsPublic());
+		assertFalse(a.getIsPrivate());
+		assertTrue(a.getIsProtected());
+		assertFalse(a.getIsFinal());
+	}
+
+	@Test
+	public void testComment() {	
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(clazz);
+		Collection<Comment> cmts = clazz.getComments();
+		assertEquals(1, cmts.size());
+		SourceAnchor anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(6, ((FileAnchor)anc).getStartLine());
+		assertEquals(10, ((FileAnchor)anc).getEndLine());
+
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "equalsSingle");
+		assertNotNull(meth);
+		cmts = meth.getComments();
+		assertEquals(1, cmts.size());
+		anc = cmts.iterator().next().getSourceAnchor();
+		assertEquals(31, ((FileAnchor)anc).getStartLine());
+		assertEquals(34, ((FileAnchor)anc).getEndLine());
+
+	}
+	
+	@Test
+	public void testMetric() {	
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
+			assertNotNull(m);
+			fr.inria.verveine.core.gen.famix.Class owner = (fr.inria.verveine.core.gen.famix.Class) m.getParentType();
+			assertNotNull(owner);
+			if (owner.getName().equals("OutputServer")) {
+			assertEquals(2, m.getCyclo());
+				assertEquals(6, m.getNOS());
+			}
+			else if (owner.getName().equals("Node")) {
+				assertEquals(1, m.getCyclo());
+				assertEquals(1, m.getNOS());
+			}
+			else if (owner.getName().equals("WorkStation")) {
+				assertEquals(2, m.getCyclo());
+				assertEquals(7, m.getNOS());
+			}
+		}		
+	}
+
+}
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 23)
@@ -0,0 +1,67 @@
+/**
+ * Copyright (c) 2010 Simon Denier
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.CaughtException;
+import fr.inria.verveine.core.gen.famix.DeclaredException;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.ThrownException;
+import fr.inria.verveine.extractor.java.VerveineJParser;
+
+/**
+ * @author Simon Denier
+ * @since May 28, 2010
+ *
+ */
+public class VerveineJTest_AdHoc {
+
+	private Repository repo;
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		VerveineJParser parser = new VerveineJParser();
+		parser.compile(new String[] {"test_src/ad_hoc"});
+		parser.renameNamespaces();
+		repo = parser.getFamixRepo();
+	}
+
+	@Test
+	public void testExceptions() {
+		// there are two "lire" methods, but both serve our purpose here so we just take the first that will be returned
+		Method meth = TestVerveineUtils.detectElement(repo, Method.class, "lire");
+		assertNotNull(meth);
+		
+		fr.inria.verveine.core.gen.famix.Class excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "ReadException");
+		
+		assertEquals(1, meth.getDeclaredExceptions().size());
+		DeclaredException exD = meth.getDeclaredExceptions().iterator().next();
+		assertSame(meth, exD.getDefiningMethod());
+		assertSame(excepClass, exD.getExceptionClass());
+		
+		assertEquals(1, meth.getThrownExceptions().size());
+		ThrownException exT = meth.getThrownExceptions().iterator().next();
+		assertSame(meth, exT.getDefiningMethod());
+		assertSame(excepClass, exT.getExceptionClass());
+
+		excepClass = TestVerveineUtils.detectElement(repo, fr.inria.verveine.core.gen.famix.Class.class, "IOException");
+		
+		assertEquals(1,meth.getCaughtExceptions().size());
+		CaughtException exC = meth.getCaughtExceptions().iterator().next();
+		assertSame(meth, exC.getDefiningMethod());
+		assertSame(excepClass, exC.getExceptionClass());
+	}
+
+}
