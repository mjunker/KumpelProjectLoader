Index: verveine.core/.classpath
===================================================================
--- verveine.core/.classpath	(revision 0)
+++ verveine.core/.classpath	(revision 1)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: verveine.core/.project
===================================================================
--- verveine.core/.project	(revision 0)
+++ verveine.core/.project	(revision 1)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>verveine.core</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: verveine.core/mse/famix30_complete.mse
===================================================================
--- verveine.core/mse/famix30_complete.mse	(revision 0)
+++ verveine.core/mse/famix30_complete.mse	(revision 1)
@@ -0,0 +1,831 @@
+(+	(FM3.Package (id: 1)+		(name 'FAMIX')+		(classes+			(FM3.Class (id: 2)+				(name 'LocalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 4)+						(name 'parentBehaviouralEntity')+						(class (ref: 2))+						(opposite (ref: 5))+						(type (ref: 6)))))+			(FM3.Class (id: 7)+				(name 'GlobalVariableGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 9)+				(name 'SourceAnchor')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 11)+						(name 'element')+						(class (ref: 9))+						(opposite (ref: 12))+						(type (ref: 13)))))+			(FM3.Class (id: 14)+				(name 'PrimitiveType')+				(package (ref: 1))+				(superclass (ref: 15)))+			(FM3.Class (id: 16)+				(name 'Parameter')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 17)+						(name 'parentBehaviouralEntity')+						(class (ref: 16))+						(opposite (ref: 18))+						(type (ref: 6)))))+			(FM3.Class (id: 10)+				(name 'Entity')+				(package (ref: 1))+				(superclass (ref: Object))+				(attributes+					(FM3.Property (id: 19)+						(name 'annotationInstances')+						(class (ref: 10))+						(derived true)+						(multivalued true)+						(opposite (ref: 20))+						(type (ref: 21)))))+			(FM3.Class (id: 22)+				(name 'ImplicitVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 23)+						(name 'container')+						(class (ref: 22))+						(type (ref: 15)))))+			(FM3.Class (id: 24)+				(name 'MethodGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 25)+				(name 'Inheritance')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 27)+						(name 'superclass')+						(class (ref: 25))+						(opposite (ref: 28))+						(type (ref: 15)))+					(FM3.Property (id: 29)+						(name 'subclass')+						(class (ref: 25))+						(opposite (ref: 30))+						(type (ref: 15)))))+			(FM3.Class (id: 3)+				(name 'StructuralEntity')+				(package (ref: 1))+				(superclass (ref: 31))+				(attributes+					(FM3.Property (id: 32)+						(name 'incomingAccesses')+						(class (ref: 3))+						(derived true)+						(multivalued true)+						(opposite (ref: 33))+						(type (ref: 34)))+					(FM3.Property (id: 35)+						(name 'declaredType')+						(class (ref: 3))+						(type (ref: 15)))))+			(FM3.Class (id: 36)+				(name 'Attribute')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 37)+						(name 'parentType')+						(class (ref: 36))+						(opposite (ref: 38))+						(type (ref: 15)))+					(FM3.Property (id: 39)+						(name 'hasClassScope')+						(class (ref: 36))+						(type (ref: Boolean)))))+			(FM3.Class (id: 40)+				(name 'Invocation')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 41)+						(name 'signature')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 42)+						(name 'receiverSourceCode')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 43)+						(name 'candidates')+						(class (ref: 40))+						(multivalued true)+						(opposite (ref: 44))+						(type (ref: 6)))+					(FM3.Property (id: 45)+						(name 'sender')+						(class (ref: 40))+						(opposite (ref: 46))+						(type (ref: 6)))+					(FM3.Property (id: 47)+						(name 'receiver')+						(class (ref: 40))+						(opposite (ref: 48))+						(type (ref: 49)))))+			(FM3.Class (id: 50)+				(name 'Reference')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 51)+						(name 'target')+						(class (ref: 50))+						(opposite (ref: 52))+						(type (ref: 53)))+					(FM3.Property (id: 54)+						(name 'source')+						(class (ref: 50))+						(opposite (ref: 55))+						(type (ref: 53)))))+			(FM3.Class (id: 56)+				(name 'DeclaredException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 58)+						(name 'definingMethod')+						(class (ref: 56))+						(opposite (ref: 59))+						(type (ref: 60)))))+			(FM3.Class (id: 61)+				(name 'ScopingEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 62)+						(name 'functions')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 63))+						(type (ref: 64)))+					(FM3.Property (id: 65)+						(name 'childScopes')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 66))+						(type (ref: 61)))+					(FM3.Property (id: 66)+						(name 'parentScope')+						(class (ref: 61))+						(opposite (ref: 65))+						(type (ref: 61)))+					(FM3.Property (id: 67)+						(name 'globalVariables')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 68))+						(type (ref: 69)))))+			(FM3.Class (id: 53)+				(name 'ContainerEntity')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 52)+						(name 'incomingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 51))+						(type (ref: 50)))+					(FM3.Property (id: 70)+						(name 'definedAnnotationTypes')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 71))+						(type (ref: 72)))+					(FM3.Property (id: 73)+						(name 'types')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 74))+						(type (ref: 15)))+					(FM3.Property (id: 55)+						(name 'outgoingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 54))+						(type (ref: 50)))))+			(FM3.Class (id: 75)+				(name 'Package')+				(package (ref: 1))+				(superclass (ref: 61))+				(attributes+					(FM3.Property (id: 76)+						(name 'childNamedEntities')+						(class (ref: 75))+						(derived true)+						(multivalued true)+						(opposite (ref: 77))+						(type (ref: 49)))))+			(FM3.Class (id: 78)+				(name 'FileAnchor')+				(package (ref: 1))+				(superclass (ref: 9))+				(attributes+					(FM3.Property (id: 79)+						(name 'endLine')+						(class (ref: 78))+						(type (ref: Number)))+					(FM3.Property (id: 80)+						(name 'fileName')+						(class (ref: 78))+						(type (ref: String)))+					(FM3.Property (id: 81)+						(name 'startLine')+						(class (ref: 78))+						(type (ref: Number)))))+			(FM3.Class (id: 6)+				(name 'BehaviouralEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 82)+						(name 'accesses')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 83))+						(type (ref: 34)))+					(FM3.Property (id: 84)+						(name 'declaredType')+						(class (ref: 6))+						(type (ref: 15)))+					(FM3.Property (id: 5)+						(name 'localVariables')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 4))+						(type (ref: 2)))+					(FM3.Property (id: 44)+						(name 'incomingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 43))+						(type (ref: 40)))+					(FM3.Property (id: 18)+						(name 'parameters')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 17))+						(type (ref: 16)))+					(FM3.Property (id: 85)+						(name 'signature')+						(class (ref: 6))+						(type (ref: String)))+					(FM3.Property (id: 46)+						(name 'outgoingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 45))+						(type (ref: 40)))))+			(FM3.Class (id: 57)+				(name 'Exception')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 86)+						(name 'exceptionClass')+						(class (ref: 57))+						(type (ref: 87)))))+			(FM3.Class (id: 15)+				(name 'Type')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 28)+						(name 'subInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 27))+						(type (ref: 25)))+					(FM3.Property (id: 30)+						(name 'superInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 29))+						(type (ref: 25)))+					(FM3.Property (id: 38)+						(name 'attributes')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 37))+						(type (ref: 36)))+					(FM3.Property (id: 88)+						(name 'methods')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 89))+						(type (ref: 60)))+					(FM3.Property (id: 74)+						(name 'container')+						(class (ref: 15))+						(opposite (ref: 73))+						(type (ref: 53)))))+			(FM3.Class (id: 90)+				(name 'ClassGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 91)+				(name 'Namespace')+				(package (ref: 1))+				(superclass (ref: 61)))+			(FM3.Class (id: 60)+				(name 'Method')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 92)+						(name 'caughtExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 93))+						(type (ref: 94)))+					(FM3.Property (id: 89)+						(name 'parentType')+						(class (ref: 60))+						(opposite (ref: 88))+						(type (ref: 15)))+					(FM3.Property (id: 95)+						(name 'hasClassScope')+						(class (ref: 60))+						(type (ref: Boolean)))+					(FM3.Property (id: 96)+						(name 'kind')+						(class (ref: 60))+						(type (ref: String)))+					(FM3.Property (id: 59)+						(name 'declaredExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 58))+						(type (ref: 56)))+					(FM3.Property (id: 97)+						(name 'thrownExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 98))+						(type (ref: 99)))))+			(FM3.Class (id: 100)+				(name 'Comment')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 101)+						(name 'container')+						(class (ref: 100))+						(opposite (ref: 102))+						(type (ref: 13)))+					(FM3.Property (id: 103)+						(name 'content')+						(class (ref: 100))+						(type (ref: String)))))+			(FM3.Class (id: 49)+				(name 'NamedEntity')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 104)+						(name 'modifiers')+						(class (ref: 49))+						(multivalued true)+						(type (ref: String)))+					(FM3.Property (id: 105)+						(name 'isAbstract')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 106)+						(name 'isPublic')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 107)+						(name 'belongsTo')+						(class (ref: 49))+						(derived true)+						(type (ref: 53)))+					(FM3.Property (id: 108)+						(name 'isPrivate')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 109)+						(name 'isPackage')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 110)+						(name 'name')+						(class (ref: 49))+						(type (ref: String)))+					(FM3.Property (id: 77)+						(name 'parentPackage')+						(class (ref: 49))+						(opposite (ref: 76))+						(type (ref: 75)))+					(FM3.Property (id: 48)+						(name 'receivingInvocations')+						(class (ref: 49))+						(derived true)+						(multivalued true)+						(opposite (ref: 47))+						(type (ref: 40)))+					(FM3.Property (id: 111)+						(name 'isProtected')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 112)+						(name 'isStub')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 113)+						(name 'isFinal')+						(class (ref: 49))+						(type (ref: Boolean)))))+			(FM3.Class (id: 21)+				(name 'AnnotationInstance')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 114)+						(name 'annotationType')+						(class (ref: 21))+						(opposite (ref: 115))+						(type (ref: 72)))+					(FM3.Property (id: 20)+						(name 'annotatedEntity')+						(class (ref: 21))+						(opposite (ref: 19))+						(type (ref: 10)))))+			(FM3.Class (id: 116)+				(name 'PackageGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 117)+				(name 'NamespaceGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 64)+				(name 'Function')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 63)+						(name 'parentScope')+						(class (ref: 64))+						(opposite (ref: 62))+						(type (ref: 61)))))+			(FM3.Class (id: 13)+				(name 'SourcedEntity')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 12)+						(name 'sourceAnchor')+						(class (ref: 13))+						(opposite (ref: 11))+						(type (ref: 9)))+					(FM3.Property (id: 102)+						(name 'comments')+						(class (ref: 13))+						(derived true)+						(multivalued true)+						(opposite (ref: 101))+						(type (ref: 100)))))+			(FM3.Class (id: 118)+				(name 'UnknownVariable')+				(package (ref: 1))+				(superclass (ref: 3)))+			(FM3.Class (id: 69)+				(name 'GlobalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 68)+						(name 'parentScope')+						(class (ref: 69))+						(opposite (ref: 67))+						(type (ref: 61)))))+			(FM3.Class (id: 87)+				(name 'Class')+				(package (ref: 1))+				(superclass (ref: 15))+				(attributes+					(FM3.Property (id: 119)+						(name 'isAbstract')+						(class (ref: 87))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 120)+						(name 'isInterface')+						(class (ref: 87))+						(type (ref: Boolean)))))+			(FM3.Class (id: 72)+				(name 'AnnotationType')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 71)+						(name 'container')+						(class (ref: 72))+						(opposite (ref: 70))+						(type (ref: 53)))+					(FM3.Property (id: 115)+						(name 'instances')+						(class (ref: 72))+						(derived true)+						(multivalued true)+						(opposite (ref: 114))+						(type (ref: 21)))))+			(FM3.Class (id: 31)+				(name 'LeafEntity')+				(package (ref: 1))+				(superclass (ref: 49)))+			(FM3.Class (id: 94)+				(name 'CaughtException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 93)+						(name 'definingMethod')+						(class (ref: 94))+						(opposite (ref: 92))+						(type (ref: 60)))))+			(FM3.Class (id: 99)+				(name 'ThrownException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 98)+						(name 'definingMethod')+						(class (ref: 99))+						(opposite (ref: 97))+						(type (ref: 60)))))+			(FM3.Class (id: 34)+				(name 'Access')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 121)+						(name 'isRead')+						(class (ref: 34))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 122)+						(name 'isWrite')+						(class (ref: 34))+						(type (ref: Boolean)))+					(FM3.Property (id: 83)+						(name 'accessor')+						(class (ref: 34))+						(opposite (ref: 82))+						(type (ref: 6)))+					(FM3.Property (id: 33)+						(name 'variable')+						(class (ref: 34))+						(opposite (ref: 32))+						(type (ref: 3)))))+			(FM3.Class (id: 123)+				(name 'SourceTextAnchor')+				(package (ref: 1))+				(superclass (ref: 9)))+			(FM3.Class (id: 26)+				(name 'Association')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 124)+						(name 'previous')+						(class (ref: 26))+						(opposite (ref: 125))+						(type (ref: 26)))+					(FM3.Property (id: 126)+						(name 'to')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 127)+						(name 'from')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 125)+						(name 'next')+						(class (ref: 26))+						(derived true)+						(opposite (ref: 124))+						(type (ref: 26)))))))+	(FM3.Package (id: 128)+		(name 'FILE')+		(classes+			(FM3.Class (id: 129)+				(name 'FileGroup')+				(package (ref: 128))+				(superclass (ref: 8)))+			(FM3.Class (id: 130)+				(name 'File')+				(package (ref: 128))+				(superclass (ref: 131)))+			(FM3.Class (id: 132)+				(name 'Folder')+				(package (ref: 128))+				(superclass (ref: 131)))+			(FM3.Class (id: 131)+				(name 'AbstractFile')+				(package (ref: 128))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 133)+						(name 'name')+						(class (ref: 131))+						(type (ref: String)))))+			(FM3.Class (id: 134)+				(name 'FolderGroup')+				(package (ref: 128))+				(superclass (ref: 8)))))+	(FM3.Package (id: 135)+		(name 'Dude')+		(classes+			(FM3.Class (id: 136)+				(name 'CodeFragment')+				(package (ref: 135))+				(superclass (ref: 10)))+			(FM3.Class (id: 137)+				(name 'CodeLine')+				(package (ref: 135))+				(superclass (ref: 10)))+			(FM3.Class (id: 138)+				(name 'Multiplication')+				(package (ref: 135))+				(superclass (ref: 10)))+			(FM3.Class (id: 139)+				(name 'MultiplicationGroup')+				(package (ref: 135))+				(superclass (ref: 8)))+			(FM3.Class (id: 140)+				(name 'DuplicationGroup')+				(package (ref: 135))+				(superclass (ref: 8)))+			(FM3.Class (id: 141)+				(name 'Duplication')+				(package (ref: 135))+				(superclass (ref: 10)))))+	(FM3.Package (id: 142)+		(name 'Hismo')+		(classes+			(FM3.Class (id: 143)+				(name 'HismoAbstractHistory')+				(package (ref: 142))+				(superclass (ref: 10)))+			(FM3.Class (id: 144)+				(name 'HismoNamespaceVersion')+				(package (ref: 142))+				(superclass (ref: 145)))+			(FM3.Class (id: 146)+				(name 'HismoAttributeHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 147)+				(name 'HismoFileHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 148)+				(name 'HismoCoChangeHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 149)+				(name 'HismoClassHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 150)+				(name 'HismoMethodVersion')+				(package (ref: 142))+				(superclass (ref: 145)))+			(FM3.Class (id: 145)+				(name 'HismoEntityVersion')+				(package (ref: 142))+				(superclass (ref: 151)))+			(FM3.Class (id: 152)+				(name 'HismoNamespaceHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 153)+				(name 'HismoNamespaceHistoryGroup')+				(package (ref: 142))+				(superclass (ref: 154)))+			(FM3.Class (id: 155)+				(name 'HismoInvocationHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 156)+				(name 'HismoClassHierarchy')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 157)+				(name 'HismoCoChangePattern')+				(package (ref: 142))+				(superclass (ref: 8)))+			(FM3.Class (id: 158)+				(name 'HismoFolderHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 159)+				(name 'HismoMethodHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 160)+				(name 'HismoClassVersion')+				(package (ref: 142))+				(superclass (ref: 145)))+			(FM3.Class (id: 161)+				(name 'HismoMethodHistoryGroup')+				(package (ref: 142))+				(superclass (ref: 154)))+			(FM3.Class (id: 162)+				(name 'HismoPackageHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 163)+				(name 'HismoClassHistoryGroup')+				(package (ref: 142))+				(superclass (ref: 154)))+			(FM3.Class (id: 164)+				(name 'HismoCoChangeVersion')+				(package (ref: 142))+				(superclass (ref: 151)))+			(FM3.Class (id: 151)+				(name 'HismoAbstractVersion')+				(package (ref: 142))+				(superclass (ref: 10)))+			(FM3.Class (id: 165)+				(name 'HismoInheritanceDefinitionHistory')+				(package (ref: 142))+				(superclass (ref: 143)))+			(FM3.Class (id: 154)+				(name 'HismoHistoryGroup')+				(package (ref: 142))+				(superclass (ref: 8)))+			(FM3.Class (id: 166)+				(name 'HismoModelHistory')+				(package (ref: 142))+				(superclass (ref: 143)))))+	(FM3.Package (id: 167)+		(name 'Moose')+		(classes+			(FM3.Class (id: 8)+				(name 'MooseGroup')+				(package (ref: 167))+				(superclass (ref: 168)))+			(FM3.Class (id: 168)+				(name 'MooseAbsractGroup')+				(abstract true)+				(package (ref: 167))+				(superclass (ref: 169)))+			(FM3.Class (id: 170)+				(name 'HismoAccessHistory')+				(package (ref: 167))+				(superclass (ref: 143)))+			(FM3.Class (id: 171)+				(name 'MooseModel')+				(package (ref: 167))+				(superclass (ref: 168))+				(attributes+					(FM3.Property (id: 172)+						(name 'sourceLanguage')+						(class (ref: 171))+						(type (ref: String)))))+			(FM3.Class (id: 169)+				(name 'MooseEntity')+				(abstract true)+				(package (ref: 167))+				(superclass (ref: Object))))))
\ No newline at end of file
Index: verveine.core/mse/famix30_famix.mse
===================================================================
--- verveine.core/mse/famix30_famix.mse	(revision 0)
+++ verveine.core/mse/famix30_famix.mse	(revision 1)
@@ -0,0 +1,648 @@
+(+	(FM3.Package (id: 1)+		(name 'FAMIX')+		(classes+			(FM3.Class (id: 2)+				(name 'LocalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 4)+						(name 'parentBehaviouralEntity')+						(class (ref: 2))+						(opposite (ref: 5))+						(type (ref: 6)))))+			(FM3.Class (id: 7)+				(name 'GlobalVariableGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 9)+				(name 'SourceAnchor')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 11)+						(name 'element')+						(class (ref: 9))+						(opposite (ref: 12))+						(type (ref: 13)))))+			(FM3.Class (id: 14)+				(name 'PrimitiveType')+				(package (ref: 1))+				(superclass (ref: 15)))+			(FM3.Class (id: 16)+				(name 'Parameter')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 17)+						(name 'parentBehaviouralEntity')+						(class (ref: 16))+						(opposite (ref: 18))+						(type (ref: 6)))))+			(FM3.Class (id: 10)+				(name 'Entity')+				(package (ref: 1))+				(superclass (ref: Object))+				(attributes+					(FM3.Property (id: 19)+						(name 'annotationInstances')+						(class (ref: 10))+						(derived true)+						(multivalued true)+						(opposite (ref: 20))+						(type (ref: 21)))))+			(FM3.Class (id: 22)+				(name 'ImplicitVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 23)+						(name 'container')+						(class (ref: 22))+						(type (ref: 15)))))+			(FM3.Class (id: 24)+				(name 'MethodGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 25)+				(name 'Inheritance')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 27)+						(name 'superclass')+						(class (ref: 25))+						(opposite (ref: 28))+						(type (ref: 15)))+					(FM3.Property (id: 29)+						(name 'subclass')+						(class (ref: 25))+						(opposite (ref: 30))+						(type (ref: 15)))))+			(FM3.Class (id: 3)+				(name 'StructuralEntity')+				(package (ref: 1))+				(superclass (ref: 31))+				(attributes+					(FM3.Property (id: 32)+						(name 'incomingAccesses')+						(class (ref: 3))+						(derived true)+						(multivalued true)+						(opposite (ref: 33))+						(type (ref: 34)))+					(FM3.Property (id: 35)+						(name 'declaredType')+						(class (ref: 3))+						(type (ref: 15)))))+			(FM3.Class (id: 36)+				(name 'Attribute')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 37)+						(name 'parentType')+						(class (ref: 36))+						(opposite (ref: 38))+						(type (ref: 15)))+					(FM3.Property (id: 39)+						(name 'hasClassScope')+						(class (ref: 36))+						(type (ref: Boolean)))))+			(FM3.Class (id: 40)+				(name 'Invocation')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 41)+						(name 'signature')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 42)+						(name 'receiverSourceCode')+						(class (ref: 40))+						(type (ref: String)))+					(FM3.Property (id: 43)+						(name 'candidates')+						(class (ref: 40))+						(multivalued true)+						(opposite (ref: 44))+						(type (ref: 6)))+					(FM3.Property (id: 45)+						(name 'sender')+						(class (ref: 40))+						(opposite (ref: 46))+						(type (ref: 6)))+					(FM3.Property (id: 47)+						(name 'receiver')+						(class (ref: 40))+						(opposite (ref: 48))+						(type (ref: 49)))))+			(FM3.Class (id: 50)+				(name 'Reference')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 51)+						(name 'target')+						(class (ref: 50))+						(opposite (ref: 52))+						(type (ref: 53)))+					(FM3.Property (id: 54)+						(name 'source')+						(class (ref: 50))+						(opposite (ref: 55))+						(type (ref: 53)))))+			(FM3.Class (id: 56)+				(name 'DeclaredException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 58)+						(name 'definingMethod')+						(class (ref: 56))+						(opposite (ref: 59))+						(type (ref: 60)))))+			(FM3.Class (id: 61)+				(name 'ScopingEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 62)+						(name 'functions')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 63))+						(type (ref: 64)))+					(FM3.Property (id: 65)+						(name 'childScopes')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 66))+						(type (ref: 61)))+					(FM3.Property (id: 66)+						(name 'parentScope')+						(class (ref: 61))+						(opposite (ref: 65))+						(type (ref: 61)))+					(FM3.Property (id: 67)+						(name 'globalVariables')+						(class (ref: 61))+						(derived true)+						(multivalued true)+						(opposite (ref: 68))+						(type (ref: 69)))))+			(FM3.Class (id: 53)+				(name 'ContainerEntity')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 52)+						(name 'incomingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 51))+						(type (ref: 50)))+					(FM3.Property (id: 70)+						(name 'definedAnnotationTypes')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 71))+						(type (ref: 72)))+					(FM3.Property (id: 73)+						(name 'types')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 74))+						(type (ref: 15)))+					(FM3.Property (id: 55)+						(name 'outgoingReferences')+						(class (ref: 53))+						(derived true)+						(multivalued true)+						(opposite (ref: 54))+						(type (ref: 50)))))+			(FM3.Class (id: 75)+				(name 'Package')+				(package (ref: 1))+				(superclass (ref: 61))+				(attributes+					(FM3.Property (id: 76)+						(name 'childNamedEntities')+						(class (ref: 75))+						(derived true)+						(multivalued true)+						(opposite (ref: 77))+						(type (ref: 49)))))+			(FM3.Class (id: 78)+				(name 'FileAnchor')+				(package (ref: 1))+				(superclass (ref: 9))+				(attributes+					(FM3.Property (id: 79)+						(name 'endLine')+						(class (ref: 78))+						(type (ref: Number)))+					(FM3.Property (id: 80)+						(name 'fileName')+						(class (ref: 78))+						(type (ref: String)))+					(FM3.Property (id: 81)+						(name 'startLine')+						(class (ref: 78))+						(type (ref: Number)))))+			(FM3.Class (id: 6)+				(name 'BehaviouralEntity')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 82)+						(name 'accesses')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 83))+						(type (ref: 34)))+					(FM3.Property (id: 84)+						(name 'declaredType')+						(class (ref: 6))+						(type (ref: 15)))+					(FM3.Property (id: 5)+						(name 'localVariables')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 4))+						(type (ref: 2)))+					(FM3.Property (id: 44)+						(name 'incomingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 43))+						(type (ref: 40)))+					(FM3.Property (id: 18)+						(name 'parameters')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 17))+						(type (ref: 16)))+					(FM3.Property (id: 85)+						(name 'signature')+						(class (ref: 6))+						(type (ref: String)))+					(FM3.Property (id: 46)+						(name 'outgoingInvocations')+						(class (ref: 6))+						(derived true)+						(multivalued true)+						(opposite (ref: 45))+						(type (ref: 40)))))+			(FM3.Class (id: 57)+				(name 'Exception')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 86)+						(name 'exceptionClass')+						(class (ref: 57))+						(type (ref: 87)))))+			(FM3.Class (id: 15)+				(name 'Type')+				(package (ref: 1))+				(superclass (ref: 53))+				(attributes+					(FM3.Property (id: 28)+						(name 'subInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 27))+						(type (ref: 25)))+					(FM3.Property (id: 30)+						(name 'superInheritances')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 29))+						(type (ref: 25)))+					(FM3.Property (id: 38)+						(name 'attributes')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 37))+						(type (ref: 36)))+					(FM3.Property (id: 88)+						(name 'methods')+						(class (ref: 15))+						(derived true)+						(multivalued true)+						(opposite (ref: 89))+						(type (ref: 60)))+					(FM3.Property (id: 74)+						(name 'container')+						(class (ref: 15))+						(opposite (ref: 73))+						(type (ref: 53)))))+			(FM3.Class (id: 90)+				(name 'ClassGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 91)+				(name 'Namespace')+				(package (ref: 1))+				(superclass (ref: 61)))+			(FM3.Class (id: 60)+				(name 'Method')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 92)+						(name 'caughtExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 93))+						(type (ref: 94)))+					(FM3.Property (id: 89)+						(name 'parentType')+						(class (ref: 60))+						(opposite (ref: 88))+						(type (ref: 15)))+					(FM3.Property (id: 95)+						(name 'hasClassScope')+						(class (ref: 60))+						(type (ref: Boolean)))+					(FM3.Property (id: 96)+						(name 'kind')+						(class (ref: 60))+						(type (ref: String)))+					(FM3.Property (id: 59)+						(name 'declaredExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 58))+						(type (ref: 56)))+					(FM3.Property (id: 97)+						(name 'thrownExceptions')+						(class (ref: 60))+						(derived true)+						(multivalued true)+						(opposite (ref: 98))+						(type (ref: 99)))))+			(FM3.Class (id: 100)+				(name 'Comment')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 101)+						(name 'container')+						(class (ref: 100))+						(opposite (ref: 102))+						(type (ref: 13)))+					(FM3.Property (id: 103)+						(name 'content')+						(class (ref: 100))+						(type (ref: String)))))+			(FM3.Class (id: 49)+				(name 'NamedEntity')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 104)+						(name 'modifiers')+						(class (ref: 49))+						(multivalued true)+						(type (ref: String)))+					(FM3.Property (id: 105)+						(name 'isAbstract')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 106)+						(name 'isPublic')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 107)+						(name 'belongsTo')+						(class (ref: 49))+						(derived true)+						(type (ref: 53)))+					(FM3.Property (id: 108)+						(name 'isPrivate')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 109)+						(name 'isPackage')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 110)+						(name 'name')+						(class (ref: 49))+						(type (ref: String)))+					(FM3.Property (id: 77)+						(name 'parentPackage')+						(class (ref: 49))+						(opposite (ref: 76))+						(type (ref: 75)))+					(FM3.Property (id: 48)+						(name 'receivingInvocations')+						(class (ref: 49))+						(derived true)+						(multivalued true)+						(opposite (ref: 47))+						(type (ref: 40)))+					(FM3.Property (id: 111)+						(name 'isProtected')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 112)+						(name 'isStub')+						(class (ref: 49))+						(type (ref: Boolean)))+					(FM3.Property (id: 113)+						(name 'isFinal')+						(class (ref: 49))+						(type (ref: Boolean)))))+			(FM3.Class (id: 21)+				(name 'AnnotationInstance')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 114)+						(name 'annotationType')+						(class (ref: 21))+						(opposite (ref: 115))+						(type (ref: 72)))+					(FM3.Property (id: 20)+						(name 'annotatedEntity')+						(class (ref: 21))+						(opposite (ref: 19))+						(type (ref: 10)))))+			(FM3.Class (id: 116)+				(name 'PackageGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 117)+				(name 'NamespaceGroup')+				(package (ref: 1))+				(superclass (ref: 8)))+			(FM3.Class (id: 64)+				(name 'Function')+				(package (ref: 1))+				(superclass (ref: 6))+				(attributes+					(FM3.Property (id: 63)+						(name 'parentScope')+						(class (ref: 64))+						(opposite (ref: 62))+						(type (ref: 61)))))+			(FM3.Class (id: 13)+				(name 'SourcedEntity')+				(package (ref: 1))+				(superclass (ref: 10))+				(attributes+					(FM3.Property (id: 12)+						(name 'sourceAnchor')+						(class (ref: 13))+						(opposite (ref: 11))+						(type (ref: 9)))+					(FM3.Property (id: 102)+						(name 'comments')+						(class (ref: 13))+						(derived true)+						(multivalued true)+						(opposite (ref: 101))+						(type (ref: 100)))))+			(FM3.Class (id: 118)+				(name 'UnknownVariable')+				(package (ref: 1))+				(superclass (ref: 3)))+			(FM3.Class (id: 69)+				(name 'GlobalVariable')+				(package (ref: 1))+				(superclass (ref: 3))+				(attributes+					(FM3.Property (id: 68)+						(name 'parentScope')+						(class (ref: 69))+						(opposite (ref: 67))+						(type (ref: 61)))))+			(FM3.Class (id: 87)+				(name 'Class')+				(package (ref: 1))+				(superclass (ref: 15))+				(attributes+					(FM3.Property (id: 119)+						(name 'isAbstract')+						(class (ref: 87))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 120)+						(name 'isInterface')+						(class (ref: 87))+						(type (ref: Boolean)))))+			(FM3.Class (id: 72)+				(name 'AnnotationType')+				(package (ref: 1))+				(superclass (ref: 49))+				(attributes+					(FM3.Property (id: 71)+						(name 'container')+						(class (ref: 72))+						(opposite (ref: 70))+						(type (ref: 53)))+					(FM3.Property (id: 115)+						(name 'instances')+						(class (ref: 72))+						(derived true)+						(multivalued true)+						(opposite (ref: 114))+						(type (ref: 21)))))+			(FM3.Class (id: 31)+				(name 'LeafEntity')+				(package (ref: 1))+				(superclass (ref: 49)))+			(FM3.Class (id: 94)+				(name 'CaughtException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 93)+						(name 'definingMethod')+						(class (ref: 94))+						(opposite (ref: 92))+						(type (ref: 60)))))+			(FM3.Class (id: 99)+				(name 'ThrownException')+				(package (ref: 1))+				(superclass (ref: 57))+				(attributes+					(FM3.Property (id: 98)+						(name 'definingMethod')+						(class (ref: 99))+						(opposite (ref: 97))+						(type (ref: 60)))))+			(FM3.Class (id: 34)+				(name 'Access')+				(package (ref: 1))+				(superclass (ref: 26))+				(attributes+					(FM3.Property (id: 121)+						(name 'isRead')+						(class (ref: 34))+						(derived true)+						(type (ref: Boolean)))+					(FM3.Property (id: 122)+						(name 'isWrite')+						(class (ref: 34))+						(type (ref: Boolean)))+					(FM3.Property (id: 83)+						(name 'accessor')+						(class (ref: 34))+						(opposite (ref: 82))+						(type (ref: 6)))+					(FM3.Property (id: 33)+						(name 'variable')+						(class (ref: 34))+						(opposite (ref: 32))+						(type (ref: 3)))))+			(FM3.Class (id: 123)+				(name 'SourceTextAnchor')+				(package (ref: 1))+				(superclass (ref: 9)))+			(FM3.Class (id: 26)+				(name 'Association')+				(package (ref: 1))+				(superclass (ref: 13))+				(attributes+					(FM3.Property (id: 124)+						(name 'previous')+						(class (ref: 26))+						(opposite (ref: 125))+						(type (ref: 26)))+					(FM3.Property (id: 126)+						(name 'to')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 127)+						(name 'from')+						(class (ref: 26))+						(derived true)+						(type (ref: 49)))+					(FM3.Property (id: 125)+						(name 'next')+						(class (ref: 26))+						(derived true)+						(opposite (ref: 124))+						(type (ref: 26)))))))+)
\ No newline at end of file
Index: verveine.core/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/fame.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.core/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java
===================================================================
--- verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 0)
+++ verveine.core/src/test/fr/inria/verveine/core/TestVerveineUtils.java	(revision 1)
@@ -0,0 +1,56 @@
+package test.fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Vector;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+
+/**
+ * Some utilities to help test extractors derived from verveine.core
+ * @author anquetil
+ */
+public class TestVerveineUtils {
+
+	/** Returns a Collection of all FAMIXEntities in repository of the given fmxClass
+	 */
+	@SuppressWarnings("unchecked")
+	public static <T extends Entity> Collection<T> selectElementsOfType(Repository repository, Class<T> fmxClass) {
+		Collection<T> selection = new Vector<T>();
+		for (Object obj : repository.getElements()) {
+			if (fmxClass.isInstance(obj)) {
+				selection.add((T) obj);
+			}
+		}
+		return selection;
+	}
+
+	/** Returns the first FAMIXEntities in repository of the given fmxClass and with the given name
+	 */
+	@SuppressWarnings("unchecked")
+	public static <T extends NamedEntity> T detectElement(Repository repository, Class<T> fmxClass, String name) {
+		for (Object obj : repository.getElements()) {
+			if (fmxClass.isInstance(obj)
+				&& ((T) obj).getName().equals(name) ) {
+				return (T) obj;
+			}
+		}
+		return null;
+	}
+
+	/** Returns a Collection of FAMIXEntities in repository of the given fmxClass and with the given name
+	 */
+	@SuppressWarnings("unchecked")
+	public static <T extends NamedEntity> Collection<T> listElements(Repository repository, Class<T> fmxClass, String name) {
+		Collection<T> selection = new Vector<T>();
+		for (Object obj : repository.getElements()) {
+			if (fmxClass.isInstance(obj)
+				&& ((T) obj).getName().equals(name) ) {
+				selection.add((T) obj);
+			}
+		}
+		return selection;
+	}
+
+}
Index: verveine.core/src/fr/inria/verveine/core/GenerateFamix.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/GenerateFamix.java	(revision 1)
@@ -0,0 +1,22 @@
+package fr.inria.verveine.core;
+
+import ch.akuhn.fame.Tower;
+import ch.akuhn.fame.codegen.CodeGeneration;
+import ch.akuhn.fame.parser.InputSource;
+
+
+public class GenerateFamix {
+	
+	public static void main(String[] args) {
+		generateCode();
+	}
+	
+	public static void generateCode() {
+		InputSource input = InputSource.fromFilename("mse/famix30_famix.mse");
+        Tower t = new Tower();
+        t.getMetamodel().importMSE(input);
+		CodeGeneration gen = new CodeGeneration("fr.inria.verveine.core.gen", "src", "");
+		gen.accept(t.getMetamodel());
+	}
+
+}
Index: verveine.core/src/fr/inria/verveine/core/EntityStack.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/EntityStack.java	(revision 1)
@@ -0,0 +1,239 @@
+package fr.inria.verveine.core;
+
+import java.util.Stack;
+
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/** A stack of FAMIX Entities so that we know in what container each new Entity is declared
+ * @author anquetil
+ */
+public class EntityStack {
+	private Namespace fmxPckg;
+	private Stack<ClassStack> fmxClass;
+	
+	// for debugging
+	private boolean tracing = false;;
+
+	/**
+	 * A structure to hold a Famix class and its current method
+	 */
+	public class ClassStack {
+		private fr.inria.verveine.core.gen.famix.Class fmxClass;
+		private Method fmxMethod;
+		
+		public ClassStack(fr.inria.verveine.core.gen.famix.Class e) {
+			fmxClass = e;
+			fmxMethod = null;
+		}
+
+		public fr.inria.verveine.core.gen.famix.Class getFmxClass() {
+			return fmxClass;
+		}
+
+		public Method getFmxMethod() {
+			return fmxMethod;
+		}
+
+		public void setFmxMethod(Method fmxMethod) {
+			this.fmxMethod = fmxMethod;
+		}
+
+		/**
+		 * Empties the context stack of Famix classes
+		 */
+		public void clearFmxClass() {
+			fmxClass = null;
+			clearFmxMethod();
+		}
+		
+		/**
+		 * Empties the context stack of Famix Methods
+		 */
+		public void clearFmxMethod() {
+			fmxMethod = null;
+		}
+
+	}
+	
+	public EntityStack() {
+		clearPckg();  // initializes (to empty) Pckgs, classes and methods
+	}
+
+	public boolean isTracing() {
+		return tracing;
+	}
+
+	public void setTracing(boolean tracing) {
+		this.tracing = tracing;
+	}
+
+	/**
+	 * Pushes an entity on top of the "context stack"
+	 * @param e -- the entity
+	 */
+	public void push(ContainerEntity e) {
+		if (e instanceof Method) {
+			pushMethod((Method) e);
+		}
+		else if (e instanceof fr.inria.verveine.core.gen.famix.Class) {
+			pushClass((fr.inria.verveine.core.gen.famix.Class) e);
+		}
+		else if (e instanceof Namespace) {
+			pushPckg((Namespace) e);
+		}
+	}
+
+	/**
+	 * Pushes a Famix method on top of the "context stack" for the current Famix class
+	 * @param e -- the Famix method
+	 */
+	public void pushMethod(Method e) {
+		if (this.tracing) {
+			System.out.println("TRACE: pushMethod "+e.getName());
+		}
+		getTopClass().setFmxMethod(e);
+	}
+
+	/**
+	 * Pushes a Famix class on top of the "context class stack"
+	 * @param e -- the Famix class
+	 */
+	public void pushClass(fr.inria.verveine.core.gen.famix.Class e) {
+		if (this.tracing) {
+			System.out.println("TRACE: pushClass "+e.getName());
+		}
+		fmxClass.push(new ClassStack(e));
+	}
+
+	/**
+	 * Sets the Famix namespace on top of the "context stack"
+	 * Not really a push, but keep the same convention as the others
+	 * @param e -- the Famix method
+	 */
+	public void pushPckg(Namespace e) {
+		if (this.tracing) {
+			System.out.println("TRACE: pushPckg "+e.getName());
+		}
+		clearClasses();
+		fmxPckg = e;
+	}
+
+	/**
+	 * Pops the top Famix method of the current class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an Exception
+	 * @return the Famix method
+	 */
+	public Method popMethod() {
+		ClassStack tmp = getTopClass();
+		Method ret = tmp.getFmxMethod();
+		tmp.clearFmxMethod();
+		
+		if (this.tracing) {
+			System.out.println("TRACE: popMethod "+ret.getName());
+		}
+		return ret;
+	}
+
+	/**
+	 * Pops the top Famix class from the "context stack"
+	 * Note: does not check that there is such a class, so could possibly throw an EmptyStackException
+	 * @return the Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class popClass() {
+		ClassStack tmp = fmxClass.pop();
+		if (this.tracing) {
+			System.out.println("TRACE: popClass "+tmp.getFmxClass().getName());
+		}
+		return tmp.getFmxClass();
+	}
+
+	/**
+	 * Removes and returns the Famix package from the "context stack"
+	 * Also empties the class stack (which was presumably associated to this package)
+	 * Note: does not check that there is such a namespace
+	 * @return the Famix method
+	 */
+	public Namespace popPckg() {
+		Namespace ret = fmxPckg;
+		clearPckg();
+		if (this.tracing) {
+			System.out.println("TRACE: popPckg "+ret.getName());
+		}
+		return ret;
+	}
+
+	/**
+	 * Empties the context stack of Famix classes
+	 */
+	public void clearClasses() {
+		fmxClass = new Stack<ClassStack>();
+	}
+	
+	/**
+	 * Empties the context stack of package and associated classes
+	 */
+	public void clearPckg() {
+		clearClasses();
+		fmxPckg = null;
+	}
+	
+	/**
+	 * Returns the Famix method  of the Famix class on top of the "context stack"
+	 * Note: does not check that there is such a class or method, so could possibly throw an EmptyStackException
+	 * @return the Famix method
+	 */
+	public Method topMethod() {
+		return getTopClass().getFmxMethod();
+	}
+	
+	/**
+	 * Returns the Famix class on top of the "context stack"
+	 * Note: does not check that there is such a class, so could possibly throw an EmptyStackException
+	 * @return the Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class topClass() {
+		return getTopClass().getFmxClass();
+	}
+	
+	/**
+	 * Returns the Famix package on top of the "context stack"
+	 * Note: does not check that there is such a package
+	 * @return the Famix namespace
+	 */
+	public Namespace topPckg() {
+		return fmxPckg;
+	}
+
+	/**
+	 * Returns the Famix entity on top of the "context stack"
+	 * Note: does not check that there is such an entity
+	 * @return the Famix entity
+	 */
+	public ContainerEntity top() {
+		ContainerEntity ret = null;
+		ClassStack topc = getTopClass();
+		if (topc != null) {
+			ret = topc.getFmxMethod();
+			if (ret == null) {
+				ret = topc.getFmxClass();
+			}
+		}
+		else {
+			ret = topPckg();
+		}
+
+		return ret;
+	}
+
+	private ClassStack getTopClass() {
+		if (fmxClass.isEmpty()) {
+			return null;
+		}
+		else {
+			return fmxClass.peek();
+		}
+	}
+}
+
Index: verveine.core/src/fr/inria/verveine/core/Dictionary.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/Dictionary.java	(revision 1)
@@ -0,0 +1,468 @@
+package fr.inria.verveine.core;
+
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.LinkedList;
+import java.util.Map;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.Entity;
+import fr.inria.verveine.core.gen.famix.ImplicitVariable;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Reference;
+import fr.inria.verveine.core.gen.famix.StructuralEntity;
+
+/**
+ * A dictionnary of Famix entities to help create them and find them back
+ * @author anquetil
+ *
+ * @param <B> The super class of all bindings. Different for JDT, PDT, ... bindings
+ */
+public class Dictionary<B> {
+
+	public static final String DEFAULT_PCKG_NAME = "<Default Package>";
+	public static final String STUB_METHOD_CONTAINER_NAME = "<StubMethodContainer>";
+	public static final String SELF_NAME = "self";
+	public static final String SUPER_NAME = "super";
+
+	/**
+	 * The FAMIX repository where all FAMIX entities are created and stored
+	 */
+	protected Repository famixRepo;
+
+	/**
+	 * A dictionary to map an IBinding to FAMIX Entity
+	 */
+	protected Map<B,NamedEntity> mapBind;
+
+	/**
+	 * Another dictionary to map a name to FAMIX Entities with this name
+	 */
+	protected Map<String,Collection<NamedEntity>> mapName;
+
+	/**
+	 * Yet another dictionary for implicit variables
+	 * 'self' and 'super' have the same binding than their associated class so they can't be kept easily in bindFmxDico
+	 */
+	protected Map<fr.inria.verveine.core.gen.famix.Class,ImplicitVars> mapImpVar;
+
+	/**
+	 * Used to keep the two possible ImplicitVariable for a given Class binding
+	 * @author anquetil
+	 */
+	protected class ImplicitVars {
+		public ImplicitVariable self_iv;
+		public ImplicitVariable super_iv;
+	}
+	
+	/** Constructor taking a FAMIX repository
+	 * @param famixRepo
+	 */
+	public Dictionary(Repository famixRepo) {
+		this.famixRepo = famixRepo;
+		
+		this.mapBind = new Hashtable<B,NamedEntity>();
+		this.mapName = new Hashtable<String,Collection<NamedEntity>>();
+		this.mapImpVar = new Hashtable<fr.inria.verveine.core.gen.famix.Class,ImplicitVars>();
+	}
+
+	/**
+	 * Returns all the Famix Entity with the given name and class 
+	 * @param fmxClass -- the subtype of Famix Entity we are looking for
+	 * @param name -- the name of the entity
+	 * @return the Collection of Famix Entities with the given name and class (possibly empty)
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> Collection<T> getEntityByName(Class<T> fmxClass, String name) {
+		Collection<T> ret = new LinkedList<T>();
+		Collection<NamedEntity> l_name = mapName.get(name);
+		
+		if (l_name != null ) {
+			for (NamedEntity obj : l_name) {
+				if (fmxClass.isInstance(obj)) {
+					ret.add((T) obj);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns the Famix Entity associated to the given binding.
+	 * <b>Note</b>: Be careful than ImplicitVariables share the same binding than their associated Class and cannot be retrieved with this method.
+	 * In such a case, this method will always retrieve the Class associated to the binding.
+	 * To get an ImplicitVariable from the binding, use {@link Dictionary#getImplicitVariableByBinding(Object, String)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public NamedEntity getEntityByBinding(B bnd) {
+		if (bnd == null) {
+			return null;
+		}
+		else {
+			return mapBind.get(bnd);
+		}
+	}
+
+	/**
+	 * Creates and returns a FAMIX Entity of the type <b>fmxClass</b>.
+	 * The Entity is always created (see {@link Dictionary#ensureFamixStub(Class, Object, String)}).
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param name -- the name of the new instance
+	 * @return the FAMIX Entity or null in case of a FAMIX error
+	 */
+	protected <T extends NamedEntity> T createFamixStub(Class<T> fmxClass, String name) {
+		T fmx = null;
+
+		try {
+			fmx = fmxClass.newInstance();
+		} catch (Exception e) {
+			System.err.println("Unexpected error, could not create a FAMIX entity: "+e.getMessage());
+			e.printStackTrace();
+		}
+		
+		if (fmx != null) {
+			fmx.setName(name);
+			fmx.setIsStub(Boolean.TRUE);
+
+			// put new entity in mappers
+			Collection<NamedEntity> l_ent = mapName.get(name);
+			if (l_ent == null) {
+				l_ent = new LinkedList<NamedEntity>();
+			}
+			l_ent.add(fmx);
+			mapName.put(name, l_ent);
+
+			// put new entity in Famix repository
+			this.famixRepo.add(fmx);
+		}
+
+		return fmx;
+	}
+	
+	/**
+	 * Returns a FAMIX Entity of the type <b>fmxClass</b> and maps it to its binding <b>bnd</b> (if not null).
+	 * The Entity is created if it did not exist.
+	 * <b>Note</b>: Should not be used to create ImplicitVariables and will silently fail if one tries. Use ensureFamixImplicitVariable instead.
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param bnd -- the binding to map to the new instance
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the FAMIX Entity or null if <b>bnd</b> was null or in case of a FAMIX error
+	 * 
+	 * TODO Make public and remove ensureFamixClass(name), ensureFamixAttribute(name), ... ????
+	 */
+	@SuppressWarnings("unchecked")
+	protected <T extends NamedEntity> T ensureFamixStub(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		
+		if (ImplicitVariable.class.isAssignableFrom(fmxClass)) {
+			return null;
+		}
+		
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		else {
+			// Unfortunately different entities with the same name and same type may exist
+			// e.g. 2 parameters of 2 different methods but having the same name
+			// so we must recreate a new entity each time
+
+			//fmxEnt = getEntityByName(fmxClass, name);
+		}
+
+		if (fmx != null) {
+			return fmx;
+		}
+
+		fmx = createFamixStub(fmxClass, name);
+		// put new entity in mappers
+		if (bnd != null) {
+			mapBind.put(bnd, fmx);
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Adds an already created Entity to the FAMIX repository
+	 * Used mainly for non-NamedEntity, for example relationships
+	 * @param e -- the FAMIX entity to add to the repository
+	 */
+	public void famixRepoAdd(Entity e) {
+		this.famixRepo.add(e);
+	}
+
+	///// ensure Famix Entities /////
+
+	/**
+	 * Returns a FAMIX Class with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Class
+	 * @return the FAMIX Class or null in case of a FAMIX error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(String name) {
+		return (fr.inria.verveine.core.gen.famix.Class) ensureFamixStub(fr.inria.verveine.core.gen.famix.Class.class, null, name);
+	}
+
+	/**
+	 * Returns a FAMIX Method with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Method
+	 * @return the FAMIX Method or null in case of a FAMIX error
+	 */
+	public Method ensureFamixMethod(String name) {
+		return (Method) ensureFamixStub(Method.class, null, name);
+	}
+
+	/**
+	 * Returns a FAMIX Attribute with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX Attribute
+	 * @return the FAMIX Attribute or null in case of a FAMIX error
+	 */
+	public Attribute ensureFamixAttribute(String name) {
+		return (Attribute) ensureFamixStub(Attribute.class, null, name);
+	}
+
+	/**
+	 * Returns a FAMIX LocalVariable with the given <b>name</b>, creating it if it does not exist yet
+	 * @param name -- the name of the FAMIX LocalVariable
+	 * @return the FAMIX LocalVariable or null in case of a FAMIX error
+	 */
+	public LocalVariable ensureFamixLocalVariable(String name) {
+		return (LocalVariable) ensureFamixStub(LocalVariable.class, null, name);
+	}
+
+	///// ensure Famix Relationships /////
+
+	/**
+	 * Returns a Famix Inheritance relationship between two Famix Classes creating it if needed
+	 * @param sup -- the super class
+	 * @param sub -- the sub class
+	 * @return the Inheritance relationship
+	 */
+	public Inheritance ensureFamixInheritance(fr.inria.verveine.core.gen.famix.Class sup, fr.inria.verveine.core.gen.famix.Class sub) {
+		for (Inheritance i : sup.getSubInheritances()) {
+			if (i.getSubclass() == sub) {
+				return i;
+			}
+		}
+		Inheritance inh = new Inheritance();
+		inh.setSuperclass(sup);
+		inh.setSubclass(sub);
+		famixRepoAdd(inh);
+		return inh;
+	}
+
+	/**
+	 * Returns a Famix Reference between two Famix Entities creating it if needed
+	 * @param src -- source of the reference
+	 * @param tgt -- target of the reference
+	 * @return the Reference
+	 */
+	public Reference ensureFamixReference(ContainerEntity src, ContainerEntity tgt) {
+		/* We want to keep multiple references between the same entities...
+		   for (Reference r : src.getOutgoingReferences()) {
+			if (r.getTarget() == tgt) {
+				return r;
+			}
+		}
+		*/
+
+		Reference ref = new Reference();
+		ref.setTarget(tgt);
+		ref.setSource(src);
+		famixRepoAdd(ref);
+		
+		return ref;
+	}
+
+	/**
+	 * Returns a Famix Invocation between two Famix Entities creating it if needed
+	 * @param sender of the invocation
+	 * @param invoked -- method invoked
+	 * @param receiver of the invocation
+	 * @return the Invocation
+	 */
+	public Invocation ensureFamixInvocation(BehaviouralEntity sender, BehaviouralEntity invoked, NamedEntity receiver) {
+		/* We keep multiple invocations from one method to another
+		   for (Invocation i : sender.getOutgoingInvocations()) {
+			if  (i.getReceiver() == receiver) {
+				if (i.getCandidates().contains(invoked)) {
+					return i;
+				}				
+			}
+		}
+		*/
+		
+		Invocation invok = new Invocation();
+		invok.setReceiver(receiver);
+		invok.setSender(sender);
+		invok.setSignature(invoked.getSignature());
+		invok.addCandidates(invoked);
+		famixRepoAdd(invok);
+		
+		return invok;
+	}
+	
+	public Access ensureFamixAccess(BehaviouralEntity accessor, StructuralEntity var) {
+		/* We keep multiple accesses from one method to a field */
+		Access acc = new Access();
+		acc.setAccessor(accessor);
+		acc.setVariable(var);
+		acc.setIsWrite(false);  // must be some default and this one seems safer than the opposite
+		famixRepoAdd(acc);
+		
+		return acc;
+	}
+
+	///// Special Case: ImplicitVariables /////
+
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given binding and name (self or super).
+	 * See also {@link Dictionary#getEntityByBinding(Object)}
+	 * @param bnd -- the binding
+	 * @return the Famix Entity associated to the binding or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByBinding(B bnd, String iv_name) {
+		return getImplicitVariableByClass((fr.inria.verveine.core.gen.famix.Class)getEntityByBinding(bnd), iv_name);
+	}
+	
+	/**
+	 * Returns the Famix ImplicitVariable associated to the given Famix Class.
+	 * @param clazz -- the FamixClass
+	 * @param name -- name of the ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the Famix ImplicitVariable associated to the Class or null if not found
+	 */
+	public ImplicitVariable getImplicitVariableByClass(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVars iv = mapImpVar.get(clazz);
+		ImplicitVariable ret = null;
+		
+		if (iv == null) {
+			iv = new ImplicitVars();
+		}
+		
+		if (name.equals(SELF_NAME)) {
+			ret = iv.self_iv;
+		}
+		else if (name.equals(SUPER_NAME)) {
+			ret = iv.super_iv;
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns a FAMIX ImplicitVariable with the given <b>name</b> (self or super) and corresponding to the <b>clazz</b>.
+	 * If this ImplicitVariable does not exist yet, it is created
+	 * @param clazz -- the Famix Class for this ImplicitVariable (should not be null)
+	 * @param name -- the name of the FAMIX ImplicitVariable (should be Dictionary.SELF_NAME or Dictionary.SUPER_NAME)
+	 * @return the FAMIX ImplicitVariable or null in case of a FAMIX error
+	 */
+	public ImplicitVariable ensureFamixImplicitVariable(fr.inria.verveine.core.gen.famix.Class clazz, String name) {
+		ImplicitVariable fmx = getImplicitVariableByClass(clazz, name);
+		
+		if (fmx == null) {
+			fmx = (ImplicitVariable) createFamixStub(ImplicitVariable.class, name);
+			if (fmx!=null) {
+				fmx.setContainer(clazz);
+				fmx.setIsStub(Boolean.FALSE);
+
+				ImplicitVars iv = mapImpVar.get(clazz);				
+				if (iv == null) {
+					iv = new ImplicitVars();
+				}
+
+				if (name.equals(SELF_NAME)) {
+					iv.self_iv = fmx;
+				}
+				else if (name.equals(SUPER_NAME)) {
+					iv.super_iv = fmx;
+				}
+				
+				mapImpVar.put(clazz, iv);
+			}
+		}
+
+		return fmx;
+	}
+
+	///// Special Case: "Uniq" Entities /////
+
+	/**
+	 * Creates or recovers a Famix Named Entity uniq for the given name.
+	 * For some specific entities we don't allow two of them with the same name.
+	 * This is the case e.g. for the default package, or the Java class "Object" and its package "java.lang".
+	 * @param fmxClass -- the FAMIX class of the instance to create
+	 * @param bnd -- a potential binding for the entity
+	 * @param name -- the name of the new instance (used if <tt>bnd == null</tt>)
+	 * @return the uniq Famix Entity for this binding and/or name
+	 */
+	@SuppressWarnings("unchecked")
+	public <T extends NamedEntity> T ensureFamixUniqEntity(Class<T> fmxClass, B bnd, String name) {
+		T fmx = null;
+		if (bnd != null) {
+			fmx = (T) getEntityByBinding(bnd);
+		}
+		
+		if (fmx == null) {
+			Collection<T> l = getEntityByName( fmxClass, name);
+			if (l.size() > 0) {
+				fmx = l.iterator().next();
+			}
+			else {
+				fmx = createFamixStub(fmxClass, name);
+			}
+			
+			if (bnd != null) {
+				// may happen for when the entity was first created without binding
+				// and we find a binding for it later
+				mapBind.put(bnd, fmx);
+			}
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a FAMIX Namespace with the given <b>name</b>, creating it if it does not exist yet
+	 * We assume that Namespaces must be uniq for a given name
+	 * @param name -- the name of the FAMIX Namespace
+	 * @return the FAMIX Namespace or null in case of a FAMIX error
+	 */
+	public Namespace ensureFamixNamespace(String name) {
+		return (Namespace) ensureFamixUniqEntity(Namespace.class, null, name);
+	}
+
+	/**
+	 * Creates or recovers a default Famix Namespace.
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix Namespace
+	 */
+	public Namespace ensureFamixNamespaceDefault() {
+		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, DEFAULT_PCKG_NAME);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers a Famix Class to contain the methods stubs (for which we ignore the real owner).
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix class
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, null, STUB_METHOD_CONTAINER_NAME);
+		fmx.setContainer( ensureFamixNamespaceDefault());
+
+		return fmx;
+	}
+	
+}
Index: verveine.core/src/fr/inria/verveine/core/gen/file/File.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/File.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/File.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("File")
+public class File extends AbstractFile {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FILEModel.java	(revision 1)
@@ -0,0 +1,24 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class FILEModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.file.FileGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.FolderGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.File.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.AbstractFile.class);
+		metamodel.with(fr.inria.verveine.core.gen.file.Folder.class);
+
+    }
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/AbstractFile.java	(revision 1)
@@ -0,0 +1,30 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("AbstractFile")
+public class AbstractFile extends Entity {
+
+
+
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FolderGroup.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("FolderGroup")
+public class FolderGroup extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/Folder.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("Folder")
+public class Folder extends AbstractFile {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/file/FileGroup.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.file;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FILE")
+@FameDescription("FileGroup")
+public class FileGroup extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModel.java	(revision 1)
@@ -0,0 +1,43 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class HismoModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoPackageHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInheritanceDefinitionHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHierarchy.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoModelHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoInvocationHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFileHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoEntityVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoFolderHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoClassHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAbstractHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoAttributeHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodVersion.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoNamespaceHistoryGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangePattern.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoMethodHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.hismo.HismoCoChangeHistory.class);
+
+    }
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFileHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoFileHistory")
+public class HismoFileHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceVersion.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceVersion")
+public class HismoNamespaceVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodHistory")
+public class HismoMethodHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHierarchy.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHierarchy")
+public class HismoClassHierarchy extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistoryGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHistoryGroup")
+public class HismoClassHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangePattern.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangePattern")
+public class HismoCoChangePattern extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractVersion.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAbstractVersion")
+public class HismoAbstractVersion extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassVersion.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassVersion")
+public class HismoClassVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoPackageHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoPackageHistory")
+public class HismoPackageHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeVersion.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangeVersion")
+public class HismoCoChangeVersion extends HismoAbstractVersion {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceHistory")
+public class HismoNamespaceHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoHistoryGroup.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoHistoryGroup")
+public class HismoHistoryGroup extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodHistoryGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodHistoryGroup")
+public class HismoMethodHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoModelHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoModelHistory")
+public class HismoModelHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoEntityVersion.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoEntityVersion")
+public class HismoEntityVersion extends HismoAbstractVersion {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInheritanceDefinitionHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoInheritanceDefinitionHistory")
+public class HismoInheritanceDefinitionHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAttributeHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAttributeHistory")
+public class HismoAttributeHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoAbstractHistory.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoAbstractHistory")
+public class HismoAbstractHistory extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoMethodVersion.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoMethodVersion")
+public class HismoMethodVersion extends HismoEntityVersion {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoClassHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoClassHistory")
+public class HismoClassHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoCoChangeHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoCoChangeHistory")
+public class HismoCoChangeHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoInvocationHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoInvocationHistory")
+public class HismoInvocationHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoNamespaceHistoryGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoNamespaceHistoryGroup")
+public class HismoNamespaceHistoryGroup extends HismoHistoryGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/hismo/HismoFolderHistory.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.hismo;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Hismo")
+@FameDescription("HismoFolderHistory")
+public class HismoFolderHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/CodeLine.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("CodeLine")
+public class CodeLine extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DudeModel.java	(revision 1)
@@ -0,0 +1,25 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class DudeModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.dude.Duplication.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.DuplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.MultiplicationGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.CodeFragment.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.Multiplication.class);
+		metamodel.with(fr.inria.verveine.core.gen.dude.CodeLine.class);
+
+    }
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/DuplicationGroup.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("DuplicationGroup")
+public class DuplicationGroup extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/MultiplicationGroup.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import fr.inria.verveine.core.gen.moose.MooseGroup;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("MultiplicationGroup")
+public class MultiplicationGroup extends MooseGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/Duplication.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("Duplication")
+public class Duplication extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/Multiplication.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("Multiplication")
+public class Multiplication extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/dude/CodeFragment.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.dude;
+
+import ch.akuhn.fame.FameDescription;
+import fr.inria.verveine.core.gen.famix.Entity;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Dude")
+@FameDescription("CodeFragment")
+public class CodeFragment extends Entity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseAbsractGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("MooseAbsractGroup")
+public class MooseAbsractGroup extends MooseEntity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseEntity.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("MooseEntity")
+public class MooseEntity  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("MooseGroup")
+public class MooseGroup extends MooseAbsractGroup {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/HismoAccessHistory.java	(revision 1)
@@ -0,0 +1,18 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import fr.inria.verveine.core.gen.hismo.HismoAbstractHistory;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("Moose")
+@FameDescription("HismoAccessHistory")
+public class HismoAccessHistory extends HismoAbstractHistory {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/moose/MooseModel.java	(revision 1)
@@ -0,0 +1,24 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.moose;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class MooseModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.moose.MooseGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.HismoAccessHistory.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.MooseModel.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.MooseAbsractGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.moose.MooseEntity.class);
+
+    }
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ThrownException.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ThrownException")
+public class ThrownException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "thrownExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getThrownExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getThrownExceptions().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Access.java	(revision 1)
@@ -0,0 +1,80 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Access")
+public class Access extends Association {
+
+
+
+    private Boolean isWrite;
+    
+    @FameProperty(name = "isWrite")
+    public Boolean getIsWrite() {
+        return isWrite;
+    }
+
+    public void setIsWrite(Boolean isWrite) {
+        this.isWrite = isWrite;
+    }
+    
+    private BehaviouralEntity accessor;
+    
+    @FameProperty(name = "accessor", opposite = "accesses")
+    public BehaviouralEntity getAccessor() {
+        return accessor;
+    }
+
+    public void setAccessor(BehaviouralEntity accessor) {
+        if (this.accessor != null) {
+            if (this.accessor.equals(accessor)) return;
+            this.accessor.getAccesses().remove(this);
+        }
+        this.accessor = accessor;
+        if (accessor == null) return;
+        accessor.getAccesses().add(this);
+    }
+    
+    private StructuralEntity variable;
+    
+    @FameProperty(name = "variable", opposite = "incomingAccesses")
+    public StructuralEntity getVariable() {
+        return variable;
+    }
+
+    public void setVariable(StructuralEntity variable) {
+        if (this.variable != null) {
+            if (this.variable.equals(variable)) return;
+            this.variable.getIncomingAccesses().remove(this);
+        }
+        this.variable = variable;
+        if (variable == null) return;
+        variable.getIncomingAccesses().add(this);
+    }
+    
+    @FameProperty(name = "isRead", derived = true)
+    public Boolean getIsRead() {
+        // TODO: this is a derived property, implement this method manually.
+        //throw new UnsupportedOperationException("Access.getIsRead() Not yet implemented!");
+    	return ! getIsWrite(); 
+    }
+
+	@Override
+	public NamedEntity getTo() {
+		return this.getVariable();
+	}
+
+	@Override
+	public NamedEntity getFrom() {
+		return this.getAccessor();
+	}
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourcedEntity.java	(revision 1)
@@ -0,0 +1,90 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourcedEntity")
+public class SourcedEntity extends Entity {
+
+
+
+    private SourceAnchor sourceAnchor;
+    
+    @FameProperty(name = "sourceAnchor", opposite = "element")
+    public SourceAnchor getSourceAnchor() {
+        return sourceAnchor;
+    }
+
+    public void setSourceAnchor(SourceAnchor sourceAnchor) {
+        if (this.sourceAnchor == null ? sourceAnchor != null : !this.sourceAnchor.equals(sourceAnchor)) {
+            SourceAnchor old_sourceAnchor = this.sourceAnchor;
+            this.sourceAnchor = sourceAnchor;
+            if (old_sourceAnchor != null) old_sourceAnchor.setElement(null);
+            if (sourceAnchor != null) sourceAnchor.setElement(this);
+        }
+    }
+    
+    private Collection<Comment> comments; 
+
+    @FameProperty(name = "comments", opposite = "container", derived = true)
+    public Collection<Comment> getComments() {
+        if (comments == null) {
+            comments = new MultivalueSet<Comment>() {
+                @Override
+                protected void clearOpposite(Comment e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(Comment e) {
+                    e.setContainer(SourcedEntity.this);
+                }
+            };
+        }
+        return comments;
+    }
+    
+    public void setComments(Collection<? extends Comment> comments) {
+        this.getComments().clear();
+        this.getComments().addAll(comments);
+    }                    
+    
+        
+    public void addComments(Comment one) {
+        this.getComments().add(one);
+    }   
+    
+    public void addComments(Comment one, Comment... many) {
+        this.getComments().add(one);
+        for (Comment each : many)
+            this.getComments().add(each);
+    }   
+    
+    public void addComments(Iterable<? extends Comment> many) {
+        for (Comment each : many)
+            this.getComments().add(each);
+    }   
+                
+    public void addComments(Comment[] many) {
+        for (Comment each : many)
+            this.getComments().add(each);
+    }
+    
+    public int numberOfComments() {
+        return getComments().size();
+    }
+
+    public boolean hasComments() {
+        return !getComments().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Comment.java	(revision 1)
@@ -0,0 +1,46 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Comment")
+public class Comment extends SourcedEntity {
+
+
+
+    private String content;
+    
+    @FameProperty(name = "content")
+    public String getContent() {
+        return content;
+    }
+
+    public void setContent(String content) {
+        this.content = content;
+    }
+    
+    private SourcedEntity container;
+    
+    @FameProperty(name = "container", opposite = "comments")
+    public SourcedEntity getContainer() {
+        return container;
+    }
+
+    public void setContainer(SourcedEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getComments().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getComments().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Attribute.java	(revision 1)
@@ -0,0 +1,46 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Attribute")
+public class Attribute extends StructuralEntity {
+
+
+
+    private Boolean hasClassScope;
+    
+    @FameProperty(name = "hasClassScope")
+    public Boolean getHasClassScope() {
+        return hasClassScope;
+    }
+
+    public void setHasClassScope(Boolean hasClassScope) {
+        this.hasClassScope = hasClassScope;
+    }
+    
+    private Type parentType;
+    
+    @FameProperty(name = "parentType", opposite = "attributes")
+    public Type getParentType() {
+        return parentType;
+    }
+
+    public void setParentType(Type parentType) {
+        if (this.parentType != null) {
+            if (this.parentType.equals(parentType)) return;
+            this.parentType.getAttributes().remove(this);
+        }
+        this.parentType = parentType;
+        if (parentType == null) return;
+        parentType.getAttributes().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamespaceGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("NamespaceGroup")
+public class NamespaceGroup  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Invocation.java	(revision 1)
@@ -0,0 +1,137 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Invocation")
+public class Invocation extends Association {
+
+
+
+    private BehaviouralEntity sender;
+    
+    @FameProperty(name = "sender", opposite = "outgoingInvocations")
+    public BehaviouralEntity getSender() {
+        return sender;
+    }
+
+    public void setSender(BehaviouralEntity sender) {
+        if (this.sender != null) {
+            if (this.sender.equals(sender)) return;
+            this.sender.getOutgoingInvocations().remove(this);
+        }
+        this.sender = sender;
+        if (sender == null) return;
+        sender.getOutgoingInvocations().add(this);
+    }
+    
+    private NamedEntity receiver;
+    
+    @FameProperty(name = "receiver", opposite = "receivingInvocations")
+    public NamedEntity getReceiver() {
+        return receiver;
+    }
+
+    public void setReceiver(NamedEntity receiver) {
+        if (this.receiver != null) {
+            if (this.receiver.equals(receiver)) return;
+            this.receiver.getReceivingInvocations().remove(this);
+        }
+        this.receiver = receiver;
+        if (receiver == null) return;
+        receiver.getReceivingInvocations().add(this);
+    }
+    
+    private String receiverSourceCode;
+    
+    @FameProperty(name = "receiverSourceCode")
+    public String getReceiverSourceCode() {
+        return receiverSourceCode;
+    }
+
+    public void setReceiverSourceCode(String receiverSourceCode) {
+        this.receiverSourceCode = receiverSourceCode;
+    }
+    
+    private String signature;
+    
+    @FameProperty(name = "signature")
+    public String getSignature() {
+        return signature;
+    }
+
+    public void setSignature(String signature) {
+        this.signature = signature;
+    }
+    
+    private Collection<BehaviouralEntity> candidates; 
+
+    @FameProperty(name = "candidates", opposite = "incomingInvocations")
+    public Collection<BehaviouralEntity> getCandidates() {
+        if (candidates == null) {
+            candidates = new MultivalueSet<BehaviouralEntity>() {
+                @Override
+                protected void clearOpposite(BehaviouralEntity e) {
+                    e.getIncomingInvocations().remove(Invocation.this);
+                }
+                @Override
+                protected void setOpposite(BehaviouralEntity e) {
+                    e.getIncomingInvocations().add(Invocation.this);
+                }
+            };
+        }
+        return candidates;
+    }
+    
+    public void setCandidates(Collection<? extends BehaviouralEntity> candidates) {
+        this.getCandidates().clear();
+        this.getCandidates().addAll(candidates);
+    }
+    
+    public void addCandidates(BehaviouralEntity one) {
+        this.getCandidates().add(one);
+    }   
+    
+    public void addCandidates(BehaviouralEntity one, BehaviouralEntity... many) {
+        this.getCandidates().add(one);
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }   
+    
+    public void addCandidates(Iterable<? extends BehaviouralEntity> many) {
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }   
+                
+    public void addCandidates(BehaviouralEntity[] many) {
+        for (BehaviouralEntity each : many)
+            this.getCandidates().add(each);
+    }
+    
+    public int numberOfCandidates() {
+        return getCandidates().size();
+    }
+
+    public boolean hasCandidates() {
+        return !getCandidates().isEmpty();
+    }
+
+	public NamedEntity getFrom() {
+		return this.getSender();
+	}
+
+	public NamedEntity getTo() {
+		return this.getReceiver();
+	}
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Entity.java	(revision 1)
@@ -0,0 +1,74 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Entity")
+public class Entity  {
+
+
+
+    private Collection<AnnotationInstance> annotationInstances; 
+
+    @FameProperty(name = "annotationInstances", opposite = "annotatedEntity", derived = true)
+    public Collection<AnnotationInstance> getAnnotationInstances() {
+        if (annotationInstances == null) {
+            annotationInstances = new MultivalueSet<AnnotationInstance>() {
+                @Override
+                protected void clearOpposite(AnnotationInstance e) {
+                    e.setAnnotatedEntity(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstance e) {
+                    e.setAnnotatedEntity(Entity.this);
+                }
+            };
+        }
+        return annotationInstances;
+    }
+    
+    public void setAnnotationInstances(Collection<? extends AnnotationInstance> annotationInstances) {
+        this.getAnnotationInstances().clear();
+        this.getAnnotationInstances().addAll(annotationInstances);
+    }                    
+    
+        
+    public void addAnnotationInstances(AnnotationInstance one) {
+        this.getAnnotationInstances().add(one);
+    }   
+    
+    public void addAnnotationInstances(AnnotationInstance one, AnnotationInstance... many) {
+        this.getAnnotationInstances().add(one);
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }   
+    
+    public void addAnnotationInstances(Iterable<? extends AnnotationInstance> many) {
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }   
+                
+    public void addAnnotationInstances(AnnotationInstance[] many) {
+        for (AnnotationInstance each : many)
+            this.getAnnotationInstances().add(each);
+    }
+    
+    public int numberOfAnnotationInstances() {
+        return getAnnotationInstances().size();
+    }
+
+    public boolean hasAnnotationInstances() {
+        return !getAnnotationInstances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Parameter.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Parameter")
+public class Parameter extends StructuralEntity {
+
+
+
+    private BehaviouralEntity parentBehaviouralEntity;
+    
+    @FameProperty(name = "parentBehaviouralEntity", opposite = "parameters")
+    public BehaviouralEntity getParentBehaviouralEntity() {
+        return parentBehaviouralEntity;
+    }
+
+    public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
+        if (this.parentBehaviouralEntity != null) {
+            if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
+            this.parentBehaviouralEntity.getParameters().remove(this);
+        }
+        this.parentBehaviouralEntity = parentBehaviouralEntity;
+        if (parentBehaviouralEntity == null) return;
+        parentBehaviouralEntity.getParameters().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Method.java	(revision 1)
@@ -0,0 +1,221 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Method")
+public class Method extends BehaviouralEntity {
+
+
+
+    private Collection<CaughtException> caughtExceptions; 
+
+    @FameProperty(name = "caughtExceptions", opposite = "definingMethod", derived = true)
+    public Collection<CaughtException> getCaughtExceptions() {
+        if (caughtExceptions == null) {
+            caughtExceptions = new MultivalueSet<CaughtException>() {
+                @Override
+                protected void clearOpposite(CaughtException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(CaughtException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return caughtExceptions;
+    }
+    
+    public void setCaughtExceptions(Collection<? extends CaughtException> caughtExceptions) {
+        this.getCaughtExceptions().clear();
+        this.getCaughtExceptions().addAll(caughtExceptions);
+    }                    
+    
+        
+    public void addCaughtExceptions(CaughtException one) {
+        this.getCaughtExceptions().add(one);
+    }   
+    
+    public void addCaughtExceptions(CaughtException one, CaughtException... many) {
+        this.getCaughtExceptions().add(one);
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }   
+    
+    public void addCaughtExceptions(Iterable<? extends CaughtException> many) {
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }   
+                
+    public void addCaughtExceptions(CaughtException[] many) {
+        for (CaughtException each : many)
+            this.getCaughtExceptions().add(each);
+    }
+    
+    public int numberOfCaughtExceptions() {
+        return getCaughtExceptions().size();
+    }
+
+    public boolean hasCaughtExceptions() {
+        return !getCaughtExceptions().isEmpty();
+    }
+    
+                
+    private Collection<DeclaredException> declaredExceptions; 
+
+    @FameProperty(name = "declaredExceptions", opposite = "definingMethod", derived = true)
+    public Collection<DeclaredException> getDeclaredExceptions() {
+        if (declaredExceptions == null) {
+            declaredExceptions = new MultivalueSet<DeclaredException>() {
+                @Override
+                protected void clearOpposite(DeclaredException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(DeclaredException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return declaredExceptions;
+    }
+    
+    public void setDeclaredExceptions(Collection<? extends DeclaredException> declaredExceptions) {
+        this.getDeclaredExceptions().clear();
+        this.getDeclaredExceptions().addAll(declaredExceptions);
+    }                    
+    
+        
+    public void addDeclaredExceptions(DeclaredException one) {
+        this.getDeclaredExceptions().add(one);
+    }   
+    
+    public void addDeclaredExceptions(DeclaredException one, DeclaredException... many) {
+        this.getDeclaredExceptions().add(one);
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }   
+    
+    public void addDeclaredExceptions(Iterable<? extends DeclaredException> many) {
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }   
+                
+    public void addDeclaredExceptions(DeclaredException[] many) {
+        for (DeclaredException each : many)
+            this.getDeclaredExceptions().add(each);
+    }
+    
+    public int numberOfDeclaredExceptions() {
+        return getDeclaredExceptions().size();
+    }
+
+    public boolean hasDeclaredExceptions() {
+        return !getDeclaredExceptions().isEmpty();
+    }
+    
+                
+    private Boolean hasClassScope;
+    
+    @FameProperty(name = "hasClassScope")
+    public Boolean getHasClassScope() {
+        return hasClassScope;
+    }
+
+    public void setHasClassScope(Boolean hasClassScope) {
+        this.hasClassScope = hasClassScope;
+    }
+    
+    private Collection<ThrownException> thrownExceptions; 
+
+    @FameProperty(name = "thrownExceptions", opposite = "definingMethod", derived = true)
+    public Collection<ThrownException> getThrownExceptions() {
+        if (thrownExceptions == null) {
+            thrownExceptions = new MultivalueSet<ThrownException>() {
+                @Override
+                protected void clearOpposite(ThrownException e) {
+                    e.setDefiningMethod(null);
+                }
+                @Override
+                protected void setOpposite(ThrownException e) {
+                    e.setDefiningMethod(Method.this);
+                }
+            };
+        }
+        return thrownExceptions;
+    }
+    
+    public void setThrownExceptions(Collection<? extends ThrownException> thrownExceptions) {
+        this.getThrownExceptions().clear();
+        this.getThrownExceptions().addAll(thrownExceptions);
+    }                    
+    
+        
+    public void addThrownExceptions(ThrownException one) {
+        this.getThrownExceptions().add(one);
+    }   
+    
+    public void addThrownExceptions(ThrownException one, ThrownException... many) {
+        this.getThrownExceptions().add(one);
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }   
+    
+    public void addThrownExceptions(Iterable<? extends ThrownException> many) {
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }   
+                
+    public void addThrownExceptions(ThrownException[] many) {
+        for (ThrownException each : many)
+            this.getThrownExceptions().add(each);
+    }
+    
+    public int numberOfThrownExceptions() {
+        return getThrownExceptions().size();
+    }
+
+    public boolean hasThrownExceptions() {
+        return !getThrownExceptions().isEmpty();
+    }
+    
+                
+    private String kind;
+    
+    @FameProperty(name = "kind")
+    public String getKind() {
+        return kind;
+    }
+
+    public void setKind(String kind) {
+        this.kind = kind;
+    }
+    
+    private Type parentType;
+    
+    @FameProperty(name = "parentType", opposite = "methods")
+    public Type getParentType() {
+        return parentType;
+    }
+
+    public void setParentType(Type parentType) {
+        if (this.parentType != null) {
+            if (this.parentType.equals(parentType)) return;
+            this.parentType.getMethods().remove(this);
+        }
+        this.parentType = parentType;
+        if (parentType == null) return;
+        parentType.getMethods().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ImplicitVariable.java	(revision 1)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ImplicitVariable")
+public class ImplicitVariable extends StructuralEntity {
+
+
+
+    private Type container;
+    
+    @FameProperty(name = "container")
+    public Type getContainer() {
+        return container;
+    }
+
+    public void setContainer(Type container) {
+        this.container = container;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/NamedEntity.java	(revision 1)
@@ -0,0 +1,227 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("NamedEntity")
+public class NamedEntity extends SourcedEntity {
+
+
+
+    private Boolean isAbstract;
+    
+    @FameProperty(name = "isAbstract")
+    public Boolean getIsAbstract() {
+        return isAbstract;
+    }
+
+    public void setIsAbstract(Boolean isAbstract) {
+        this.isAbstract = isAbstract;
+    }
+    
+    private Boolean isPrivate;
+    
+    @FameProperty(name = "isPrivate")
+    public Boolean getIsPrivate() {
+        return isPrivate;
+    }
+
+    public void setIsPrivate(Boolean isPrivate) {
+        this.isPrivate = isPrivate;
+    }
+    
+    private Boolean isPackage;
+    
+    @FameProperty(name = "isPackage")
+    public Boolean getIsPackage() {
+        return isPackage;
+    }
+
+    public void setIsPackage(Boolean isPackage) {
+        this.isPackage = isPackage;
+    }
+    
+    private Package parentPackage;
+    
+    @FameProperty(name = "parentPackage", opposite = "childNamedEntities")
+    public Package getParentPackage() {
+        return parentPackage;
+    }
+
+    public void setParentPackage(Package parentPackage) {
+        if (this.parentPackage != null) {
+            if (this.parentPackage.equals(parentPackage)) return;
+            this.parentPackage.getChildNamedEntities().remove(this);
+        }
+        this.parentPackage = parentPackage;
+        if (parentPackage == null) return;
+        parentPackage.getChildNamedEntities().add(this);
+    }
+    
+    private String name;
+    
+    @FameProperty(name = "name")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+    private Boolean isStub;
+    
+    @FameProperty(name = "isStub")
+    public Boolean getIsStub() {
+        return isStub;
+    }
+
+    public void setIsStub(Boolean isStub) {
+        this.isStub = isStub;
+    }
+    
+    private Boolean isPublic;
+    
+    @FameProperty(name = "isPublic")
+    public Boolean getIsPublic() {
+        return isPublic;
+    }
+
+    public void setIsPublic(Boolean isPublic) {
+        this.isPublic = isPublic;
+    }
+    
+    private Boolean isProtected;
+    
+    @FameProperty(name = "isProtected")
+    public Boolean getIsProtected() {
+        return isProtected;
+    }
+
+    public void setIsProtected(Boolean isProtected) {
+        this.isProtected = isProtected;
+    }
+    
+    private Collection<Invocation> receivingInvocations; 
+
+    @FameProperty(name = "receivingInvocations", opposite = "receiver", derived = true)
+    public Collection<Invocation> getReceivingInvocations() {
+        if (receivingInvocations == null) {
+            receivingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.setReceiver(null);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.setReceiver(NamedEntity.this);
+                }
+            };
+        }
+        return receivingInvocations;
+    }
+    
+    public void setReceivingInvocations(Collection<? extends Invocation> receivingInvocations) {
+        this.getReceivingInvocations().clear();
+        this.getReceivingInvocations().addAll(receivingInvocations);
+    }                    
+    
+        
+    public void addReceivingInvocations(Invocation one) {
+        this.getReceivingInvocations().add(one);
+    }   
+    
+    public void addReceivingInvocations(Invocation one, Invocation... many) {
+        this.getReceivingInvocations().add(one);
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }   
+    
+    public void addReceivingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }   
+                
+    public void addReceivingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getReceivingInvocations().add(each);
+    }
+    
+    public int numberOfReceivingInvocations() {
+        return getReceivingInvocations().size();
+    }
+
+    public boolean hasReceivingInvocations() {
+        return !getReceivingInvocations().isEmpty();
+    }
+    
+                
+    private Collection<String> modifiers; 
+
+    @FameProperty(name = "modifiers")
+    public Collection<String> getModifiers() {
+        if (modifiers == null) modifiers = new HashSet<String>();
+        return modifiers;
+    }
+    
+    public void setModifiers(Collection<? extends String> modifiers) {
+        this.getModifiers().clear();
+        this.getModifiers().addAll(modifiers);
+    }                    
+
+    public void addModifiers(String one) {
+        this.getModifiers().add(one);
+    }   
+    
+    public void addModifiers(String one, String... many) {
+        this.getModifiers().add(one);
+        for (String each : many)
+            this.getModifiers().add(each);
+    }   
+    
+    public void addModifiers(Iterable<? extends String> many) {
+        for (String each : many)
+            this.getModifiers().add(each);
+    }   
+                
+    public void addModifiers(String[] many) {
+        for (String each : many)
+            this.getModifiers().add(each);
+    }
+    
+    public int numberOfModifiers() {
+        return getModifiers().size();
+    }
+
+    public boolean hasModifiers() {
+        return !getModifiers().isEmpty();
+    }
+    
+                
+    @FameProperty(name = "belongsTo", derived = true)
+    public ContainerEntity getBelongsTo() {
+        // TODO: this is a derived property, implement this method manually.
+    	return null;
+    }
+    
+    private Boolean isFinal;
+    
+    @FameProperty(name = "isFinal")
+    public Boolean getIsFinal() {
+        return isFinal;
+    }
+
+    public void setIsFinal(Boolean isFinal) {
+        this.isFinal = isFinal;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/DeclaredException.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("DeclaredException")
+public class DeclaredException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "declaredExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getDeclaredExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getDeclaredExceptions().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariableGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("GlobalVariableGroup")
+public class GlobalVariableGroup  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/FAMIXModel.java	(revision 1)
@@ -0,0 +1,60 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.MetaRepository;
+
+public class FAMIXModel {
+
+    public static MetaRepository metamodel() {
+        MetaRepository metamodel = new MetaRepository();
+        importInto(metamodel);
+        return metamodel;
+    }
+    
+    public static void importInto(MetaRepository metamodel) {
+		metamodel.with(fr.inria.verveine.core.gen.famix.FileAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Class.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Invocation.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.CaughtException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.DeclaredException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ClassGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourcedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Association.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Namespace.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LeafEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PackageGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.AnnotationInstance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.SourceTextAnchor.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.MethodGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ScopingEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Function.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Attribute.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.UnknownVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamedEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.BehaviouralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Access.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Method.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Type.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.PrimitiveType.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Exception.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.NamespaceGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Parameter.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Inheritance.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Entity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ThrownException.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.LocalVariable.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.GlobalVariableGroup.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ContainerEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Package.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Comment.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.StructuralEntity.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.Reference.class);
+		metamodel.with(fr.inria.verveine.core.gen.famix.ImplicitVariable.class);
+
+    }
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourceAnchor.java	(revision 1)
@@ -0,0 +1,34 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceAnchor")
+public class SourceAnchor extends Entity {
+
+
+
+    private SourcedEntity element;
+    
+    @FameProperty(name = "element", opposite = "sourceAnchor")
+    public SourcedEntity getElement() {
+        return element;
+    }
+
+    public void setElement(SourcedEntity element) {
+        if (this.element == null ? element != null : !this.element.equals(element)) {
+            SourcedEntity old_element = this.element;
+            this.element = element;
+            if (old_element != null) old_element.setSourceAnchor(null);
+            if (element != null) element.setSourceAnchor(this);
+        }
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Package.java	(revision 1)
@@ -0,0 +1,74 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Package")
+public class Package extends ScopingEntity {
+
+
+
+    private Collection<NamedEntity> childNamedEntities; 
+
+    @FameProperty(name = "childNamedEntities", opposite = "parentPackage", derived = true)
+    public Collection<NamedEntity> getChildNamedEntities() {
+        if (childNamedEntities == null) {
+            childNamedEntities = new MultivalueSet<NamedEntity>() {
+                @Override
+                protected void clearOpposite(NamedEntity e) {
+                    e.setParentPackage(null);
+                }
+                @Override
+                protected void setOpposite(NamedEntity e) {
+                    e.setParentPackage(Package.this);
+                }
+            };
+        }
+        return childNamedEntities;
+    }
+    
+    public void setChildNamedEntities(Collection<? extends NamedEntity> childNamedEntities) {
+        this.getChildNamedEntities().clear();
+        this.getChildNamedEntities().addAll(childNamedEntities);
+    }                    
+    
+        
+    public void addChildNamedEntities(NamedEntity one) {
+        this.getChildNamedEntities().add(one);
+    }   
+    
+    public void addChildNamedEntities(NamedEntity one, NamedEntity... many) {
+        this.getChildNamedEntities().add(one);
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }   
+    
+    public void addChildNamedEntities(Iterable<? extends NamedEntity> many) {
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }   
+                
+    public void addChildNamedEntities(NamedEntity[] many) {
+        for (NamedEntity each : many)
+            this.getChildNamedEntities().add(each);
+    }
+    
+    public int numberOfChildNamedEntities() {
+        return getChildNamedEntities().size();
+    }
+
+    public boolean hasChildNamedEntities() {
+        return !getChildNamedEntities().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Namespace.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Namespace")
+public class Namespace extends ScopingEntity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Exception.java	(revision 1)
@@ -0,0 +1,29 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Exception")
+public class Exception extends Entity {
+
+
+
+    private Class exceptionClass;
+    
+    @FameProperty(name = "exceptionClass")
+    public Class getExceptionClass() {
+        return exceptionClass;
+    }
+
+    public void setExceptionClass(Class exceptionClass) {
+        this.exceptionClass = exceptionClass;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/BehaviouralEntity.java	(revision 1)
@@ -0,0 +1,311 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("BehaviouralEntity")
+public class BehaviouralEntity extends ContainerEntity {
+
+
+
+    private Collection<Access> accesses; 
+
+    @FameProperty(name = "accesses", opposite = "accessor", derived = true)
+    public Collection<Access> getAccesses() {
+        if (accesses == null) {
+            accesses = new MultivalueSet<Access>() {
+                @Override
+                protected void clearOpposite(Access e) {
+                    e.setAccessor(null);
+                }
+                @Override
+                protected void setOpposite(Access e) {
+                    e.setAccessor(BehaviouralEntity.this);
+                }
+            };
+        }
+        return accesses;
+    }
+    
+    public void setAccesses(Collection<? extends Access> accesses) {
+        this.getAccesses().clear();
+        this.getAccesses().addAll(accesses);
+    }                    
+    
+        
+    public void addAccesses(Access one) {
+        this.getAccesses().add(one);
+    }   
+    
+    public void addAccesses(Access one, Access... many) {
+        this.getAccesses().add(one);
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }   
+    
+    public void addAccesses(Iterable<? extends Access> many) {
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }   
+                
+    public void addAccesses(Access[] many) {
+        for (Access each : many)
+            this.getAccesses().add(each);
+    }
+    
+    public int numberOfAccesses() {
+        return getAccesses().size();
+    }
+
+    public boolean hasAccesses() {
+        return !getAccesses().isEmpty();
+    }
+    
+                
+    private Collection<Invocation> outgoingInvocations; 
+
+    @FameProperty(name = "outgoingInvocations", opposite = "sender", derived = true)
+    public Collection<Invocation> getOutgoingInvocations() {
+        if (outgoingInvocations == null) {
+            outgoingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.setSender(null);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.setSender(BehaviouralEntity.this);
+                }
+            };
+        }
+        return outgoingInvocations;
+    }
+    
+    public void setOutgoingInvocations(Collection<? extends Invocation> outgoingInvocations) {
+        this.getOutgoingInvocations().clear();
+        this.getOutgoingInvocations().addAll(outgoingInvocations);
+    }                    
+    
+        
+    public void addOutgoingInvocations(Invocation one) {
+        this.getOutgoingInvocations().add(one);
+    }   
+    
+    public void addOutgoingInvocations(Invocation one, Invocation... many) {
+        this.getOutgoingInvocations().add(one);
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }   
+    
+    public void addOutgoingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }   
+                
+    public void addOutgoingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getOutgoingInvocations().add(each);
+    }
+    
+    public int numberOfOutgoingInvocations() {
+        return getOutgoingInvocations().size();
+    }
+
+    public boolean hasOutgoingInvocations() {
+        return !getOutgoingInvocations().isEmpty();
+    }
+    
+                
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private Collection<Invocation> incomingInvocations; 
+
+    @FameProperty(name = "incomingInvocations", opposite = "candidates", derived = true)
+    public Collection<Invocation> getIncomingInvocations() {
+        if (incomingInvocations == null) {
+            incomingInvocations = new MultivalueSet<Invocation>() {
+                @Override
+                protected void clearOpposite(Invocation e) {
+                    e.getCandidates().remove(BehaviouralEntity.this);
+                }
+                @Override
+                protected void setOpposite(Invocation e) {
+                    e.getCandidates().add(BehaviouralEntity.this);
+                }
+            };
+        }
+        return incomingInvocations;
+    }
+    
+    public void setIncomingInvocations(Collection<? extends Invocation> incomingInvocations) {
+        this.getIncomingInvocations().clear();
+        this.getIncomingInvocations().addAll(incomingInvocations);
+    }
+    
+    public void addIncomingInvocations(Invocation one) {
+        this.getIncomingInvocations().add(one);
+    }   
+    
+    public void addIncomingInvocations(Invocation one, Invocation... many) {
+        this.getIncomingInvocations().add(one);
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }   
+    
+    public void addIncomingInvocations(Iterable<? extends Invocation> many) {
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }   
+                
+    public void addIncomingInvocations(Invocation[] many) {
+        for (Invocation each : many)
+            this.getIncomingInvocations().add(each);
+    }
+    
+    public int numberOfIncomingInvocations() {
+        return getIncomingInvocations().size();
+    }
+
+    public boolean hasIncomingInvocations() {
+        return !getIncomingInvocations().isEmpty();
+    }
+    
+                
+    private Collection<LocalVariable> localVariables; 
+
+    @FameProperty(name = "localVariables", opposite = "parentBehaviouralEntity", derived = true)
+    public Collection<LocalVariable> getLocalVariables() {
+        if (localVariables == null) {
+            localVariables = new MultivalueSet<LocalVariable>() {
+                @Override
+                protected void clearOpposite(LocalVariable e) {
+                    e.setParentBehaviouralEntity(null);
+                }
+                @Override
+                protected void setOpposite(LocalVariable e) {
+                    e.setParentBehaviouralEntity(BehaviouralEntity.this);
+                }
+            };
+        }
+        return localVariables;
+    }
+    
+    public void setLocalVariables(Collection<? extends LocalVariable> localVariables) {
+        this.getLocalVariables().clear();
+        this.getLocalVariables().addAll(localVariables);
+    }                    
+    
+        
+    public void addLocalVariables(LocalVariable one) {
+        this.getLocalVariables().add(one);
+    }   
+    
+    public void addLocalVariables(LocalVariable one, LocalVariable... many) {
+        this.getLocalVariables().add(one);
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }   
+    
+    public void addLocalVariables(Iterable<? extends LocalVariable> many) {
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }   
+                
+    public void addLocalVariables(LocalVariable[] many) {
+        for (LocalVariable each : many)
+            this.getLocalVariables().add(each);
+    }
+    
+    public int numberOfLocalVariables() {
+        return getLocalVariables().size();
+    }
+
+    public boolean hasLocalVariables() {
+        return !getLocalVariables().isEmpty();
+    }
+    
+                
+    private Collection<Parameter> parameters; 
+
+    @FameProperty(name = "parameters", opposite = "parentBehaviouralEntity", derived = true)
+    public Collection<Parameter> getParameters() {
+        if (parameters == null) {
+            parameters = new MultivalueSet<Parameter>() {
+                @Override
+                protected void clearOpposite(Parameter e) {
+                    e.setParentBehaviouralEntity(null);
+                }
+                @Override
+                protected void setOpposite(Parameter e) {
+                    e.setParentBehaviouralEntity(BehaviouralEntity.this);
+                }
+            };
+        }
+        return parameters;
+    }
+    
+    public void setParameters(Collection<? extends Parameter> parameters) {
+        this.getParameters().clear();
+        this.getParameters().addAll(parameters);
+    }                    
+    
+        
+    public void addParameters(Parameter one) {
+        this.getParameters().add(one);
+    }   
+    
+    public void addParameters(Parameter one, Parameter... many) {
+        this.getParameters().add(one);
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }   
+    
+    public void addParameters(Iterable<? extends Parameter> many) {
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }   
+                
+    public void addParameters(Parameter[] many) {
+        for (Parameter each : many)
+            this.getParameters().add(each);
+    }
+    
+    public int numberOfParameters() {
+        return getParameters().size();
+    }
+
+    public boolean hasParameters() {
+        return !getParameters().isEmpty();
+    }
+    
+                
+    private String signature;
+    
+    @FameProperty(name = "signature")
+    public String getSignature() {
+        return signature;
+    }
+
+    public void setSignature(String signature) {
+        this.signature = signature;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ScopingEntity.java	(revision 1)
@@ -0,0 +1,199 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ScopingEntity")
+public class ScopingEntity extends ContainerEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope", opposite = "childScopes")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    public void setParentScope(ScopingEntity parentScope) {
+        if (this.parentScope != null) {
+            if (this.parentScope.equals(parentScope)) return;
+            this.parentScope.getChildScopes().remove(this);
+        }
+        this.parentScope = parentScope;
+        if (parentScope == null) return;
+        parentScope.getChildScopes().add(this);
+    }
+    
+    private Collection<Function> functions; 
+
+    @FameProperty(name = "functions", opposite = "parentScope", derived = true)
+    public Collection<Function> getFunctions() {
+        if (functions == null) {
+            functions = new MultivalueSet<Function>() {
+                @Override
+                protected void clearOpposite(Function e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(Function e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return functions;
+    }
+    
+    public void setFunctions(Collection<? extends Function> functions) {
+        this.getFunctions().clear();
+        this.getFunctions().addAll(functions);
+    }                    
+    
+        
+    public void addFunctions(Function one) {
+        this.getFunctions().add(one);
+    }   
+    
+    public void addFunctions(Function one, Function... many) {
+        this.getFunctions().add(one);
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }   
+    
+    public void addFunctions(Iterable<? extends Function> many) {
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }   
+                
+    public void addFunctions(Function[] many) {
+        for (Function each : many)
+            this.getFunctions().add(each);
+    }
+    
+    public int numberOfFunctions() {
+        return getFunctions().size();
+    }
+
+    public boolean hasFunctions() {
+        return !getFunctions().isEmpty();
+    }
+    
+                
+    private Collection<ScopingEntity> childScopes; 
+
+    @FameProperty(name = "childScopes", opposite = "parentScope", derived = true)
+    public Collection<ScopingEntity> getChildScopes() {
+        if (childScopes == null) {
+            childScopes = new MultivalueSet<ScopingEntity>() {
+                @Override
+                protected void clearOpposite(ScopingEntity e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(ScopingEntity e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return childScopes;
+    }
+    
+    public void setChildScopes(Collection<? extends ScopingEntity> childScopes) {
+        this.getChildScopes().clear();
+        this.getChildScopes().addAll(childScopes);
+    }                    
+    
+        
+    public void addChildScopes(ScopingEntity one) {
+        this.getChildScopes().add(one);
+    }   
+    
+    public void addChildScopes(ScopingEntity one, ScopingEntity... many) {
+        this.getChildScopes().add(one);
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }   
+    
+    public void addChildScopes(Iterable<? extends ScopingEntity> many) {
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }   
+                
+    public void addChildScopes(ScopingEntity[] many) {
+        for (ScopingEntity each : many)
+            this.getChildScopes().add(each);
+    }
+    
+    public int numberOfChildScopes() {
+        return getChildScopes().size();
+    }
+
+    public boolean hasChildScopes() {
+        return !getChildScopes().isEmpty();
+    }
+    
+                
+    private Collection<GlobalVariable> globalVariables; 
+
+    @FameProperty(name = "globalVariables", opposite = "parentScope", derived = true)
+    public Collection<GlobalVariable> getGlobalVariables() {
+        if (globalVariables == null) {
+            globalVariables = new MultivalueSet<GlobalVariable>() {
+                @Override
+                protected void clearOpposite(GlobalVariable e) {
+                    e.setParentScope(null);
+                }
+                @Override
+                protected void setOpposite(GlobalVariable e) {
+                    e.setParentScope(ScopingEntity.this);
+                }
+            };
+        }
+        return globalVariables;
+    }
+    
+    public void setGlobalVariables(Collection<? extends GlobalVariable> globalVariables) {
+        this.getGlobalVariables().clear();
+        this.getGlobalVariables().addAll(globalVariables);
+    }                    
+    
+        
+    public void addGlobalVariables(GlobalVariable one) {
+        this.getGlobalVariables().add(one);
+    }   
+    
+    public void addGlobalVariables(GlobalVariable one, GlobalVariable... many) {
+        this.getGlobalVariables().add(one);
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }   
+    
+    public void addGlobalVariables(Iterable<? extends GlobalVariable> many) {
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }   
+                
+    public void addGlobalVariables(GlobalVariable[] many) {
+        for (GlobalVariable each : many)
+            this.getGlobalVariables().add(each);
+    }
+    
+    public int numberOfGlobalVariables() {
+        return getGlobalVariables().size();
+    }
+
+    public boolean hasGlobalVariables() {
+        return !getGlobalVariables().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationInstance.java	(revision 1)
@@ -0,0 +1,52 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationInstance")
+public class AnnotationInstance extends Entity {
+
+
+
+    private Entity annotatedEntity;
+    
+    @FameProperty(name = "annotatedEntity", opposite = "annotationInstances")
+    public Entity getAnnotatedEntity() {
+        return annotatedEntity;
+    }
+
+    public void setAnnotatedEntity(Entity annotatedEntity) {
+        if (this.annotatedEntity != null) {
+            if (this.annotatedEntity.equals(annotatedEntity)) return;
+            this.annotatedEntity.getAnnotationInstances().remove(this);
+        }
+        this.annotatedEntity = annotatedEntity;
+        if (annotatedEntity == null) return;
+        annotatedEntity.getAnnotationInstances().add(this);
+    }
+    
+    private AnnotationType annotationType;
+    
+    @FameProperty(name = "annotationType", opposite = "instances")
+    public AnnotationType getAnnotationType() {
+        return annotationType;
+    }
+
+    public void setAnnotationType(AnnotationType annotationType) {
+        if (this.annotationType != null) {
+            if (this.annotationType.equals(annotationType)) return;
+            this.annotationType.getInstances().remove(this);
+        }
+        this.annotationType = annotationType;
+        if (annotationType == null) return;
+        annotationType.getInstances().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/SourceTextAnchor.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("SourceTextAnchor")
+public class SourceTextAnchor extends SourceAnchor {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/LocalVariable.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("LocalVariable")
+public class LocalVariable extends StructuralEntity {
+
+
+
+    private BehaviouralEntity parentBehaviouralEntity;
+    
+    @FameProperty(name = "parentBehaviouralEntity", opposite = "localVariables")
+    public BehaviouralEntity getParentBehaviouralEntity() {
+        return parentBehaviouralEntity;
+    }
+
+    public void setParentBehaviouralEntity(BehaviouralEntity parentBehaviouralEntity) {
+        if (this.parentBehaviouralEntity != null) {
+            if (this.parentBehaviouralEntity.equals(parentBehaviouralEntity)) return;
+            this.parentBehaviouralEntity.getLocalVariables().remove(this);
+        }
+        this.parentBehaviouralEntity = parentBehaviouralEntity;
+        if (parentBehaviouralEntity == null) return;
+        parentBehaviouralEntity.getLocalVariables().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/LeafEntity.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("LeafEntity")
+public class LeafEntity extends NamedEntity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/UnknownVariable.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("UnknownVariable")
+public class UnknownVariable extends StructuralEntity {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/StructuralEntity.java	(revision 1)
@@ -0,0 +1,85 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("StructuralEntity")
+public class StructuralEntity extends LeafEntity {
+
+
+
+    private Type declaredType;
+    
+    @FameProperty(name = "declaredType")
+    public Type getDeclaredType() {
+        return declaredType;
+    }
+
+    public void setDeclaredType(Type declaredType) {
+        this.declaredType = declaredType;
+    }
+    
+    private Collection<Access> incomingAccesses; 
+
+    @FameProperty(name = "incomingAccesses", opposite = "variable", derived = true)
+    public Collection<Access> getIncomingAccesses() {
+        if (incomingAccesses == null) {
+            incomingAccesses = new MultivalueSet<Access>() {
+                @Override
+                protected void clearOpposite(Access e) {
+                    e.setVariable(null);
+                }
+                @Override
+                protected void setOpposite(Access e) {
+                    e.setVariable(StructuralEntity.this);
+                }
+            };
+        }
+        return incomingAccesses;
+    }
+    
+    public void setIncomingAccesses(Collection<? extends Access> incomingAccesses) {
+        this.getIncomingAccesses().clear();
+        this.getIncomingAccesses().addAll(incomingAccesses);
+    }                    
+    
+        
+    public void addIncomingAccesses(Access one) {
+        this.getIncomingAccesses().add(one);
+    }   
+    
+    public void addIncomingAccesses(Access one, Access... many) {
+        this.getIncomingAccesses().add(one);
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }   
+    
+    public void addIncomingAccesses(Iterable<? extends Access> many) {
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }   
+                
+    public void addIncomingAccesses(Access[] many) {
+        for (Access each : many)
+            this.getIncomingAccesses().add(each);
+    }
+    
+    public int numberOfIncomingAccesses() {
+        return getIncomingAccesses().size();
+    }
+
+    public boolean hasIncomingAccesses() {
+        return !getIncomingAccesses().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Class.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Class")
+public class Class extends Type {
+
+
+
+    @FameProperty(name = "isAbstract", derived = true)
+    public Boolean getIsAbstract() {
+        // TODO: this is a derived property, implement this method manually.
+        return this.getModifiers().contains("abstract");
+    }
+    
+    private Boolean isInterface;
+    
+    @FameProperty(name = "isInterface")
+    public Boolean getIsInterface() {
+        return isInterface;
+    }
+
+    public void setIsInterface(Boolean isInterface) {
+        this.isInterface = isInterface;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/GlobalVariable.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("GlobalVariable")
+public class GlobalVariable extends StructuralEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope", opposite = "globalVariables")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    public void setParentScope(ScopingEntity parentScope) {
+        if (this.parentScope != null) {
+            if (this.parentScope.equals(parentScope)) return;
+            this.parentScope.getGlobalVariables().remove(this);
+        }
+        this.parentScope = parentScope;
+        if (parentScope == null) return;
+        parentScope.getGlobalVariables().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/PackageGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("PackageGroup")
+public class PackageGroup  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/PrimitiveType.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("PrimitiveType")
+public class PrimitiveType extends Type {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/FileAnchor.java	(revision 1)
@@ -0,0 +1,51 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("FileAnchor")
+public class FileAnchor extends SourceAnchor {
+
+
+
+    private Number startLine;
+    
+    @FameProperty(name = "startLine")
+    public Number getStartLine() {
+        return startLine;
+    }
+
+    public void setStartLine(Number startLine) {
+        this.startLine = startLine;
+    }
+    
+    private Number endLine;
+    
+    @FameProperty(name = "endLine")
+    public Number getEndLine() {
+        return endLine;
+    }
+
+    public void setEndLine(Number endLine) {
+        this.endLine = endLine;
+    }
+    
+    private String fileName;
+    
+    @FameProperty(name = "fileName")
+    public String getFileName() {
+        return fileName;
+    }
+
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/AnnotationType.java	(revision 1)
@@ -0,0 +1,91 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("AnnotationType")
+public class AnnotationType extends NamedEntity {
+
+
+
+    private ContainerEntity container;
+    
+    @FameProperty(name = "container", opposite = "definedAnnotationTypes")
+    public ContainerEntity getContainer() {
+        return container;
+    }
+
+    public void setContainer(ContainerEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getDefinedAnnotationTypes().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getDefinedAnnotationTypes().add(this);
+    }
+    
+    private Collection<AnnotationInstance> instances; 
+
+    @FameProperty(name = "instances", opposite = "annotationType", derived = true)
+    public Collection<AnnotationInstance> getInstances() {
+        if (instances == null) {
+            instances = new MultivalueSet<AnnotationInstance>() {
+                @Override
+                protected void clearOpposite(AnnotationInstance e) {
+                    e.setAnnotationType(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationInstance e) {
+                    e.setAnnotationType(AnnotationType.this);
+                }
+            };
+        }
+        return instances;
+    }
+    
+    public void setInstances(Collection<? extends AnnotationInstance> instances) {
+        this.getInstances().clear();
+        this.getInstances().addAll(instances);
+    }                    
+    
+        
+    public void addInstances(AnnotationInstance one) {
+        this.getInstances().add(one);
+    }   
+    
+    public void addInstances(AnnotationInstance one, AnnotationInstance... many) {
+        this.getInstances().add(one);
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }   
+    
+    public void addInstances(Iterable<? extends AnnotationInstance> many) {
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }   
+                
+    public void addInstances(AnnotationInstance[] many) {
+        for (AnnotationInstance each : many)
+            this.getInstances().add(each);
+    }
+    
+    public int numberOfInstances() {
+        return getInstances().size();
+    }
+
+    public boolean hasInstances() {
+        return !getInstances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Association.java	(revision 1)
@@ -0,0 +1,62 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Association")
+public class Association extends SourcedEntity {
+
+
+
+    @FameProperty(name = "to", derived = true)
+    public NamedEntity getTo() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Association.getTo() Not yet implemented!");  
+    }
+    
+    private Association previous;
+    
+    @FameProperty(name = "previous", opposite = "next")
+    public Association getPrevious() {
+        return previous;
+    }
+
+    public void setPrevious(Association previous) {
+        if (this.previous == null ? previous != null : !this.previous.equals(previous)) {
+            Association old_previous = this.previous;
+            this.previous = previous;
+            if (old_previous != null) old_previous.setNext(null);
+            if (previous != null) previous.setNext(this);
+        }
+    }
+    
+    private Association next;
+    
+    @FameProperty(name = "next", opposite = "previous", derived = true)
+    public Association getNext() {
+        return next;
+    }
+
+    public void setNext(Association next) {
+        if (this.next == null ? next != null : !this.next.equals(next)) {
+            Association old_next = this.next;
+            this.next = next;
+            if (old_next != null) old_next.setPrevious(null);
+            if (next != null) next.setPrevious(this);
+        }
+    }
+    
+    @FameProperty(name = "from", derived = true)
+    public NamedEntity getFrom() {
+        // TODO: this is a derived property, implement this method manually.
+        throw new UnsupportedOperationException("Association.getFrom() Not yet implemented!");  
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ContainerEntity.java	(revision 1)
@@ -0,0 +1,236 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ContainerEntity")
+public class ContainerEntity extends NamedEntity {
+
+
+
+    private Collection<AnnotationType> definedAnnotationTypes; 
+
+    @FameProperty(name = "definedAnnotationTypes", opposite = "container", derived = true)
+    public Collection<AnnotationType> getDefinedAnnotationTypes() {
+        if (definedAnnotationTypes == null) {
+            definedAnnotationTypes = new MultivalueSet<AnnotationType>() {
+                @Override
+                protected void clearOpposite(AnnotationType e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(AnnotationType e) {
+                    e.setContainer(ContainerEntity.this);
+                }
+            };
+        }
+        return definedAnnotationTypes;
+    }
+    
+    public void setDefinedAnnotationTypes(Collection<? extends AnnotationType> definedAnnotationTypes) {
+        this.getDefinedAnnotationTypes().clear();
+        this.getDefinedAnnotationTypes().addAll(definedAnnotationTypes);
+    }                    
+    
+        
+    public void addDefinedAnnotationTypes(AnnotationType one) {
+        this.getDefinedAnnotationTypes().add(one);
+    }   
+    
+    public void addDefinedAnnotationTypes(AnnotationType one, AnnotationType... many) {
+        this.getDefinedAnnotationTypes().add(one);
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }   
+    
+    public void addDefinedAnnotationTypes(Iterable<? extends AnnotationType> many) {
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }   
+                
+    public void addDefinedAnnotationTypes(AnnotationType[] many) {
+        for (AnnotationType each : many)
+            this.getDefinedAnnotationTypes().add(each);
+    }
+    
+    public int numberOfDefinedAnnotationTypes() {
+        return getDefinedAnnotationTypes().size();
+    }
+
+    public boolean hasDefinedAnnotationTypes() {
+        return !getDefinedAnnotationTypes().isEmpty();
+    }
+    
+                
+    private Collection<Reference> outgoingReferences; 
+
+    @FameProperty(name = "outgoingReferences", opposite = "source", derived = true)
+    public Collection<Reference> getOutgoingReferences() {
+        if (outgoingReferences == null) {
+            outgoingReferences = new MultivalueSet<Reference>() {
+                @Override
+                protected void clearOpposite(Reference e) {
+                    e.setSource(null);
+                }
+                @Override
+                protected void setOpposite(Reference e) {
+                    e.setSource(ContainerEntity.this);
+                }
+            };
+        }
+        return outgoingReferences;
+    }
+    
+    public void setOutgoingReferences(Collection<? extends Reference> outgoingReferences) {
+        this.getOutgoingReferences().clear();
+        this.getOutgoingReferences().addAll(outgoingReferences);
+    }                    
+    
+        
+    public void addOutgoingReferences(Reference one) {
+        this.getOutgoingReferences().add(one);
+    }   
+    
+    public void addOutgoingReferences(Reference one, Reference... many) {
+        this.getOutgoingReferences().add(one);
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }   
+    
+    public void addOutgoingReferences(Iterable<? extends Reference> many) {
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }   
+                
+    public void addOutgoingReferences(Reference[] many) {
+        for (Reference each : many)
+            this.getOutgoingReferences().add(each);
+    }
+    
+    public int numberOfOutgoingReferences() {
+        return getOutgoingReferences().size();
+    }
+
+    public boolean hasOutgoingReferences() {
+        return !getOutgoingReferences().isEmpty();
+    }
+    
+                
+    private Collection<Type> types; 
+
+    @FameProperty(name = "types", opposite = "container", derived = true)
+    public Collection<Type> getTypes() {
+        if (types == null) {
+            types = new MultivalueSet<Type>() {
+                @Override
+                protected void clearOpposite(Type e) {
+                    e.setContainer(null);
+                }
+                @Override
+                protected void setOpposite(Type e) {
+                    e.setContainer(ContainerEntity.this);
+                }
+            };
+        }
+        return types;
+    }
+    
+    public void setTypes(Collection<? extends Type> types) {
+        this.getTypes().clear();
+        this.getTypes().addAll(types);
+    }                    
+    
+        
+    public void addTypes(Type one) {
+        this.getTypes().add(one);
+    }   
+    
+    public void addTypes(Type one, Type... many) {
+        this.getTypes().add(one);
+        for (Type each : many)
+            this.getTypes().add(each);
+    }   
+    
+    public void addTypes(Iterable<? extends Type> many) {
+        for (Type each : many)
+            this.getTypes().add(each);
+    }   
+                
+    public void addTypes(Type[] many) {
+        for (Type each : many)
+            this.getTypes().add(each);
+    }
+    
+    public int numberOfTypes() {
+        return getTypes().size();
+    }
+
+    public boolean hasTypes() {
+        return !getTypes().isEmpty();
+    }
+    
+                
+    private Collection<Reference> incomingReferences; 
+
+    @FameProperty(name = "incomingReferences", opposite = "target", derived = true)
+    public Collection<Reference> getIncomingReferences() {
+        if (incomingReferences == null) {
+            incomingReferences = new MultivalueSet<Reference>() {
+                @Override
+                protected void clearOpposite(Reference e) {
+                    e.setTarget(null);
+                }
+                @Override
+                protected void setOpposite(Reference e) {
+                    e.setTarget(ContainerEntity.this);
+                }
+            };
+        }
+        return incomingReferences;
+    }
+    
+    public void setIncomingReferences(Collection<? extends Reference> incomingReferences) {
+        this.getIncomingReferences().clear();
+        this.getIncomingReferences().addAll(incomingReferences);
+    }                    
+    
+        
+    public void addIncomingReferences(Reference one) {
+        this.getIncomingReferences().add(one);
+    }   
+    
+    public void addIncomingReferences(Reference one, Reference... many) {
+        this.getIncomingReferences().add(one);
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }   
+    
+    public void addIncomingReferences(Iterable<? extends Reference> many) {
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }   
+                
+    public void addIncomingReferences(Reference[] many) {
+        for (Reference each : many)
+            this.getIncomingReferences().add(each);
+    }
+    
+    public int numberOfIncomingReferences() {
+        return getIncomingReferences().size();
+    }
+
+    public boolean hasIncomingReferences() {
+        return !getIncomingReferences().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Type.java	(revision 1)
@@ -0,0 +1,253 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.internal.MultivalueSet;
+import java.util.*;
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Type")
+public class Type extends ContainerEntity {
+
+
+
+    private Collection<Method> methods; 
+
+    @FameProperty(name = "methods", opposite = "parentType", derived = true)
+    public Collection<Method> getMethods() {
+        if (methods == null) {
+            methods = new MultivalueSet<Method>() {
+                @Override
+                protected void clearOpposite(Method e) {
+                    e.setParentType(null);
+                }
+                @Override
+                protected void setOpposite(Method e) {
+                    e.setParentType(Type.this);
+                }
+            };
+        }
+        return methods;
+    }
+    
+    public void setMethods(Collection<? extends Method> methods) {
+        this.getMethods().clear();
+        this.getMethods().addAll(methods);
+    }                    
+    
+        
+    public void addMethods(Method one) {
+        this.getMethods().add(one);
+    }   
+    
+    public void addMethods(Method one, Method... many) {
+        this.getMethods().add(one);
+        for (Method each : many)
+            this.getMethods().add(each);
+    }   
+    
+    public void addMethods(Iterable<? extends Method> many) {
+        for (Method each : many)
+            this.getMethods().add(each);
+    }   
+                
+    public void addMethods(Method[] many) {
+        for (Method each : many)
+            this.getMethods().add(each);
+    }
+    
+    public int numberOfMethods() {
+        return getMethods().size();
+    }
+
+    public boolean hasMethods() {
+        return !getMethods().isEmpty();
+    }
+    
+                
+    private Collection<Inheritance> superInheritances; 
+
+    @FameProperty(name = "superInheritances", opposite = "subclass", derived = true)
+    public Collection<Inheritance> getSuperInheritances() {
+        if (superInheritances == null) {
+            superInheritances = new MultivalueSet<Inheritance>() {
+                @Override
+                protected void clearOpposite(Inheritance e) {
+                    e.setSubclass(null);
+                }
+                @Override
+                protected void setOpposite(Inheritance e) {
+                    e.setSubclass(Type.this);
+                }
+            };
+        }
+        return superInheritances;
+    }
+    
+    public void setSuperInheritances(Collection<? extends Inheritance> superInheritances) {
+        this.getSuperInheritances().clear();
+        this.getSuperInheritances().addAll(superInheritances);
+    }                    
+    
+        
+    public void addSuperInheritances(Inheritance one) {
+        this.getSuperInheritances().add(one);
+    }   
+    
+    public void addSuperInheritances(Inheritance one, Inheritance... many) {
+        this.getSuperInheritances().add(one);
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }   
+    
+    public void addSuperInheritances(Iterable<? extends Inheritance> many) {
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }   
+                
+    public void addSuperInheritances(Inheritance[] many) {
+        for (Inheritance each : many)
+            this.getSuperInheritances().add(each);
+    }
+    
+    public int numberOfSuperInheritances() {
+        return getSuperInheritances().size();
+    }
+
+    public boolean hasSuperInheritances() {
+        return !getSuperInheritances().isEmpty();
+    }
+    
+                
+    private ContainerEntity container;
+    
+    @FameProperty(name = "container", opposite = "types")
+    public ContainerEntity getContainer() {
+        return container;
+    }
+
+    public void setContainer(ContainerEntity container) {
+        if (this.container != null) {
+            if (this.container.equals(container)) return;
+            this.container.getTypes().remove(this);
+        }
+        this.container = container;
+        if (container == null) return;
+        container.getTypes().add(this);
+    }
+    
+    private Collection<Attribute> attributes; 
+
+    @FameProperty(name = "attributes", opposite = "parentType", derived = true)
+    public Collection<Attribute> getAttributes() {
+        if (attributes == null) {
+            attributes = new MultivalueSet<Attribute>() {
+                @Override
+                protected void clearOpposite(Attribute e) {
+                    e.setParentType(null);
+                }
+                @Override
+                protected void setOpposite(Attribute e) {
+                    e.setParentType(Type.this);
+                }
+            };
+        }
+        return attributes;
+    }
+    
+    public void setAttributes(Collection<? extends Attribute> attributes) {
+        this.getAttributes().clear();
+        this.getAttributes().addAll(attributes);
+    }                    
+    
+        
+    public void addAttributes(Attribute one) {
+        this.getAttributes().add(one);
+    }   
+    
+    public void addAttributes(Attribute one, Attribute... many) {
+        this.getAttributes().add(one);
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }   
+    
+    public void addAttributes(Iterable<? extends Attribute> many) {
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }   
+                
+    public void addAttributes(Attribute[] many) {
+        for (Attribute each : many)
+            this.getAttributes().add(each);
+    }
+    
+    public int numberOfAttributes() {
+        return getAttributes().size();
+    }
+
+    public boolean hasAttributes() {
+        return !getAttributes().isEmpty();
+    }
+    
+                
+    private Collection<Inheritance> subInheritances; 
+
+    @FameProperty(name = "subInheritances", opposite = "superclass", derived = true)
+    public Collection<Inheritance> getSubInheritances() {
+        if (subInheritances == null) {
+            subInheritances = new MultivalueSet<Inheritance>() {
+                @Override
+                protected void clearOpposite(Inheritance e) {
+                    e.setSuperclass(null);
+                }
+                @Override
+                protected void setOpposite(Inheritance e) {
+                    e.setSuperclass(Type.this);
+                }
+            };
+        }
+        return subInheritances;
+    }
+    
+    public void setSubInheritances(Collection<? extends Inheritance> subInheritances) {
+        this.getSubInheritances().clear();
+        this.getSubInheritances().addAll(subInheritances);
+    }                    
+    
+        
+    public void addSubInheritances(Inheritance one) {
+        this.getSubInheritances().add(one);
+    }   
+    
+    public void addSubInheritances(Inheritance one, Inheritance... many) {
+        this.getSubInheritances().add(one);
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }   
+    
+    public void addSubInheritances(Iterable<? extends Inheritance> many) {
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }   
+                
+    public void addSubInheritances(Inheritance[] many) {
+        for (Inheritance each : many)
+            this.getSubInheritances().add(each);
+    }
+    
+    public int numberOfSubInheritances() {
+        return getSubInheritances().size();
+    }
+
+    public boolean hasSubInheritances() {
+        return !getSubInheritances().isEmpty();
+    }
+    
+                
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/ClassGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("ClassGroup")
+public class ClassGroup  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Function.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Function")
+public class Function extends BehaviouralEntity {
+
+
+
+    private ScopingEntity parentScope;
+    
+    @FameProperty(name = "parentScope", opposite = "functions")
+    public ScopingEntity getParentScope() {
+        return parentScope;
+    }
+
+    public void setParentScope(ScopingEntity parentScope) {
+        if (this.parentScope != null) {
+            if (this.parentScope.equals(parentScope)) return;
+            this.parentScope.getFunctions().remove(this);
+        }
+        this.parentScope = parentScope;
+        if (parentScope == null) return;
+        parentScope.getFunctions().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Inheritance.java	(revision 1)
@@ -0,0 +1,64 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Inheritance")
+public class Inheritance extends Association {
+
+
+
+    private Type superclass;
+    
+    @FameProperty(name = "superclass", opposite = "subInheritances")
+    public Type getSuperclass() {
+        return superclass;
+    }
+
+    public void setSuperclass(Type superclass) {
+        if (this.superclass != null) {
+            if (this.superclass.equals(superclass)) return;
+            this.superclass.getSubInheritances().remove(this);
+        }
+        this.superclass = superclass;
+        if (superclass == null) return;
+        superclass.getSubInheritances().add(this);
+    }
+    
+    private Type subclass;
+    
+    @FameProperty(name = "subclass", opposite = "superInheritances")
+    public Type getSubclass() {
+        return subclass;
+    }
+
+    public void setSubclass(Type subclass) {
+        if (this.subclass != null) {
+            if (this.subclass.equals(subclass)) return;
+            this.subclass.getSuperInheritances().remove(this);
+        }
+        this.subclass = subclass;
+        if (subclass == null) return;
+        subclass.getSuperInheritances().add(this);
+    }
+
+	@Override
+	public NamedEntity getFrom() {
+		return getSubclass();
+	}
+
+	@Override
+	public NamedEntity getTo() {
+		return getSuperclass();
+	}
+    
+    
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/CaughtException.java	(revision 1)
@@ -0,0 +1,35 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("CaughtException")
+public class CaughtException extends Exception {
+
+
+
+    private Method definingMethod;
+    
+    @FameProperty(name = "definingMethod", opposite = "caughtExceptions")
+    public Method getDefiningMethod() {
+        return definingMethod;
+    }
+
+    public void setDefiningMethod(Method definingMethod) {
+        if (this.definingMethod != null) {
+            if (this.definingMethod.equals(definingMethod)) return;
+            this.definingMethod.getCaughtExceptions().remove(this);
+        }
+        this.definingMethod = definingMethod;
+        if (definingMethod == null) return;
+        definingMethod.getCaughtExceptions().add(this);
+    }
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/MethodGroup.java	(revision 1)
@@ -0,0 +1,17 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("MethodGroup")
+public class MethodGroup  {
+
+
+
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/gen/famix/Reference.java	(revision 1)
@@ -0,0 +1,62 @@
+// Automagically generated code, please do not change
+package fr.inria.verveine.core.gen.famix;
+
+import ch.akuhn.fame.FameProperty;
+import ch.akuhn.fame.FameDescription;
+import ch.akuhn.fame.FamePackage;
+
+
+@FamePackage("FAMIX")
+@FameDescription("Reference")
+public class Reference extends Association {
+
+
+
+    private ContainerEntity source;
+    
+    @FameProperty(name = "source", opposite = "outgoingReferences")
+    public ContainerEntity getSource() {
+        return source;
+    }
+
+    public void setSource(ContainerEntity source) {
+        if (this.source != null) {
+            if (this.source.equals(source)) return;
+            this.source.getOutgoingReferences().remove(this);
+        }
+        this.source = source;
+        if (source == null) return;
+        source.getOutgoingReferences().add(this);
+    }
+    
+    private ContainerEntity target;
+    
+    @FameProperty(name = "target", opposite = "incomingReferences")
+    public ContainerEntity getTarget() {
+        return target;
+    }
+
+    public void setTarget(ContainerEntity target) {
+        if (this.target != null) {
+            if (this.target.equals(target)) return;
+            this.target.getIncomingReferences().remove(this);
+        }
+        this.target = target;
+        if (target == null) return;
+        target.getIncomingReferences().add(this);
+    }
+
+	@Override
+	public NamedEntity getFrom() {
+		return getSource();
+	}
+
+	@Override
+	public NamedEntity getTo() {
+		return getTarget();
+	}
+    
+
+
+}
+
Index: verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java
===================================================================
--- verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java	(revision 0)
+++ verveine.core/src/fr/inria/verveine/core/NonCloseablePrintStream.java	(revision 1)
@@ -0,0 +1,21 @@
+package fr.inria.verveine.core;
+
+import java.io.OutputStream;
+import java.io.PrintStream;
+
+/**
+ * A non-closeable output stream
+ * Exists solely to redefine an empty close()
+ */
+public class NonCloseablePrintStream extends PrintStream {
+
+	
+	public NonCloseablePrintStream(OutputStream underlying) {
+		super(underlying);
+	}
+
+	public void close() {
+		// Aah aaaah! NOT closing :-)
+	}
+	
+}
Index: verveine.core/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- verveine.core/.settings/org.eclipse.jdt.core.prefs	(revision 0)
+++ verveine.core/.settings/org.eclipse.jdt.core.prefs	(revision 1)
@@ -0,0 +1,12 @@
+#Thu Sep 16 17:16:46 CEST 2010
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 0)
+++ verveine.extractor.java/.classpath	(revision 1)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/verveine.core/src/fr/inria/verveine/core"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.osgi_3.6.0.v20100517.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
+	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
+	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
+	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
+	<classpathentry kind="lib" path="lib/fame.jar"/>
+	<classpathentry kind="lib" path="lib/famix.jar"/>
+	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: verveine.extractor.java/.project
===================================================================
--- verveine.extractor.java/.project	(revision 0)
+++ verveine.extractor.java/.project	(revision 1)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>verveine.extractor.java</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/famix.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.jdt.core_3.6.0.v_A58.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/fame.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/fame.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.core.runtime_3.6.0.v20100505.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.core.runtime_3.6.0.v20100505.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.core.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.equinox.common_3.6.0.v20100503.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.equinox.common_3.6.0.v20100503.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/verveine.extractor.java.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.core.jobs_3.5.0.v20100515.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.core.jobs_3.5.0.v20100515.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/lib/org.eclipse.osgi_3.6.0.v20100517.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: verveine.extractor.java/lib/org.eclipse.osgi_3.6.0.v20100517.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/WorkStation.java	(revision 1)
@@ -0,0 +1,55 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class WorkStation extends Node {
+
+	private String type;
+	
+	/*
+	 * 	This is how packets get inserted into the network. This is a likely method to be rwritten to permit  
+	 * 	packets to be entered in various ways. Currently, I assume that someone alse creates the packet,  
+	 * 	and passes it to me as an argument. 
+	 */
+	public void originate(Packet thePacket) {
+		thePacket.originator(this);
+		send(thePacket);
+	}
+	
+	/*
+	 * accept the packet and see if I am the originator. If this is the case, take the packet out 
+	 * because the addressee is unknown. Print this on the Transcript.
+	 * 
+	 * @see moose.lan.Node#accept(moose.lan.Packet)
+	 */
+	public void accept(Packet thePacket) {
+		if( thePacket.originator().equals(this) ) {
+			System.out.println("The receiver of following packet does not exist:");
+			System.out.println(thePacket.toString());
+		} else {
+			send(thePacket);
+		}
+	}
+
+	public boolean canOriginate() {
+		return true;
+	}
+
+	/*
+	 * added for candidate invocations operator test. 
+	 * 
+	 * @see moose.lan.Node#name()
+	 */
+	public String name() {
+		return super.name();
+	}
+
+	
+	
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/Node.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/Node.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/Node.java	(revision 1)
@@ -0,0 +1,70 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class Node {
+
+	private String name;
+	
+	private Node nextNode;
+	
+	
+	public Node() {
+		name("Undefined");
+	}
+	
+	public String name() {
+		return this.name;
+	}
+	
+	public void name(String name) {
+		this.name = name;
+	}
+	
+	public Node nextNode() {
+		return this.nextNode;
+	}
+	
+	public void nextNode(Node node) {
+		this.nextNode = node;
+	}
+	
+	public void methodWithEmptyBody() {
+	}
+
+	public boolean canOutput() {
+		return false;
+	}
+	
+	public boolean canOriginate() {
+		return false;
+	}
+	
+	/*
+	 * Having received the packet, send it on. This is the default behavior. 
+	 * My subclasses will probably override this method to do something special 
+	 */
+	public void accept(Packet thePacket) {
+		send(thePacket);
+	}
+	
+	//	Display debug information in the Transcript, then send the packet to the node which whom I communicate
+	public void send(Packet thePacket) {
+		System.out.println(name() + " sending the packet to " + nextNode().name());
+		nextNode().accept(thePacket);
+	}
+	
+	public void printOn(StringBuffer aStream) {
+		aStream.append(": ").append(name());
+		if( nextNode() != null ) {
+			aStream.append(", pointing to ").append(nextNode().name());
+		}
+	}
+	
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/server/PrintServer.java	(revision 1)
@@ -0,0 +1,55 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Packet;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class PrintServer extends OutputServer {
+	
+	private IPrinter printer;
+	
+	public class XPrinter implements IPrinter {
+
+		private int uselessNumber;
+		
+		/* (non-Javadoc)
+		 * @see moose.lan.server.IPrinter#print(java.lang.String, boolean)
+		 */
+		public void print(String contents, boolean rv) {
+		}
+		
+		public int idNumber() {
+			return this.uselessNumber;
+		}
+		
+	}
+	
+	public PrintServer() {
+		this.printer = new IPrinter() {
+			public void print(String contents, boolean rv) {
+				System.out.println(contents);		
+			}
+		};
+	}
+	
+
+	/* (non-Javadoc)
+	 * @see moose.lan.server.OutputServer#output(moose.lan.Packet)
+	 */
+	@Override
+	public void output(Packet thePacket) {
+		System.out.println();
+		for (int i = 0; i < 80; i++) {
+			System.out.print("-");
+		}
+		System.out.println();
+		this.printer.print("Printer " + name() + " prints " + thePacket.contents(), false);
+	}
+
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/server/FileServer.java	(revision 1)
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Packet;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class FileServer extends OutputServer {
+
+	/* (non-Javadoc)
+	 * @see moose.lan.server.OutputServer#output(moose.lan.Packet)
+	 */
+	public void output(Packet thePacket) {
+		System.out.println();
+		System.out.println("FileServer " + name() + " saves " + thePacket.contents());
+	}
+	
+	public String name() {
+		return super.name();
+	}
+	
+	public void setServerType() {
+		this.serverType = "FileServer";
+	}
+
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/server/OutputServer.java	(revision 1)
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+import moose.lan.Node;
+import moose.lan.Packet;
+
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public abstract class OutputServer extends Node {
+
+	protected String serverType = null;
+	
+	/*
+	 * I first see if the packet is for me. If it is, I output it. Otherwise, I pass it on.
+	 */
+	public void accept(Packet thePacket) {
+		if( thePacket.addressee().isDestinationFor(name()) ) {
+			output(thePacket);
+		} else {
+			send(thePacket);
+		}
+	}
+	
+	public boolean canOutput() {
+		return true;
+	}
+	
+	/*
+	 * My subclasses have to use this method to define their outputting behavior.
+	 */
+	public abstract void output(Packet thePacket);
+	
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/server/IPrinter.java	(revision 1)
@@ -0,0 +1,15 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan.server;
+
+/**
+ * @author Simon Denier
+ * @since Mar 6, 2009
+ *
+ */
+public interface IPrinter {
+	
+	public void print(String contents, boolean rv);
+
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/Packet.java	(revision 1)
@@ -0,0 +1,47 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class Packet {
+
+	private String contents;
+	private SingleDestinationAddress addressee;
+	private Node originator;
+	
+	public String contents() {
+		return this.contents;
+	}
+	
+	public void contents(String contents) {
+		this.contents = contents;
+	}
+	
+	public SingleDestinationAddress addressee() {
+		return this.addressee;
+	}
+	
+	public void addressee(SingleDestinationAddress addressee) {
+		this.addressee = addressee;
+	}
+	
+	public Node originator() {
+		return this.originator;
+	}
+
+	public void originator(Node originator) {
+		this.originator = originator;
+	}
+	
+	public void printOn(StringBuffer aStream) {
+		if( originator()!=null ) {
+			aStream.append(" coming from ").append(originator().name());
+		}
+		aStream.append(" addressed to " + addressee().id() + " with contents: " + contents());
+	}
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/SingleDestinationAddress.java	(revision 1)
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public class SingleDestinationAddress extends AbstractDestinationAddress {
+
+	private String id;
+	
+	public String id() {
+		return this.id;
+	}
+	
+	public void id(String id) {
+		this.id = id;
+	}
+	
+	/* (non-Javadoc)
+	 * @see moose.lan.AbstractDestinationAddress#isDestinationFor(moose.lan.AbstractDestinationAddress)
+	 */
+	@Override
+	public boolean isDestinationFor(String id) {
+		return this.equalsSingle(id);
+	}
+
+	/**
+	 * @param singleDestinationAddress
+	 * @return
+	 */
+	public boolean equalsSingle(String id) {
+		return id().equals(id);
+	}
+	
+	public boolean equalsMultiple(AbstractDestinationAddress anAddress) {
+		return false;
+	}
+
+}
Index: verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java
===================================================================
--- verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java	(revision 0)
+++ verveine.extractor.java/test_src/LANModel/moose/lan/AbstractDestinationAddress.java	(revision 1)
@@ -0,0 +1,15 @@
+/**
+ * Copyright (c) 2009 Simon Denier
+ */
+package moose.lan;
+
+/**
+ * @author Simon Denier
+ * @since Feb 25, 2009
+ *
+ */
+public abstract class AbstractDestinationAddress {
+
+	public abstract boolean isDestinationFor(String id);
+
+}
Index: verveine.extractor.java/verveinej.sh
===================================================================
--- verveine.extractor.java/verveinej.sh	(revision 0)
+++ verveine.extractor.java/verveinej.sh	(revision 1)
@@ -0,0 +1,52 @@
+#!/bin/bash
+
+if [ -z "$1" ]
+then
+	echo "Usage: verveinej.sh [ <jvm-options> -- ] [ <verveine-options> ] <java-source>" >&2
+	echo "  <verveine-options> from Eclipse JDT Batch Compiler:" >&2
+	echo "" >&2
+fi
+
+# Directory for verveine source
+BASELIB=`dirname $0`/lib
+
+
+# JVM options e.g. -Xmx2500m to augment maximum memory size of the vm to 2.5Go.
+JOPT=""
+# Verveine option
+VOPT=""
+
+# Any argument before "--" is for the JVM
+# Any argument after "--" is for verveine
+# Without "--" every argument goes to verveine
+while [ ${1:-"--"} != "--" ]
+do
+	JOPT="$JOPT $1"
+	shift
+done
+
+if [ "$1" == "--" ]
+then
+	shift
+	VOPT=$*
+else
+	# without the special "--" argument, all options are assumed to be for Verveine
+	VOPT=$JOPT
+	JOPT=""
+fi
+
+CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.extractor.java.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/fame.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/famix.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/verveine.core.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.jdt.core_3.6.0.v_A58.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.jobs_3.5.0.v20100515.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.core.runtime_3.6.0.v20100505.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.equinox.common_3.6.0.v20100503.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"
+CLASSPATH="${CLASSPATH}:${BASELIB}/org.eclipse.osgi_3.6.0.v20100517.jar"
+
+
+java $JOPT -cp $CLASSPATH fr.inria.verveine.extractor.java.BatchParser $VOPT

Property changes on: verveine.extractor.java/verveinej.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 0)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 1)
@@ -0,0 +1,334 @@
+/**
+ * Copyright (c) 2010 Simon Denier
+ */
+package tests.fr.inria.verveine.extractor.java;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.io.PrintWriter;
+import java.util.Collection;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import test.fr.inria.verveine.core.TestVerveineUtils;
+
+import ch.akuhn.fame.Repository;
+
+
+import fr.inria.verveine.core.gen.famix.Access;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Inheritance;
+import fr.inria.verveine.core.gen.famix.Invocation;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+
+import fr.inria.verveine.extractor.java.BatchParser;
+import fr.inria.verveine.extractor.java.JavaDictionary;
+
+/**
+ * @author Simon Denier
+ * @since May 28, 2010
+ *
+ */
+public class VerveineExtractorJavaTest {
+
+	private static final String A_CLASS_NAME = "--aClassName--";
+
+	private Repository repo;
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		BatchParser parser = new BatchParser(new PrintWriter(System.out), new PrintWriter(System.err), true/*systemExit*/, null/*options*/, null/*progress*/);
+		parser.systemExitWhenFinished = false;
+		parser.compile(new String[] {"test_src/LANModel"});
+		repo = parser.getFamixRepo();
+	}
+
+	@Test
+	public void testEntitiesNumber() {
+		assertEquals(11+11, TestVerveineUtils.selectElementsOfType(repo,fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {int,boolean,void,Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System}
+		assertEquals(40+7, TestVerveineUtils.selectElementsOfType(repo,Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
+		assertEquals(10+1, TestVerveineUtils.selectElementsOfType(repo,Attribute.class).size());//10+{System.out}
+		assertEquals(2+5, TestVerveineUtils.selectElementsOfType(repo,Namespace.class).size());//2+{moose,<primitive>,java.lang,java.io,java}
+		assertEquals(26, TestVerveineUtils.selectElementsOfType(repo,Parameter.class).size());
+		assertEquals(54, TestVerveineUtils.selectElementsOfType(repo,Invocation.class).size());//actually 54, missing 2 !!!!
+		assertEquals(5+12, TestVerveineUtils.selectElementsOfType(repo,Inheritance.class).size());//5 internal + 12 from imported packages/classes
+		assertEquals(25, TestVerveineUtils.selectElementsOfType(repo,Access.class).size());// 16 "internal" attributes + 9 System.out
+		assertEquals(0, TestVerveineUtils.selectElementsOfType(repo,LocalVariable.class).size());
+	}
+
+	@Test
+	public void testClassProperties() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		assertEquals("Node", nodeClass.getName());
+		assertEquals(11, nodeClass.getMethods().size());
+		assertEquals(2, nodeClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,Namespace.class, "moose.lan"), nodeClass.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class innerClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "XPrinter");
+		assertNotNull(innerClass);
+		assertEquals("XPrinter", innerClass.getName());
+		assertEquals(2, innerClass.getMethods().size());
+		assertEquals(1, innerClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer"), innerClass.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class anonClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "anonymous(IPrinter)");
+		assertNotNull(anonClass);
+		assertEquals("anonymous(IPrinter)", anonClass.getName());
+		assertEquals(1, anonClass.getMethods().size());
+		assertEquals(0, anonClass.getAttributes().size());
+		assertSame(TestVerveineUtils.detectElement(repo,Method.class, "PrintServer"), anonClass.getContainer());
+	}
+
+	@Test
+	public void testNamedEntities() {
+		JavaDictionary dico = new JavaDictionary(repo);
+		
+		assertNotSame(dico.ensureFamixClass(A_CLASS_NAME),dico.ensureFamixClass(A_CLASS_NAME));
+		
+		Namespace javaLang = dico.ensureFamixNamespaceJavaLang(null);
+		assertEquals(JavaDictionary.OBJECT_PACKAGE_NAME, javaLang.getName());
+		assertSame(javaLang, dico.ensureFamixNamespaceJavaLang(null));
+
+		fr.inria.verveine.core.gen.famix.Class obj = dico.ensureFamixClassObject(null);
+		assertEquals(JavaDictionary.OBJECT_NAME, obj.getName());
+		assertSame(obj, dico.ensureFamixClassObject(null));
+		assertEquals(0, obj.getSuperInheritances().size());
+		assertSame(javaLang, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClassStubOwner();
+		assertEquals(JavaDictionary.STUB_METHOD_CONTAINER_NAME, fmx.getName());
+		assertSame(fmx, dico.ensureFamixClassStubOwner());
+	}
+
+	@Test
+	public void testInheritance() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<Inheritance> superInheritances;
+		Inheritance inh;
+		
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "PrintServer");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "OutputServer"), inh.getSuperclass());
+
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		superInheritances = clazz.getSuperInheritances();
+		assertEquals(1, superInheritances.size());
+		inh = superInheritances.iterator().next();
+		assertSame(clazz, inh.getSubclass());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME), inh.getSuperclass());
+	}
+
+	@Test
+	public void testMethodProperties() {
+		Method mweb = TestVerveineUtils.detectElement(repo,Method.class, "methodWithEmptyBody");
+		assertNotNull(mweb);
+		assertEquals("methodWithEmptyBody", mweb.getName());
+		assertEquals("methodWithEmptyBody ()", mweb.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node"), mweb.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "void"), mweb.getDeclaredType());
+
+		Method em = TestVerveineUtils.detectElement(repo,Method.class, "equalsMultiple");
+		assertNotNull(em);
+		assertEquals("equalsMultiple", em.getName());
+		assertEquals("equalsMultiple (AbstractDestinationAddress)", em.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress"), em.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "boolean"), em.getDeclaredType());
+
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer");
+		assertNotNull(clazz);
+		Method n = null;
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals("name")) {
+				n = m;
+				break;
+			}
+		}
+		assertNotNull(n);
+		assertEquals("name", n.getName());
+		assertEquals("name ()", n.getSignature());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "FileServer"), n.getParentType());
+		assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), n.getDeclaredType());
+	}
+
+	@Test
+	public void testFieldType() {
+		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(clazz);
+		Collection<Attribute> l_atts = clazz.getAttributes();
+		assertEquals(2, l_atts.size());
+		for (Attribute a : l_atts) {
+			if (a.getName().equals("nextNode")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(clazz, a.getDeclaredType());
+			}
+			else if (a.getName().equals("name")) {
+				assertSame(clazz, a.getParentType());
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), a.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testStubs() {
+		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, JavaDictionary.OBJECT_PACKAGE_NAME);
+		assertNotNull(ns);
+		assertEquals(5, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System
+		
+		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
+		assertNotNull(obj);
+		assertFalse(ns.getIsStub());
+		assertSame(ns, obj.getContainer());
+		
+		fr.inria.verveine.core.gen.famix.Class str = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String");
+		assertNotNull(str);
+		assertFalse(str.getIsStub());
+		assertSame(ns, str.getContainer());
+	}
+
+	@Test
+	public void testParameter() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("Node")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOriginate")) ||
+				 (mNode.getName().equals("canOutput")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 0, mNode.getParameters().size());
+			}
+			else if ( (mNode.getName().equals("name")) ||
+					  (mNode.getName().equals("nextNode")) ) {
+				assertTrue("Wrong number of parameter for method Node."+mNode.getName()+"()",  (mNode.getParameters().size()==0) || (mNode.getParameters().size()==1));
+			}
+			else if ( (mNode.getName().equals("accept")) ||
+					 (mNode.getName().equals("send")) ||
+					 (mNode.getName().equals("printOn")) ) {
+				assertEquals("Wrong number of parameter for method Node."+mNode.getName()+"()", 1, mNode.getParameters().size());
+			}
+		}
+		fr.inria.verveine.core.gen.famix.Class iprintClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "IPrinter");
+		assertNotNull(iprintClass);
+		Method mPrint = iprintClass.getMethods().iterator().next();
+		assertEquals(2, mPrint.getParameters().size());
+		for (Parameter p : mPrint.getParameters()) {
+			assertSame(mPrint, p.getParentBehaviouralEntity());
+			assertTrue(p.getName().equals("contents") || p.getName().equals("rv"));
+			if (p.getName().equals("contents")) {
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), p.getDeclaredType());
+			}
+			if (p.getName().equals("rv")) {
+				assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "boolean"), p.getDeclaredType());
+			}
+		}
+	}
+
+	@Test
+	public void testInvocation() {
+		fr.inria.verveine.core.gen.famix.Class nodeClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
+		assertNotNull(nodeClass);
+		for (Method mNode : nodeClass.getMethods()) {
+			if ( (mNode.getName().equals("name")) ||
+				 (mNode.getName().equals("nextNode")) ||
+				 (mNode.getName().equals("methodWithEmptyBody")) ||
+				 (mNode.getName().equals("canOutput")) ||
+				 (mNode.getName().equals("canOriginate")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 0, mNode.getOutgoingInvocations().size());
+			}
+			else if ( (mNode.getName().equals("Node")) ||
+					  (mNode.getName().equals("accept")) ) {
+				assertEquals("Wrong number of outgoing invocation for method Node."+mNode.getName()+"()", 1, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("send"))  {
+				assertEquals("Wrong number of outgoing invocation for method Node.send()", 6, mNode.getOutgoingInvocations().size());
+			}
+			else if (mNode.getName().equals("printOn")) {
+				assertEquals("Wrong number of outgoing invocation for method Node.printOn()", 8, mNode.getOutgoingInvocations().size());
+			}
+		}
+		
+		fr.inria.verveine.core.gen.famix.Class sdaClass = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "SingleDestinationAddress");
+		assertNotNull(sdaClass);
+		for (Method mSDA : sdaClass.getMethods()) {
+			for (Invocation inv : mSDA.getOutgoingInvocations()) {
+				assertTrue( "Unexpected method signature: "+inv.getSignature(),
+							inv.getSignature().equals("equalsSingle (String)") || inv.getSignature().equals("id ()") || inv.getSignature().equals("equals (Object)"));
+				if (inv.getSignature().equals("equalsSingle (String)")) {
+					assertSame(sdaClass, ((Method)inv.getSender()).getParentType());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getCandidates().iterator().next());
+				}
+				else if (inv.getSignature().equals("id ()")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals("self", inv.getReceiver().getName());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(sdaClass, ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+				else if (inv.getSignature().equals("equals (Object)")) {
+					assertSame(TestVerveineUtils.detectElement(repo,Method.class, "equalsSingle"), inv.getSender());
+					assertEquals(null, inv.getReceiver());
+					assertEquals(1, inv.getCandidates().size());
+					assertSame(TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "String"), ((Method)inv.getCandidates().iterator().next()).getParentType());
+				}
+			}
+		}
+	}
+	
+	@Test
+	public void testAccess() {
+		Attribute att;
+		BehaviouralEntity accessor;
+		
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "name");
+		assertNotNull(att);
+		assertSame(2, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("name", accessor.getName());
+		assertEquals("Node", ((Method)accessor).getParentType().getName());
+
+		att = TestVerveineUtils.detectElement(repo, Attribute.class, "serverType");
+		assertNotNull(att);
+		assertSame(1, att.getIncomingAccesses().size());
+		accessor = att.getIncomingAccesses().iterator().next().getAccessor();
+		assertSame(Method.class, accessor.getClass());
+		assertEquals("setServerType", accessor.getName());
+		assertEquals("FileServer", ((Method)accessor).getParentType().getName());
+
+		// finds method PrintServer.output()
+		Method output = null;
+		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "output")) {
+			if (m.getParentType().getName().equals("PrintServer")) {
+				output = m;
+				break;
+			}
+		}
+		assertNotNull(output);
+		assertEquals("Wrong number of outgoing access for method PrintServer.output()", 4, output.getAccesses().size());
+		for (Access acc : output.getAccesses()) {
+			assertTrue("Unexpected field accessed: "+acc.getVariable().getName(),
+						acc.getVariable().getName().equals("out") || acc.getVariable().getName().equals("printer"));
+			assertEquals(output, acc.getAccessor());
+		}
+	}
+}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineRefVisitor.java	(revision 1)
@@ -0,0 +1,346 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.ArrayAccess;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.Assignment;
+import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConditionalExpression;
+import org.eclipse.jdt.core.dom.Expression;
+import org.eclipse.jdt.core.dom.FieldAccess;
+import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.IPackageBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.ImportDeclaration;
+import org.eclipse.jdt.core.dom.InfixExpression;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.Name;
+import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.ParenthesizedExpression;
+import org.eclipse.jdt.core.dom.QualifiedName;
+import org.eclipse.jdt.core.dom.StringLiteral;
+import org.eclipse.jdt.core.dom.SuperFieldAccess;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeLiteral;
+
+import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.NamedEntity;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/**
+ * AST Visitor that defines all the (Famix) entities of interest and links betgween them
+ * Famix entities are stored in a Map along with the (AST) IBindings to which they correspond
+ */
+public class VerveineRefVisitor extends ASTVisitor {
+
+	/** 
+	 * A dictionary allowing to recover created FAMIX Entities
+	 */
+	protected JavaDictionary dico;
+
+	/**
+	 * A stack that keeps the current definition context (package/class/method)
+	 */
+	protected EntityStack context;
+
+	public VerveineRefVisitor(JavaDictionary dico) {
+		this.dico = dico;
+		this.context = new EntityStack();
+	}
+
+	// VISITOR METHODS
+
+	public boolean visit(CompilationUnit node) {
+		PackageDeclaration pckg = node.getPackage();
+		if (pckg==null) {
+			this.context.pushPckg( dico.ensureFamixNamespaceDefault() );
+		}
+		else {
+			this.context.pushPckg( (Namespace)dico.getEntityByBinding(pckg.resolveBinding()) );
+		}
+		return super.visit(node);
+
+	}
+
+	public void endVisit(CompilationUnit node) {
+		this.context.popPckg();
+		super.endVisit(node);
+	}
+
+	/**
+	 * creating reference from package of this compilation unit to imported package
+	 * not sure it is a good idea ?!?
+	 */
+	public boolean visit(ImportDeclaration node) {
+
+		Namespace fmxSrc = this.context.topPckg();  // could access it through recursive node.getParent() ?
+
+		IBinding importBnd = node.resolveBinding();
+		if (importBnd instanceof IMethodBinding)  {
+			importBnd = ((IMethodBinding)importBnd).getDeclaringClass().getPackage();
+		}
+		else if (importBnd instanceof IVariableBinding)  {
+			importBnd = ((IVariableBinding)importBnd).getDeclaringClass().getPackage();
+		}
+		else if (importBnd instanceof ITypeBinding)  {
+			importBnd = ((ITypeBinding)importBnd).getPackage();
+		}
+
+		this.dico.ensureFamixReference(fmxSrc, dico.ensureFamixNamespace( (IPackageBinding) importBnd));
+		
+		return super.visit(node);
+	}
+
+	public boolean visit(TypeDeclaration node) {
+		this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(node.resolveBinding()));
+
+		return super.visit(node);
+	}
+
+	public void endVisit(TypeDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(ClassInstanceCreation node) {
+		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
+		if (decl != null) {
+			this.context.pushClass((fr.inria.verveine.core.gen.famix.Class)dico.getEntityByBinding(decl.resolveBinding()));
+		}
+		return super.visit(node);
+	}
+
+	public void endVisit(AnonymousClassDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(MethodDeclaration node) {
+		this.context.pushMethod((Method)dico.ensureFamixMethod(node.resolveBinding()));
+		return super.visit(node);	
+	}
+
+	public void endVisit(MethodDeclaration node) {
+		this.context.popMethod();
+		super.endVisit(node);
+	}
+
+	public boolean visit(MethodInvocation node) {
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), getReceiver(node.getExpression()));
+
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("static-access")
+	public boolean visit(SuperMethodInvocation node) {
+		methodInvocation(node.resolveMethodBinding(), node.getName().getFullyQualifiedName(), this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SUPER_NAME));
+		return super.visit(node);
+	}
+
+	public boolean visit(FieldAccess node) {
+		fieldAccess(node.resolveFieldBinding());
+		
+		return super.visit(node);
+	}
+
+	/* Could be a FieldAccess (see JDT javadoc: class FieldAccess) 
+	 */
+	public boolean visit(QualifiedName node) {
+		IBinding bnd = node.resolveBinding();
+		if (bnd instanceof IVariableBinding) {
+			// apparently this is a field
+			fieldAccess((IVariableBinding) bnd);
+		}
+		return super.visit(node);
+	}
+
+	/**
+	 * Finds and/or create the Famix Entity receiving a message
+	 * Can be: ImplicitVariable (this, super), GlobalVariable, LocalVariable, Attribute, UnknownVariable, Parameter
+	 * @param expr -- the Java expression describing the receiver
+	 * @return the Famix Entity or null if could not find it
+	 */
+	@SuppressWarnings("static-access")
+	private NamedEntity getReceiver(Expression expr) {
+		// msg(), same as ThisExpression
+		if (expr == null) {
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+		}
+
+		// array[i].msg()
+		else if (expr instanceof ArrayAccess) {
+			return getReceiver(((ArrayAccess) expr).getArray());
+		}
+
+		// new type[].msg() -- TODO similar to ClassInstanceCreation
+		else if (expr instanceof ArrayCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ArrayCreation");
+			return null;
+		}
+
+		// (variable = value).msg()
+		else if (expr instanceof Assignment) {
+			return getReceiver(((Assignment) expr).getLeftHandSide());
+		}
+
+		// ((type)expr).msg()
+		else if (expr instanceof CastExpression) {
+			return getReceiver(((CastExpression) expr).getExpression());
+		}
+
+		// new Class().msg() -- TODO anonymous object of a known class ...
+		else if (expr instanceof ClassInstanceCreation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: ClassInstanceCreation");
+			return null;
+		}
+
+		// (cond-expr ? then-expr : else-expr).msg()
+		else if (expr instanceof ConditionalExpression) {
+			// can be one or the other (then-expr/else-expr) so we choose one
+			NamedEntity ret = getReceiver(((ConditionalExpression) expr).getThenExpression());
+			if (ret == null) {
+				// can as well try the other
+				ret = getReceiver(((ConditionalExpression) expr).getElseExpression());
+			}
+			return ret;
+		}
+
+		// field.msg()
+		else if (expr instanceof FieldAccess) {
+			Attribute ret = null;
+			IVariableBinding bnd = ((FieldAccess) expr).resolveFieldBinding();
+			if (bnd == null) {
+				ret = dico.ensureFamixAttribute(((FieldAccess)expr).getName().getIdentifier());
+			}
+			else {
+				ret = this.dico.ensureFamixAttribute(bnd);
+			}
+
+			return ret;
+		}
+
+		// (left-expr oper right-expr).msg()
+		else if (expr instanceof InfixExpression) {
+			// anonymous receiver
+			return null;
+		}
+
+		// msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof MethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: MethodInvocation");
+
+			return null;
+		}
+
+		// name.msg()
+		else if (expr instanceof Name) {
+			NamedEntity ret = null;
+			// can be a class or a variable name
+			IBinding bnd = ((Name) expr).resolveBinding();
+			if (bnd != null) {
+				if (bnd instanceof ITypeBinding) {
+					// msg() is a static method of Name
+					ret = dico.createFamixUnknownVariable( dico.ensureFamixClass((ITypeBinding)bnd), bnd.getName());
+				}
+				else if (bnd instanceof IVariableBinding) {
+					if ( ((IVariableBinding)bnd).isField() ) {
+						ret = dico.ensureFamixAttribute( (IVariableBinding)bnd);
+					}
+					else if ( ((IVariableBinding)bnd).isParameter() ) {
+						ret = dico.ensureFamixParameter( (IVariableBinding)bnd);
+					}
+					else { // suppose it's a local variable
+						ret = dico.ensureFamixLocalVariable( (IVariableBinding)bnd);
+					}
+				}
+			}
+			
+			return ret;
+		}
+
+		// (expr).msg()
+		else if (expr instanceof ParenthesizedExpression) {
+			return getReceiver(((ParenthesizedExpression) expr).getExpression());
+		}
+
+		// "string".msg() -- TODO similar to ClassInstanceCreation, anonymous String object
+		else if (expr instanceof StringLiteral) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: StringLiteral");
+			return null;
+		}
+
+		// super.field.msg()
+		else if (expr instanceof SuperFieldAccess) {
+			Attribute ret = null;
+			IVariableBinding bnd = ((SuperFieldAccess) expr).resolveFieldBinding();
+			if (bnd == null) {
+				ret = dico.ensureFamixAttribute(((SuperFieldAccess)expr).getName().getIdentifier());
+			}
+			else {
+				ret = this.dico.ensureFamixAttribute(bnd);
+			}
+
+			return ret;
+		}
+
+		// super.msg1().msg() -- TODO similar to ClassInstanceCreation, 'msg()' is sent to the object returned by 'msg1()'
+		else if (expr instanceof SuperMethodInvocation) {
+			//System.err.println("WARNING: Ignored receiver expression in method call: SuperMethodInvocation");
+			
+			return null;
+		}
+		
+		// this.msg()
+		else if (expr instanceof ThisExpression) {
+			return this.dico.ensureFamixImplicitVariable(this.context.topClass(), dico.SELF_NAME);
+		}
+
+		// type.class.msg()
+		else if (expr instanceof TypeLiteral) {
+			return dico.ensureFamixClass( expr.resolveTypeBinding());
+		}
+
+		// ... OTHER POSSIBLE EXPRESSIONS ?
+		else  {
+			System.err.println("WARNING: Unexpected receiver expression: "+expr.getClass().getName()+" (method called is" + expr.getClass().getName() + ".aMethod(...))");
+		}
+
+		return null;
+	}
+
+	private void fieldAccess(IVariableBinding bnd) {
+		BehaviouralEntity accessor = this.context.topMethod();
+		if (accessor != null) {
+			Attribute accessed = this.dico.ensureFamixAttribute(bnd);
+			if (accessed != null) {
+				dico.ensureFamixAccess(accessor, accessed);
+			}
+		}
+	}
+
+	private void methodInvocation(IMethodBinding bnd, String name, NamedEntity receiver) {
+		BehaviouralEntity sender = this.context.topMethod();
+		if (sender != null) {
+			Method invoked = this.dico.ensureFamixMethod(bnd);
+			if (invoked == null) {
+				invoked = this.dico.ensureFamixStubMethod(name);
+			}
+			/*Invocation inv =*/ dico.ensureFamixInvocation(sender, invoked, receiver);
+			/* An example of how to include location information to an entity:
+			   dico.addSourceAnchor(inv, node); */
+		}
+	}
+
+
+}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 1)
@@ -0,0 +1,189 @@
+package fr.inria.verveine.extractor.java;
+
+import java.util.Iterator;
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.PackageDeclaration;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.VariableDeclaration;
+import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+
+import fr.inria.verveine.core.EntityStack;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+
+/**
+ * AST Visitor that defines all the (Famix) entities of interest
+ * Famix entities are stored in a Map along with the IBindings to which they correspond
+ */
+public class VerveineDefVisitor extends ASTVisitor {
+
+	/** 
+	 * A dictionary allowing to recover created FAMIX Entities
+	 */
+	protected JavaDictionary dico;
+
+	/**
+	 * A stack that keeps the current definition context (package/class/method)
+	 */
+	protected EntityStack context;
+
+	public VerveineDefVisitor(JavaDictionary dico) {
+		this.dico = dico;
+		this.context = new EntityStack();
+	}
+
+	// VISITOR METHODS
+
+	public boolean visit(CompilationUnit node) {
+//		System.err.println("TRACE, DefVisiting CompilationUnit");
+		Namespace fmx = null;
+		PackageDeclaration pckg = node.getPackage();
+		if (pckg==null) {
+			fmx = dico.ensureFamixNamespaceDefault();
+		}
+		else {
+			fmx = dico.ensureFamixNamespace(pckg.resolveBinding());
+			if (fmx == null) {
+			System.err.println("         Namespace="+pckg.getName().getFullyQualifiedName());
+				fmx = dico.ensureFamixNamespace(pckg.getName().getFullyQualifiedName());
+			}
+		}
+		this.context.pushPckg(fmx);
+		return super.visit(node);
+
+	}
+
+	public void endVisit(CompilationUnit node) {
+		this.context.popPckg();
+		super.endVisit(node);
+	}
+
+	public boolean visit(TypeDeclaration node) {
+//		System.err.println("TRACE, DefVisiting TypeDeclaration: "+node.getName().getIdentifier());
+		fr.inria.verveine.core.gen.famix.Class fmx = dico.ensureFamixClass(node.resolveBinding());
+		if (fmx == null) {
+			// TODO try to find a bounded version corresponding to this stub?
+			System.err.println("         Class="+node.getName().getIdentifier());
+			fmx = dico.ensureFamixClass(node.getName().getIdentifier());
+			dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
+			fmx.setContainer( context.top());
+		}
+		this.context.pushClass(fmx);
+		return super.visit(node);
+	}
+
+	public void endVisit(TypeDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(ClassInstanceCreation node) {
+//		System.err.println("TRACE, DefVisiting ClassInstanceCreation");
+		AnonymousClassDeclaration decl = node.getAnonymousClassDeclaration(); 
+		if (decl != null) {
+			fr.inria.verveine.core.gen.famix.Class fmx = this.dico.ensureFamixClass(decl.resolveBinding());
+			if (fmx == null) {
+				System.err.println("         Class="+"anonymous(??)");
+				fmx = dico.ensureFamixClass("anonymous(??)");
+				dico.ensureFamixInheritance(dico.ensureFamixClassObject(null), fmx);
+				fmx.setContainer( context.top());
+			}
+			this.context.pushClass(fmx);
+		}
+		return super.visit(node);
+	}
+
+	public void endVisit(AnonymousClassDeclaration node) {
+		this.context.popClass();
+		super.endVisit(node);
+	}
+
+	public boolean visit(MethodDeclaration node) {
+//		System.err.println("TRACE, DefVisiting MethodDeclaration: "+node.getName().getIdentifier());
+		Method fmx = dico.ensureFamixMethod(node.resolveBinding());
+		if (fmx == null) {
+			System.err.println("         Method="+node.getName().getIdentifier());
+			fmx = dico.ensureFamixMethod(node.getName().getIdentifier());
+			fmx.setParentType(context.topClass());
+			fmx.setSignature(fmx.getName()+" (???)");
+			fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+		}
+		if (fmx != null) {
+			@SuppressWarnings("unchecked")
+			Iterator<SingleVariableDeclaration> iter = node.parameters().iterator();
+			while (iter.hasNext()) {
+				SingleVariableDeclaration param = iter.next();
+				dico.ensureFamixParameter(param.resolveBinding());
+			}
+			this.context.pushMethod(fmx);
+		}
+		return super.visit(node);	
+	}
+
+	public void endVisit(MethodDeclaration node) {
+		this.context.popMethod();
+		super.endVisit(node);
+	}
+
+	@SuppressWarnings({ "unchecked" })
+	public boolean visit(FieldDeclaration node) {
+//		System.err.println("TRACE, DefVisiting FieldDeclaration");
+		for (VariableDeclarationFragment vd : (List<VariableDeclarationFragment>)node.fragments()) {
+//			System.err.println("            Field: "+vd.getName().getIdentifier());
+			Attribute fmx = dico.ensureFamixAttribute(vd.resolveBinding());
+			if (fmx == null) {
+				System.err.println("         Attribute="+vd.getName().getFullyQualifiedName());
+				fmx = dico.ensureFamixAttribute(vd.getName().getFullyQualifiedName());
+				fmx.setParentType(context.topClass());
+				// should try to find type name from 'node.getType()' ?
+				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+			}
+		}
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationExpression node) {
+		//System.err.println("TRACE, DefVisiting VariableDeclarationExpression");
+		visitVariableDeclaration(node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		return super.visit(node);
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean visit(VariableDeclarationStatement node) {
+		//System.err.println("TRACE, DefVisiting VariableDeclarationStatement");
+		visitVariableDeclaration(node.getType(), (List<VariableDeclarationFragment>)node.fragments());
+		return super.visit(node);
+	}
+
+	private void visitVariableDeclaration(Type nodeTyp, List<VariableDeclarationFragment> fragments) {
+		if (nodeTyp.isPrimitiveType()) {
+			return;
+		}
+
+		for (VariableDeclarationFragment vd : fragments) {
+			LocalVariable fmx = dico.ensureFamixLocalVariable(vd.resolveBinding());
+			if (fmx == null) {
+				System.err.println("         Variable="+vd.getName().getFullyQualifiedName());
+				fmx = dico.ensureFamixLocalVariable(vd.getName().getFullyQualifiedName());
+				fmx.setParentBehaviouralEntity(context.topMethod());
+				// should try to find type name from 'node.getType()' ?
+				fmx.setDeclaredType( dico.ensureFamixClassObject(null) );
+			}
+		}
+	}
+
+}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 1)
@@ -0,0 +1,569 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.IBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.IPackageBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+
+import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.Dictionary;
+import fr.inria.verveine.core.gen.famix.Attribute;
+import fr.inria.verveine.core.gen.famix.ContainerEntity;
+import fr.inria.verveine.core.gen.famix.FileAnchor;
+import fr.inria.verveine.core.gen.famix.LocalVariable;
+import fr.inria.verveine.core.gen.famix.Method;
+import fr.inria.verveine.core.gen.famix.Namespace;
+import fr.inria.verveine.core.gen.famix.Parameter;
+import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.SourcedEntity;
+import fr.inria.verveine.core.gen.famix.UnknownVariable;
+
+/**
+ * A {@link fr.inria.verveine.Dictionary} specialized for Java
+ * @author anquetil
+ */
+public class JavaDictionary extends Dictionary<IBinding> {
+
+	// a property added to CompilationUnits to record the name of the source file name they come from
+	public static final String SOURCE_FILENAME_PROPERTY = "verveine-source-filename";
+
+	public static final String OBJECT_NAME = "Object";
+	public static final String OBJECT_PACKAGE_NAME = "java.lang";
+	public static final String PRIMITIVE_PCKG_NAME = "<Primitive Package>";   // for int, boolean, .... types
+	public static final String INSTANCE_INIT_BLOCK_NAME = "<InstanceInitializer>";
+	public static final String STATIC_INIT_BLOCK_NAME = "<StaticInitializer>";
+
+	/**
+	 * @param famixRepo
+	 */
+	public JavaDictionary(Repository famixRepo) {
+		super(famixRepo);
+	}
+
+	/**
+	 * Returns a Famix Namespace associated with the IPackageBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Namespace ensureFamixNamespace(IPackageBinding bnd) {
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Namespace");
+			return null;
+		}
+
+		Namespace fmx = ensureFamixUniqEntity(Namespace.class, bnd, bnd.getName());
+
+		if (fmx!=null) {
+			if (createParentScope(fmx) != null) {
+				// remove the name of the parent from the name of this package
+				/*String name = fmx.getName();
+				fmx.setName(name.substring(name.lastIndexOf('.')+1));*/
+			}
+			fmx.setIsStub(Boolean.FALSE);			
+		}
+		return fmx;
+	}
+
+	@Override
+	public Namespace ensureFamixNamespace(String name) {
+		Namespace fmx = super.ensureFamixNamespace(name);
+		
+		if (fmx!=null) {
+			if (createParentScope(fmx) != null) {
+				// remove the name of the parent from the name of this package
+				/*fmx.setName(name.substring(name.lastIndexOf('.')+1));*/
+			}
+			fmx.setIsStub(Boolean.FALSE);			
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Creates and returns a parent namespace for 'fmx'
+	 * @param fmx - the namespace for which to create a parent
+	 * @return the parent namespace created or null
+	 */
+	private Namespace createParentScope(Namespace fmx) {
+		String name = fmx.getName();
+		Namespace parentScope = null;
+		if (fmx.getParentScope() == null) {
+			int pt = name.lastIndexOf('.');
+			if (pt > 0) {
+				parentScope = ensureFamixNamespace(name.substring(0, pt));
+				if (parentScope != null) {
+					parentScope.addChildScopes(fmx);
+				}
+			}
+		}
+		
+		return parentScope;
+	}
+
+	/**
+	 * Returns a Famix Class associated with the ITypeBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClass(ITypeBinding bnd) {
+		ContainerEntity owner = null;
+		fr.inria.verveine.core.gen.famix.Class sup = null;
+		String identifier = null;
+		
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Class");
+			return null;
+		}
+
+		while (bnd.isArray()) {
+			bnd = bnd.getComponentType();
+		}
+		
+		// container
+		IMethodBinding parentMtd = bnd.getDeclaringMethod();
+		if (parentMtd != null) {
+			owner = this.ensureFamixMethod(parentMtd);
+		}
+		else {
+			ITypeBinding parentClass = bnd.getDeclaringClass();
+			if (parentClass != null) {
+				owner = this.ensureFamixClass(parentClass);
+			}
+			else {
+				IPackageBinding parentPckg = bnd.getPackage();
+				if (parentPckg != null) {
+					owner = this.ensureFamixNamespace(parentPckg);
+				}
+				else {
+					if (bnd.isPrimitive()) {
+						owner = this.ensureFamixNamespacePrimitives();
+					}
+					else {
+						owner = this.ensureFamixNamespaceDefault();
+					}
+				}
+			}
+		}
+
+		// name
+		if (bnd.isAnonymous()) {
+			if (bnd.getSuperclass() != null) {
+				identifier = bnd.getSuperclass().getName();
+			}
+			if ( (identifier == null) || identifier.equals(OBJECT_NAME)) {
+				ITypeBinding[] intfcs = bnd.getInterfaces();
+				if ( (intfcs != null) && (intfcs.length > 0) ) {
+					identifier = bnd.getInterfaces()[0].getName();
+				}
+				else {
+					identifier = "???";
+				}
+			}
+			identifier = "anonymous(" + identifier + ")";
+		}
+		else {
+			identifier = bnd.getName();
+		}
+
+		// superclass
+		if (bnd.isInterface()) {
+			// TODO interface don't have superclass
+		}
+		else if ( (! bnd.isPrimitive()) && (! bnd.getName().equals(OBJECT_NAME)) ) {
+			// "Object" and primitive types don't have a superclass
+			ITypeBinding supbnd = bnd.getSuperclass();
+			if (supbnd == null) {
+				sup = ensureFamixClassObject(null);
+			}
+			else {
+				sup = ensureFamixClass(supbnd);
+			}
+		}
+
+		// finally trying to recover the entity or creating it
+		fr.inria.verveine.core.gen.famix.Class fmx = null;
+		// ... trying to recover from binding
+		fmx = (fr.inria.verveine.core.gen.famix.Class) getEntityByBinding(bnd);
+		
+		if (fmx == null) {
+			// trying to recover from name and other informations
+			for (fr.inria.verveine.core.gen.famix.Class candidate : getEntityByName(fr.inria.verveine.core.gen.famix.Class.class, identifier) ) {
+				if ( (! candidate.getIsStub()) &&
+						(candidate.getBelongsTo() == owner) ) {
+					// could test superclass also...
+					fmx = candidate;
+					mapBind.put(bnd, fmx);
+					break;
+				}
+				else if ( candidate.getIsStub() ) {
+					ContainerEntity ownerBnd = owner;
+					ContainerEntity ownerStub = candidate.getBelongsTo();
+					while ( (! (ownerBnd instanceof Namespace)) &&
+							(ownerBnd.getClass() == ownerStub.getClass()) &&
+							ownerBnd.getName().equals(ownerStub.getName()) ) {
+								ownerBnd = ownerBnd.getBelongsTo();
+								ownerStub = ownerStub.getBelongsTo();
+					}
+					if ( (ownerBnd instanceof Namespace) &&
+						(ownerStub instanceof Namespace) &&
+						ownerBnd.getName().equals(ownerStub.getName()) ) {
+						fmx = candidate;
+						mapBind.put(bnd, fmx);
+						break;
+					}
+				}
+			}
+		}
+		
+		if (fmx == null) {
+			// could not recover it, creating a new entity
+			fmx = (fr.inria.verveine.core.gen.famix.Class) ensureFamixStub(fr.inria.verveine.core.gen.famix.Class.class, bnd, bnd.getName());
+		}
+		
+		if ((fmx!=null) && fmx.getIsStub()) {
+			// apparently we just created it, so add information to it
+			fmx.setContainer(owner);
+			if (sup != null) {
+				// some types don't have superclass
+				ensureFamixInheritance(sup, fmx);
+			}
+			fmx.setName(identifier); // might be different from bnd.getName() in the case of anonymous class
+			fmx.setIsStub(Boolean.FALSE);
+		}
+	
+		return fmx;
+	}
+
+	/**
+	 * Returns a Famix Method associated with the IMethodBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Method ensureFamixMethod(IMethodBinding bnd) {
+		fr.inria.verveine.core.gen.famix.Class parentClass = null;
+		fr.inria.verveine.core.gen.famix.Class rettyp = null;
+		String sig = null;
+		
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Method");
+			return null;
+		}
+
+		// owner
+		parentClass = this.ensureFamixClass(bnd.getDeclaringClass());
+
+		// return type
+		if (bnd.isConstructor()) {
+			// TODO what to put in metamodel?
+		}
+		else {
+			rettyp = this.ensureFamixClass(bnd.getReturnType());	
+		}
+
+		// method signature
+		sig = bnd.getName() + " (";
+		boolean first = true;
+		for (ITypeBinding parBnd : bnd.getParameterTypes()) {
+			if (! first) {
+				sig += "," + parBnd.getName();
+			}
+			else {
+				sig += parBnd.getName();
+				first = false;
+			}
+		}
+		sig += ")";
+
+		// finally trying to recover the entity or creating it
+		Method fmx = null;
+		// ... trying to recover from binding
+		fmx = (Method) getEntityByBinding(bnd);
+		
+		if (fmx == null) {
+			// trying to recover from name and other informations
+			for (Method candidate : getEntityByName(Method.class, bnd.getName()) ) {
+				if ( (! candidate.getIsStub()) &&
+					 (candidate.getParentType() == parentClass) &&
+					 (candidate.getDeclaredType() == rettyp) &&
+					 (candidate.getSignature().equals(sig)) ) {
+					fmx = candidate;
+					mapBind.put(bnd, fmx);
+					break;
+				}
+			}
+		}
+		
+		if (fmx == null) {
+			// could not recover it, creating a new entity
+			fmx = (Method) ensureFamixStub(Method.class, bnd, bnd.getName());
+		}
+		
+		if ((fmx!=null) && fmx.getIsStub()) {
+			// apparently we just created it, so add information to it
+			fmx.setParentType(parentClass);
+			fmx.setDeclaredType(rettyp);	
+			fmx.setName(bnd.getName());
+			fmx.setSignature(sig);
+			fmx.setIsStub(Boolean.FALSE);
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a Famix Attribute associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Attribute ensureFamixAttribute(IVariableBinding bnd) {
+		fr.inria.verveine.core.gen.famix.Class parentClass = null;
+		fr.inria.verveine.core.gen.famix.Class typ = null;
+
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Attribute");
+			return null;
+		}
+
+		parentClass = this.ensureFamixClass(bnd.getDeclaringClass());
+		typ = this.ensureFamixClass(bnd.getType());
+
+		// finally trying to recover the entity or creating it
+		Attribute fmx = null;
+		// ... trying to recover from binding
+		fmx = (Attribute) getEntityByBinding(bnd);
+		
+		if (fmx == null) {
+			// trying to recover from name and other informationsparentBehaviouralEntity
+			for (Attribute candidate : getEntityByName(Attribute.class, bnd.getName()) ) {
+				if ( (! candidate.getIsStub()) &&
+					 (candidate.getParentType() == parentClass) &&
+					 (candidate.getDeclaredType() == typ) ) {
+					fmx = candidate;
+					mapBind.put(bnd, fmx);
+					break;
+				}
+			}
+		}
+		
+		if (fmx == null) {
+			// could not recover it, creating a new entity
+			fmx = ensureFamixStub(Attribute.class, bnd, bnd.getName());
+		}
+		
+		if ((fmx!=null) && fmx.getIsStub()) {
+			// apparently we just created it, so add information to it
+			fmx.setParentType(parentClass);
+			fmx.setDeclaredType(typ);	
+			fmx.setName(bnd.getName());
+			fmx.setIsStub(Boolean.FALSE);
+		}
+
+		return fmx;
+	}
+
+	/**
+	 * Returns a Famix Paramenter associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public Parameter ensureFamixParameter(IVariableBinding bnd) {
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix Parameter");
+			return null;
+		}
+
+		Parameter fmx = (Parameter) ensureFamixStub(Parameter.class, bnd, bnd.getName());
+		if ( (fmx!=null) && fmx.getIsStub() ) {
+			// declaring method
+			fmx.setParentBehaviouralEntity(ensureFamixMethod(bnd.getDeclaringMethod()));
+
+			// type of the attribute
+			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
+
+			fmx.setIsStub(Boolean.FALSE);
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Returns a Famix LocalVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public LocalVariable ensureFamixLocalVariable(IVariableBinding bnd) {
+		Method parentMeth = null;
+		fr.inria.verveine.core.gen.famix.Class typ = null;
+
+		if (bnd == null) {
+			System.err.println("Warning: Unexpected null binding, cannot create Famix LocalVariable");
+			return null;
+		}
+
+		parentMeth = this.ensureFamixMethod(bnd.getDeclaringMethod());
+		typ = this.ensureFamixClass(bnd.getType());
+
+		// finally trying to recover the entity or creating it
+		LocalVariable fmx = null;
+		// ... trying to recover from binding
+		fmx = (LocalVariable) getEntityByBinding(bnd);
+
+		if (fmx == null) {
+			// trying to recover from name and other informationsparentBehaviouralEntity
+			for (LocalVariable candidate : getEntityByName(LocalVariable.class, bnd.getName()) ) {
+				if ( (! candidate.getIsStub()) &&
+					 (candidate.getParentBehaviouralEntity() == parentMeth) &&
+					 (candidate.getDeclaredType() == typ) ) {
+					fmx = candidate;
+					mapBind.put(bnd, fmx);
+					break;
+				}
+			}
+		}
+		
+		if (fmx == null) {
+			// could not recover it, creating a new entity
+			fmx = ensureFamixStub(LocalVariable.class, bnd, bnd.getName());
+		}
+
+		if ( (fmx!=null) && fmx.getIsStub() ) {
+			// apparently we just created it, so add information to it
+			fmx.setParentBehaviouralEntity(parentMeth);
+			fmx.setDeclaredType(this.ensureFamixClass(bnd.getType()));
+			fmx.setIsStub(Boolean.FALSE);
+		}
+		
+		return fmx;
+	}
+
+	/**
+	 * Returns a Famix UnknownVariable associated with the IVariableBinding. The Entity is created if it does not exist.
+	 * The JDT Binding is a unique representation of a java entity within the AST.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param bnd -- the JDT Binding 
+	 * @return the Famix Entity found or created. May return null if "bnd" is null or in case of a Famix error
+	 */
+	public UnknownVariable createFamixUnknownVariable(fr.inria.verveine.core.gen.famix.Class ofType, String name) {
+//		System.err.println("TRACE -- createFamixUnknownVariable: "+name);
+		UnknownVariable fmx = (UnknownVariable) createFamixStub(UnknownVariable.class, name);
+		if (fmx!=null) {
+			fmx.setDeclaredType(ofType);
+			fmx.setIsStub(Boolean.FALSE);
+		}
+		return fmx;
+	}
+
+	/**
+	 * Adds location information to a Famix Entity.
+	 * Location informations are: <b>name</b> of the source file and <b>line</b> position in this file. They are found in the JDT ASTNode: ast.
+	 * This method also creates some basic links between the entity and others (e.g. declaring container, return type, ...)
+	 * @param fmx -- Famix Entity to add the anchor to
+	 * @param ast -- JDT ASTNode, where the information are extracted
+	 * @return the Famix SourceAnchor added to fmx. May be null in case of incorrect parameter ('fmx' or 'ast' == null) 
+	 */
+	public SourceAnchor addSourceAnchor(SourcedEntity fmx, ASTNode ast) {
+		FileAnchor fa = null;
+		
+		if ( (fmx != null) && (ast != null) ) {
+			// position in source file
+			int pos = ast.getStartPosition();
+			// find source file
+			while ( ! (ast instanceof CompilationUnit) ) {
+				ASTNode tmp = ast.getParent();
+				if ( (ast == null) || (tmp == ast) ) {
+					// we reach the top node without finding a CompilationUnit. This is strange, but what can we do ... ?
+					return null;
+				}
+				else {
+					ast = tmp;
+				}
+			}
+			// noew create the Famix SourceAnchor
+			fa = new FileAnchor();
+			fa.setFileName((String) ((CompilationUnit)ast).getProperty(SOURCE_FILENAME_PROPERTY));
+			fa.setStartLine(((CompilationUnit)ast).getLineNumber(pos));
+			fmx.setSourceAnchor(fa);
+			famixRepo.add(fa);
+		}
+		
+		return fa;
+	}
+
+	/**
+	 * Creates or recovers a stub Famix Method
+	 * @param name of the method
+	 * @return the Famix Method
+	 */
+	public Method ensureFamixStubMethod(String name) {
+		Method fmx = ensureFamixMethod(name);
+		fmx.setSignature(name + " (<unknown-stub>)");
+		fmx.setParentType( ensureFamixClassStubOwner());
+		fmx.setDeclaredType(ensureFamixClassObject(null));
+		
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers a Famix Namespace for the package of Java class "Object" (i.e. "java.lang").
+	 * Because "Object" is the root of the inheritance tree, it needs to be treated differently.
+	 * @param bnd -- a potential binding for the "java.lang" package
+	 * @return a Famix Namespace for "java.lang"
+	 */
+	public Namespace ensureFamixNamespaceJavaLang(ITypeBinding bnd) {
+		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, bnd, OBJECT_PACKAGE_NAME);
+		fmx.setIsStub(false);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers a Famix Namespace for the primitive types in Java.
+	 * Because this package does not really exist, it has no binding.
+	 * @return a Famix Namespace
+	 */
+	public Namespace ensureFamixNamespacePrimitives() {
+		Namespace fmx =  ensureFamixUniqEntity(Namespace.class, null, PRIMITIVE_PCKG_NAME);
+		fmx.setIsStub(false);
+
+		return fmx;
+	}
+
+	/**
+	 * Creates or recovers a Famix Class for the Java "Object".
+	 * @param bnd -- a potential binding for the java "object" class
+	 * @return a Famix class for Java "Object"
+	 */
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassObject(ITypeBinding bnd) {
+		fr.inria.verveine.core.gen.famix.Class fmx =  ensureFamixUniqEntity(fr.inria.verveine.core.gen.famix.Class.class, bnd, OBJECT_NAME);
+		
+		fmx.setContainer( ensureFamixNamespaceJavaLang(null));
+		// Note: "Object" has no superclass
+		fmx.setIsStub(false);
+
+		return fmx;
+	}
+
+	@Override
+	public fr.inria.verveine.core.gen.famix.Class ensureFamixClassStubOwner() {
+		fr.inria.verveine.core.gen.famix.Class fmx = super.ensureFamixClassStubOwner();
+		ensureFamixInheritance(ensureFamixClassObject(null), fmx);
+
+		return fmx;
+	}
+
+}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/BatchParser.java	(revision 1)
@@ -0,0 +1,100 @@
+package fr.inria.verveine.extractor.java;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import java.util.Map;
+
+import org.eclipse.jdt.core.compiler.CompilationProgress;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
+import org.eclipse.jdt.internal.compiler.batch.Main;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+import ch.akuhn.fame.Repository;
+
+import fr.inria.verveine.core.gen.famix.FAMIXModel;
+
+
+//import fr.inria.verveine.NonCloseablePrintStream;
+
+/**
+ * A batch parser inspired from org.eclipse.jdt.internal.compiler.batch.Main (JDT-3.6)
+ * run with:
+ * java -cp lib/org.eclipse.jdt.core_3.6.0.v_A48.jar:../Fame:/usr/local/share/eclipse/plugins/org.eclipse.equinox.common_3.5.1.R35x_v20090807-1100.jar:/usr/local/share/eclipse/plugins/org.eclipse.equinox.preferences_3.2.301.R35x_v20091117.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.jobs_3.4.100.v20090429-1800.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.contenttype_3.4.1.R35x_v20090826-0451.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.resources_3.5.2.R35x_v20091203-1235.jar:/usr/local/share/eclipse/plugins/org.eclipse.core.runtime_3.5.0.v20090525.jar:/usr/local/share/eclipse/plugins/org.eclipse.osgi_3.5.2.R35x_v20100126.jar:../Fame/lib/akuhn-util-r28011.jar:lib/fame.jar:bin fr.inria.verveine.parser.BatchParser [files|directory]_to_parse
+ */
+
+public class BatchParser extends Main {
+	
+	private Repository famixRepo;
+
+	public static void main(String[] args) {
+		new BatchParser(new PrintWriter(System.out), new PrintWriter(System.err), true/*systemExit*/, null/*options*/, null/*progress*/).compile(args);
+	}
+
+	public BatchParser(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, @SuppressWarnings("rawtypes") Map customDefaultOptions, CompilationProgress compilationProgress) {
+		super(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, compilationProgress);
+	}
+
+	/*
+	 *  Low-level API performing the actual parsing
+	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
+	 */
+	public void performCompilation() {
+
+		famixRepo = new Repository(FAMIXModel.metamodel());
+
+		this.compilerOptions = new CompilerOptions(this.options);
+		this.compilerOptions.performMethodsFullRecovery = false;
+		this.compilerOptions.performStatementsRecovery = false;
+
+		// NA --- beginning of parsing code --------------------------------------------------
+		String[] tmpclasspath=null;
+		if (this.checkedClasspaths!=null) {
+			tmpclasspath = new String[this.checkedClasspaths.length];
+			int i = 0;
+			for (Classpath cp : this.checkedClasspaths) {
+				tmpclasspath[i++] = cp.getPath();
+			}
+		}
+
+		ASTParser pars = ASTParser.newParser(AST.JLS3);
+		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
+				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
+				/*encodings*/null, 
+				/*includeRunningVMBootclasspath*/true);
+		pars.setResolveBindings(true);
+		pars.setKind(ASTParser.K_COMPILATION_UNIT);
+		pars.createASTs(/*sourceFilePaths*/this.filenames, 
+				/*encodings*/this.encodings, 
+				/*bindingKeys*/new String[0], 
+				/*requestor*/new FamixRequestor(famixRepo), 
+				/*monitor*/null);
+		// NA --- end of parsing code --------------------------------------------------
+
+		/* 
+		 * NA --- Outputting --------------------------------------------------
+		 * To stdout
+		 * Repository.exportMSE() closes the stream when it finishes, we don't want this
+		 * The NonCloseOutputStream class prevents that by redefining an empty close() that does nothing
+		 * (particularly not closing the underlying System.out)
+		 */
+		//famixRepo.exportMSE( new NonCloseablePrintStream(System.out));
+		//System.out.println();
+		
+		
+		// outputting to a file
+		try {
+			famixRepo.exportMSE(new FileWriter("output.mse"));
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public Repository getFamixRepo() {
+		return famixRepo;
+	}
+	
+}
Index: verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 0)
+++ verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 1)
@@ -0,0 +1,25 @@
+package fr.inria.verveine.extractor.java;
+
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.FileASTRequestor;
+
+import ch.akuhn.fame.Repository;
+
+public class FamixRequestor extends FileASTRequestor {
+
+	protected Repository famixRepo;
+	
+	protected JavaDictionary famixDictionnary;
+	
+	public FamixRequestor(Repository r) {
+		this.famixRepo = r;
+		this.famixDictionnary = new JavaDictionary(famixRepo);
+	}
+
+	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
+		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, sourceFilePath);
+		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
+		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
+		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
+	}
+}
Index: verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs	(revision 0)
+++ verveine.extractor.java/.settings/org.eclipse.jdt.core.prefs	(revision 1)
@@ -0,0 +1,12 @@
+#Thu Sep 16 21:04:28 CEST 2010
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
