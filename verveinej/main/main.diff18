Index: branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/.classpath	(revision 105)
@@ -2,11 +2,6 @@
 <classpath>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="lib/org.eclipse.jdt.core_3.6.0.v_A58.jar" sourcepath="/org.eclipse.jdt.core/">
-		<attributes>
-			<attribute name="javadoc_location" value="jar:file:/usr/local/share/eclipse-3_6/plugins/isv-3.2.1-r321_v20060907.jar!/reference/api"/>
-		</attributes>
-	</classpathentry>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.runtime_3.6.0.v20100505.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.resources_3.6.0.v20100526-0737.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.core.jobs_3.5.0.v20100515.jar"/>
@@ -15,7 +10,9 @@
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.common_3.6.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/org.eclipse.equinox.preferences_3.3.0.v20100503.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar" sourcepath="/Fame/"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/verveine.core"/>
+	<classpathentry kind="lib" path="lib/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
+	<classpathentry kind="lib" path="lib/junit.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.jdt.core"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/junit.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/junit.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: branches/postMoose4_3Refactoring/verveine.extractor.java/lib/org.hamcrest.core_1.1.0.v20090501071000.jar
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_LanModel.java	(revision 105)
@@ -36,6 +36,7 @@
 import fr.inria.verveine.core.gen.famix.Parameter;
 import fr.inria.verveine.core.gen.famix.PrimitiveType;
 import fr.inria.verveine.core.gen.famix.SourceAnchor;
+import fr.inria.verveine.core.gen.famix.Type;
 import fr.inria.verveine.extractor.java.JavaDictionary;
 import fr.inria.verveine.extractor.java.VerveineJParser;
 
@@ -97,8 +98,9 @@
 				};
 		
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(args);
+		parser.parse();
 		
 		new File(VerveineJParser.OUTPUT_FILE).delete();  // delete old MSE file
 		parser.outputMSE();  // to create a new one
@@ -106,9 +108,6 @@
 
 	@Test
 	public void testEntitiesNumber() {
-		for (Method c : TestVerveineUtils.selectElementsOfType(repo,Method.class)) {
-			//System.out.println("meth -- "+c.getBelongsTo()+"::"+c.getSignature());
-		}
 		assertEquals(11+14, TestVerveineUtils.selectElementsOfType(repo, fr.inria.verveine.core.gen.famix.Class.class).size()); // 11 + {Object,String,StringBuffer,AbstractStringBuilder,PrintStream,FilterOutputStream,OutputStream,System,Comparable,Serializable,Flushable,Appendable,CharSequence,Closeable}
 		assertEquals(3,     TestVerveineUtils.selectElementsOfType(repo, PrimitiveType.class).size());//int,boolean,void
 		assertEquals(40+7,  TestVerveineUtils.selectElementsOfType(repo, Method.class).size());//40+{System.out.println(),System.out.println(...),System.out.print,StringBuffer.append,Object.equals,String.equals,Object.toString}
@@ -278,7 +277,7 @@
 		String javaLangName = JavaDictionary.OBJECT_PACKAGE_NAME.substring(JavaDictionary.OBJECT_PACKAGE_NAME.lastIndexOf('.')+1);
 		Namespace ns = TestVerveineUtils.detectElement(repo,Namespace.class, javaLangName);
 		assertNotNull(ns);
-		assertEquals(8, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Appendable,CharSequence
+		assertEquals(9, ns.getTypes().size());  // Object,String,StringBuffer,AbstractStringBuilder,System,Comparable,Comparable<String>,Appendable,CharSequence
 		assertTrue(ns.getIsStub());
 			
 		fr.inria.verveine.core.gen.famix.Class obj = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, JavaDictionary.OBJECT_NAME);
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 105)
@@ -53,8 +53,9 @@
 	public void setUp() throws Exception {
 		new File(VerveineJParser.OUTPUT_FILE).delete();
 		VerveineJParser parser = new VerveineJParser();
-		parser.compile(new String[] {"test_src/ad_hoc"});
-		repo = parser.getFamixRepo();
+		this.repo = parser.getFamixRepo();
+		parser.setOptions(new String[] {"test_src/ad_hoc"});
+		parser.parse();
 		repo.exportMSE(new FileWriter(VerveineJParser.OUTPUT_FILE));
 	}
 
@@ -163,8 +164,11 @@
 	public void testParameterizableClass() {
 		ParameterizableClass dico = TestVerveineUtils.detectElement(repo, ParameterizableClass.class, "Dictionary");
 		assertNotNull(dico);
+		for (Type t : dico.getTypes()) {
+			System.out.println("dico type: "+t.getName());
+		}
 		assertEquals("Dictionary", dico.getName());
-		assertEquals(2, dico.getTypes().size());
+		assertEquals(6, dico.getTypes().size());  // <B> , ImplicitVars , Map<B,NamedEntity> , Map<String,Collection<NamedEntity>> , Collection<NamedEntity> , Map<Class,ImplicitVars>
 		assertEquals(1, dico.getParameters().size());
 		
 		ParameterType dicoParam = TestVerveineUtils.detectElement(repo, ParameterType.class, "B");
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineDefVisitor.java	(revision 105)
@@ -251,10 +251,6 @@
 		if (retTyp == null) {
 			fmxTyp = null;
 		}
-		else if (retTyp.isParameterizedType()) {
-			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
-			fmxTyp = dico.ensureFamixParameterizedType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
-		}
 		else {
 			fmxTyp = dico.ensureFamixType(retTyp.resolveBinding(), dico.findTypeName(retTyp), /*owner*/null, context.top());
 		}
@@ -307,7 +303,7 @@
 		}
 		super.endVisit(node);
 	}
-	
+
 	@SuppressWarnings({ "unchecked" })
 	public boolean visit(FieldDeclaration node) {
 //		System.err.println("TRACE, DefVisiting FieldDeclaration");
@@ -354,9 +350,17 @@
 
 		fr.inria.verveine.core.gen.famix.Type fmxTyp;
 		if (varTyp.isParameterizedType()) {
-			// some type (e.g. Collection<...>) are defined as ParameterizedType in the AST (here 'nodeTyp') and not in the binding (here 'nodeTyp.resolveBinding()')
-			fmxTyp = dico.ensureFamixParameterizedType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
-			// TODO treat ParameterTypes
+			ITypeBinding tbnd = varTyp.resolveBinding();
+			String tname = dico.findTypeName(varTyp);
+			ParameterizableClass tmpGeneric = null;
+			if (tbnd != null) {
+				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(tbnd.getErasure(), tname, /*owner*/null, /*isGeneric*/true);
+			}
+			else {
+				tmpGeneric = (ParameterizableClass) dico.ensureFamixClass(null, tname, /*owner*/null, /*isGeneric*/true);
+			}
+			// varType.typeArguments()
+			fmxTyp = dico.ensureFamixParameterizedType(tbnd, tname, tmpGeneric, /*owner*/ctxt);
 		}
 		else {
 			fmxTyp = dico.ensureFamixType(varTyp.resolveBinding(), dico.findTypeName(varTyp), /*owner*/null, ctxt);
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/JavaDictionary.java	(revision 105)
@@ -152,7 +152,7 @@
 		}
 
 		if (bnd.isParameterizedType()) {
-			return ensureFamixParameterizedType(bnd, name, (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true), owner);
+			return ensureFamixParameterizedType(bnd, name, /*generic*/null, owner);
 		}
 
 		// it seems wise to test isClass after isGenericType, isParameterizedType, ... ? 
@@ -261,18 +261,18 @@
 		}
 
 		// --------------- superclasses (including interfaces)
-		Collection<fr.inria.verveine.core.gen.famix.Class> sups = new LinkedList<fr.inria.verveine.core.gen.famix.Class>();
+		Collection<Type> sups = new LinkedList<Type>();
 		if (! bnd.isInterface()) {
 			ITypeBinding supbnd = bnd.getSuperclass();
 			if (supbnd != null) {
-				sups.add((Class)ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
+				sups.add(ensureFamixType(supbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); //supbnd.isGenericType()));
 			}
 			else {
 				sups.add( ensureFamixClassObject(null));
 			}
 		}
 		for (ITypeBinding intbnd : bnd.getInterfaces()) {
-			sups.add( (Class)ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/null)); // intbnd.isGenericType()));
+			sups.add( ensureFamixType(intbnd, /*name*/null, /*owner*/null, /*ctxt*/owner));
 		}
 
 		// --------------- recover from name ?
@@ -295,7 +295,7 @@
 			// we just created it or it was not bound, so we make sure it has the right information in it
 			fmx.setIsInterface(bnd.isInterface());
 			Inheritance lastInheritance = null;
-			for (fr.inria.verveine.core.gen.famix.Class sup : sups) {
+			for (Type sup : sups) {
 				lastInheritance = ensureFamixInheritance(sup, fmx, lastInheritance);
 			}
 			setNamedEntityModifiers(fmx, bnd.getDeclaredModifiers());
@@ -353,6 +353,11 @@
 			}
 		}
 
+		// --------------- generic
+		if (generic == null) {
+			generic = (ParameterizableClass) ensureFamixClass(bnd.getErasure(), name, owner, /*isGeneric*/true);
+		}
+
 		// --------------- recover from name ?
 		for (ParameterizedType candidate : getEntityByName(ParameterizedType.class, name) ) {
 			if ( checkAndMapType(bnd, candidate) ) {
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/VerveineJParser.java	(revision 105)
@@ -1,9 +1,13 @@
 package fr.inria.verveine.extractor.java;
 
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTParser;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 import fr.inria.verveine.core.VerveineParser;
 import fr.inria.verveine.core.gen.famix.Namespace;
@@ -20,35 +24,83 @@
 	 * The arguments that were passed to the parser
 	 * Needed to relativize the source file names
 	 */
-	private String[] initialArgs;
+	private Collection<String> sourceFiles;
 	
-	public static void main(String[] args) {
-		VerveineJParser parser = new VerveineJParser();
-		parser.compile(args);
-		parser.outputMSE();
+	private ASTParser jdtParser = null;
+	
+	public VerveineJParser() {
+		super();
+
+		jdtParser = ASTParser.newParser(AST.JLS3);
 	}
+	
+	public void setOptions(String[] args) {
+		// we assume java 1.5 code for now, this should be configurable
+		@SuppressWarnings("unchecked")
+		Map<String,String> options = JavaCore.getOptions();
+		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5);
+		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
+		jdtParser.setCompilerOptions(options);
 
-	private void setInitialArgs(String[] args) {
-		this.initialArgs = args;
+		Collection<String> classPath = new ArrayList<String>();
+		Collection<String> sourcePath = new ArrayList<String>();
+		sourceFiles = new ArrayList<String>();
+		for (int i=0; i < args.length; i++) {
+			String current = args[i];
+			if (current.equals("-cp")) {
+				classPath.add(args[++i]);
+			}
+			else if (current.endsWith(".java")) {
+				sourceFiles.add(current);
+			}
+			else {
+				sourcePath.add(current);
+			}
+		}
+		
+		jdtParser.setEnvironment(classPath.toArray(new String[0]), sourcePath.toArray(new String[0]), null, true);
+		jdtParser.setResolveBindings(true);
+		jdtParser.setKind(ASTParser.K_COMPILATION_UNIT);
+		
+		collectJavaFiles(sourcePath, sourceFiles);
 	}
 
-	public String[] getInitialArgs() {
-		return this.initialArgs;
+	private void collectJavaFiles(Collection<String> paths, Collection<String> files) {
+		for (String p : paths) {
+			collectJavaFiles(new File(p), files);
+		}
 	}
 
-	@Override
-	public boolean compile(String[] argv) {
-		boolean ret;
+	private void collectJavaFiles(File f, Collection<String> files) {
+		if (f.isFile() && f.getName().endsWith(".java")) {
+			files.add(f.getAbsolutePath());
+		}
+		else if (f.isDirectory()){
+			for (File child : f.listFiles()) {
+				collectJavaFiles(child, files);
+			}
+		}
+		// else ignore it?
+		
+	}
+
+	public static void main(String[] args) {
+		VerveineJParser parser = new VerveineJParser();
+		parser.setOptions(args);
+		parser.parse();
+		parser.outputMSE();
+	}
+
+	public void parse() {
 		if (this.linkToExisting()) {
 			this.expandNamespacesNames();
 		}
 
-		setInitialArgs(argv);
-		ret = super.compile(argv);
+		FamixRequestor req = new FamixRequestor(getFamixRepo(), new String[0]);
+		jdtParser.createASTs(sourceFiles.toArray(new String[0]), null, new String[0], req, null);
 		
 		this.compressNamespacesNames();
-		
-		return ret;
 	}
 
 	/**
@@ -90,41 +142,5 @@
 			}
 		}
 	}
-
-	/*
-	 *  Low-level API performing the actual parsing
-	 *  Overwrite the one in org.eclipse.jdt.internal.compiler.batch.Main;
-	 *  SHOULD NOT USE an internal JDT class. But I don't know how to do it otherwise
-	 */
-	public void performCompilation() {
-
-		this.compilerOptions = new CompilerOptions(this.options);
-		this.compilerOptions.performMethodsFullRecovery = false;
-		this.compilerOptions.performStatementsRecovery = false;
-
-		// NA --- beginning of parsing code --------------------------------------------------
-		String[] tmpclasspath=null;
-		if (this.checkedClasspaths!=null) {
-			tmpclasspath = new String[this.checkedClasspaths.length];
-			int i = 0;
-			for (Classpath cp : this.checkedClasspaths) {
-				tmpclasspath[i++] = cp.getPath();
-			}
-		}
-
-		ASTParser pars = ASTParser.newParser(AST.JLS3);
-		pars.setEnvironment(/*classpathEntries*/tmpclasspath,
-				/*sourcepathEntries*/ new String[0],  // TODO this might be wrong. What if the user specifies some "-sourcepath" when calling Verveine?
-				/*encodings*/null, 
-				/*includeRunningVMBootclasspath*/true);
-		pars.setResolveBindings(true);
-		pars.setKind(ASTParser.K_COMPILATION_UNIT);
-		pars.createASTs(/*sourceFilePaths*/this.filenames, 
-				/*encodings*/this.encodings, 
-				/*bindingKeys*/new String[0], 
-				/*requestor*/new FamixRequestor(getFamixRepo(), getInitialArgs()), 
-				/*monitor*/null);
-		// NA --- end of parsing code --------------------------------------------------
-	}
 	
 }
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 104)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/src/fr/inria/verveine/extractor/java/FamixRequestor.java	(revision 105)
@@ -21,9 +21,9 @@
 	}
 
 	public void acceptAST(String sourceFilePath, CompilationUnit ast) {
+//		System.out.println("  ******* TRACE, Requestor is visiting : "+sourceFilePath+" *******");
 		
 		ast.setProperty(JavaDictionary.SOURCE_FILENAME_PROPERTY, relativePath(sourceFilePath));
-		//System.out.println("  ******* DOING : "+sourceFilePath+" *******");
 		ast.accept(new VerveineDefVisitor(this.famixDictionnary));
 		ast.accept(new VerveineRefVisitor(this.famixDictionnary));
 	}
Index: branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml
===================================================================
--- branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 0)
+++ branches/postMoose4_3Refactoring/verveine.extractor.java/build.xml	(revision 105)
@@ -0,0 +1,88 @@
+<?xml version="1.0"?>
+<project name="verveine.extractor.java" default="main" basedir=".">
+	<!-- Sets variables which can later be used. -->
+	<!-- The value of a property is accessed via ${} -->
+	<property name="src.dir"      location="src" />
+	<property name="build.dir"    location="bin" />
+	<property name="docs.dir"     location="docs" />
+	<property name="dist.dir"     location="lib" />
+	<property name="verveine.jar" location="${dist.dir}/verveine.extractor,java.jar" />
+
+	<!-- Variables used for JUnit testin -->
+	<property name="test.dir" location="src/tests/fr/inria/verveine/extractor/java/" />
+	<property name="test.report.dir" location="testrep" />
+
+
+	<!-- Create a classpath container which can be later used in the ant task -->
+	<path id="build.classpath">
+		<fileset dir="${dist.dir}">
+			<include name="*.jar" />
+		</fileset>
+	</path>
+
+
+	<!-- Deletes the existing build, docs and dist directory-->
+	<target name="clean">
+		<delete dir="${build.dir}" />
+		<delete dir="${docs.dir}" />
+		<delete file="${verveine.jar}" />
+	</target>
+
+	<!-- Creates the  build, docs and dist directory-->
+	<target name="makedir">
+		<mkdir dir="${build.dir}" />
+		<mkdir dir="${docs.dir}" />
+		<mkdir dir="${test.report.dir}" />
+	</target>
+
+	<!-- copies the jar from verveine.core -->
+	<target name="corejars" depends="makedir">
+		<copy todir="${dist.dir}" file="../verveine.core/lib/famix.jar"/>
+		<copy todir="${dist.dir}" file="../verveine.core/lib/verveine.core.jar"/>
+	</target>
+
+	<!-- Compiles the java code (including the usage of library for JUnit -->
+	<target name="compile" depends="clean, corejars">
+		<javac srcdir="${src.dir}" destdir="${build.dir}" classpathref="build.classpath">
+		</javac>
+	</target>
+
+	<!-- Creates Javadoc -->
+	<target name="docs" depends="compile">
+		<javadoc packagenames="src" sourcepath="${src.dir}" destdir="${docs.dir}">
+			<!-- Define which files / directory should get included, we include all -->
+			<fileset dir="${src.dir}">
+				<include name="**" />
+			</fileset>
+		</javadoc>
+	</target>
+
+	<!--Creates the deployable jar file  -->
+	<target name="jar" depends="compile">
+		<jar destfile="${verveine.jar}" basedir="${build.dir}">
+			<include name="fr/inria/verveine/extractor/java/*.class"/>
+		</jar>
+	</target>
+
+	<!-- Run the JUnit Tests -->
+	<!-- Output is XML, could also be plain-->
+	<target name="junit" depends="compile">
+		<junit printsummary="on" fork="true" haltonfailure="no">
+			<classpath>
+				<pathelement path="${build.dir}"/>
+				<fileset dir="${dist.dir}">
+  				  <include name="*.jar"/>
+				</fileset>
+			</classpath>
+			<formatter type="plain" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_LanModel" todir="${test.report.dir}" />
+			<test name="tests.fr.inria.verveine.extractor.java.VerveineJTest_AdHoc" todir="${test.report.dir}" />
+		</junit>
+	</target>
+
+
+	<target name="main" depends="junit">
+		<description>Main target</description>
+	</target>
+
+</project>
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 47)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineJTest_AdHoc.java	(revision 48)
@@ -9,6 +9,7 @@
 import static org.junit.Assert.assertSame;
 
 import java.io.File;
+import java.util.Collection;
 
 import org.junit.After;
 import org.junit.Before;
@@ -16,6 +17,9 @@
 
 import test.fr.inria.verveine.core.TestVerveineUtils;
 import ch.akuhn.fame.Repository;
+import fr.inria.verveine.core.gen.famix.AnnotationInstance;
+import fr.inria.verveine.core.gen.famix.AnnotationType;
+import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.CaughtException;
 import fr.inria.verveine.core.gen.famix.DeclaredException;
 import fr.inria.verveine.core.gen.famix.Method;
@@ -77,5 +81,108 @@
 		assertSame(meth, exC.getDefiningMethod());
 		assertSame(excepClass, exC.getExceptionClass());
 	}
-
-}
+	
+	@Test
+	public void testAnnotation() {
+		fr.inria.verveine.core.gen.famix.Class clazz;
+		Collection<AnnotationInstance> annInstances;
+		
+		AnnotationType annTypeOverride = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Override");
+		assertNotNull(annTypeOverride);
+		assertEquals("Override", annTypeOverride.getName());
+		
+		AnnotationType annTypeDeprecated = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.AnnotationType.class, "Deprecated");
+		assertNotNull(annTypeDeprecated);
+		assertEquals("Deprecated", annTypeDeprecated.getName());
+		
+		//Annotations to the class
+		clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Client");
+		assertNotNull(clazz);
+		annInstances = clazz.getAnnotationInstances();
+		assertEquals(2, annInstances.size());
+		for (AnnotationInstance annotationInstance : annInstances) {
+			assertSame(clazz, annotationInstance.getAnnotatedEntity());
+			if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+				assertEquals("Override", annotationInstance.getAnnotationType().getName());
+				assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+			} else {
+				assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+				assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+			}
+		}
+		//Annotations to the attributes
+		for (Attribute attribute : clazz.getAttributes()) {
+			annInstances = attribute.getAnnotationInstances();
+			if (attribute.getName().equals("num")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
+					assertSame(attribute, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (attribute.getName().equals("nom")) {
+				assertEquals(1, annInstances.size());
+				for (AnnotationInstance annotationInstance : attribute.getAnnotationInstances()) {
+					assertSame(attribute, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+		//Annotations to the methods
+		for (Method method : clazz.getMethods()) {
+			annInstances = method.getAnnotationInstances();
+			if (method.getName().equals("Client")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (method.getName().equals("lire")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			} else if (method.getName().equals("setNum")) {
+				assertEquals(2, annInstances.size());
+				for (AnnotationInstance annotationInstance : method.getAnnotationInstances()) {
+					assertSame(method, annotationInstance.getAnnotatedEntity());
+					if (annotationInstance.getAnnotationType().getName().equals("Override")) {
+						assertEquals("Override", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeOverride, annotationInstance.getAnnotationType());
+					} else {
+						assertEquals("Deprecated", annotationInstance.getAnnotationType().getName());
+						assertSame(annTypeDeprecated, annotationInstance.getAnnotationType());
+					}
+				}
+			}else {
+				assertEquals(0, annInstances.size());
+			}
+		}
+	}
+}
\ No newline at end of file
Index: verveine.extractor.java/.classpath
===================================================================
--- verveine.extractor.java/.classpath	(revision 12)
+++ verveine.extractor.java/.classpath	(revision 13)
@@ -13,7 +13,7 @@
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.junit_4.8.1.v4_8_1_v20100427-1100/junit.jar"/>
 	<classpathentry kind="var" path="ECLIPSE_HOME/plugins/org.hamcrest.core_1.1.0.v20090501071000.jar"/>
 	<classpathentry kind="lib" path="lib/fame.jar"/>
-	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="lib" path="lib/verveine.core.jar"/>
+	<classpathentry kind="lib" path="lib/famix.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: verveine.extractor.java/lib/famix.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.core.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/lib/verveine.extractor.java.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java
===================================================================
--- verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 12)
+++ verveine.extractor.java/src/tests/fr/inria/verveine/extractor/java/VerveineExtractorJavaTest.java	(revision 13)
@@ -25,6 +25,7 @@
 import fr.inria.verveine.core.gen.famix.Access;
 import fr.inria.verveine.core.gen.famix.Attribute;
 import fr.inria.verveine.core.gen.famix.BehaviouralEntity;
+import fr.inria.verveine.core.gen.famix.Class;
 import fr.inria.verveine.core.gen.famix.FileAnchor;
 import fr.inria.verveine.core.gen.famix.Inheritance;
 import fr.inria.verveine.core.gen.famix.Invocation;
@@ -225,6 +226,13 @@
 		fr.inria.verveine.core.gen.famix.Class clazz = TestVerveineUtils.detectElement(repo,fr.inria.verveine.core.gen.famix.Class.class, "Node");
 		assertNotNull(clazz);
 		assertFalse(clazz.getIsStub());
+		
+		/* [].length notused in the default test case 
+		Attribute att = TestVerveineUtils.detectElement(repo, Attribute.class, "length");
+		assertNotNull(att);
+		clazz = (Class) att.getParentType();
+		assertNotNull(clazz);
+		assertEquals(JavaDictionary.ARRAYS_NAME, clazz.getName());*/
 	}
 
 	@Test
@@ -438,7 +446,6 @@
 		assertFalse(a.getIsFinal());
 	}
 
-
 	@Test
 	public void testMetric() {	
 		for (Method m : TestVerveineUtils.listElements(repo, Method.class, "accept")) {
